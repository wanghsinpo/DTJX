 COM /Alglib/ INTEGER Alg    !! 189
 COM /Alglib/ Nam$(1:189)[32]
 COM /Alglib/ INTEGER Num(1:189,0:3)
 COM /Alglib/ Var$(1:189,0:3,0:255)[32]
 COM /Alglib/ INTEGER Typ(1:189,0:3,0:255)
 COM /Alglib/ INTEGER Dim(1:189,0:3,0:255)
 COM /Alglib/ INTEGER Loc(1:189,0:3,0:255)
 COM /Alglib/ INTEGER Vali(1:189,0:3,0:255)
 COM /Alglib/ REAL Valr(1:189,0:3,0:31)
 COM /Alglib/ Valc$(1:189,0:3,0:31)[1]
 COM /Alglib/ Vals$(1:189,0:3,0:31)[255]
 !
 Main:!
 CALL Direct_data
 CALL Direct_init
 CALL Direct_algo
 CALL Direct_uninit
 END
 !
 Algpanel_launch:SUB Algpanel_launch(Session$,Port$,Project$,Hostname$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : ALGPANEL_LAUNCH
 !  Vers : 1
 !  Desc : Execute Algorithm Panel.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -        Session ID
 !      2 Port            S    -        Port ID
 !      3 Project         S    -        Project ID
 !      4 Hostname        S    -        Hostname
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Buf$(32)[256]
   INTEGER Nopt
  !
   Nopt=0
  !
   Nopt=Nopt+1
   Buf$(Nopt)="-O"
   Nopt=Nopt+1
   Buf$(Nopt)="-c"&Port$
   Nopt=Nopt+1
   Buf$(Nopt)="-g"&Session$
   Nopt=Nopt+1
   Buf$(Nopt)="-j"&Project$
  !
   Ap_init(Buf$(*),Nopt)
  !
 SUBEND
 Algpanel_start:SUB Algpanel_start(INTEGER Mode)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : ALGPANEL_START
 !  Vers : 1
 !  Desc : Popdup Algorithm Panel.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Mode            I    -        0:Normal, 1:Disable problibs
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Ap_popup(Mode)
  !
 SUBEND
 Algpanel_stop:SUB Algpanel_stop
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : ALGPANEL_STOP
 !  Vers : 1
 !  Desc : Popdown Algorithm Panel.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Ap_popdown
  !
 SUBEND
 Apply_fwkconf:SUB Apply_fwkconf(File$,INTEGER Type,Errno,Errmsg$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : APPLY_FWKCONF
 !  Vers : 1
 !  Desc : Read configuration parameter and apply them.
 !       :   SPECS2.5: Added special parameters.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 File            S    -
 !      2 Type            I    -        0:All vars, 1:Normal vars only,
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Errno           I    -
 !      2 Errmsg          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Line$[8196],Symbol$[8196],Value$[8196],Token$[8196],Name$[32],Src$[8196]
   INTEGER P_col,P_exc,P_comma                      !":", "!" and ","
   INTEGER Idx_tag,Idx_dim1,Typ,Dim,Size1,Size2,Length
   Errno=0
   Errmsg$=""
   ON ERROR GOTO Err
   ASSIGN @Fwkconf TO File$;FORMAT ON
   ON END @Fwkconf GOTO Endoffile
   LOOP
     Symbol$=""
     Value$=""
  !
     ENTER @Fwkconf;Line$
     Line$=TRIM$(Line$)
     P_exc=POS(Line$,"!")
     SELECT P_exc
     CASE 0
     CASE 1
       Line$=""
     CASE ELSE
       Line$=Line$[1,P_exc-1]
     END SELECT
  !
     P_col=POS(Line$,":")
     IF P_col>=2 THEN 
       Symbol$=Line$[1,P_col-1]
       Symbol$=TRIM$(Symbol$)
       IF Symbol$<>"" AND LEN(Line$)>P_col THEN 
         Value$=Line$[P_col+1,LEN(Line$)]
         Value$=TRIM$(Value$)
       END IF
     END IF
  !
     IF Symbol$<>"" AND Value$<>"" THEN 
       IF Symbol$[1,1]="*" THEN 
         IF Type=1 THEN Loop_next
         Src$=Symbol$[2,LEN(Symbol$)]
       ELSE
         IF Type=2 THEN Loop_next
         Src$=Symbol$
       END IF
  !
       Tpltagindex("SYSTEM",Src$,Idx_tag)
       IF Idx_tag=-1 THEN 
         Errno=1
         Errmsg$=Src$&" is not defined as TAG variable"
         GOTO Endoffile
       END IF
       Tpltaginfo("SYSTEM",Idx_tag,Name$,Typ,Dim,Size1,Size2)
       SELECT Dim
       CASE 0
         SELECT Typ
         CASE 0
           Tplputrtag("SYSTEM",Idx_tag,0,VAL(Value$))
         CASE 1
           Tplputitag("SYSTEM",Idx_tag,0,INT(VAL(Value$)))
         CASE 2
           IF LEN(Value$)>0 THEN 
             Tplputctag("SYSTEM",Idx_tag,0,Value$[1,1])
           END IF
         CASE 3
           Tplputstag("SYSTEM",Idx_tag,0,Value$)
         END SELECT
       CASE 1
         SELECT Typ
         CASE 0
           ALLOCATE REAL Ra(Size1)
         CASE 1
           ALLOCATE INTEGER Ia(Size1)
         CASE 2
           ALLOCATE Ca$(Size1)[1]
         CASE 3
           ALLOCATE Sa$(Size1)[255]
         END SELECT
  !
         Idx_dim1=1
         LOOP
           P_comma=POS(Value$,",")
           SELECT P_comma
           CASE 0
             Token$=Value$
           CASE 1
             Token$=""
           CASE ELSE
             Token$=Value$[1,P_comma-1]
           END SELECT
           Token$=TRIM$(Token$)
  !
           SELECT Typ
           CASE 0
             Ra(Idx_dim1)=VAL(Token$)
           CASE 1
             Ia(Idx_dim1)=INT(VAL(Token$))
           CASE 2
             IF LEN(Token$)>0 THEN 
               Ca$(Idx_dim1)=Token$[1,1]
             ELSE
               Ca$(Idx_dim1)=" "
             END IF
           CASE 3
             Sa$(Idx_dim1)=Token$
           END SELECT
  !
           Length=LEN(Value$)
         EXIT IF P_comma=0 OR Length=P_comma
  !
           Value$=Value$[P_comma+1,Length]
           Idx_dim1=Idx_dim1+1
         END LOOP
  !
         SELECT Typ
         CASE 0
           Tplputratag("SYSTEM",Idx_tag,0,Ra(*))
           DEALLOCATE Ra(*)
         CASE 1
           Tplputiatag("SYSTEM",Idx_tag,0,Ia(*))
           DEALLOCATE Ia(*)
         CASE 2
           Tplputcatag("SYSTEM",Idx_tag,0,Ca$(*))
           DEALLOCATE Ca$(*)
         CASE 3
           Tplputsatag("SYSTEM",Idx_tag,0,Sa$(*))
           DEALLOCATE Sa$(*)
         END SELECT
       CASE 2
         SELECT Typ
         CASE 0
           ALLOCATE REAL Ra2(Size2,Size1)
         CASE 1
           ALLOCATE INTEGER Ia2(Size2,Size1)
         CASE 2
           ALLOCATE Ca2$(Size2,Size1)[1]
         CASE 3
           ALLOCATE Sa2$(Size2,Size1)[255]
         END SELECT
  !
         Idx_dim1=1
         FOR J=1 TO Size2
           FOR K=1 TO Size1
             P_comma=POS(Value$,",")
             SELECT P_comma
             CASE 0
               Token$=Value$
             CASE 1
               Token$=""
             CASE ELSE
               Token$=Value$[1,P_comma-1]
             END SELECT
             Token$=TRIM$(Token$)
  !
             SELECT Typ
             CASE 0
               Ra2(J,K)=VAL(Token$)
             CASE 1
               Ia2(J,K)=INT(VAL(Token$))
             CASE 2
               IF LEN(Token$)>0 THEN 
                 Ca2$(J,K)=Token$[1,1]
               ELSE
                 Ca2$(J,K)=" "
               END IF
             CASE 3
               Sa2$(J,K)=Token$
             END SELECT
  !
             Length=LEN(Value$)
             Value$=Value$[P_comma+1,Length]
             Idx_dim1=Idx_dim1+1
           NEXT K
         NEXT J
  !
         SELECT Typ
         CASE 0
           Tplputratag("SYSTEM",Idx_tag,0,Ra2(*))
           DEALLOCATE Ra2(*)
         CASE 1
           Tplputiatag("SYSTEM",Idx_tag,0,Ia2(*))
           DEALLOCATE Ia2(*)
         CASE 2
           Tplputcatag("SYSTEM",Idx_tag,0,Ca2$(*))
           DEALLOCATE Ca2$(*)
         CASE 3
           Tplputsatag("SYSTEM",Idx_tag,0,Sa2$(*))
           DEALLOCATE Sa2$(*)
         END SELECT
       END SELECT
     END IF
 Loop_next: !
   END LOOP
 Endoffile:                                  !
   ASSIGN @Fwkconf TO *
   SUBEXIT
 Err:                                  !
   ASSIGN @Fwkconf TO *
   Errno=ERRN
   Errmsg$=ERRM$
 SUBEND
 Array_lookup1:SUB Array_lookup1(Src$(*),Pat$,INTEGER Pos)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : ARRAY_LOOKUP1
 !  Vers : 1
 !  Desc : Returns the array index for a specified data element of a
 !       :  STRING array.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Src             S    256      Source strings
 !      2 Pat             S    -        Pattern string
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Pos             I    -        Position (>0 position, 0 not fou
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER S,P
   S=SIZE(Src$,1)
   MAT SEARCH Src$(*),LOC(Pat$);P
   IF P>S THEN 
     Pos=0
   ELSE
     Pos=P
   END IF
 SUBEND
 Array_lookup2:SUB Array_lookup2(Src$(*),Pat$(*),INTEGER Pos(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : ARRAY_LOOKUP2
 !  Vers : 1
 !  Desc : Returns the array indices for the specified data elements
 !       :  of a STRING array.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Src             S    256      Source strings
 !      2 Pat             S    256      Pattern strings
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Pos             I    256      Positions of each pattern string
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER S1,S2,P
   S1=SIZE(Src$,1)
   S2=SIZE(Pat$,1)
   FOR I=1 TO S2
     MAT SEARCH Src$(*),LOC(Pat$(I));P
     IF P>S2 THEN 
       Pos(I)=0
     ELSE
       Pos(I)=P
     END IF
   NEXT I
 SUBEND
 Array_lookup3:SUB Array_lookup3(Src$(*),INTEGER Pos(*),Sub$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : ARRAY_LOOKUP3
 !  Vers : 1
 !  Desc : Returns the data elements for the specified indices of a
 !       : STRING array
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Src             S    256      Source strings
 !      2 Pos             I    256      Positions of strings to extract
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Sub             S    256      Extracted strings
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER S1,S2
   S1=SIZE(Src$,1)
   S2=SIZE(Pos,1)
   FOR I=1 TO S2
     IF Pos(I)>=1 AND Pos(I)<=S1 THEN 
       Sub$(I)=Src$(Pos(I))
     ELSE
       Sub$(I)=""
     END IF
   NEXT I
 SUBEND
 Attrib_file:SUB Attrib_file(Filename$,Permission$,Owner$,Group$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : ATTRIB_FILE
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Filename        S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Permission      S    -
 !      2 Owner           S    -
 !      3 Group           S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Mode
  !
   ON ERROR GOTO Err
   ASSIGN @Pipe TO "ls -l -d "&Filename$&" 2>/dev/null | awk '{printf(""%s\n%s\n%s"", $1, $3, $4); }' |"
   ON END @Pipe GOTO Nofile
  !
   ENTER @Pipe;Attrib$
   Mode=0
   IF Attrib$[2,2]="r" THEN Mode=Mode+400
   IF Attrib$[3,3]="w" THEN Mode=Mode+200
   IF Attrib$[4,4]="x" THEN Mode=Mode+100
   IF Attrib$[4,4]="s" THEN Mode=Mode+4100
   IF Attrib$[4,4]="S" THEN Mode=Mode+4000
   IF Attrib$[5,5]="r" THEN Mode=Mode+40
   IF Attrib$[6,6]="w" THEN Mode=Mode+20
   IF Attrib$[7,7]="x" THEN Mode=Mode+10
   IF Attrib$[7,7]="s" THEN Mode=Mode+2010
   IF Attrib$[7,7]="S" THEN Mode=Mode+2000
   IF Attrib$[8,8]="r" THEN Mode=Mode+4
   IF Attrib$[9,9]="w" THEN Mode=Mode+2
   IF Attrib$[10,10]="x" THEN Mode=Mode+1
   IF Attrib$[10,10]="t" THEN Mode=Mode+1001
   Permission$=VAL$(Mode)
  !
   ENTER @Pipe;Owner$
   ENTER @Pipe;Group$
  !
   OFF END @Pipe
   OFF ERROR 
   SUBEXIT
  !
 Nofile: !
   PRINT "ATTRIB_FILE ERROR: "&Filename$&" is not accessible."
   OFF END @Pipe
   OFF ERROR 
   SUBEXIT
  !
 Err: !
   PRINT "ATTRIB_FILE ERROR: "&ERRM$
   OFF END @Pipe
   OFF ERROR 
 SUBEND
 Beep:SUB Beep(REAL Freq,Dur)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : BEEP
 !  Vers : 1
 !  Desc : Specifies frquency and duration for the beep, and sounds
 !       : the beep
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Freq            R    -        Frequency
 !      2 Dur             R    -        Duration
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   BEEP Freq,Dur
 SUBEND
 Call_errhandler:SUB Call_errhandler(Errorno$,Message$,Moreinfo$,INTEGER Status,Errmsg$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CALL_ERRHANDLER
 !  Vers : 1
 !  Desc : Error Handler.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 ErrorNo         S    -        ErrorCode  .ex  "12-34567"
 !      2 Message         S    -        Error Message
 !      3 MoreInfo        S    -        More Info
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0: OK, -1: Exec Err, -2: No File
 !      2 Errmsg          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Eflag$[1024],Ecommand$[1024],Oplang$[1024]
   DIM Cmd$[1024],Line$[256]
   DIM Cl$[3072]
   DIM Ver$[20]
   INTEGER St,I,Cmd_ret
   DIM Tmpfile$[256],Logfile$[256]
   DIM Messagefile$[256],Fmessage$[3072]
   DIM Tmperrorno$[1024],Tmpmessage$[1024],Tmpmoreinfo$[1024]
   DIM Tmpstrmp$[3072]
  !
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")
   Logfile$="/var/opt/SPECS/log/syslog"
   Status=0
   Ndetail=0
   FOR I=1 TO 10
     Detail$(I)=""
   NEXT I
   Cmd_ret=0
  !
   Cmd$="/usr/bin/grep -Ee '^[ \t]*"&"ERR_HANDLER"&"[ \t]*=' /opt/SPECS/sys/config/sysconf"
   Cmd$=Cmd$&"| /usr/bin/awk -F '=' '{val=$2;gsub(""^[ \t]*"","""",val);gsub(""[ \t]*$"","""",val); print val;}'"
   ON ERROR GOTO No_error
   ASSIGN @Pipe TO Cmd$&" |"
   OFF ERROR 
   ON END @Pipe GOTO Pipeeof
   ENTER @Pipe;Eflag$
   OFF END @Pipe
   ASSIGN @Pipe TO *
  !
   IF UPC$(Eflag$)="TRUE" THEN 
     Cmd$="/usr/bin/grep -Ee '^[ \t]*"&"ERR_HANDLER_SCRIPT"&"[ \t]*=' /opt/SPECS/sys/config/sysconf"
     Cmd$=Cmd$&"| /usr/bin/awk -F '=' '{val=$2;gsub(""^[ \t]*"","""",val);gsub(""[ \t]*$"","""",val); print val;}'"
     ON ERROR GOTO No_exec
     ASSIGN @Pipe TO Cmd$&" |"
     OFF ERROR 
     ON END @Pipe GOTO Pipeeof
     ENTER @Pipe;Ecommand$
     OFF END @Pipe
     ASSIGN @Pipe TO *
  !
     IF Ecommand$="" THEN 
       GOTO No_exec
     END IF
  !
     Oplang$="C"
  !    Cmd$="/usr/bin/grep -Ee '^[ \t]*"&"OP_LANG"&"[ \t]*=' /opt/SPECS/sys/config/sysconf"
  !    Cmd$=Cmd$&"| /usr/bin/awk -F '=' '{val=$2;gsub(""^[ \t]*"","""",val);gsub(""[ \t]*$"","""",val); print val;}'"
  !    ON ERROR GOTO No_exec
  !    ASSIGN @Pipe TO Cmd$&" |"
  !    OFF ERROR
  !    ON END @Pipe GOTO Pipeeof
  !    ENTER @Pipe;OpLang$
  !    OFF END @Pipe
  !    ASSIGN @Pipe TO *
  !
     IF Errorno$[1,1]="$" THEN 
       Messagefile$="/opt/SPECS/usr/fwk/HPSTD_"&Message$&"~/"&Oplang$&"/"&Errorno$[2]
       ON ERROR GOTO Std_arg_point
       ASSIGN @F TO Messagefile$
       OFF ERROR 
       ON END @F GOTO File_readend
       ENTER @F;Fmessage$
       OFF END @F
       ASSIGN @F TO *
 File_readend:        !
       I=POS(Fmessage$,CHR$(10))
       IF I<1 THEN 
         Tmperrorno$=Fmessage$
         Tmpmessage$=""
       ELSE
         Tmperrorno$=Fmessage$[1,I-1]
         Tmpmessage$=Fmessage$[I+1]
       END IF
       GOTO File_arg_point
     END IF
  !
 Std_arg_point:        !
     Tmperrorno$=Errorno$
     Tmpmessage$=Message$
  !
 File_arg_point:       !
     Tmperrorno$=TRIM$(Tmperrorno$)
     Tmpmessage$=TRIM$(Tmpmessage$)
     Tmpmoreinfo$=TRIM$(Moreinfo$)
     I=POS(Tmperrorno$," ")
     REPEAT
       IF I<1 THEN 
         GOTO Mes_cutenda
       ELSE
         Tmpstrmp$=Tmperrorno$[1;I-1]
         Tmperrorno$=Tmpstrmp$&"\ "&Tmperrorno$[I+1]
       END IF
       J=POS(Tmperrorno$[I+2]," ")
       I=J+I+2-1
     UNTIL J<1
 Mes_cutenda:        !
     I=POS(Tmpmessage$," ")
     REPEAT
       IF I<1 THEN 
         GOTO Mes_cutendb
       ELSE
         Tmpstrmp$=Tmpmessage$[1;I-1]
         Tmpmessage$=Tmpstrmp$&"\ "&Tmpmessage$[I+1]
       END IF
       J=POS(Tmpmessage$[I+2]," ")
       I=J+I+2-1
     UNTIL J<1
 Mes_cutendb:        !
     I=POS(Tmpmessage$,CHR$(10))
     REPEAT
       IF I<1 THEN 
         GOTO Mes_cutendc
       ELSE
         Tmpstrmp$=Tmpmessage$[1;I-1]
         Tmpmessage$=Tmpstrmp$&"\\n"&Tmpmessage$[I+1]
       END IF
       J=POS(Tmpmessage$[I+3],CHR$(10))
       I=J+I+3-1
     UNTIL J<1
 Mes_cutendc:        !
     I=POS(Tmpmoreinfo$," ")
     REPEAT
       IF I<1 THEN 
         GOTO Mes_cutendd
       ELSE
         Tmpstrmp$=Tmpmoreinfo$[1;I-1]
         Tmpmoreinfo$=Tmpstrmp$&"\ "&Tmpmoreinfo$[I+1]
       END IF
       J=POS(Tmpmoreinfo$[I+2]," ")
       I=J+I+2-1
     UNTIL J<1
 Mes_cutendd:        !
     I=POS(Tmpmoreinfo$,CHR$(10))
     REPEAT
       IF I<1 THEN 
         GOTO Mes_cutende
       ELSE
         Tmpstrmp$=Tmpmoreinfo$[1;I-1]
         Tmpmoreinfo$=Tmpstrmp$&"\\n"&Tmpmoreinfo$[I+1]
       END IF
       J=POS(Tmpmoreinfo$[I+3],CHR$(10))
       I=J+I+3-1
     UNTIL J<1
 Mes_cutende:        !
     Cl$=Ecommand$&" "&Tmperrorno$&" "&Tmpmessage$&" "&Tmpmoreinfo$
  !
     CREATE Tmpfile$,1
     ASSIGN @Tmp TO Tmpfile$;FORMAT ON
     OUTPUT @Tmp;DATE$(TIMEDATE)&" "&TIME$(TIMEDATE)&": CALL_ERRHANDLER algorithm utility."
     OUTPUT @Tmp;" Start      : Error Handler."
     OUTPUT @Tmp;" Command    : "&Ecommand$
     OUTPUT @Tmp;"---------------"
     OUTPUT @Tmp;" ERROR CODE : "&Tmperrorno$
     OUTPUT @Tmp;Tmpmessage$
     OUTPUT @Tmp;"---------------"
     OUTPUT @Tmp;""
     EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
     ASSIGN @Tmp TO *
     PURGE Tmpfile$
  !
     ON ERROR GOTO Commanderror
     EXECUTE Cl$;RETURN St
     OFF ERROR 
  !
     Cmd_ret=SHIFT(St,8) MOD 256
     IF Cmd_ret>=128 THEN Cmd_ret=Cmd_ret-256
  !
     Errmsg$="exit("&VAL$(Cmd_ret)&")"
     Status=Cmd_ret
  !
     SUBEXIT
 Commanderror:        !
     Errmsg$="exec() Error"
     Status=-1
     SUBEXIT
   ELSE
     Status=0
     SUBEXIT
   END IF
  !
 Pipeeof:        !
   OFF END @Pipe
   ASSIGN @Pipe TO *
 No_exec:        !
   Errmsg$="Command is """"."
   Status=-2
   SUBEXIT
 No_error:        !
   Status=0
   SUBEXIT
  !
 SUBEND
 Check_datafile:SUB Check_datafile(Filename$,INTEGER Valid)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CHECK_DATAFILE
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Filename        S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Valid           I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER I,Length
  !
   Valid=1
   Length=LEN(Filename$)
  !
   FOR I=1 TO Length
     IF Filename$[I,I]=" " THEN 
       Valid=0
       I=Length
     END IF
   NEXT I
  !
 SUBEND
 Check_file:SUB Check_file(Testplan$,Limit$,INTEGER Result)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CHECK_FILE
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Testplan        S    -
 !      2 Limit           S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Result          I    -        0: OK 1: File Mismatch: 2: Revis
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tplattr$[32]
   DIM Tplnam$[1024],Tplver$[128]
   DIM Limnam$[1024],Limver$[128]
   DIM Limtplnam$[1024],Limtplver$[128]
   DIM Spcnam$[1024],Spcver$[128],Spctyp$[32]
   DIM Buffer$[1024]
   INTEGER Verifylimit,Revcont
   INTEGER Tplnum,Limnum,Length,I
  !
   Result=0
   Tplattr$="/opt/SPECS/sys/bin/tplattr"    ! AVPATH_
  !
   ON ERROR GOTO Nofile
   ASSIGN @Pipe TO "grep -c -x VERIFYLIMIT=FALSE /opt/SPECS/sys/config/sysconf 2>/dev/null |"    ! AVPATH_
   OFF ERROR 
   ON END @Pipe GOTO Eof
   ON ERROR GOTO Overflow
   ENTER @Pipe;Buffer$
   IF VAL(Buffer$)>0 THEN 
     Verifylimit=0
   ELSE
     Verifylimit=1
   END IF
   Tplgetrevcont(Revcont)
  !
   Length=LEN(Testplan$)
   IF Length>3 THEN 
     IF Testplan$[Length-3;Length]=".tpl" THEN 
       Testplan$=Testplan$[1;Length-4]
     END IF
   END IF
   Length=LEN(Limit$)
   IF Length>3 THEN 
     IF Limit$[Length-3;Length]=".lim" THEN 
       Limit$=Limit$[1;Length-4]
     END IF
   END IF
  !
   IF NOT LEN(Testplan$) THEN 
     Tplfiletpl(Tplnam$,Tplver$,Tplnum)
     IF NOT LEN(Tplnam$) THEN 
       GOTO Nofile
     END IF
     Tplnam$=Tplnam$&".tpl"
     IF Tplver$="1" THEN 
       Tplver$=""
     END IF
   ELSE
     Tplnam$=Testplan$&".tpl"
     ON ERROR GOTO Nofile
     ASSIGN @Pipe TO Tplattr$&" -a Vers -t tpl "&Testplan$&" 2>/dev/null |"
     OFF ERROR 
     ON END @Pipe GOTO Eof
     ON ERROR GOTO Overflow
     ENTER @Pipe;Buffer$
     Length=LEN(Buffer$)
     Tplver$=Buffer$[7;Length]
     ASSIGN @Pipe TO *
   END IF
  !
   IF NOT LEN(Limit$) THEN 
     Limver$=" "
     Limtplnam$=Tplnam$
     Limtplver$=Tplver$
   ELSE
     Limnam$=Limit$&".lim"
     ON ERROR GOTO Nofile
     ASSIGN @Pipe TO Tplattr$&" -a Vers -t lim "&Limit$&" 2>/dev/null |"
     OFF ERROR 
     ON END @Pipe GOTO Eof
     ON ERROR GOTO Overflow
     ENTER @Pipe;Buffer$
     Length=LEN(Buffer$)
     Limver$=Buffer$[7;Length]
     ASSIGN @Pipe TO *
  !
     ON ERROR GOTO Nofile
     ASSIGN @Pipe TO Tplattr$&" -a TplName -t lim "&Limit$&" 2>/dev/null |"
     OFF ERROR 
     ON END @Pipe GOTO Eof
     ON ERROR GOTO Overflow
     ENTER @Pipe;Buffer$
     Length=LEN(Buffer$)
     Limtplnam$=Buffer$[10;Length]
     ASSIGN @Pipe TO *
  !
     ON ERROR GOTO Nofile
     ASSIGN @Pipe TO Tplattr$&" -a TplVers -t lim "&Limit$&" 2>/dev/null |"
     OFF ERROR 
     ON END @Pipe GOTO Eof
     ON ERROR GOTO Overflow
     ENTER @Pipe;Buffer$
     Length=LEN(Buffer$)
     Limtplver$=Buffer$[10;Length]
     ASSIGN @Pipe TO *
   END IF
  !
   IF (Verifylimit=1) AND (Tplnam$<>Limtplnam$) THEN 
     GOTO Tpl_err
   END IF
   IF (Verifylimit=1) AND (Tplver$<>Limtplver$) THEN 
     GOTO Ver_err
   END IF
   IF (Revcont=1) AND (NOT LEN(Tplver$)) THEN 
     IF NOT LEN(Testplan$) THEN 
       FOR I=0 TO Tplnum
         Tplfilespctpl(I,Spcnam$,Spctyp$,Spcver$)
         IF Spcver$="1" THEN 
           GOTO Norev_tpl
         END IF
       NEXT I
     ELSE
       ON ERROR GOTO Nofile
       ASSIGN @Pipe TO Tplattr$&" -A -a Vers -t tpl "&Testplan$&" 2>/dev/null | grep -c -x \$Vers. |"
       OFF ERROR 
       ON END @Pipe GOTO Eof
       ON ERROR GOTO Overflow
       ENTER @Pipe;Buffer$
       IF VAL(Buffer$)>0 THEN 
         GOTO Norev_tpl
       END IF
     END IF
   END IF
   IF (Revcont=1) AND (NOT LEN(Limver$)) THEN 
     GOTO Norev_lim
   END IF
  !
 No_err: !
   Result=0
   SUBEXIT
 Nofile: !
   Result=-1
   SUBEXIT
 Eof: !
   Result=-1
   SUBEXIT
 Overflow: !
   Result=-1
   SUBEXIT
 Tpl_err: !
   Result=1
   SUBEXIT
 Ver_err: !
   Result=2
   SUBEXIT
 Norev_tpl: !
   Result=3
   SUBEXIT
 Norev_lim: !
   Result=4
   SUBEXIT
 SUBEND
 Check_passwd:SUB Check_passwd(Name$,Command$,INTEGER Result)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CHECK_PASSWD
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Name            S    -
 !      2 Command         S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Result          I    -        0: Fail 1: OK
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Cmd$[256],Ok$[3]
  !
   Result=0
   Ok$=""
  !
   Tmpfile$="/var/tmp/PASSWD"&SYSTEM$("PROCESS ID")         ! AVPATH_
   ON ERROR GOTO Nofile
   PURGE Tmpfile$
   GOTO Exec_su
 Nofile: !
   IF ERRN<>56 THEN                          ! File name is undefined
     SUBEXIT
   END IF
  !
 Exec_su: !
   ON ERROR GOTO Err
   IF Command$="" THEN 
     Cmd$="/usr/dt/bin/dtterm -e su "&Name$&" -c 'echo OK >"&Tmpfile$&"'"
   ELSE
     Cmd$="/usr/dt/bin/dtterm -e su "&Name$&" -c '"&Command$&"&& echo OK >"&Tmpfile$&"'"
   END IF
   EXECUTE Cmd$
   ASSIGN @File TO Tmpfile$
   ON END @File GOTO Eof
   ENTER @File;Ok$
 Eof: !
   OFF END @File
   ASSIGN @File TO *
   IF Ok$[1,2]="OK" THEN 
     Result=1
   END IF
   PURGE Tmpfile$
 Err: !
   OFF ERROR 
 SUBEND
 Check_prober:SUB Check_prober(Symbol$,Vendor$,Model$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CHECK_PROBER
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Symbol          S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Vendor          S    -
 !      2 Model           S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   SELECT Symbol$
   CASE "TELP8"
     Vendor$="Tokyo Electron"
     Model$="P-8"
   CASE "TSK90A"
     Vendor$="Tokyo Seimitsu"
     Model$="A-PM-90A/UF200"
   CASE "EG4080"
     Vendor$="Electroglas"
     Model$="4080/4090"
   END SELECT
 SUBEND
 Check_profile:SUB Check_profile(INTEGER Result)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CHECK_PROFILE
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Result          I    -        0:OK 1:TPL: 2:FWK: 3:MLIB: 4:TLI
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Nam$[1024],Ver$[128],Typ$[32]
   INTEGER Revcont,Num
   INTEGER Length,I,J,Libc
  !
   ON ERROR GOTO Nofile
   Result=0
   Tplgetrevcont(Revcont)
  !
   Tplfiletpl(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_tpl
       FOR I=0 TO Num-1
         Tplfilespctpl(I,Nam$,Typ$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_tpl
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfilefwk(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_fwk
       FOR I=0 TO Num-1
         Tplfilespcfwk(I,Nam$,Typ$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_fwk
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfilenummlib(Libc)
   FOR J=0 TO Libc-1
     Tplfilemlibm(J,Nam$,Ver$,Num)
     IF LEN(Nam$) THEN 
       IF Ver$="1" THEN 
         IF Num=0 THEN GOTO Norev_mlib
         FOR I=0 TO Num-1
           Tplfilespcmlibm(J,I,Nam$,Ver$)
           IF Ver$="1" THEN 
             GOTO Norev_mlib
           END IF
         NEXT I
       END IF
     END IF
   NEXT J
  !
   Tplfiletlib(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_tlib
       FOR I=0 TO Num-1
         Tplfilespctlib(I,Nam$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_tlib
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfileplib(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_plib
       FOR I=0 TO Num-1
         Tplfilespcplib(I,Nam$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_plib
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfileulib(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_ulib
       FOR I=0 TO Num-1
         Tplfilespculib(I,Nam$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_ulib
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfilelim2(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" OR Ver$="" THEN 
       IF Num=0 THEN GOTO Norev_lim
       FOR I=0 TO Num-1
         Tplfilespclim(I,Nam$,Ver$)
         IF Ver$="" THEN 
           GOTO Norev_lim
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfilenumtco(Num)
   FOR I=0 TO Num-1
     Tplfiletco(I,Nam$,Ver$)
     IF Ver$="1" THEN 
       GOTO Norev_tco
     END IF
   NEXT I
  !
   Tplfiledlib(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_dlib
       FOR I=0 TO Num-1
         Tplfilespcdlib(I,Nam$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_dlib
         END IF
       NEXT I
     END IF
   END IF
  !
 No_err: !
   Result=0
   SUBEXIT
 Nofile: !
   Result=-1
   SUBEXIT
 Norev_tpl: !
   Result=1
   SUBEXIT
 Norev_fwk: !
   Result=2
   SUBEXIT
 Norev_mlib: !
   Result=3
   SUBEXIT
 Norev_tlib: !
   Result=4
   SUBEXIT
 Norev_plib: !
   Result=5
   SUBEXIT
 Norev_ulib: !
   Result=6
   SUBEXIT
 Norev_lim: !
   Result=7
   SUBEXIT
 Norev_tco: !
   Result=8
   SUBEXIT
 Norev_dlib: !
   Result=9
   SUBEXIT
 SUBEND
 Check_sysconf:SUB Check_sysconf(INTEGER Errno,Errmsg$,Smode$,Op_lang$,Adtformat$,Clearonretest$,Clearonreject$,Portid$,Projid$,Hostname$,Adtlogging$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CHECK_SYSCONF
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 ERRNO           I    -
 !      2 ERRMSG          S    -
 !      3 SMODE           S    -
 !      4 OP_LANG         S    -
 !      5 ADTFORMAT       S    -
 !      6 CLEARONRETEST   S    -
 !      7 CLEARONREJECT   S    -
 !      8 PORTID          S    -
 !      9 PROJID          S    -
 !     10 HOSTNAME        S    -
 !     11 ADTLOGGING      S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Line$[4096],Symbol$[4096],Value$[4096]
   INTEGER P
  !
   Errno=0
   Errmsg$=""
   Smode$=""
   Op_lang$=""
   Adtformat$=""
   Clearonretest$=""
   Clearonreject$=""
   Portid$=""
   Projid$=""
   Hostname$=""
   Adtlogging$=""
  !
   ON ERROR GOTO Err
   ASSIGN @Sysconf TO "/opt/SPECS/sys/config/sysconf";FORMAT ON           ! AVPATH_
   ON END @Sysconf GOTO Endoffile
   LOOP
     ENTER @Sysconf;Line$
     Line$=TRIM$(Line$)
     P=POS(Line$,"=")
     IF P>=2 THEN 
       Symbol$=Line$[1,P-1]
       Value$=Line$[P+1,LEN(Line$)]
       SELECT Symbol$
       CASE "SMODE"
         IF Smode$="" THEN Smode$=Value$
       CASE "OP_LANG"
         IF Op_lang$="" THEN Op_lang$=Value$
       CASE "ADTFORMAT"
         IF Adtformat$="" THEN Adtformat$=Value$
       CASE "CLEARONRETEST"
         IF Clearonretest$="" THEN Clearonretest$=Value$
       CASE "CLEARONREJECT"
         IF Clearonreject$="" THEN Clearonreject$=Value$
       CASE "IPCPORT"
         IF Portid$="" THEN Portid$=Value$
       CASE "PROJECT"
         IF Projid$="" THEN Projid$=Value$
       CASE "HOSTNAME"
         IF Hostname$="" THEN Hostname$=Value$
       CASE "ADTLOGGING"
         IF Adtlogging$="" THEN Adtlogging$=Value$
       END SELECT
     END IF
   END LOOP
 Endoffile: !
   IF Smode$="" THEN 
     Errno=-1
     Errmsg$="No SMODE found in /opt/SPECS/sys/config/sysconf"            ! AVPATH_
   END IF
   IF Op_lang$="" THEN 
     Errno=-1
     Errmsg$="No OP_LANG found in /opt/SPECS/sys/config/sysconf"          ! AVPATH_
   END IF
   IF Adtformat$="" THEN 
     Errno=-1
     Errmsg$="No ADTFORMAT found in /opt/SPECS/sys/config/sysconf"        ! AVPATH_
   END IF
   IF Clearonretest$="" THEN 
     Errno=-1
     Errmsg$="No CLEARONRETEST found in /opt/SPECS/sys/config/sysconf"    ! AVPATH_
   END IF
   IF Clearonreject$="" THEN 
     Errno=-1
     Errmsg$="No CLEARONREJECT found in /opt/SPECS/sys/config/sysconf"    ! AVPATH_
   END IF
   IF Portid$="" THEN 
     Errno=-1
     Errmsg$="No IPCPORT found in /opt/SPECS/sys/config/sysconf"          ! AVPATH_
   END IF
   IF Projid$="" THEN 
     Errno=-1
     Errmsg$="No PROJECT found in /opt/SPECS/sys/config/sysconf"          ! AVPATH_
   END IF
   IF Hostname$="" THEN 
     Errno=-1
     Errmsg$="No HOSTNAME found in /opt/SPECS/sys/config/sysconf"         ! AVPATH_
   END IF
   IF Adtlogging$="" THEN 
     Errno=-1
     Errmsg$="No ADTLOGGING found in /opt/SPECS/sys/config/sysconf"       ! AVPATH_
   END IF
   ASSIGN @Sysconf TO *
   SUBEXIT
 Err: !
   Errno=ERRN
   Errmsg$=ERRM$
 SUBEND
 Check_time:SUB Check_time(REAL Time)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CHECK_TIME
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Time            R    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Time=TIMEDATE
 SUBEND
 Clock:SUB Clock(INTEGER Digit,Year,Month,Day,Hour,Minute,Second,REAL Value)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CLOCK
 !  Vers : 1
 !  Desc : Returns the present date and time
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Digit           I    -        # digits to represent a year
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Year            I    -        Year:   YY or YYYY
 !      2 Month           I    -        Month:  MM
 !      3 Day             I    -        Day:    DD
 !      4 Hour            I    -        Hour:   HH
 !      5 Minute          I    -        Minute: MM
 !      6 Second          I    -        Second: SS
 !      7 Value           R    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM S$[80]
   Value=TIMEDATE
   ASSIGN @Pipe TO "date +'%C'; date +'%D'; date '+%H:%M:%S' |"
   ENTER @Pipe;S$
   Cent=VAL(S$[1;2])
   ENTER @Pipe;S$
   Year=VAL(S$[7;2])
   Month=VAL(S$[1;2])
   Day=VAL(S$[4;2])
   ENTER @Pipe;S$
   Hour=VAL(S$[1;2])
   Minute=VAL(S$[4;2])
   Second=VAL(S$[7;2])
   ASSIGN @Pipe TO *
   IF Digit=4 THEN Year=Cent*100+Year
 SUBEND
 Copy_file:SUB Copy_file(Source_file$,Desti_file$,INTEGER Mode,Status$,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : COPY_FILE
 !  Vers : 1
 !  Desc : Copy file or Move file
 !  Date : 03/05/2002
 !  Time : 21:30:23
 !  User : joy
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Source_file     S    -        Source file
 !      2 Desti_file      S    -        Destination file
 !      3 Mode            I    -        1: copy, 2: move
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          S    -        "OK", "ERROR"
 !      2 Error           S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                 !***** DON'T REMOVE THIS LINE *****
   ON ERROR GOTO Next_step
   PURGE Desti_file$
 Next_step:OFF ERROR 
   ON ERROR GOTO Fail_copy
   COPY Source_file$ TO Desti_file$
   OFF ERROR 
   PERMIT Desti_file$; OWNER:READ,WRITE; GROUP:READ,WRITE; OTHER:READ,WRITE
   IF Mode=2 THEN PURGE Source_file$
   Status$="OK"
   Error$=""
   SUBEXIT
 Fail_copy:      !
   OFF ERROR 
   PRINT "Fail to copy file from ";Source_file$;" to ";Desti_file$
   Status$="ERROR"
   Error$=""
 SUBEND
 Create_window:SUB Create_window(INTEGER Window,X,Y,W,H,Label$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CREATE_WINDOW
 !  Vers : 1
 !  Desc : Opens a new HP BASIC/UX window
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Window          I    -
 !      2 X               I    -
 !      3 Y               I    -
 !      4 W               I    -
 !      5 H               I    -
 !      6 Label           S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   ON ERROR GOTO Ignored
   CREATE WINDOW Window,X,Y,W,H;LABEL Label$,RETAIN
   GOTO Created
 Ignored:OFF ERROR 
 Created:SUBEXIT
 SUBEND
 Ctm_chk_log4070:SUB Ctm_chk_log4070(INTEGER Fixture_status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_CHK_LOG4070
 !  Vers : 1
 !  Desc : 201703,sami: check syslog4070 to find 7-10003 Fixture ope
 !       : n or not
 !       : 20200617,Echo modify to check probe card change status fo
 !       : r HLIC
 !  Date : 07/07/2020
 !  Time : 13:17:27
 !  User : agilent
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Fixture_status  I    -        1: open then normal, 2: open the
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
   INTEGER Code,Result
   DIM Sh_cmd$[1024]
  !
   DISP "in CTM_CHK_LOG4070"
   Sh_cmd$="/WATSERV/BIN/check_syslog4070.sh"
  !
   CALL Ctm_exeshell(Sh_cmd$,Result)
   PRINT "Check fixture in syslog4070:";Result
  !
   SELECT Result
   CASE 1
     Fixture_status=1
     PRINT "Fixture open then normal:PC changed, need update PCID"
   CASE 2
     Fixture_status=2
     PRINT "Fixture open then no action:not return normal in 5min,check log"
   CASE 0
     Fixture_status=0
    !PRINT "Fixture not open"
   CASE ELSE
     Fixture_status=-1
     PRINT "Shell execution error"
   END SELECT
   DISP 
  !
 SUBEND
 Ctm_clr_xterm:SUB Ctm_clr_xterm(Title$,Proc_kill$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_CLR_XTERM
 !  Vers : 1
 !  Desc : 201205,sami:close xterm
 !  Date : 05/31/2012
 !  Time : 03:47:04
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Title           S    -
 !      2 Proc_kill       S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
   ON ERROR GOSUB Nofile_4
   PURGE "/tmp/"&Proc_kill$
   OFF ERROR 
   CREATE "/tmp/"&Proc_kill$,2
   !EXECUTE "ps -ef|grep yellow|grep dtterm|grep WAT_TEST|cut -c 10-15 > /tmp/proc_kill"
   !EXECUTE "ps -ef|grep "&Back_ground$&"|grep xterm|grep "&Title$&"|cut -c 10-15 > /tmp/"&Proc_kill$
   EXECUTE "ps -ef|grep xterm|grep "&Title$&"|cut -c 10-15 > /tmp/"&Proc_kill$
   ON ERROR GOTO Cont10! No previous ddterm window opened
   ASSIGN @K TO "/tmp/"&Proc_kill$;FORMAT ON
   ON END @K GOTO Cont10
 Loop1:LOOP
     ENTER @K;Proc_id$
     EXECUTE "kill "&TRIM$(Proc_id$)
   END LOOP
  !ASSIGN @K TO *
  !OFF ERROR
   GOTO Cont10
 Nofile_4:OFF ERROR 
   CREATE "/tmp/"&Proc_kill$,2
   RETURN 
 Cont10:    !
   ASSIGN @K TO *
   OFF ERROR 
 SUBEND
 Ctm_diesize_chk:SUB Ctm_diesize_chk(Status$,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_DIESIZE_CHK
 !  Vers : 1
 !  Desc : Get die size from prober and compare this die size with i
 !       : t in wafer spec
 !  Date : 05/12/2014
 !  Time : 11:22:22
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          S    -        "OK" or "ERROR"
 !      2 Error           S    -        Error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                      !***** DON'T REMOVE THIS LINE *****
   COM /Hp_prbdvr/ Prb_model$[255],INTEGER Prb_address
   COM /Hp_prbdvr/ Prb_parm$[255],Prb_lot$[255],Prb_dev$[255]
   COM /Hp_prbdvr/ INTEGER Prb_diameter,Prb_coord,Prb_flat
   COM /Hp_prbdvr/ REAL Prb_stepx,Prb_stepy
   COM /Hp_prbdvr/ REAL Prb_init_dx,Prb_init_dy,Prb_init_mx,Prb_init_my
   COM /Hp_prbdvr/ REAL Prb_curr_dx,Prb_curr_dy,Prb_curr_mx,Prb_curr_my
   COM /Hp_prbdvr/ REAL Prb_curr_x,Prb_curr_y
   COM /Hp_prbdvr/ Prb_status$[255],Prb_error$[255]
     !
   DIM P_para$[255],Die_x$[20],Die_y$[20],Flat$[20],Info$[1000],Diex$[20],Diey$[20],Wafer_flat$[10],String1$[20],String2$[20],String3$[20],R_para$[255],Refer_x$[10],Refer_y$[10]
   DIM String4$[20],String5$[20],Rx_tester$[10],Ry_tester$[10]
   REAL Diex,Diey,Flat,Diex_tester,Diey_tester,Flat_tester,Rx,Ry,Rx_tester,Ry_tester
   INTEGER Tag_idx
     !
   Prober_output("G",Status$,Error$)                 ! Product parameter
   IF Status$<>"OK" THEN SUBEXIT
   Prober_enter(P_para$,Status$,Error$)
   IF Status$<>"OK" THEN SUBEXIT
     !
   Flat$=P_para$[22;1]
   IF Flat$="0" THEN Flat=0
   IF Flat$="3" THEN Flat=90
   IF Flat$="5" THEN Flat=180
   IF Flat$="7" THEN Flat=270
   Die_x$=P_para$[23;5]
   Die_y$=P_para$[28;5]
   Diex=VAL(Die_x$)
   Diey=VAL(Die_y$)
   PRINT "die x of prober is",Diex
   PRINT "die y of prober is",Diey
   PRINT "flat of prober is",Flat
     !
   ! Prober_output("a",Status$,Error$)   ! get reference die coordinates from prober
   ! IF Status$<>"OK" THEN SUBEXIT
   ! Prober_enter(R_para$,Status$,Error$)
   ! IF Status$<>"OK" THEN SUBEXIT
   ! Refer_x$=R_para$[1,3]
   ! Refer_y$=R_para$[4,6]
   ! Rx=VAL(Refer_x$)
   ! Ry=VAL(Refer_y$)
   ! PRINT "reference die x of prober is",Rx
   ! PRINT "reference die y of prober is",Ry
     !
      !Tpltagindex("SYSTEM","PRB_DIEX",Tag_idx)
      !Tplgetrtag("SYSTEM",Tag_idx,0,Diex_tester)
      !Tpltagindex("SYSTEM","PRB_DIEY",Tag_idx)
      !Tplgetrtag("SYSTEM",Tag_idx,0,Diey_tester)
      !Tpltagindex("WAFER","TMP_FLAT",Tag_idx)
      !Tplgetrtag("WAFER",Tag_idx,0,Flat_tester)
      !
   ON ERROR GOTO Err_file_miss
   ASSIGN @Tpl TO "/tmp/tempfmt.tpl"
   OFF ERROR 
   ON END @Tpl GOTO Err_not_found
 Loop1:LOOP
     ON ERROR GOTO Loop1
     ENTER @Tpl USING "K";Info$
     String1$=TRIM$(Info$[12,16])
     IF String1$="STEPX" THEN 
       Diex$=Info$[32,46]
       Diex_tester=VAL(Diex$)
       PRINT "diex of tester is",Diex_tester
       GOTO Loop2
     END IF
   END LOOP
 Loop2:LOOP
     ON ERROR GOTO Loop2
     ENTER @Tpl USING "K";Info$
     String2$=TRIM$(Info$[12,16])
     IF String2$="STEPY" THEN 
       Diey$=Info$[32,46]
       Diey_tester=VAL(Diey$)
       PRINT "diey of tester is",Diey_tester
       GOTO Loop3
     END IF
   END LOOP
 Loop3:LOOP
     ON ERROR GOTO Loop3
     ENTER @Tpl USING "K";Info$
     String3$=TRIM$(Info$[12,15])
     IF String3$="FLAT" THEN 
       Wafer_flat$=Info$[32,34]
       Flat_tester=VAL(Wafer_flat$)
       PRINT "flat of tester is",Flat_tester
       GOTO Judge
     END IF
   END LOOP
  !  Loop4:  LOOP
          ! ON ERROR GOTO Loop4
          ! ENTER @Tpl USING "K";Info$
          ! String4$=TRIM$(Info$[12,20])
          ! IF String4$="ALIGNDIEX" THEN
          ! Rx_tester$=Info$[32,34]
          ! Rx_tester=VAL(Rx_tester$)
          ! PRINT "reference die x of tester is",Rx_tester
          ! GOTO Loop5
          ! END IF
          ! END LOOP
   !   Loop5:  LOOP
          ! ON ERROR GOTO Loop5
          ! ENTER @Tpl USING "K";Info$
          ! String5$=TRIM$(Info$[12,20])
          ! IF String5$="ALIGNDIEY" THEN
          ! Ry_tester$=Info$[32,34]
          ! Ry_tester=VAL(Ry_tester$)
          ! PRINT "reference die y of tester is",Ry_tester
          ! GOTO Judge
          ! END IF
          ! END LOOP
      !
 Judge:     !
   IF Diex<>Diex_tester THEN 
     Status$="ERROR"
     Error$="The DIEX of tester doesn't match with prober!"
     PRINT "ERROR of CTM_DIESIZE_CHK is: ",Error$
     SUBEXIT
   END IF
   IF Diey<>Diey_tester THEN 
     Status$="ERROR"
     Error$="Then DIEY of tester doesn't match with prober!"
     PRINT "ERROR of CTM_DIESIZE_CHK is: ",Error$
     SUBEXIT
   END IF
   IF Flat<>Flat_tester THEN 
     Status$="ERROR"
     Error$="The FLAT of tester doesn't match with prober!"
     PRINT "ERROR of CTM_DIESIZE_CHK is:",Error$
     SUBEXIT
   END IF
    !  IF Rx<>Rx_tester THEN
    !  Status$="ERROR"
    !  Error$="The reference die x of tester doesn't match with prober!"
    !  PRINT "ERROR of CTM_DIESIZE_CHK is:",Error$
    !  SUBEXIT
    !  END IF
    !  IF Ry<>Ry_tester THEN
    !  Status$="ERROR"
    !  Error$="The reference die y of tester doesn't match with prober!"
    !  PRINT "ERROR of CTM_DIESIZE_CHK is:",Error$
    !  SUBEXIT
    !  END IF
       !
   Status$="OK"
   Error$=""
   SUBEXIT
 Err_file_miss:      !
   Status$="ERROR"
   Error$="Can't find the file of /tmp/tempfmt.tpl!"
   SUBEXIT
 Err_not_found:   !
   Status$="ERROR"
   Error$="Can't find the STEPX,STEPY and Flat in the file!"
   SUBEXIT
 SUBEND
 Ctm_exeshell:SUB Ctm_exeshell(Cmd$,INTEGER Rst)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_EXESHELL
 !  Vers : 1
 !  Desc : 20200617:Echo modify for HLIC
 !  Date : 06/17/2020
 !  Time : 16:43:17
 !  User : agilent
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Cmd             S    -        shell command to execute
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Rst             I    -        exit code of shell executing
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
   INTEGER Code
   EXECUTE Cmd$;RETURN Code
   Rst=SHIFT(Code,8)
 SUBEND
 Ctm_file_lookup:SUB Ctm_file_lookup(File$,Key$,Field$,INTEGER Position,Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_FILE_LOOKUP
 !  Vers : 1
 !  Desc : 201205,sami:Returns specified field of specified line in
 !       : an ASCII data file
 !  Date : 05/31/2012
 !  Time : 03:35:55
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 File            S    -        Master filename
 !      2 Key             S    -        Key string,will add ` in head an
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Field           S    -        Extracted field
 !      2 Position        I    -        position of key in extracted fie
 !      3 Stat            I    -        0(ok),-1(no key),-2(invalid),-3(
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                 !***** DON'T REMOVE THIS LINE *****
   Field$=""
   Position=0
   Key$="`"&Key$&"`"
   ON ERROR GOTO Nofile
   ASSIGN @Tmp TO File$;FORMAT ON
   OFF ERROR 
   ON END @Tmp GOTO Eof
   ON ERROR GOTO Overflow
   LOOP
     ENTER @Tmp;Field$
     IF Field$[1,1]<>"#" THEN 
       Position=POS(Field$,Key$)
     ! PRINT Position,Key$,Field$
       IF Position>0 THEN GOTO Exit1
     END IF
   END LOOP
   GOTO Exit1
 Nofile:Stat=-3
   SUBEXIT
 Eof:Stat=-1
   GOTO Exit1
 Overflow:Field$=""
   Stat=-2
   GOTO Exit1
 Exit1:    !
   ASSIGN @Tmp TO *
   SUBEXIT
 SUBEND
 Ctm_last_waf:SUB Ctm_last_waf(INTEGER Last_waf_no)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_LAST_WAF
 !  Vers : 1
 !  Desc : Get last wafer number from recipe
 !  Date : 01/15/2015
 !  Time : 10:19:42
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Last_waf_no     I    -        last wafer no. for testing
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                    !***** DON'T REMOVE THIS LINE *****
   COM /Hp_prbdvr/ Prb_model$[255],INTEGER Prb_address
   COM /Hp_prbdvr/ Prb_parm$[255],Prb_lot$[255],Prb_dev$[255]
   COM /Hp_prbdvr/ INTEGER Prb_diameter,Prb_coord,Prb_flat
   COM /Hp_prbdvr/ REAL Prb_stepx,Prb_stepy
   COM /Hp_prbdvr/ REAL Prb_init_dx,Prb_init_dy,Prb_init_mx,Prb_init_my
   COM /Hp_prbdvr/ REAL Prb_curr_dx,Prb_curr_dy,Prb_curr_mx,Prb_curr_my
   COM /Hp_prbdvr/ REAL Prb_curr_x,Prb_curr_y
   COM /Hp_prbdvr/ Prb_status$[255],Prb_error$[255]
   !
   DIM Fa_waf$(1:25,1:2)[2],Last_waf$[2]
   INTEGER Tag_idx
   !
   Tpltagindex("SYSTEM","FA_WAF_LIST",Tag_idx)
   Tplgetsatag("SYSTEM",Tag_idx,0,Fa_waf$(*))
   !
   FOR I=1 TO 25
     PRINT "fa_waf$ is ",Fa_waf$(I,1)
     IF Fa_waf$(I,1)<>"0" THEN 
       Last_waf$=Fa_waf$(I,1)
       PRINT "I=",Last_waf$
     END IF
   NEXT I
   PRINT "Last wafer no. is: ",Last_waf$
   Last_waf_no=VAL(Last_waf$)
    !
 SUBEND
 Ctm_mon_conv:SUB Ctm_mon_conv(INTEGER Month,Mon$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_MON_CONV
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 05/26/2011
 !  Time : 17:57:11
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Month           I    -        Month in integer
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Mon             S    -        Month in MMM
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
   SELECT Month
   CASE 1
     Mon$="JAN"
   CASE 2
     Mon$="FEB"
   CASE 3
     Mon$="MAR"
   CASE 4
     Mon$="APR"
   CASE 5
     Mon$="MAY"
   CASE 6
     Mon$="JUN"
   CASE 7
     Mon$="JUL"
   CASE 8
     Mon$="AUG"
   CASE 9
     Mon$="SEP"
   CASE 10
     Mon$="OCT"
   CASE 11
     Mon$="NOV"
   CASE 12
     Mon$="DEC"
   END SELECT
 SUBEND
 Ctm_pc_count:SUB Ctm_pc_count(INTEGER Prb_adr,REAL Count)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_PC_COUNT
 !  Vers : 1
 !  Desc : 2002/8/21: Joy HUANG
 !       : Send "kc" to P8 to request probe-card contact times in ON
 !       : _LINE mode
 !  Date : 08/21/2002
 !  Time : 22:05:18
 !  User : ae
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Prb_adr         I    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Count           R    -        the Z up/down times of prober ch
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
   DIM Count_temp$[20]
   INTEGER Online,Logmode
   Is_on_line(Online)
   ON ERROR GOSUB Err
   IF Online=1 THEN 
     OUTPUT Prb_adr;"kc"
     ENTER Prb_adr;Count_temp$
     Count=VAL(Count_temp$[3,12])
   ELSE
     PRINT "TEST session is OFFLINE, skip the GPIB command output"
     Count=1
     SUBEXIT
   END IF
    !
 Err:    !
   OFF ERROR 
   PRINT ERRM$
   BEEP 
  !
   Prober_log(Logmode)
   IF Logmode=1 THEN 
     ON ERROR GOTO Log_err_assign
     ASSIGN @File TO "/var/opt/SPECS/log/prober.log";APPEND           ! AVPATH_
     ON ERROR GOTO Log_err_output
     OUTPUT @File;TIME$(TIMEDATE)&" OUTPUT> "&"kc"&CHR$(10)
     OUTPUT @File;TIME$(TIMEDATE)&" ENTER < "&Count_temp$&CHR$(10)
 Log_err_output:  !
     ASSIGN @File TO *
 Log_err_assign:  !
     OFF ERROR 
   END IF
  !
 SUBEND
 Ctm_pc_leak:SUB Ctm_pc_leak(REAL Vbias,Ifail,Pcard_type$,Pcard_spec_dir$,REAL Wd,Wt,INTEGER Adc,Integ,Status$,Msg$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_PC_LEAK
 !  Vers : 1
 !  Desc : CTM: check probe-card leak
 !  Date : 01/19/2011
 !  Time : 13:09:41
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Vbias           R    -
 !      2 Ifail           R    -
 !      3 Pcard_type      S    -
 !      4 Pcard_spec_dir  S    -
 !      5 Wd              R    -        Waiting time for discharging pro
 !      6 Wt              R    -        Waiting time from force to measu
 !      7 ADC             I    -        ADC TYPE (0:HI-SPEED, 1:HI-RESOL
 !      8 INTEG           I    -        INTEGRATION TIME (0:MAN. 1:S, 2:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          S    -
 !      2 Msg             S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
   INTEGER Sta,Pin
   DIM Info$[100],Pcard_pinno$[2]
    !Pcard_pinno$=Pcard_type$[3,4]
   Pcard_pinno$=Pcard_type$[5,6]     ! Paul change for fab6  2018/07/17
                                        !
   DISP "Probe card leakage check ...."
   IF VAL(Pcard_pinno$)=0 THEN SUBEXIT
   ALLOCATE REAL Im(VAL(Pcard_pinno$)),INTEGER Pad(VAL(Pcard_pinno$))
   ASSIGN @Tmp TO Pcard_spec_dir$&"/"&Pcard_type$&".prb"
   ON END @Tmp GOTO Close_prb_spec
                                        ! Skip the header of probe spec
   Set_smu_ch(FNPort(0,2),Adc,0)
   Set_adc(Adc,Integ)
   Gnd_open_guard(1)
   Connect_th(FNPort(0,3),1,49)         ! all pins grounding,use SMU3 instead of GNDU
   Force_v(FNPort(0,3),0,0,.01)
   WAIT Wd
                                        !
   PRINT 
   PRINT "---------------- Probe card leakage result -----------------"
   PRINT 
   PRINT "            Pad   :   Pin   : Leakage (pA)    Port_status"
                                        !
                                        !
   FOR N=1 TO 11
     ENTER @Tmp USING "K";Info$
   NEXT N
   FOR M=1 TO VAL(Pcard_pinno$)
     ENTER @Tmp USING "K";Info$
     Pin=VAL(TRIM$(Info$[POS(Info$,",")+1]))         ! extract after "," in probe spec
     Pad(M)=Pin
     Connect(FNPort(0,2),Pad(M))
     Force_v(Pad(M),0,0,.01)
     Wait_th(.5)
     Force_v(Pad(M),Vbias,Vbias,.01)           ! Set 0V force/compliance
     Wait_th(Wt)
     Measure_i(Pad(M),Im(M),0)
     Port_status(Pad(M),Sta)
     Connect(FNPort(0,3),Pad(M))               ! use SMU3 instead of GNDU
     Force_v(FNPort(0,3),0,0,.01)
     IF ABS(Im(M))>=Ifail*1.E-12 THEN 
     !PRINT "     Fail    ";M;"      ";Pad(M);"    ";Im(M)*1.E+12;"        ";Sta
       PRINT USING "K,DD,K,DD,K,K,K,D";"     Fail    ";M;"        ";Pad(M);"       ";PROUND(Im(M)*1.E+12,-2);"             ";Sta
       Msg$=Msg$&" "&VAL$(M)&" "
       Status$="LEAK_FAIL"
     ELSE
     !PRINT "             ";M;"      ";Pad(M);"    ";Im(M)*1.E+12;"        ";Sta
       PRINT USING "K,DD,K,DD,K,K,K,Z";"             ";M;"        ";Pad(M);"        ";PROUND(Im(M)*1.E+12,-2);"             ";Sta
     END IF
   NEXT M
   IF Msg$="" THEN 
     Status$="LEAK_PASS"
   ELSE
     PRINT 
     PRINT "The leakage of below pins > ";Ifail;"pA"
     PRINT "["&Msg$&"]"
   END IF
                                    !
 Close_prb_spec:      !
   ASSIGN @Tmp TO *
                                    !
   PRINT "Done."
   Disable_port
   Connect
 SUBEND
 Ctm_pc_leak_dis:SUB Ctm_pc_leak_dis(REAL Vbias,Ifail,Pcard_type$,Pcard_spec_dir$,REAL Wd,Wt,INTEGER Adc,Integ,Pcard_id$,Status$,Msg$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_PC_LEAK_DIS
 !  Vers : 1
 !  Desc : CTM: check probe-card leak
 !  Date : 05/02/2013
 !  Time : 12:07:02
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Vbias           R    -
 !      2 Ifail           R    -
 !      3 Pcard_type      S    -
 !      4 Pcard_spec_dir  S    -
 !      5 Wd              R    -        Waiting time for discharging pro
 !      6 Wt              R    -        Waiting time from force to measu
 !      7 ADC             I    -        ADC TYPE (0:HI-SPEED, 1:HI-RESOL
 !      8 INTEG           I    -        INTEGRATION TIME (0:MAN. 1:S, 2:
 !      9 Pcard_id        S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          S    -
 !      2 Msg             S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
   INTEGER Sta,Pin
   DIM Info$[100],Pcard_pinno$[2]
    !Pcard_pinno$=Pcard_type$[3,4]
   Pcard_pinno$=Pcard_type$[5,6]    !Paul change for fab6  2018/07/17
                                        !
   DISP "Probe card leakage check ...."
   ASSIGN @File TO "/WAT/tmp/pc_leak";APPEND
   EXECUTE "xterm -geometry 50x15 -bg yellow -fg blue -title WAT_TEST -sb -e tail -f -n 25 /WAT/tmp/pc_leak &"
   IF VAL(Pcard_pinno$)=0 THEN SUBEXIT
    !ALLOCATE REAL Im(VAL(Pcard_pinno$)),INTEGER Pad(VAL(Pcard_pinno$))
   ALLOCATE REAL Im(50),INTEGER Pad(50)
   ASSIGN @Tmp TO Pcard_spec_dir$&"/"&Pcard_type$&".prb"
   ON END @Tmp GOTO Close_prb_spec
                                        ! Skip the header of probe spec
   Set_smu_ch(FNPort(0,2),Adc,0)
   Set_adc(Adc,Integ)
   Gnd_open_guard(1)
   Connect_th(FNPort(0,3),1,49)         ! all pins grounding,use SMU3 instead of GNDU
   Force_v(FNPort(0,3),0,0,.01)         ! use SMU3 instead of GNDU
   WAIT Wd
                                        !
   PRINT 
   PRINT "---------------- Probe card leakage result -----------------"
   PRINT 
   PRINT "            Pad   :   Pin   : Leakage (pA) :  Port_status"
                                        !
   DIM Pcard_name$[300]
   Pcard_name$=Pcard_type$&Pcard_id$
   OUTPUT @File USING "K";"Time:";DATE$(TIMEDATE)&" "&TIME$(TIMEDATE)
   OUTPUT @File USING "K";"Probe card ID:";Pcard_name$
   OUTPUT @File USING "K";"----------- Probe card leakage result -----------"
   OUTPUT @File USING "K";"     Pad   :   Pin   : Leakage (pA) : Port_status"
                                        !
                                        !
   FOR N=1 TO 11
     ENTER @Tmp USING "K";Info$
   NEXT N
   FOR M=1 TO VAL(Pcard_pinno$)
     ENTER @Tmp USING "K";Info$
     Pin=VAL(TRIM$(Info$[POS(Info$,",")+1]))         ! extract after "," in probe spec
     Pad(M)=Pin
     Connect(FNPort(0,2),Pad(M))
     Force_v(Pad(M),0,0,.01)
     Wait_th(.5)
     Force_v(Pad(M),Vbias,Vbias,.01)           ! Set 0V force/compliance
     Wait_th(Wt)
     Measure_i(Pad(M),Im(M),0)
     Im(M)=PROUND(Im(M)*1.E+12,-2)
     Port_status(Pad(M),Sta)
     Connect(FNPort(0,3),Pad(M))               ! use SMU3 instead of GNDU
     Force_v(FNPort(0,3),0,0,.01)              ! use SMU3 instead of GNDU
     IF ABS(Im(M))>=Ifail THEN 
       PRINT USING "K,DD,K,DD,K,K,K,D";"     Fail    ";M;"        ";Pad(M);"       ";Im(M);"             ";Sta
       IF LEN(VAL$(Im(M)))>4 THEN 
         OUTPUT @File USING "K,DD,K,DD,K,K,K,D";"Fail  ";M;"        ";Pad(M);"       ";Im(M);"            ";Sta
       ELSE
         OUTPUT @File USING "K,DD,K,DD,K,K,K,D";"Fail  ";M;"        ";Pad(M);"        ";Im(M);"            ";Sta
       END IF
       Msg$=Msg$&" "&VAL$(M)&" "
       Status$="LEAK_FAIL"
     ELSE
       PRINT USING "K,DD,K,DD,K,K,K,Z";"             ";M;"        ";Pad(M);"        ";Im(M);"             ";Sta
       IF LEN(VAL$(Im(M)))>4 THEN 
         OUTPUT @File USING "K,DD,K,DD,K,K,K,D";"      ";M;"        ";Pad(M);"       ";Im(M);"            ";Sta
       ELSE
         IF Im(M)>-1 THEN 
           OUTPUT @File USING "K,DD,K,DD,K,Z.DD,K,D";"      ";M;"        ";Pad(M);"        ";Im(M);"            ";Sta
         ELSE
           OUTPUT @File USING "K,DD,K,DD,K,ZZ.DD,K,D";"      ";M;"        ";Pad(M);"        ";Im(M);"            ";Sta
         END IF
       END IF
     END IF
   NEXT M
   IF Msg$="" THEN 
     Status$="LEAK_PASS"
   ELSE
     PRINT 
     PRINT "The leakage of below pins > ";Ifail;"pA"
     PRINT "["&Msg$&"]"
   END IF
                                    !
 Close_prb_spec:      !
   ASSIGN @Tmp TO *
   ASSIGN @File TO *
                                    !
   PRINT "Done."
   Disable_port
   Connect
 SUBEND
 Ctm_pc_mgr:SUB Ctm_pc_mgr(Pcil_mgr$,Pcard_type$,Pcard_id$,REAL Count,Leak_pin$,St$,Err$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_PC_MGR
 !  Vers : 1
 !  Desc : To update probe-card contact numbe and review the card
 !  Date : 03/27/2003
 !  Time : 13:46:34
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Pcil_mgr        S    -        PRBC_LIFE file for managing Prob
 !      2 Pcard_type      S    -        Probecard type
 !      3 Pcard_id        S    -        Probecard ID
 !      4 Count           R    -        the contact no. record in prober
 !      5 Leak_pin        S    -        If content is not empity, it wil
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 St              S    -
 !      2 Err             S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1    !***** DON'T REMOVE THIS LINE *****
   DISP "Ctm_pcil_mgr"
   DIM A$[400],Pcil_mgr_tmp$[50],Pcil_mgr_bak$[150],Shell_path$[50]
   DIM Pcil_r$[10],Pm_limit$[11],Pm_count$[14],Pcil_prb$[20]
   DIM Life_limit$[14],Life_count$[14],Pc_status$[11],Position$[9],Flag$[5],Leak$[5],Pin$[300]
   DIM Count_update$[80],File_check$[80],Char_alarm$[80],Shft_alarm$[80]
   DIM Lock_file$[80],Unlock_file$[80],Pm_alarm$[80],Show_log$[80]
                                            ! Define File PATH
   Pin$=TRIM$(Leak_pin$)
   Pcil_mgr_tmp$="/var/tmp/PRBC_LIFE.tmp"
   Pcil_mgr_bak$="/WATSERV/LOG/PRBC_LIFE.bak"
   Shell_path$="/WATSERV/BIN"
                                            ! in /WATSERV/LOG
                                            ! $cp PRBC_LIFE PRBC_LIFE.bak
                                            ! then
                                            ! $cp PRBC_LIFE /var/tmp/PRBC_LIFE.tmp
   EXECUTE "cp -p "&Pcil_mgr$&" "&Pcil_mgr_bak$
   EXECUTE "cp -p "&Pcil_mgr$&" "&Pcil_mgr_tmp$
                                            ! Define Shell Command
   Count_update$=Shell_path$&"/Prbc_update -u"
   File_check$=Shell_path$&"/Prbc_update -c"
   Lock_file$=Shell_path$&"/Prbc_update -k"
   Unlock_file$=Shell_path$&"/Prbc_update -r"
   Char_alarm$=Shell_path$&"/Prbc_update -x"
   Shft_alarm$=Shell_path$&"/Prbc_update -s"
   Pm_alarm$=Shell_path$&"/Prbc_update -p"
   Show_log$=Shell_path$&"/Prbc_update -v"
                                            !
   ON ERROR GOTO Shell_file_err
   ASSIGN @Shell TO Shell_path$&"/Prbc_update"
   ASSIGN @Shell TO *
   OFF ERROR 
                                            !
   EXECUTE Show_log$
   EXECUTE "cat /dev/null > "&Pcil_mgr_tmp$
   EXECUTE File_check$
   EXECUTE Lock_file$
                                            !
   ON ERROR GOTO Pcil_tmp_error
   ASSIGN @Tmp TO Pcil_mgr_tmp$
   OFF ERROR 
   ON ERROR GOTO Pcil_mgr_error
   ASSIGN @Plog TO Pcil_mgr$
   OFF ERROR 
                                            !
   ON END @Tmp GOTO Close_file
   ON END @Plog GOTO Close_file
   LOOP
     ENTER @Plog USING "K,#";A$              ! read from /WATSERV/LOG/PRBC_LIFE
      !IF A$=" " OR LEN(A$)<78 THEN GOTO Close_file
     Pcil_type$=TRIM$(A$[1,11])
     Pcil_id$=TRIM$(A$[12,17])
     Pcil_r$=A$[18,27]
     Pcil_prb$=A$[28,37]
     Pm_limit$=A$[38,48]
     Pm_count$=A$[49,62]
     Life_limit$=A$[63,76]
     Life_count$=A$[77,90]
     Pc_status$=A$[91,101]
     Position$=A$[102,110]
     Flag$=A$[111,115]
                                            !
     IF Pcil_type$=Pcard_type$ AND Pcil_id$=Pcard_id$ THEN 
       A$[49,62]=VAL$(VAL(Pm_count$)+Count)
       A$[77,90]=VAL$(VAL(Life_count$)+Count)
       PRINT "PCID:";Pcil_type$&"-"&Pcil_id$
       PRINT "Count no. before/after test:";TRIM$(Pm_count$)&"/"&TRIM$(A$[49,62])
       A$[111,115]="OK   "
       St$=""
       Err$=""
          !
          !20160615
       IF Pc_status$="IDLE       " OR Pc_status$="RUN        " THEN 
          !20160615
          !
                                            ! Card for DEAD/PM
         IF VAL(A$[77,90])>VAL(Life_limit$) THEN 
           BEEP 
           A$[111,115]="DEAD "
           St$="1"
           Err$="This card should be discarded !"
           PRINT Err$
           ASSIGN @Pc TO "/WAT/tmp/PC_STATUS"
           OUTPUT @Pc USING "K";"This card should be discarded"
           EXECUTE "xterm -geometry 50x10 -bg red -fg white -title PROBE_CARD_STATUS -sb -e tail -f -n 25 /WAT/tmp/PC_STATUS&"
           ASSIGN @Pc TO *
         END IF
         IF VAL(A$[49,62])>VAL(Pm_limit$) THEN 
           BEEP 
           EXECUTE Pm_alarm$&" "&TRIM$(Pcard_type$)&TRIM$(Pcard_id$)
           A$[111,115]="PM   "
           St$="1"
           Err$="This card should be PM !"
           PRINT Err$
           ASSIGN @Pc TO "/WAT/tmp/PC_STATUS"
           OUTPUT @Pc USING "K";"This card should be PM       "
           EXECUTE "xterm -geometry 50x10 -bg white -fg blue -title PROBE_CARD_STATUS -sb -e tail -f -n 25 /WAT/tmp/PC_STATUS&"
           ASSIGN @Pc TO *
         END IF
         IF LEN(Pin$)>0 THEN 
           A$[111,115]="X    "
           A$[116,120]="leak "
           A$=A$[1,120]&Pin$
           BEEP 
           BEEP 
           St$="1"
           Err$="Leakage of the probe-card > 1pA"
           PRINT "           ----------  WARNING  ---------"
           PRINT Err$
         ELSE
           A$=A$[1,115]
         END IF
          !
          !20160615
       ELSE
         St$="2"
         Err$="This card status is "&Pc_status$&"!"
         PRINT "St=";St$
         PRINT "Err=";Err$
       END IF
          !20160615
          !
     END IF
                                            !
     OUTPUT @Tmp USING "K,#";A$&CHR$(10)    ! write to /var/tmp/PRBC_LIFE.tmp
     PRINT A$
   END LOOP
                                            !
 Close_file:     !
   OFF ERROR 
   ASSIGN @Tmp TO *
   ASSIGN @Plog TO *
                                           ! cp /var/tmp/PRBC_LIFE.tmp /WATSERV/LOG/PRBC_LIFE
   EXECUTE "cp -p "&Pcil_mgr_tmp$&" "&Pcil_mgr$
   IF Alarm=0 AND Count_plus<>0 THEN EXECUTE Count_update$
   EXECUTE Unlock_file$
   SUBEXIT
                                            !
 Shell_file_err:     !
   OFF ERROR 
   PRINT "Can not find shell script : "&Shell_path$&"/prbc_update"
   SUBEXIT
 Pcil_tmp_error:      !
   OFF ERROR 
   PRINT Pcil_mgr_tmp$&" can not be opened !!!"
   EXECUTE Unlock_file$
   SUBEXIT
 Pcil_mgr_error:     !
   OFF ERROR 
   PRINT Pcil_mgr$&" error or Something wrong in SUB Prbc_life !"
   EXECUTE Unlock_file$
   SUBEXIT
   EXECUTE Unlock_file$
 SUBEND
 Ctm_pcid_log:SUB Ctm_pcid_log(File$,Eqid$,Pcid$,Rep_eqid$,Rep_pcid$,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_PCID_LOG
 !  Vers : 1
 !  Desc : 201301,sami: read/write host,pcid
 !  Date : 01/31/2013
 !  Time : 15:41:01
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 File            S    -        file name to log host,pcid
 !      2 Eqid            S    -        Tester host ID
 !      3 Pcid            S    -        Probecard ID
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Rep_eqid        S    -        replaced EQID in previous log fi
 !      2 Rep_pcid        S    -        replaced PCID in previous log fi
 !      3 Stat            I    -        0:no change; 1:replace OK; -1:EQ
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
 !
   DIM A$[45]
   DIM F_eqid$[20],F_pcid$[20]
   DIM Tmpfile$[50]
   INTEGER D,Find_eqid
 !
   Rep_eqid$="NULL"
   Rep_pcid$="NULL"
 !
   Tmpfile$="/d2/tmp/EQ_PCID.tmp"
   ON ERROR GOTO Create_f
   PURGE Tmpfile$
   OFF ERROR 
 Create_f: !
   CREATE Tmpfile$,2
   ASSIGN @Tmp TO Tmpfile$
 !
   ON ERROR GOTO File_not_found
   ASSIGN @F TO File$
   OFF ERROR 
 !
   ON END @F GOTO Close_file
   LOOP
     ENTER @F USING "K,K";A$
     D=POS(A$,",")
     F_eqid$=TRIM$(A$[1,D-1])
     F_pcid$=TRIM$(A$[D+1])
  !PRINT A$,D,F_eqid$,F_pcid$
   !
     IF Eqid$=F_eqid$ THEN 
       Find_eqid=1
       IF Pcid$=F_pcid$ THEN 
         PRINT "Found EQ and PC no change: "&A$
         Stat=0
       ELSE
         PRINT "Found EQ and change PC: "&A$&"->"&F_eqid$&","&Pcid$
         Rep_eqid$=F_eqid$
         Rep_pcid$=F_pcid$
         A$=Eqid$&","&Pcid$
         Stat=1
       END IF
     END IF
     OUTPUT @Tmp USING "K,K";A$
     PRINT A$
   END LOOP
 !
 Close_file:   !
   OFF ERROR 
   ASSIGN @F TO *
   ASSIGN @Tmp TO *
   EXECUTE "cp -p "&File$&" "&"/d2/tmp/"
   EXECUTE "cp -p "&Tmpfile$&" "&File$
   IF Find_eqid=0 THEN 
     PRINT "Can not find EQ: "&Eqid$
     Stat=-1
   END IF
   SUBEXIT
 !
 !
 File_not_found:  !
   PRINT "Can not find log file: "&File$
   ASSIGN @Tmp TO *
   Stat=-2
 SUBEND
 Ctm_pcid_upd:SUB Ctm_pcid_upd(Equip_id$,Pcard_type$,Pcard_id$,Dir_pcfile$,INTEGER Upd_syslog,Stat$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_PCID_UPD
 !  Vers : 1
 !  Desc : 201703,sami: update PCID to txt file for IT reading.
 !       : 20200617:Echo modify to update probe card status for HLIC
 !       : .
 !  Date : 06/17/2020
 !  Time : 16:46:32
 !  User : agilent
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Equip_id        S    -
 !      2 Pcard_type      S    -
 !      3 Pcard_id        S    -
 !      4 Dir_pcfile      S    -
 !      5 Upd_syslog      I    -        0: no update log deadline; 1: up
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Stat            S    -        "OK","ERROR"
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
   DIM Pc_file$[256],Log_date$[8],Log_time$[8],Log_timedate$[32]
   DIM Eq_id$[8]
  !
   IF Upd_syslog THEN 
     EXECUTE "wc /var/opt/hp4070/syslog4070 > /tmp/wc_syslog4070.txt"
   END IF
  !
   IF Pcard_type$="" OR Pcard_id$="" THEN 
     Pcard_type$="NO     CARD"
     Pcard_id$="NO     CARD"
   END IF
  !
   Eq_id$=UPC$(Equip_id$)
  !
   ASSIGN @Pipe TO "date '+Y%/%m/%d %H:%M:%S' |"
   ENTER @Pipe;Log_timedate$
   Log_date$=Log_timedate$[1;8]
  !
   Pc_file$=Dir_pcfile$&Equip_id$&".txt"
   ON ERROR GOTO File_error
   EXECUTE "cat /dev/null > "&Pc_file$
   ASSIGN @F TO Pc_file$;FORMAT ON
   OUTPUT @F;"EQ,Probe Card Type,Probe Card ID,Datetime"
   OUTPUT @F;Eq_id$&","&Pcard_type$&","&Pcard_id$&","&Log_timedate$
   ASSIGN @F TO *
   Stat$="OK"
   GOSUB Sub_exit
  !
 File_error:   !
   OFF ERROR 
   PRINT "PCID_UPD:Error when update PCID to /*/ProbeCard_Info/ file!"
   Stat$="ERROR"
 Sub_exit:     !
 SUBEND
 Ctm_pcil_acceso:SUB Ctm_pcil_acceso(INTEGER Check,Pcil_file$,INTEGER Hi,Lo,REAL Vf,Dev,Ip_file$,Pcard_type$,Pcard_id$,Pcard_spec$,St$,Err$,INTEGER Pcard_st)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_PCIL_ACCESo
 !  Vers : 1
 !  Desc : 20080424,sami: RFID & Meas R for PC ID extract from PCIL
 !       : Access PCIL to extract ProbeCard type/id       2002/8/16
 !       : Joy Huang
 !       : remove check for 48pin Pcard        2007/12/05 angel
 !       : RFID read R               2008/01/03 angel
 !  Date : 03/03/2011
 !  Time : 16:20:04
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Check           I    -        to decide if user want to extrac
 !      2 Pcil_file       S    -        Filename of PCIL file
 !      3 Hi              I    -        Hi, Lo mean the 2 pin (related t
 !      4 Lo              I    -
 !      5 Vf              R    -        force voltage to measure the res
 !      6 Dev             R    -        Tolerance btw Rmean and Rpcil to
 !      7 Ip_file         S    -        IP=10.216.54.14,Port=5000
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Pcard_type      S    -        Probecard type
 !      2 Pcard_id        S    -        Probecard ID
 !      3 Pcard_spec      S    -
 !      4 St              S    -        "OK" or "ERROR" or "END"
 !      5 Err             S    -        Error message
 !      6 Pcard_st        I    -        0: error   1:Wu   2:Cu
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
   DIM Info$[512],R$[20],R_pcil$[20],Unit$[1],Metal$[1],Item$(10)[8]
   INTEGER L,Online,Status
   REAL Delta,Rval,Res,Im,R1
  !------------ PCIL format ------------
  !   Pcard_type$   Pcard_id$    Pcil_r$
  !       1             2           3
  !
  !
  !
   Is_on_line(Online)
   IF Check=0 OR Online=0 THEN 
     Pcard_type$="IS12W"
     Pcard_id$="J01"
     St$="OK"
     Err$="SKIP"
     Pcard_spec$="IS12W" ! 2007/9/24 modify by angel for distinguish Pcard
     Pcard_st=0
     SUBEXIT
   END IF
   ON ERROR GOTO Measure_id ! 2008/3/12 modify by angel for no rfid
  !!!!!!!read Ip !!!!!!!!!!!!
  !DIM Ip$[20],Ports$[10]
  !INTEGER Port
  !ASSIGN @File TO "/WAT/ETC/IP_RFID"
  !ENTER @File USING "K";Ip$
  !ENTER @File USING "K";Ports$
  !ASSIGN @File TO *
  !Port=VAL(Ports$)
  ! PRINT Ip$,Ports$
  !
   IF Check=2 THEN  !20080530,sami: no rfid, goto measure Res
     GOSUB Measure_id
   END IF
  !!!!!! read rfid !!!!!!!!!!!!!
   Ctm_rfid(Ip_file$,6,0,"",Item$(*),Status)
   R1=VAL(Item$(6)) ! Page3:Res
   Res=R1
   PRINT "RFID_R1=",R1,"Status=",Status
   IF Status=0 THEN GOTO Find_id
   OFF ERROR  ! 2008/3/12 modify by angel for no rfid
  ! To measure the probe-card R
 Measure_id:      !
  !!!!!!!! measure R1!!!!!!!!!!!!
   Connect(FNGnd,Hi,Lo)
   Connect(FNPort(0,3),Hi)
   Force_v(Hi,Vf,Vf,.02)
   Measure_i(Hi,Im,0)
   Res=ABS(Vf/Im)
   PRINT "Card R=";Res
   Delta=(Dev/100.0)*Res ! Define the tolerance btw Rcard / Rpcil
  !
  !!!!! find pcid!!!!!!!!!!!!!!!!
 Find_id:    !
   PRINT "Find_id"
   ON ERROR GOTO Err_file_miss
   ASSIGN @Pcil TO Pcil_file$
   OFF ERROR 
   ON END @Pcil GOTO Err_not_found
 Loop1:LOOP
     PRINT "Loop1"
     ENTER @Pcil USING "K";Info$
     PRINT Info$
     Pcard_type$=TRIM$(Info$[1,6]) ! Levis for PCIL error handle
  !IF LEN(Pcard_type$)>2 THEN    ! 2004/4/21 levis for special probe card using
  !  Pcard_type$=""
  !END IF
     Pcard_id$=TRIM$(Info$[8,12])
     Matel$=Pcard_type$[5,5] ! 2007/9/26 angel for card type
     Mate=NUM(Matel$)
     IF Mate>64 AND Mate<91 THEN 
       IF Mate<79 THEN 
         Pcard_st=2             ! Pcard matel is for C
       ELSE
         Pcard_st=1             ! Pcard matel is for W
       END IF
     ELSE
       Pcard_st=0
     END IF ! 2007/9/26 angel for card type
  !IF LEN(Pcard_id$)>2 THEN
  !  Pcard_id$=""
  !END IF
     R_pcil$=TRIM$(Info$[14,22])
     R$=R_pcil$
     Pcard_spec$=TRIM$(Info$[24,31]) ! 2007/9/24 angel for distinguish Pcard
  !
     ON ERROR GOTO Loop1 ! Skip PCIL header, comment, title
  !
     L=LEN(R_pcil$)
     Unit$[1,1]=R_pcil$[L,L]
     SELECT Unit$
     CASE "K","k"
       R_pcil$[L,L]=" "
       Rval=VAL(R_pcil$)*1.E+3
     CASE "M"
       R_pcil$[L,L]=" "
       Rval=VAL(R_pcil$)*1.E+6
     CASE "G"
       R_pcil$[L,L]=" "
       Rval=VAL(R_pcil$)*1.E+9
     CASE ELSE
       Rval=VAL(R_pcil$)
     END SELECT
     PRINT "R_pcil:";Rval
     OFF ERROR 
  !
     IF (Res>=Rval-Delta) AND (Res<=Rval+Delta) THEN 
       PRINT 
       PRINT "Type  ID    Pcard_R"
       PRINT "-------------------"
       PRINT Info$
       PRINT 
       St$="OK"
       Err$=""
       SUBEXIT
     END IF
   END LOOP
  !
 Err_file_miss:      !
   PRINT "File_Miss"
   Pcard_type$="??"
   Pcard_id$="??"
   St$="ERROR"
   Err$="MISS"
   PRINT "**** Can NOT find ";Pcil_file$;" check if it is lost!! ****"
   SUBEXIT
 Err_not_found:      !
   PRINT "Not_found"
   Pcard_type$="??"
   Pcard_id$="??"
   St$="ERROR"
   Err$="NOT_FOUND"
   PRINT "**** The card ID can NOT be recognized in ";Pcil_file$;" ****"
   SUBEXIT
 SUBEND
 Ctm_pcil_access:SUB Ctm_pcil_access(INTEGER Check,Pcil_file$,INTEGER Hi,Lo,REAL Vf,Dev,Ip_file$,Pcard_type$,Pcard_id$,Pcard_spec$,St$,Err$,INTEGER Pcard_st)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_PCIL_ACCESS
 !  Vers : 1
 !  Desc : 20080424,sami: RFID & Meas R for PC ID extract from PCIL
 !       : Access PCIL to extract ProbeCard type/id       2002/8/16
 !       : Joy Huang
 !       : remove check for 48pin Pcard        2007/12/05 angel
 !       : increase probe card type length from 5 to 10    paul 2018
 !       : /07/17
 !       : RFID read R               2008/01/03 angel
 !  Date : 07/17/2018
 !  Time : 08:55:33
 !  User : agilent
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Check           I    -        to decide if user want to extrac
 !      2 Pcil_file       S    -        Filename of PCIL file
 !      3 Hi              I    -        Hi, Lo mean the 2 pin (related t
 !      4 Lo              I    -
 !      5 Vf              R    -        force voltage to measure the res
 !      6 Dev             R    -        Tolerance btw Rmean and Rpcil to
 !      7 Ip_file         S    -        IP=10.216.54.14,Port=5000
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Pcard_type      S    -        Probecard type
 !      2 Pcard_id        S    -        Probecard ID
 !      3 Pcard_spec      S    -
 !      4 St              S    -        "OK" or "ERROR" or "END"
 !      5 Err             S    -        Error message
 !      6 Pcard_st        I    -        0: error   1:Wu   2:Cu
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
   DIM Info$[512],R$[20],R_pcil$[20],Unit$[1],Pc_vendor$[1],Item$(10)[8],Page1_pctype$[10],Page2_pcid$[10]
   INTEGER L,Online,Status
   REAL Delta,Rval,Res,Im,R1
  !------------ PCIL format ------------
  !   Pcard_type$   Pcard_id$    Pcil_r$
  !       1             2           3
  !
  !
  !
   Is_on_line(Online)
   IF Check=0 OR Online=0 THEN 
     Pcard_type$="KIS012WAC"
     Pcard_id$="BM001"
     St$="OK"
     Err$="SKIP"
     Pcard_spec$="KIS012WAC" ! 2007/9/24 modify by angel for distinguish Pcard
     Pcard_st=1
     SUBEXIT
   END IF
  ! ON ERROR GOTO Measure_id! 2008/3/12 modify by angel for no rfid
  !
   IF Check=2 THEN  !20080530,sami: no rfid, goto measure Res
     GOSUB Measure_id
   END IF
  !!!!!! read rfid !!!!!!!!!!!!!
   Ctm_rfid(Ip_file$,2,0,"",Item$(*),Status)
  ! R1=VAL(Item$(6))! Page3:Res
  ! Res=R1
   Page1_pctype$=TRIM$(Item$(1))
   Page2_pcid$=TRIM$(Item$(2))
   PRINT "RFID_PC=",Page1_pctype$&Page2_pcid$,"Status=",Status
  ! Pcard_type$=Page1_pctype$
  ! Pcard_id$=Page2_pcid$
  ! Pc_vendor$=Pcard_id$[1,1]
  ! Pcard_st=Status
  ! Pcard_spec$=Page1_pctype$
  ! PRINT "RF read PCID"
  ! PRINT "Type   ID    Pcard_R"
  ! PRINT "-------------------"
  ! PRINT Info$
  ! PRINT
  ! St$="OK"
  ! Err$=""
    !
   IF Status=0 THEN GOTO Find_id
  !   SUBEXIT
  ! ELSE
  !   GOSUB Measure_id
  ! END IF
    !
  ! OFF ERROR ! 2008/3/12 modify by angel for no rfid
  ! To measure the probe-card R
 Measure_id:      !
  !!!!!!!! measure R1!!!!!!!!!!!!
   Connect(FNGnd,Hi,Lo)
   Connect(FNPort(0,3),Hi)
   Force_v(Hi,Vf,Vf,.02)
   Measure_i(Hi,Im,0)
   Res=ABS(Vf/Im)
   PRINT "Card R=";Res
   Delta=(Dev/100.0)*Res ! Define the tolerance btw Rcard / Rpcil
  !
  !!!!! find pcid!!!!!!!!!!!!!!!!
 Find_id:    !
   PRINT "Find_id"
   ON ERROR GOTO Err_file_miss
   ASSIGN @Pcil TO Pcil_file$
   OFF ERROR 
   ON END @Pcil GOTO Err_not_found
 Loop1:LOOP
     PRINT "Loop1"
     ENTER @Pcil USING "K";Info$
     PRINT Info$
     Pcard_type$=TRIM$(Info$[1,10]) ! Levis for PCIL error handle
     Pcard_id$=TRIM$(Info$[12,16])
     Pc_vendor$=Pcard_id$[2,2]
     Pcard_st=0
     R_pcil$=TRIM$(Info$[18,26])
     R$=R_pcil$
     Pcard_spec$=TRIM$(Info$[28,36]) ! 2007/9/24 angel for distinguish Pcard
  !
     ON ERROR GOTO Loop1 ! Skip PCIL header, comment, title
  !
     L=LEN(R_pcil$)
     Unit$[1,1]=R_pcil$[L,L]
     SELECT Unit$
     CASE "K","k"
       R_pcil$[L,L]=" "
       Rval=VAL(R_pcil$)*1.E+3
     CASE "M"
       R_pcil$[L,L]=" "
       Rval=VAL(R_pcil$)*1.E+6
     CASE "G"
       R_pcil$[L,L]=" "
       Rval=VAL(R_pcil$)*1.E+9
     CASE ELSE
       Rval=VAL(R_pcil$)
     END SELECT
     PRINT "R_pcil:";Rval
     OFF ERROR 
  !
     DIM Page1_type$[10],Page2_id$[10]
     INTEGER Length
     IF (Page1_pctype$<>"") AND (Page2_pcid$<>"") THEN 
       Page1_type$=Page1_pctype$&Page2_pcid$[1,1]
       Length=LEN(Page2_pcid$)
       Page2_id$=Page2_pcid$[2,Length]
     END IF
      !
     IF (Page1_type$=Pcard_type$) AND (Page2_id$=Pcard_id$) THEN 
     !IF (Page1_pctype$=Pcard_type$) AND (Page2_pcid$=Pcard_id$) THEN
       PRINT "RF read PCID"
       PRINT "Type   ID    Pcard_R"
       PRINT "-------------------"
       PRINT Info$
       PRINT 
       St$="OK"
       Err$=""
       SUBEXIT
     ELSE
       IF (Res>=Rval-Delta) AND (Res<=Rval+Delta) AND Rval<>0 THEN 
         PRINT "Measured PCID"
         PRINT "Type   ID    Pcard_R"
         PRINT "-------------------"
         PRINT Info$
         PRINT 
         St$="OK"
         Err$=""
         SUBEXIT
       END IF
     END IF
   END LOOP
  !
 Err_file_miss:      !
   PRINT "File_Miss"
   Pcard_type$="??"
   Pcard_id$="??"
   St$="ERROR"
   Err$="MISS"
   PRINT "**** Can NOT find ";Pcil_file$;" check if it is lost!! ****"
   SUBEXIT
 Err_not_found:      !
   PRINT "Not_found"
   Pcard_type$="??"
   Pcard_id$="??"
   St$="ERROR"
   Err$="NOT_FOUND"
   PRINT "**** The card ID can NOT be recognized in ";Pcil_file$;" ****"
   SUBEXIT
 SUBEND
 Ctm_pos:SUB Ctm_pos(Original$,Search$,INTEGER Length,Position,Prefix$,Postfix$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_POS
 !  Vers : 1
 !  Desc : 20080522,sami:Check string position for MergeLot
 !  Date : 03/30/2012
 !  Time : 07:59:45
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Original        S    -        Input string:E001_WAT1M1
 !      2 Search          S    -        string position:E001
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Length          I    -
 !      2 Position        I    -
 !      3 Prefix          S    -
 !      4 Postfix         S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
   INTEGER N
   Length=LEN(Original$) ! 20080527,sami: eg: Original$=0001A_WAT1RC
   N=LEN(Search$) ! 20080527,sami: eg: Search$=0001A
   Position=POS(Original$,Search$)
   IF Position=0 THEN SUBEXIT
   Prefix$=Original$[1,Position-1] ! 20080527,sami: eg: Prefix$=""
   Postfix$=Original$[Position+N+5,Length] ! 20080527,sami: eg: Postfix$=RC
 SUBEND
 Ctm_posold:SUB Ctm_posold(Original$,Search$,INTEGER Length,Position,Prefix$,Postfix$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_POSold
 !  Vers : 1
 !  Desc : Check string position
 !  Date : 05/22/2003
 !  Time : 10:29:44
 !  User : f2eng
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Original        S    -        Input string
 !      2 Search          S    -        string position
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Length          I    -
 !      2 Position        I    -
 !      3 Prefix          S    -
 !      4 Postfix         S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
   Length=LEN(Original$)
   Position=POS(Original$,Search$)
   IF Position=0 THEN SUBEXIT
   Prefix$=Original$[1,Position-1]
   Postfix$=Original$[Position+5,Length]
 SUBEND
 Ctm_purge_disp:SUB Ctm_purge_disp(Purge_file$,Create_file$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_PURGE_DISP
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 06/17/2003
 !  Time : 14:24:44
 !  User : levis
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Purge_file      S    -
 !      2 Create_file     S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
   ON ERROR GOSUB Nofile_4
   PURGE Purge_file$
   OFF ERROR 
   CREATE Create_file$,2
   OFF ERROR 
   GOTO Cont10
 Nofile_4:OFF ERROR 
   CREATE Create_file$,2
   RETURN 
 Cont10:   !
   OFF ERROR 
 SUBEND
 Ctm_rfid:SUB Ctm_rfid(Ip_file$,INTEGER Page,Rw,Write_info$,Item$(*),INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_RFID
 !  Vers : 1
 !  Desc : 20080520,sami: read/write PC info by RFID
 !       : 1.Flag,2:Contact_PM,3:Contact_total,4:PM_Limit,5:Life_Lim
 !       : it,6:Res,7:Prb,8:Type,9:ID
 !  Date : 05/16/2011
 !  Time : 07:18:21
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 IP_FILE         S    -        IP=10.216.54.14,Port=5000
 !      2 PAGE            I    -        1.PC_type;2.PC_ID
 !      3 RW              I    -        0:read,1:write
 !      4 WRITE_INFO      S    -        Information to write in RFID
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 ITEM            S    10
 !      2 STATUS          I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
   DIM Read_data$(17)[8] ! define tag 17page & 8bits
   INTEGER I,N,M,Online
   DIM Info$[200]
   ON ERROR GOTO Error_handle
   Info$=""
   FOR I=1 TO SIZE(Item$,1)
     Item$(I)=""
   NEXT I
   IF Write_info$="" THEN 
     Rw=0
   END IF
   IF Rw=1 AND Page>2 THEN  !20080530,sami: can not write to page 3~9
     Rw=0
   END IF
  ! IF LEN(Write_info$)>8 THEN         ! 20080527,sami: check write string length(0~8)
  !   Status=1
  !   GOSUB Check_status
  ! END IF
  ! Is_on_line(Online)
  ! IF Online=0 THEN
  !   Status=0
  !   GOSUB Check_status
  ! END IF
  !
  ! Read IP
   DIM Ip$[20],Ports$[10]
   INTEGER Port
   ON ERROR GOSUB Ip_file_error
   ASSIGN @File TO Ip_file$
   ENTER @File USING "K";Ip$
   ENTER @File USING "K";Ports$
   ASSIGN @File TO *
   OFF ERROR 
   Port=VAL(Ports$)
   PRINT Ip$,Ports$
  !
   N=0
   M=0
   Status=0
 Check_read:    !
   N=N+1
   WAIT 1 ! 20080527,sami:add for rfid prepare
   ASSIGN @Data TO 1
   ASSIGN @Data TO "/WATSERV/BIN/rfid/read "&Ip$&" "&VAL$(Port)&" "&VAL$(Page)&" |"
   ON END @Data GOSUB Loop_begin
   FOR I=1 TO SIZE(Item$,1)
     ENTER @Data;Item$(I)
   NEXT I
 Loop_begin:     !
   WHILE N<=3 !20080527,sami: total check <3 times
     FOR I=1 TO Page !20080529,sami: only check until written page
       IF Item$(I)="" THEN 
         PRINT I," Page is NULL"
         SELECT I
         CASE 1,2
           Status=2
           PRINT "Status=",Status,"i=",I
           GOTO Check_read
         CASE 3,4,5,6,7,8,9
           Status=0
           PRINT "Status=",Status,"i=",I     !201105,sami:page3-9 is null as default
          ! GOTO Check_read
         END SELECT
       END IF
     NEXT I
     PRINT "Read Pass!"
     N=4 ! 20080527,sami: normal quit loop
   END WHILE
  !
  ! Read-Write to RFID
   IF Rw=1 AND Write_info$<>Item$(Page) AND M<3 THEN  !20080529,sami: re-write times<3
  ! ASSIGN @Data TO 1
  ! ASSIGN @Data TO "/WATSERV/TOOLS/rfid/read "&Ip$&" "&VAL$(Port)&" "&VAL$(Page)&" |"
  ! ON END @Data GOSUB Rf_write
  ! FOR I=1 TO SIZE(Item$,1)
  !   ENTER @Data;Item$(I)
  ! NEXT I
  !
 Rf_write:   !
     PRINT "Pre-Write:",Item$(*)
     Item$(Page)=Write_info$
     FOR I=1 TO Page ! 20080529,sami: only write until destination page
       Info$=Info$&" "&Item$(I)
     NEXT I
     PRINT "Write to RFID:",Info$
     WAIT 1 ! 20080527,sami: add for rfid read/write prepare
     EXECUTE "/WATSERV/BIN/rfid/write "&Ip$&" "&VAL$(Port)&" "&Info$
     N=0
     M=M+1
     GOSUB Check_read
   END IF
  !
   OFF ERROR 
   PRINT "Read Rfid:",Item$(*),"Status=",Status
   GOSUB Check_status
 Error_handle:     !
   OFF ERROR 
   Status=4
 Ip_file_error:    !
   OFF ERROR 
   Status=5
 Check_status:     !
   IF Status<>0 THEN 
     FOR I=1 TO SIZE(Item$,1)
       Item$(I)="1E+34"
     NEXT I
   END IF
 SUBEND
 Ctm_telp8_info:SUB Ctm_telp8_info(Overdrive$,Status$,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_TELP8_INFO
 !  Vers : 1
 !  Desc : Gets prober recipe overdrive
 !  Date : 06/20/2003
 !  Time : 15:57:05
 !  User : levis
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Overdrive       S    -        Flat angle defined in prober
 !      2 Status          S    -        "OK" or "ERROR"
 !      3 Error           S    -        Error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                   !***** DON'T REMOVE THIS LINE *****
   COM /Hp_prbdvr/ Prb_model$[255],INTEGER Prb_address
   COM /Hp_prbdvr/ Prb_parm$[255],Prb_lot$[255],Prb_dev$[255]
   COM /Hp_prbdvr/ INTEGER Prb_diameter,Prb_coord,Prb_flat
   COM /Hp_prbdvr/ REAL Prb_stepx,Prb_stepy
   COM /Hp_prbdvr/ REAL Prb_init_dx,Prb_init_dy,Prb_init_mx,Prb_init_my
   COM /Hp_prbdvr/ REAL Prb_curr_dx,Prb_curr_dy,Prb_curr_mx,Prb_curr_my
   COM /Hp_prbdvr/ REAL Prb_curr_x,Prb_curr_y
   COM /Hp_prbdvr/ Prb_status$[255],Prb_error$[255]
  !
   DIM P_para$[255]
  !
   Prober_output("G",Status$,Error$)              ! Product parameter
   IF Status$<>"OK" THEN SUBEXIT
   Prober_enter(P_para$,Status$,Error$)
   IF Status$<>"OK" THEN SUBEXIT
  !
   Overdrive$=P_para$[33;3]
   Overdrive=VAL(Overdrive$)
   Overdrive$=VAL$(Overdrive)
  !
   Status$="OK"
   Error$=""
   SUBEXIT
 SUBEND
 Ctm_test_log:SUB Ctm_test_log(Testlog$,INTEGER Status,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_TEST_LOG
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !       : 1. change product ID to "TST_RCP_PROCESS"   ----Paul, 201
 !       : 10425
 !       : 2. change probe card ID from 9 bits to 10 bits  ----Paul,
 !       :  20110425
 !       : 3. add prober recipe to Testlog file   ----Paul, 20110425
 !       : 4. Add Technology ID into Testlog file. / Richard Shen 20
 !       : 15.2.28
 !  Date : 04/14/2015
 !  Time : 14:14:56
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Testlog         S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -
 !      2 Error           S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1   !***** DON'T REMOVE THIS LINE *****
   DIM Lid$[256],Pro$[256],Fp$[256],Op$[256],Sdt$[256],Edt$[256],Eq$[256],T$[256],Pc$[256],Prb$[256],Wj$[256],Prbt$[256],Od$[256],Wn$[256],Wp$[256],Wf$[256],Lt$[256],Wt$[256],Ctr$[256]
   DIM Tech$[256]     ! New added. Richard Shen 2015.2.28
   DIM Contact$[50]   ! New added. Paul zhu  2018/10/23
   INTEGER Tag_idx,I,Length,Wcnt,Wpass
   REAL Lottime,Waftime,Contact_count
   T$=" "
   I=1
   Tpltagindex("SYSTEM","TST_RCP_LOTID",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Lid$)
   Tpltagindex("SYSTEM","TST_RCP_PROCESS",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Pro$)
   Tpltagindex("SYSTEM","OVERDRIVE",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Od$)
   Tpltagindex("SYSTEM","CTM_OP_ID",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Op$)
   Tpltagindex("SYSTEM","CTM_EQUIPID",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Eq$)
   Tpltagindex("LOT","CTM_TESTSTART",Tag_idx)
   Tplgetstag("LOT",Tag_idx,0,Sdt$)
   Tpltagindex("LOT","CTM_TESTEND",Tag_idx)
   Tplgetstag("LOT",Tag_idx,0,Edt$)
   Tpltagindex("SYSTEM","CTM_PC_ID",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Pc$)
   Tpltagindex("SYSTEM","CTM_PROBER_RECIPE",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Prb$)
   Tpltagindex("SYSTEM","CTM_WAF_JDG",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Wj$)
   Tpltagindex("SYSTEM","CTM_TEMPERATURE",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Prbt$)
   Tpltagindex("SYSTEM","CTM_LOT_TIME",Tag_idx)
   Tplgetrtag("SYSTEM",Tag_idx,0,Lottime)
   Tpltagindex("SYSTEM","CTM_WAF_COUNT",Tag_idx)
   Tplgetitag("SYSTEM",Tag_idx,0,Wcnt)
   Tpltagindex("SYSTEM","CTM_WAF_PASS",Tag_idx)
   Tplgetitag("SYSTEM",Tag_idx,0,Wpass)
   Tpltagindex("SYSTEM","CTM_WAF_TIME",Tag_idx)
   Tplgetrtag("SYSTEM",Tag_idx,0,Waftime)
   Tpltagindex("SYSTEM","CTM_FOUP_ID",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Fp$)
   Tpltagindex("SYSTEM","FA_CONTROL_MODE",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Ctr$)
   Tpltagindex("SYSTEM","CTM_TECH",Tag_idx)
   Tplgetstag("SYSTEM",Tag_idx,0,Tech$)
   Tpltagindex("SYSTEM","CTM_CONTACT",Tag_idx)
   Tplgetrtag("SYSTEM",Tag_idx,0,Contact_count)
     !
   Contact$=VAL$(Contact_count)
     !
   Length=LEN(Lid$)
   IF Length<24 THEN 
     FOR I=Length+1 TO 24
       Lid$[I]=" "
     NEXT I
   END IF
     !
   Length=LEN(Pro$)
   IF Length<24 THEN 
     FOR I=Length+1 TO 24
       Pro$[I]=" "
     NEXT I
   END IF
     !
   Length=LEN(Fp$)
   IF Length<14 THEN 
     FOR I=Length+1 TO 14
       Fp$[I]=" "
     NEXT I
   END IF
   Length=LEN(Od$)
   IF Length<4 THEN 
     FOR I=Length+1 TO 4
       Od$[I]=" "
     NEXT I
   END IF
     !
   Length=LEN(Op$)
   IF Length<9 THEN 
     FOR I=Length+1 TO 9
       Op$[I]=" "
     NEXT I
   END IF
     !
   Length=LEN(Eq$)
   IF Length<14 THEN 
     FOR I=Length+1 TO 14
       Eq$[I]=" "
     NEXT I
   END IF
     !
   Length=LEN(Pc$)
   IF Length<9 THEN 
     FOR I=Length+1 TO 9
       Pc$[I]=" "
     NEXT I
   END IF
     !
   Length=LEN(Prb$)
   IF Length<14 THEN 
     FOR I=Length+1 TO 14
       Prb$[I]=" "
     NEXT I
   END IF
    !
   Length=LEN(Prbt$)
   IF Length<9 THEN 
     FOR I=Length+1 TO 9
       Prbt$[I]=" "
     NEXT I
   END IF
    !
   Length=LEN(Wj$)
   IF Length<150 THEN 
     FOR I=Length+1 TO 150
       Wj$[I]=" "
     NEXT I
   END IF
    !
   Lt$=VAL$(DROUND(Lottime,7))
   Length=LEN(Lt$)
   IF Length<14 THEN 
     FOR I=Length+1 TO 14
       Lt$[I]=" "
     NEXT I
   END IF
    !
   Wt$=VAL$(DROUND(Waftime,7))
   Length=LEN(Wt$)
   IF Length<14 THEN 
     FOR I=Length+1 TO 14
       Wt$[I]=" "
     NEXT I
   END IF
     !
   Wn$=VAL$(Wcnt)
   Length=LEN(Wn$)
   IF Length<4 THEN 
     FOR I=Length+1 TO 4
       Wn$[I]=" "
     NEXT I
   END IF
    !
   Wp$=VAL$(Wpass)
   Length=LEN(Wp$)
   IF Length<4 THEN 
     FOR I=Length+1 TO 4
       Wp$[I]=" "
     NEXT I
   END IF
     !
   Wf$=VAL$(Wcnt-Wpass)
   Length=LEN(Wf$)
   IF Length<4 THEN 
     FOR I=Length+1 TO 4
       Wf$[I]=" "
     NEXT I
   END IF
     !
   Length=LEN(Ctr$)
   IF Length<10 THEN 
     FOR I=Length+1 TO 10
       Ctr$[I]=" "
     NEXT I
   END IF
     !
   Fp$="FOUP_ID"
     !!!
   ASSIGN @Tl TO Testlog$;APPEND
   ON ERROR GOTO Eof
      !OUTPUT @Tl USING "K";"LOT ID         Product    Overdrive       Operator START DATE START TIME END DATE   END TIME   Equipment "
   OUTPUT @Tl USING "K";Lid$;T$;Pro$;T$;Prb$;T$;Fp$;T$;Tech$;T$;Op$;T$;Eq$;T$;Ctr$;T$;Pc$;T$;Od$;T$;Prbt$;T$;Sdt$;T$,Edt$;T$;Lt$;T$;Wt$;T$;Wn$;T$;Wp$;T$;Wf$;T$;Wj$;T$;Contact$
   ON END @Tl GOTO Eof
 Eof:ASSIGN @Tl TO *
 SUBEND
 Ctm_time_cal:SUB Ctm_time_cal(Start_time$,End_time$,REAL Timespend)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_TIME_CAL
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 03/23/2012
 !  Time : 05:27:49
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Start_time      S    -
 !      2 End_time        S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Timespend       R    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1  !***** DON'T REMOVE THIS LINE *****
   DIM Start_m$[2],Start_d$[2],Start_y$[4],End_m$[2],End_d$[2],End_y$[4]
   REAL Time_min,Date_min
   DIM Temp_string1$[20],Temp_string2$[20],Start_mon$[3],End_mon$[3]
   INTEGER Pos1,Pos2,Pos3,Pos4,Mon1,Mon2,Pos5,Pos6
     !
     ! time="2012/03/23_13:35:43"
     !
   Pos1=POS(Start_time$,"_")            ! seperate date and time
   Pos2=POS(End_time$,"_")
   PRINT Pos1,Pos2,Start_time$[Pos1+1],"--",End_time$[Pos2+1]
   Time_min=(TIME(End_time$[Pos2+1])-TIME(Start_time$[Pos1+1]))/60      ! second -> minute
   ! PRINT "date",Start_time$[1,Pos1-1],End_time$[1,Pos2-1]
   IF Start_time$[1,Pos1]<>End_time$[1,Pos2] THEN 
     Pos3=POS(Start_time$[1,Pos1],"/")        ! seperate year and mon/day
     Pos4=POS(End_time$[1,Pos2],"/")
     Pos5=POS(Start_time$[Pos3+1],"/")        ! seperate mon and day
     Pos6=POS(End_time$[Pos4+1],"/")
     Mon1=VAL(Start_time$[Pos3+1,Pos3+Pos5-1])
     Mon2=VAL(End_time$[Pos4+1,Pos4+Pos6-1])
      !PRINT Mon1,Mon2
     CALL Ctm_mon_conv(Mon1,Start_mon$)
     CALL Ctm_mon_conv(Mon2,End_mon$)
       !
       ! temp_date="23 Mar 2012"
       !
     Temp_string1$=Start_time$[Pos3+Pos5+1,Pos1-1]&" "&Start_mon$&" "&Start_time$[1,Pos3-1]
     Temp_string2$=End_time$[Pos4+Pos6+1,Pos2-1]&" "&End_mon$&" "&End_time$[1,Pos4-1]
     ! PRINT Temp_string1$,"--",Temp_string2$
     Date_min=((DATE(Temp_string2$)-DATE(Temp_string1$)))/60
   END IF
   Timespend=Date_min+Time_min
   ! PRINT "date-date",DATE("28 Apr 2011")-DATE("27 Apr 2011")    ! 86400
   ! PRINT "time-time",TIME("16:21:26")-TIME("15:21:26")          !3600
 SUBEND
 Ctm_timedate:SUB Ctm_timedate(Time$,Time2$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_TIMEDATE
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 03/27/2012
 !  Time : 04:32:31
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Time            S    -        20111231142325
 !      2 Time2           S    -        2011/12/31_14:23:25
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
  !Time=TIMEDATE
   ASSIGN @Pipe TO "date +'%C%y%m%d%H%M%S'; date +'%C%y/%m/%d_%H:%M:%S' |"
   ENTER @Pipe;Time$
   ENTER @Pipe;Time2$
   ASSIGN @Pipe TO *
 SUBEND
 Ctm_upd_info:SUB Ctm_upd_info(Info_file$,Lot_id$,Pc_id$,Recipe$,Start_time$,End_time$,Waf_done$,Waf_untest$,Status$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_UPD_INFO
 !  Vers : 1
 !  Desc : 2020/8/12 Echo add for testinfo log update
 !  Date : 08/12/2020
 !  Time : 13:42:42
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Info_file       S    -
 !      2 Lot_id          S    -
 !      3 Pc_id           S    -
 !      4 Recipe          S    -
 !      5 Start_time      S    -
 !      6 End_time        S    -
 !      7 Waf_done        S    -
 !      8 Waf_untest      S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1   !***** DON'T REMOVE THIS LINE *****
   DIM Cmd$[1000],Hostname$[50],Info$[600]
   DIM Shell_path$[50],Testinfo_tmp$[600],Testinfo_bak$[600]
   DIM Count_update$[80],File_check$[80],Char_alarm$[80],Shft_alarm$[80]
   DIM Lock_file$[80],Unlock_file$[80],Show_log$[80]
     !
   Testinfo_tmp$="/tmp/info_update.tmp"
   Testinfo_bak$="/WATSERV/LOG/TEST_INFO.bak"
   Shell_path$="/WATSERV/BIN"
     !
   EXECUTE "cp -p "&Info_file$&" "&Testinfo_bak$
   EXECUTE "cp -p "&Info_file$&" "&Testinfo_tmp$
     !
   File_check$=Shell_path$&"/testlog_update -c"
   Lock_file$=Shell_path$&"/testlog_update -k"
   Unlock_file$=Shell_path$&"/testlog_update -r"
   Char_alarm$=Shell_path$&"/testlog_update -x"
   Shft_alarm$=Shell_path$&"/testlog_update -s"
   Show_log$=Shell_path$&"/testlog_update -v"
     !
   ON ERROR GOTO Shell_file_err
   ASSIGN @Shell TO Shell_path$&"/testlog_update"
   ASSIGN @Shell TO *
   OFF ERROR 
     !
   EXECUTE Show_log$
   EXECUTE "cat /dev/null > "&Testinfo_tmp$
   EXECUTE File_check$
   EXECUTE Lock_file$
     !
   ON ERROR GOTO Info_tmp_error
   ASSIGN @Tmp TO Testinfo_tmp$
   OFF ERROR 
   ON ERROR GOTO Info_file_error
   ASSIGN @Plog TO Info_file$
   OFF ERROR 
     !
   ON END @Tmp GOTO Close_file
   ON END @Plog GOTO Close_file
     !
   ON ERROR GOTO System_error
   ASSIGN @File TO "hostname |"
   ENTER @File;Hostname$
   ASSIGN @File TO *
     !
   Info$=Hostname$&"  "&Lot_id$&"  "&Pc_id$&"  "&Recipe$&"  "&Start_time$&"  "&End_time$&"  ALL_WAFER_ID: "&Waf_done$&"  DONE_WAFER_ID: "&Waf_untest$
   Cmd$="awk -F"&CHR$(34)&"\t"&CHR$(34)&" 'BEGIN{OFS="&CHR$(34)&" "&CHR$(34)&";FS="&CHR$(34)&" "&CHR$(34)&";}{if($1=="&CHR$(34)&Hostname$
   Cmd$=Cmd$&CHR$(34)&") print "&CHR$(34)&Info$&CHR$(34)&";else print $0;}' "&Info_file$&" >/tmp/info_update.tmp"
   PRINT "cmd=",Cmd$
   EXECUTE Cmd$
   EXECUTE "cp /tmp/info_update.tmp "&Info_file$
   Status$="OK"
   EXECUTE Unlock_file$
   SUBEXIT
 System_error:    !
   OFF ERROR 
   Status$="ERROR"
   EXECUTE Unlock_file$
   SUBEXIT
 Close_file:      !
   OFF ERROR 
   ASSIGN @Tmp TO *
   ASSIGN @Plog TO *
   EXECUTE Unlock_file$
   SUBEXIT
 Shell_file_err:  !
   OFF ERROR 
   PRINT "Can not find shell script : "&Shell_path$&"/testlog_update"
   SUBEXIT
 Info_tmp_error:  !
   OFF ERROR 
   PRINT Testinfo_tmp$&" can not be opened !!!"
   EXECUTE Unlock_file$
   SUBEXIT
 Info_file_error: !
   OFF ERROR 
   PRINT Info_file$&" error or something wrong in sub test_info !"
   EXECUTE Unlock_file$
   SUBEXIT
   EXECUTE Unlock_file$
 SUBEND
 Ctm_update_info:SUB Ctm_update_info(Info_file$,Lot_id$,Pc_id$,Recipe$,Start_time$,End_time$,Waf_done$,Waf_untest$,Status$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : CTM_UPDATE_INFO
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 03/02/2020
 !  Time : 10:10:02
 !  User : agilent
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Info_file       S    -
 !      2 Lot_id          S    -
 !      3 Pc_id           S    -
 !      4 Recipe          S    -
 !      5 Start_time      S    -
 !      6 End_time        S    -
 !      7 Waf_done        S    -
 !      8 Waf_untest      S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1  !***** DON'T REMOVE THIS LINE *****
   DIM Cmd$[1000],Hostname$[50],Info$[600]
    !
   ON ERROR GOTO System_error
   ASSIGN @File TO "hostname |"
   ENTER @File;Hostname$
   ASSIGN @Fiel TO *
    !
   Info$=Hostname$&"  "&Lot_id$&"  "&Pc_id$&"  "&Recipe$&"  "&Start_time$&"  "&End_time$&"  ALL_WAFER_ID: "&Waf_done$&"  DONE_WAFER_ID: "&Waf_untest$
   Cmd$="awk -F"&CHR$(34)&"\t"&CHR$(34)&" 'BEGIN{OFS="&CHR$(34)&" "&CHR$(34)&";FS="&CHR$(34)&" "&CHR$(34)&";}{if($1=="&CHR$(34)&Hostname$
   Cmd$=Cmd$&CHR$(34)&") print "&CHR$(34)&Info$&CHR$(34)&";else print $0;}' "&Info_file$&" >/tmp/info_update.tmp"
   PRINT "cmd=",Cmd$
   EXECUTE Cmd$
   EXECUTE "cp /tmp/info_update.tmp "&Info_file$
   Status$="OK"
   SUBEXIT
 System_error:   !
   Status$="ERROR"
 SUBEND
 Datalog_dieend:SUB Datalog_dieend(Filename$,INTEGER Mode)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : DATALOG_DIEEND
 !  Vers : 1
 !  Desc : Logs datas on the specified file. This uses user bin.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Filename        S    -        Filename.
 !      2 Mode            I    -        All(0), Failed only(1)
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Diepos,Diex,Diey          ! Current die position
   INTEGER Windex                    ! System variable index
   INTEGER Mini,Maxi                 ! Output variable range
   INTEGER Type,Dim,S1,S2            ! Variable information
   INTEGER Judge                     ! Pass=1/Fail=0/Invalid=2
   INTEGER Bin(6)                    ! Binning limit
   INTEGER Bc,Num,Den                ! Statical calculation condition
   INTEGER I                         !
   INTEGER Ival                      ! Integer-type output value
   REAL Lolim(6),Hilim(6)            ! Limit
   REAL Rval                         ! Real-type output value
   DIM Wafid$[256]                   ! Wafer ID
   DIM Outname$[256]                 ! Output variable name
   DIM Jdg$[32],Sp$[8],Info$[1024]
  !
   ON ERROR GOTO Errored
   Sp$=CHR$(9)
   Tpldiepos(Diepos)
   Tpldieinfo(Diepos,Diex,Diey)
   IF Diepos=0 THEN 
     ON ERROR GOTO No_file
     PURGE Filename$
 No_file: !
     OFF ERROR 
   END IF
   ON ERROR GOTO Exist
   CREATE Filename$,1
   EXECUTE "chmod 666 "&Filename$
 Exist: !
   ON ERROR GOTO Errored
   ASSIGN @File TO Filename$;FORMAT ON,APPEND
   ON ERROR GOTO Endalg
  !
   Tpltagindex("WAFER","SYS_WAFERID",Windex)
   Tplgetstag("WAFER",Windex,Diepos,Wafid$)
   Tplgetrangedie(Diepos,Mini,Maxi)
   IF Mini<0 OR Maxi<0 THEN Endalg
  !
   I=Mini
   FOR I=Mini TO Maxi
     Tploutinfo(I,Outname$,Type,Dim,S1,S2)
     Tploutjudge(I,Diepos,Judge)
     Tplgetwafubin(I,Bc,Lolim(*),Uplim(*),Bin(*),Num,Den)
     IF (Dim=0) AND (Mode=0 OR Judge=0) AND (Bc>0) THEN 
       Tplmodulelabel(I,Modlabel$)
       Tpldevicelabel(I,Devlabel$)
       SELECT (Judge)
       CASE 0
         Jdg$="FAIL!!"
       CASE 1
         Jdg$="PASS"
       CASE ELSE
         Jdg$="INVALID"
       END SELECT
       OUTPUT @File USING "#,K";Wafid$;Sp$;Diex;Sp$;Diey;Sp$;Modlabel$;Sp$
       OUTPUT @File USING "#,K";Devlabel$;Sp$;Outname$;Sp$
       SELECT (Type)
       CASE 0
         Tplgetrout(I,Diepos,Rval)
         OUTPUT @File USING "#,SD.3DE";Rval
       CASE 1
         Tplgetiout(I,Diepos,Ival)
         OUTPUT @File USING "#,K";Ival
       CASE ELSE
       END SELECT
       OUTPUT @File USING "-,K,SD.3DE,K,SD.3DE,K,K";Sp$;Lolim(Num);Sp$;Uplim(Num);Sp$;Jdg$
     END IF
   NEXT I
   ASSIGN @File TO *
   OFF ERROR 
   SUBEXIT
  !
 Endalg: !
   OFF ERROR 
   OUTPUT @File USING "-,K";Sp$
   ASSIGN @File TO *
   SUBEXIT
 Errored: !
   OFF ERROR 
 SUBEND
 Destroy_window:SUB Destroy_window(INTEGER Window)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : DESTROY_WINDOW
 !  Vers : 1
 !  Desc : Closes an existing HP BASIC/UX window
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Window          I    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   ON ERROR GOTO Ignored
   DESTROY WINDOW Window
   GOTO Destroyed
 Ignored:OFF ERROR 
 Destroyed:SUBEXIT
 SUBEND
 Discharge_all:SUB Discharge_all(INTEGER Port,REAL Hold,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : DISCHARGE_ALL
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 08/03/2013
 !  Time : 16:48:41
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Port            I    -        SMU1-SMU8, GNDU
 !      2 Hold            R    -        hold time for discharge
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Stat            I    -        0: OK -1:Error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
   ON ERROR RECOVER E
   Connect_th(FNPort(0,Port),1,49)
   Wait_th(Hold)
   Connect
   Stat=0
   SUBEXIT
 E: !
   OFF ERROR 
   Stat=-1
 SUBEND
 Esd_absorb:SUB Esd_absorb(Mode$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : ESD_ABSORB
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 09/10/2019
 !  Time : 22:13:00
 !  User : agilent
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 MODE            S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1 !***** DON'T REMOVE THIS LINE *****
   IF Mode$="START" THEN 
     Connect_th(FNPort(1,1),1,48)
     Connect(FNPort(1,2),49)
   ELSE
     Connect
   END IF
 SUBEND
 Fa_bldscr_lim:SUB Fa_bldscr_lim(Masscr$,Fmtscr$,INTEGER Status,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_BLDSCR_LIM
 !  Vers : 1
 !  Desc : This algorithm alters Limit File according to conditions
 !       : specified by external file.
 !  Date : 03/24/2011
 !  Time : 15:12:22
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Masscr          S    -        Master script file to read
 !      2 Fmtscr          S    -        Script file for limformat to wri
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Command status
 !      2 Error           S    -        Error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER I,Length
   DIM Cmd$[256],Tab$[1]
   DIM Fa_limit$[256]
   DIM Lim_index$[256],Lim_name$[256]
   DIM Lim_speclo$[256],Lim_spechi$[256]
   DIM Lim_prodlo$[256],Lim_prodhi$[256],Lim_flag$[256]
   DIM Lim_yield$[10]
  !
   Tab$=CHR$(9)
   Status=0
  !
   ON ERROR GOTO File_open_error                        !! Mar.02/01
   ASSIGN @Mas TO Masscr$;FORMAT ON
   OFF ERROR 
  !
   ON ERROR GOTO File_open_error
   ASSIGN @Fmt TO Fmtscr$;FORMAT ON,EOL CHR$(10)
   OFF ERROR 
  !
   OUTPUT @Fmt;"rep";Tab$;"flgd";Tab$;0     ! disable all log flag initially
   OUTPUT @Fmt;"rep";Tab$;"flgl";Tab$;0     ! disable all display flag initially
   ON END @Mas GOTO Eof
 Loop:LOOP
     ENTER @Mas;Fa_limit$
     IF (TRIM$(Fa_limit$[1,1])="#") THEN 
       GOTO Loop
     END IF
     Length=LEN(Fa_limit$)
     IF Length<68 THEN GOTO Eof
     FOR I=54 TO Length
       IF Fa_limit$[I,I]="e" THEN Fa_limit$[I,I]="E"
     NEXT I
     Lim_index$=TRIM$(Fa_limit$[3,8])
     Lim_name$=TRIM$(Fa_limit$[10,41])
     Lim_flag$=TRIM$(Fa_limit$[1,1])
     Lim_speclo$=TRIM$(Fa_limit$[54,64])          !narrow
     Lim_spechi$=TRIM$(Fa_limit$[66,76])          !narrow
     Lim_prodlo$=TRIM$(Fa_limit$[78,88])          !wider
     Lim_prodhi$=TRIM$(Fa_limit$[90,100])         !wider
   ! Lim_yield$=TRIM$(Fa_limit$[70,72])
   !
   !  prodlo < speclo < spechi < prodhi
   !
     ON ERROR GOTO Next_step1
     IF VAL(Lim_prodlo$)>VAL(Lim_speclo$) THEN 
       PRINT "Index ";Lim_index$;" in LIMIT file,"
       PRINT "WARNING ValidLo=";Lim_prodlo$,"SpecLo=";Lim_speclo$
       Lim_speclo$=VAL$(VAL(Lim_prodlo$)*1.1)
       PRINT " changed to ValidLo=";Lim_prodlo$,"SpecLo=";Lim_speclo$
     END IF
     IF VAL(Lim_spechi$)>VAL(Lim_prodhi$) THEN 
       PRINT "Index ";Lim_index$;" in LIMIT file,"
       PRINT "WARNING,  ValidHi=";Lim_prodhi$,"SpecHi=";Lim_spechi$
       Lim_spechi$=VAL$(VAL(Lim_prodhi$)*.9)
       PRINT " changed to ValidHi=";Lim_spechi$,"SpecHi=";Lim_prodhi$
     END IF
 Next_step1:OFF ERROR 
     Lim_name$=Lim_index$&"_"&Lim_name$
     !
     OUTPUT @Fmt;"var";Tab$;Lim_name$;Tab$;
  !  OUTPUT @Fmt;"rep";Tab$;"flgd";Tab$;Lim_flag$[1,1];Tab$;
  !  OUTPUT @Fmt;"rep";Tab$;"flgl";Tab$;Lim_flag$[2,2];Tab$;
     OUTPUT @Fmt;"rep";Tab$;"flgd";Tab$;"1";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"flgl";Tab$;"1";Tab$;
     SELECT Lim_flag$
     CASE "1","5"
       OUTPUT @Fmt;"rep";Tab$;"flg1";Tab$;"1";Tab$;
     CASE "2","3","4","6","7","8","9","0"
       OUTPUT @Fmt;"rep";Tab$;"flg1";Tab$;"0";Tab$;
     CASE ELSE
       GOTO Loop
     END SELECT
     !
     OUTPUT @Fmt;"rep";Tab$;"limmin";Tab$;"1";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"lim1";Tab$;Lim_prodlo$;Tab$;
     OUTPUT @Fmt;"rep";Tab$;"lim2";Tab$;Lim_speclo$;Tab$;
     OUTPUT @Fmt;"rep";Tab$;"lim3";Tab$;Lim_spechi$;Tab$;
     OUTPUT @Fmt;"rep";Tab$;"lim4";Tab$;Lim_prodhi$;Tab$;
     OUTPUT @Fmt;"rep";Tab$;"limmax";Tab$;"1";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"bin1";Tab$;"2";Tab$;"3";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"bin2";Tab$;"1";Tab$;"4";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"bin3";Tab$;"-";Tab$;"+";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"jdg";Tab$;"1";Tab$;"3";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"yld";Tab$;Lim_yield$
   END LOOP
  !
 Eof:ASSIGN @Fmt TO *
   ASSIGN @Mas TO *
  !
   Status=0
   Error$=""
  !
   SUBEXIT
  !
 File_open_error:   !
   OFF ERROR 
   ASSIGN @Mas TO *
   Status=-1
   Error$="Master file not found."
  !
 SUBEND
 Fa_bldscr_tpl:SUB Fa_bldscr_tpl(Masscr$,Fmtscr$,INTEGER Status,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_BLDSCR_TPL
 !  Vers : 1
 !  Desc : This algorithm alters Test Plan according to conditions s
 !       : pecified by external file.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Masscr          S    -        Master script file to read
 !      2 Fmtscr          S    -        Script file for tplformat to wri
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Command status
 !      2 Error           S    -        Error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Cmd$[256],Tab$[1]
   DIM Fmttpl$[256],Fmterr$[256]
   DIM Fa_limit$[256]
   DIM Lim_index$[256]
   DIM Lim_dname$[256]
   DIM Lim_outname$[256]
  !
   Tab$=CHR$(9)
   Status=0
  !
   ON ERROR GOTO File_open_error                    !! Mar.02/01
   ASSIGN @Mas TO Masscr$;FORMAT ON
   OFF ERROR 
  !
   ON ERROR GOTO File_open_error
   ASSIGN @Fmt TO Fmtscr$;FORMAT ON,EOL CHR$(10)
   OFF ERROR 
  !
   ON END @Mas GOTO Eof
 Loop:LOOP
     ENTER @Mas;Fa_limit$
     PRINT Fa_limit$
     IF (TRIM$(Fa_limit$[1,1])="#") THEN 
       GOTO Loop
     END IF
     IF LEN(Fa_limit$)<26 THEN GOTO Eof
     PRINT Lim_index$;Lim_dname$;Lim_outname$
     Lim_index$=TRIM$(Fa_limit$[3,8])
     Lim_dname$="R["&Lim_index$&"]"
     Lim_outname$=TRIM$(Fa_limit$[10,41])
  !
     Lim_outname$=Lim_index$&"_"&Lim_outname$
  !
     OUTPUT @Fmt;"rep";Tab$;
     OUTPUT @Fmt;"var";Tab$;Lim_dname$;Tab$;
     OUTPUT @Fmt;Lim_outname$
  !
   END LOOP
  !
 Eof:ASSIGN @Fmt TO *
   ASSIGN @Mas TO *
  !
   Status=0
   Error$=""
  !
   SUBEXIT
  !
 File_open_error:        !
   OFF ERROR 
   Status=-1
   Error$="Master file not found."
  !
 SUBEND
 Fa_chk_files:SUB Fa_chk_files(INTEGER Rev_flag,Dir$,Filename_rev$,Suffix$,Brk_chr$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_CHK_FILES
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Rev_flag        I    -        0:Revision Control not available
 !      2 Dir             S    -        Direcory of file
 !      3 Filename_rev    S    -        Filename with revision number
 !      4 Suffix          S    -        suffix of Filename
 !      5 Brk_chr         S    -        Connection char between filename
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0:OK -1:ERR
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Cmd$[32],Opt$[32],Tplattr$[32]
   DIM Suf$[32],File$[512],Full$[512]
   DIM Rev$[256],Buf$[256]
   INTEGER Rev_mode
   INTEGER Is_rev
   INTEGER Stat,R,W,X,E
   ON ERROR GOTO Basic_err
  !
   Rev_mode=0                 ! 0:RevisionName 1:RevisionNumber
  !
   Status=0
   Tplattr$="/opt/SPECS/sys/bin/tplattr"
   Cmd$="/opt/SPECS/sys/bin/revopen"    ! AVPATH_
   IF Rev_mode=0 THEN 
     Opt$=" -a "
   ELSE
     Opt$=" -n "
   END IF
  !
   IF POS(Filename_rev$,Brk_chr$)>0 THEN 
     Full$=Filename_rev$[1,POS(Filename_rev$,Brk_chr$)-1]
     Rev$=Filename_rev$[POS(Filename_rev$,Brk_chr$)+LEN(Brk_chr$);LEN(Filename_rev$)]
     Is_rev=1
   ELSE
     Full$=Filename_rev$
     Rev$=""
     Is_rev=0
   END IF
   IF POS(Full$,".")>0 THEN 
     File$=Full$[1,POS(Full$,".")-1]
     Suf$=Full$[POS(Full$,".")+1;LEN(Full$)]
   ELSE
     File$=Full$
     Suf$=Suffix$
   END IF
   Full$=Dir$&"/"&File$
   IF Dir$[LEN(Dir$)]="/" THEN Full$=Dir$&File$
  !                                             ! Mode Check
   CALL Verify_file(Full$&"."&Suf$,"Normal",E,R,W,X)
   IF E<>1 THEN GOTO Permit_exist
   IF R<>1 THEN GOTO Permit_read
   IF W<>1 THEN GOTO Permit_write
  !
   IF NOT Is_rev THEN SUBEXIT              ! No revisionname in input parameter
   IF Rev_flag=0 THEN GOTO Rev_unable      ! Revision Control Not Available
  !
   ASSIGN @Pipe TO Tplattr$&" -a Vers -t "&Suf$&" "&Full$&" 2>/dev/null |"
   ON END @Pipe GOTO Eof
   ENTER @Pipe;Buf$
   ASSIGN @Pipe TO *
   IF LEN(Buf$)<7 THEN GOTO No_rev
  !
   EXECUTE Cmd$&Opt$&Rev$&" -t "&Suf$&" "&Full$&" 2> /dev/null";RETURN Stat
  ! PRINT Cmd$&Opt$&Rev$&" -t "&Suf$&" "&Full$&" 2> /dev/null"
   IF Stat<>0 THEN Status=-7
   SUBEXIT
 Permit_exist: !
   Status=-3
   SUBEXIT
 Permit_read: !
   Status=-2
   SUBEXIT
 Permit_write: !
   Status=-1
   SUBEXIT
 Rev_unable: !
   Status=-4
   SUBEXIT
 No_rev: !
   Status=-5
   SUBEXIT
 Eof: !
   Status=-6
   SUBEXIT
 Basic_err: !
   Statsu=-9
 SUBEND
 Fa_chk_files2:SUB Fa_chk_files2(INTEGER Rev_flag,Dir$,Filename_rev$,Suffix$,Brk_chr$,INTEGER Status,File_name$,Rev$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_CHK_FILES2
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Rev_flag        I    -        0:Revision Control not available
 !      2 Dir             S    -        Direcory of file
 !      3 Filename_rev    S    -        Filename with revision number
 !      4 Suffix          S    -        suffix of Filename
 !      5 Brk_chr         S    -        Connection char between filename
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0:OK -1:ERR
 !      2 File_name       S    -        File name without revision name
 !      3 Rev             S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Cmd$[32],Opt$[32],Tplattr$[32]
   DIM Suf$[32],File$[512],Full$[512]
   DIM Buf$[256]
   INTEGER Rev_mode
   INTEGER Is_rev
   INTEGER Stat,R,W,X,E
   ON ERROR GOTO Basic_err
  !
   Rev_mode=0                 ! 0:RevisionName 1:RevisionNumber
  !
   File_name$=""     ! Default value is null string '01/10/10 */
   Status=0
   Tplattr$="/opt/SPECS/sys/bin/tplattr"
   Cmd$="/opt/SPECS/sys/bin/revopen"    ! AVPATH_
   IF Rev_mode=0 THEN 
     Opt$=" -a "
   ELSE
     Opt$=" -n "
   END IF
  !
   IF POS(Filename_rev$,Brk_chr$)>0 THEN 
     Full$=Filename_rev$[1,POS(Filename_rev$,Brk_chr$)-1]
     Rev$=Filename_rev$[POS(Filename_rev$,Brk_chr$)+LEN(Brk_chr$);LEN(Filename_rev$)]
     Is_rev=1
   ELSE
     Full$=Filename_rev$
     Rev$=""
     Is_rev=0
   END IF
   IF POS(Full$,".")>0 THEN 
     File$=Full$[1,POS(Full$,".")-1]
     Suf$=Full$[POS(Full$,".")+1;LEN(Full$)]
   ELSE
     File$=Full$
     Suf$=Suffix$
   END IF
   File_name$=File$&"."&Suf$      ! Make file name again '01/10/10
   Full$=Dir$&"/"&File$
   IF Dir$[LEN(Dir$)]="/" THEN Full$=Dir$&File$
  !                                             ! Mode Check
   CALL Verify_file(Full$&"."&Suf$,"Normal",E,R,W,X)
   IF E<>1 THEN GOTO Permit_exist
   IF R<>1 THEN GOTO Permit_read
   IF W<>1 THEN GOTO Permit_write
  !
   IF NOT Is_rev THEN SUBEXIT              ! No revisionname in input parameter
   IF Rev_flag=0 THEN GOTO Rev_unable      ! Revision Control Not Available
  !
   ASSIGN @Pipe TO Tplattr$&" -a Vers -t "&Suf$&" "&Full$&" 2>/dev/null |"
   ON END @Pipe GOTO Eof
   ENTER @Pipe;Buf$
   ASSIGN @Pipe TO *
   IF LEN(Buf$)<7 THEN GOTO No_rev
  !
   EXECUTE Cmd$&Opt$&Rev$&" -t "&Suf$&" "&Full$&" 2> /dev/null";RETURN Stat
  ! PRINT Cmd$&Opt$&Rev$&" -t "&Suf$&" "&Full$&" 2> /dev/null"
   IF Stat<>0 THEN Status=-7
   SUBEXIT
 Permit_exist: !
   Status=-3
   SUBEXIT
 Permit_read: !
   Status=-2
   SUBEXIT
 Permit_write: !
   Status=-1
   SUBEXIT
 Rev_unable: !
   Status=-4
   SUBEXIT
 No_rev: !
   Status=-5
   SUBEXIT
 Eof: !
   Status=-6
   SUBEXIT
 Basic_err: !
   Statsu=-9
 SUBEND
 Fa_chk_libpath:SUB Fa_chk_libpath(Orig$,INTEGER Status,Pathflug,Path$,Filename$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_CHK_LIBPATH
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Orig            S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -
 !      2 Pathflug        I    -
 !      3 Path            S    -
 !      4 Filename        S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Revpath$[256]     ! Add 2005/11/01 and Modify 2006/11/02
  !
   Status=0
   IF Orig$[1,1]="/" THEN 
     Pathflug=1
   ELSE
     Pathflug=0
   END IF
   Step=LEN(Orig$)
   FOR I=1 TO LEN(Orig$)
     IF Orig$[Step,Step]="/" THEN 
       GOTO Loopend
     END IF
     Step=Step-1
   NEXT I
 Loopend:  !
   IF Step>1 THEN 
     Path$=Orig$[1,LEN(Orig$)-I]
   ELSE
     Status=1
     Path$=""
     Filename$=Orig$
     SUBEXIT
   END IF
   Revpath$=REV$(Orig$)
   Pos_fname=POS(Revpath$,"/")
   IF Pos_fname=0 THEN 
     Filename$=Orig$
   ELSE
     Filename$=REV$(Revpath$[1,Pos_fname-1])
   END IF
   Status=0
 SUBEND
 Fa_chk_measlib:SUB Fa_chk_measlib(INTEGER Revcont,Lib$(*),INTEGER Libnum,Delimiter$,INTEGER Status,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_CHK_MEASLIB
 !  Vers : 1
 !  Desc : Check multi-measurement libraris.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Revcont         I    -        Revision Control Mode
 !      2 Lib             S    256      Measurement Library File (with R
 !      3 Libnum          I    -        Number of Measurement Library
 !      4 Delimiter       S    -        Delimiter between File and Revis
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Error Code
 !      2 Error           S    -        Error Message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Problib$[256],Testlib$[256],Utillib$[256]
   DIM Probrev$[256],Testrev$[256],Utilrev$[256]
   INTEGER Probnum,Testnum,Utilnum
   DIM Measlib$[256],Libname$[256],Basname$[256]
   INTEGER Cnt
  !
   Status=0
   Error$=""
  !
   Tplfileplib(Problib$,Probrev$,Probnum)
   Tplfiletlib(Testlib$,Testrev$,Testnum)
   Tplfileulib(Utillib$,Utilrev$,Utilnum)
  !
   FOR Cnt=1 TO Libnum
 Libnext:     !
     IF Cnt>Libnum OR Cnt>256 THEN 
       GOTO Libend
     END IF
     IF LEN(Lib$(Cnt))=0 THEN 
       Cnt=Cnt+1
       GOTO Libnext
     END IF
  !
     Measlib$=Lib$(Cnt)
     IF Revcont<>0 THEN 
       Pos=POS(Measlib$,Delimiter$)
       Measlib$=Measlib$[1,LEN(Measlib$)-Pos]
     END IF
     IF Measlib$[1]<>"/" THEN 
       Measlib$="/opt/SPECS/usr/alg/"&Measlib$
     END IF
  !
     IF Probnum<>0 AND Measlib$=Problib$ THEN 
       Status=-1
       Error$="Illegal measurement library is specified : "&Problib$
       SUBEXIT
     END IF
     IF Testnum<>0 AND Measlib$=Testlib$ THEN 
       Status=-2
       Error$="Illegal measurement library is specified : "&Testlib$
       SUBEXIT
     END IF
     IF Utilnum<>0 AND Measlib$=Utillib$ THEN 
       Status=-3
       Error$="Illegal measurement library is specified : "&Utillib$
       SUBEXIT
     END IF
  !
     Libname$=Measlib$&".lib"
     Basname$=Measlib$&".bas"
  !
     ON ERROR GOTO Nolib
     ASSIGN @Pipe TO "ls -l -d "&Libname$&" 2>/dev/null | cut -c -10 |"
     ON END @Pipe GOTO Nolib
     ENTER @Pipe;Libmode$
     IF Libmode$[2,2]<>"r" THEN 
       GOTO Nolib
     END IF
     OFF END @Pipe
     OFF ERROR 
  !
     ON ERROR GOTO Nobas
     ASSIGN @Pipe TO "ls -l -d "&Basname$&" 2>/dev/null | cut -c -10 |"
     ON END @Pipe GOTO Nobas
     ENTER @Pipe;Basmode$
     IF Basmode$[2,2]<>"r" THEN 
       GOTO Nobas
     END IF
     OFF END @Pipe
     OFF ERROR 
   NEXT Cnt
 Libend:     !
   SUBEXIT
  !
 Nolib:     !
   OFF END @Pipe
   OFF ERROR 
   Status=-4
   Error$="Cannot access the specified file : "&Libname$
   SUBEXIT
 Nobas:     !
   OFF END @Pipe
   OFF ERROR 
   Status=-5
   Error$="Cannot access the specified file : "&Basname$
   SUBEXIT
 SUBEND
 Fa_chk_rev:SUB Fa_chk_rev(Session$,Kinds$,INTEGER Status,Filename$,Rev$,Path$,Basicpath$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_CHK_REV
 !  Vers : 1
 !  Desc : Read configuration parameter and apply them.
 !       :   SPECS2.5: Added special parameters.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -
 !      2 Kinds           S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -
 !      2 Filename        S    -
 !      3 Rev             S    -
 !      4 Path            S    -
 !      5 BasicPath       S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Line$[256],Rpath$[256]
   INTEGER Idx_tag,Counter,Key_step,Filearea,Revarea,N_session,Pos_l
  !
  !
   ON ERROR GOTO Err
   EXECUTE "/opt/SPECS/sys/bin/tplstat -S "&Session$&" >/usr/tmp/tmp_stat_res"
   ASSIGN @F TO "/usr/tmp/tmp_stat_res";FORMAT ON
   ON END @F GOTO Endoffile
   N_session=VAL(Session$)
   Key_step=0
  !
   Flg=0
   Counter=0
   LOOP
     Counter=Counter+1
     ENTER @F;Line$
     IF Counter=1 THEN 
       IF Line$=Session$ THEN 
         Key_step=Counter-1
         Flg=1
       END IF
     END IF
     IF Counter=25 THEN 
       IF Line$=Session$ THEN 
         Key_step=Counter-1
         Flg=1
       END IF
     END IF
     IF Counter=49 THEN 
       IF Line$=Session$ THEN 
         Key_step=Counter-1
         Flg=1
       END IF
     END IF
     IF Counter=73 THEN 
       IF Line$=Session$ THEN 
         Key_step=Counter-1
         Flg=1
       END IF
     END IF
  !
     IF Flg=1 THEN 
       IF Kinds$="MEAS" THEN 
         Filearea=10+Key_step
         Revarea=11+Key_step
       END IF
       IF Kinds$="TST" THEN 
         Filearea=13+Key_step
         Revarea=14+Key_step
       END IF
       IF Kinds$="PRB" THEN 
         Filearea=16+Key_step
         Revarea=17+Key_step
       END IF
       IF Kinds$="UTL" THEN 
         Filearea=19+Key_step
         Revarea=20+Key_step
       END IF
       IF Kinds$="DEV" THEN 
         Filearea=22+Key_step
         Revarea=23+Key_step
       END IF
  !
       IF Counter=Filearea THEN 
         Path$=Line$
       END IF
       IF Counter=Revarea THEN 
         Rev$=Line$
         GOTO Breakloop
       END IF
     END IF
   END LOOP
 Breakloop:    !
   Rpath$=REV$(Path$)
   Pos_l=POS(Rpath$,"/")
   Basicpath$=Path$[1,LEN(Path$)-Pos_l+1]
   Filename$=REV$(Rpath$[1,Pos_l-1])
   Status=0
   SUBEXIT
 Endoffile:  !
   ASSIGN @F TO *
   Status=-6
   SUBEXIT
 Err:                                  !
   ASSIGN @F TO *
   Status=-9
 SUBEND
 Fa_chk_rev2:SUB Fa_chk_rev2(Session$,Kinds$,INTEGER Count,Status,Filename$,Rev$,Path$,Basicpath$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_CHK_REV2
 !  Vers : 1
 !  Desc : Get TPL file information.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -        Session Number
 !      2 Kinds           S    -        Type of Library
 !      3 Count           I    -        Index of Multi-Measurement Libra
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Error Code
 !      2 Filename        S    -        File Name
 !      3 Rev             S    -        Revision
 !      4 Path            S    -        File Name with Directory
 !      5 BasicPath       S    -        Directory
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Revpath$[256]
   INTEGER Num,Pos
  !
   Status=0
   Filename$=""
   Rev$=""
   Path$=""
   Basicpath$=""
  !
   SELECT Kinds$
   CASE "MEAS"
     Tplfilenummlib(Num)
     IF Count<Num THEN 
       Tplfilemlibm(Count,Path$,Rev$,Num)
     ELSE
       Status=-2
     END IF
   CASE "PRB"
     Tplfileplib(Path$,Rev$,Num)
   CASE "TST"
     Tplfiletlib(Path$,Rev$,Num)
   CASE "UTL"
     Tplfileulib(Path$,Rev$,Num)
   CASE "DEV"
     Tplfiledlib(Path$,Rev$,Num)
   CASE ELSE
     Status=-1
   END SELECT
  !
   IF Num<>0 AND Status=0 THEN 
     Revpath$=REV$(Path$)
     Pos=POS(Revpath$,"/")
     Filename$=REV$(Revpath$[1,Pos-1])
     Basicpath$=Path$[1,LEN(Path$)-Pos+1]
   END IF
 SUBEND
 Fa_chkrun_fwk:SUB Fa_chkrun_fwk(Name$,Status$,INTEGER Numfile,Numrunning)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_CHKRUN_FWK
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Name            S    -        Key word of grep
 !      2 Status          S    -        SPECS Status
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 numFile         I    -        The number of process regarding
 !      2 numRunning      I    -        The number of running process re
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   ON ERROR GOTO Err
  ! ASSIGN @Pipe TO "tplstat 2>/dev/null | awk '{print $8}' | grep "&Name$&" | wc | cut -c -1 |"
   ASSIGN @Pipe TO "tplstat 2>/dev/null | awk '{print $8}' | grep "&Name$&" | wc | awk '{print $1}'|"
   ENTER @Pipe;Numfile
  ! ASSIGN @Pipe TO "tplstat 2>/dev/null | awk '{print $2 $8}' | grep "&Name$&" | grep "&Status$&" | wc | cut -c -1 |"
   ASSIGN @Pipe TO "tplstat 2>/dev/null | awk '{print $2 $8}' | grep "&Name$&" | grep "&Status$&" | wc | awk '{print $1}'|"
   ENTER @Pipe;Numrunning
   GOTO Check_file
 Err:       !
   OFF ERROR 
   PRINT "PROCESS CHECK ERROR: "&Name$&" or "&Status$&" is not accessible."
   SUBEXIT
  !
 Check_file:   !
  !
 SUBEND
 Fa_getkey_items:SUB Fa_getkey_items(Key$,Filename$,Waf$,Die$,Tst$,Prb$,Tpl$,Lim$,Rcp$,Lot_id$,Product_id$,Process_id$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_GETKEY_ITEMS
 !  Vers : 1
 !  Desc : Desc: Get many items in the file from key recipe id.
 !       : Date: '00/Nov/28 Initial revision
 !       : Date: '01/Mar/09 Released  K.N
 !       : Date: '01/Jul/19 Change to Lynx1 by M.N
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Key             S    -        Key ID (PPExecName)
 !      2 Filename        S    -        File Name
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Waf             S    -        Wafer spec name
 !      2 Die             S    -        Die spec name
 !      3 Tst             S    -        Test spec name
 !      4 Prb             S    -        Probe card spec name
 !      5 Tpl             S    -        Test plan file name
 !      6 Lim             S    -        Limit file name
 !      7 Rcp             S    -        Prober recipe file name
 !      8 Lot_id          S    -        LotID
 !      9 Product_id      S    -        ProductID
 !     10 Process_id      S    -        ProcessID
 !     11 Status          I    -        0:OK -1:Eof -2:No Data -3:No Fil
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER I
   DIM Field$[256]
   Field$=""
   Waf$=""
   Die$=""
   Tst$=""
   Prb$=""
   Tpl$=""
   Lim$=""
   Rcp$=""
   Lot_id$=""
   Product_id$=""
   Process_id$=""
   Status=0
   ON ERROR GOTO Nofile
   ASSIGN @Tmp TO Filename$
   ASSIGN @Tmp TO *
   OFF ERROR 
   FOR I=1 TO 10
     ON ERROR GOTO Nofile
     ASSIGN @Pipe TO "grep -v '^#' "&Filename$&" | awk -F: '{ if($1 == """&Key$&"""){ if("&VAL$(I+1)&"<=NF){ print $"&VAL$(I+1)&"; } else { print "":""; }}}'| "
     OFF ERROR 
     ON END @Pipe GOTO Eof
     ON ERROR GOTO Overflow
     ENTER @Pipe;Field$
     ASSIGN @Pipe TO *
     IF Field$=":" THEN 
       Field$=""
       Status=-2
     ELSE
       Status=0
       SELECT I
       CASE 1
         Lot_id$=Field$
       CASE 2
         Product_id$=Field$
       CASE 3
         Process_id$=Field$
       CASE 4
         Waf$=Field$
       CASE 5
         Die$=Field$
       CASE 6
         Tst$=Field$
       CASE 7
         Prb$=Field$
       CASE 8
         Tpl$=Field$
       CASE 9
         Lim$=Field$
       CASE 10
         Rcp$=Field$
       END SELECT
     END IF
   NEXT I
   ASSIGN @Pipe TO *
   SUBEXIT
 Nofile:Status=-3
   ASSIGN @Pipe TO *
   SUBEXIT
 Eof:Status=-1
   ASSIGN @Pipe TO *
   SUBEXIT
 Overflow:Status=-2
   ASSIGN @Pipe TO *
 SUBEND
 Fa_limbld:SUB Fa_limbld(INTEGER Rev_flag,Brk_chr$,Tpl_dir$,Lim_dir$,Tpl$,Lim$,INTEGER Status,Error$,INTEGER Ndetail,Detail$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_LIMBLD
 !  Vers : 1
 !  Desc : This algorithm generates Limit File dynamically.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Rev_flag        I    -        0:Revision Control not available
 !      2 Brk_chr         S    -        Connection char between filename
 !      3 Tpl_dir         S    -        Testplan file directory
 !      4 Lim_dir         S    -        Limit file directory
 !      5 Tpl             S    -        Test Plan name to read
 !      6 Lim             S    -        Limit file name to write
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Command status
 !      2 Error           S    -        Error message
 !      3 Ndetail         I    -        # of lines of detail error messa
 !      4 Detail          S    10       detailed error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Stat
   DIM Cmd$[256],Err$[256]
   DIM T$[512],L$[512]
   DIM T2$[512],L2$[512]
  !
   ON ERROR GOTO Basic_syserr
  !
   Ndetail=0
   Cmd$="/opt/SPECS/sys/bin/limbuild "
   CALL Fa_chk_files(Rev_flag,Tpl_dir$,Tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-1 THEN GOTO File_check_err
   CALL Fa_chk_files(Rev_flag,Lim_dir$,Lim$,"lim",Brk_chr$,Stat)
   IF Stat<-3 THEN GOTO File_check_err
   T2$=Tpl$
   L2$=Lim$
   IF POS(T2$,Brk_chr$)>0 THEN T2$=Tpl$[1,POS(Tpl$,Brk_chr$)-1]
   IF POS(L2$,Brk_chr$)>0 THEN L2$=Lim$[1,POS(Lim$,Brk_chr$)-1]
   IF POS(T2$,".tpl")=0 THEN T2$=T2$&".tpl"
   IF POS(L2$,".lim")=0 THEN L2$=L2$&".lim"
   T$=Tpl_dir$&"/"&T2$
   L$=Lim_dir$&"/"&L2$
   IF Tpl_dir$[LEN(Tpl_dir$)]="/" THEN T$=Tpl_dir$&T2$
   IF Lim_dir$[LEN(Lim_dir$)]="/" THEN L$=Lim_dir$&L2$
   Err$="/usr/tmp/limbld.err"
   EXECUTE Cmd$&T$&" > "&L$&" 2> "&Err$;RETURN Stat
  ! PRINT Cmd$&T$&" > "&L$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     Error$="ERROR"
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO E
     ENTER @E;Error$
     Ndetail=0
     LOOP
       ENTER @E;Detail$(Ndetail+1)
       Ndetail=Ndetail+1
     END LOOP
 E:  ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
   PURGE Err$
   SUBEXIT
 File_check_err: !
   Status=-1
   Error$="File_check_error "&VAL$(Stat)
   SUBEXIT
 Basic_syserr: !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
 SUBEND
 Fa_limbld2:SUB Fa_limbld2(INTEGER Rev_flag,Brk_chr$,Tpl_dir$,Lim_dir$,Lms_dir$,Tpl$,Lim$,Lms$(*),INTEGER Status,Error$,INTEGER Ndetail,Detail$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_LIMBLD2
 !  Vers : 1
 !  Desc : This algorithm generates Limit File dynamically.
 !       : 2005/09/02 Bugfix Call limbuild/limformat
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Rev_flag        I    -        0:Revision Control not available
 !      2 Brk_chr         S    -        Connection char between filename
 !      3 Tpl_dir         S    -        Testplan file directory
 !      4 Lim_dir         S    -        Limit file directory
 !      5 Lms_dir         S    -        Limit spec directory
 !      6 Tpl             S    -        Test Plan name to read
 !      7 Lim             S    -        Limit file name to write
 !      8 Lms             S    256      Limit spec name
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Command status
 !      2 Error           S    -        Error message
 !      3 Ndetail         I    -        # of lines of detail error messa
 !      4 Detail          S    10       detailed error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Stat
   DIM Cmd$[256],Err$[256]
   DIM T$[512],L$[512]
   DIM T2$[512],L2$[512]
   DIM Lms2$[4098]   ! 2005/11/01
   INTEGER Lms_size  ! 2005/11/01
  !
   ON ERROR GOTO Basic_syserr
  !
   Ndetail=0
   Lms_size=256   ! 2005/11/01
   Cmd$="/opt/SPECS/sys/bin/limbuild "
   CALL Fa_chk_files(Rev_flag,Tpl_dir$,Tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-1 THEN GOTO File_check_err
   CALL Fa_chk_files(Rev_flag,Lim_dir$,Lim$,"lim",Brk_chr$,Stat)
   IF Stat<-3 THEN GOTO File_check_err
  ! FOR I=1 TO I<=Lms_size   ! 2005/11/01
   FOR I=1 TO Lms_size       ! 2005/11/01
     IF Lms$(I)="" THEN 
       GOTO End_loop
     END IF
     CALL Fa_chk_files(Rev_flag,Lms_dir$,Lms$(I),"lms",Brk_chr$,Stat)           ! 2005/11/01
  !   Lms2$=Lms2$&" -lms "&Lms_dir$&Lms$(I)                                     ! 2005/11/01
     Lms2$=Lms2$&" -lms "&Lms_dir$&"/"&Lms$(I)                                  ! 2005/11/01
     IF Lms_dir$[LEN(Lms_dir$)]="/" THEN Lms2$=Lms2$&" -lms "&Lms_dir$&Lms$(I)  ! 2005/11/01
  !   IF POS(Lms2$,".lms")=0 THEN Lms2$=Lms2$&".lms"                            ! 2005/11/01
     IF POS(Lms$(I),".lms")=0 THEN Lms2$=Lms2$&".lms"                           ! 2005/11/01
   NEXT I
 End_loop:   !
   T2$=Tpl$
   L2$=Lim$
   IF POS(T2$,Brk_chr$)>0 THEN T2$=Tpl$[1,POS(Tpl$,Brk_chr$)-1]
   IF POS(L2$,Brk_chr$)>0 THEN L2$=Lim$[1,POS(Lim$,Brk_chr$)-1]
   IF POS(T2$,".tpl")=0 THEN T2$=T2$&".tpl"
   IF POS(L2$,".lim")=0 THEN L2$=L2$&".lim"
   T$=Tpl_dir$&"/"&T2$
   L$=Lim_dir$&"/"&L2$
   IF Tpl_dir$[LEN(Tpl_dir$)]="/" THEN T$=Tpl_dir$&T2$
   IF Lim_dir$[LEN(Lim_dir$)]="/" THEN L$=Lim_dir$&L2$
   Err$="/usr/tmp/limbld.err"
   EXECUTE Cmd$&T$&Lms2$&" > "&L$&" 2> "&Err$;RETURN Stat
  ! PRINT Cmd$&T$&Lms2$&" > "&L$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     Error$="ERROR"
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO E
     ENTER @E;Error$
     Ndetail=0
     LOOP
       ENTER @E;Detail$(Ndetail+1)
       Ndetail=Ndetail+1
     END LOOP
 E:  ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
   PURGE Err$
   SUBEXIT
 File_check_err: !
   Status=-1
   Error$="File_check_error "&VAL$(Stat)
   SUBEXIT
 Basic_syserr: !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
 SUBEND
 Fa_limfmt:SUB Fa_limfmt(INTEGER Rev_flag,Brk_chr$,Src_lim_dir$,Script_dir$,Dst_lim_dir$,Src_lim$,Script$,Dst_lim$,INTEGER Status,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_LIMFMT
 !  Vers : 1
 !  Desc : This algorithm alters Limit File according to conditions
 !       : specified by external file.
 !       : 2005/09/02 Bugfix Call limformat
 !  Date : 03/24/2011
 !  Time : 15:12:22
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Rev_flag        I    -        0:Revision Control not available
 !      2 Brk_chr         S    -        Connection char between filename
 !      3 Src_lim_dir     S    -        Temporary file directory
 !      4 Script_dir      S    -        Script file directory
 !      5 Dst_lim_dir     S    -        New limit file directory
 !      6 Src_lim         S    -        Temporay Limit File to read
 !      7 Script          S    -        Specified script file
 !      8 Dst_lim         S    -        Generated Limit File to write"
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Command status
 !      2 Error           S    -        Error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !123456789012345678901234567890123456789012345678901234567890123456789012345678
  !
  !    1 VT_N1 EXT  V 20/20         0.4500      1.0500 12      0.6000      0.9000
  !    2 GAM_N1     20/20           0.0500      1.0000 11      0.3000      0.8000
  !    3 BET_N1 Slo uA/V**2        70.0000    150.0000 11     90.0000    130.0000
  !   17 VT_N6 EXT  V.35/20 PG      0.2000      1.1500 11      0.3200      0.9300
  !
  !  1- 5  index
  !  7-16  name
  ! 18-27  unit
  ! 29-39  spec lo  (wider)
  ! 41-51  spec hi
  ! 53-54  flag
  ! 56-66  prod lo  (narrower)
  ! 68-78  prod hi
  ! 80-82  Yield
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   DIM Cmd$[256],Tab$[1]
   DIM Cmd2$[256]         ! 2005/11/01
   DIM Err$[256],Src$[512],Dst$[512]
   DIM Tmplim$[512],Genlim$[512],Scr$[512]
   DIM Fmtscr$[512]
   INTEGER Stat
  !
   ON ERROR GOTO Basic_syserr
  !
   Cmd$="/opt/SPECS/sys/bin/limformat"
   Cmd2$="/usr/bin/cat"                   ! 2005/11/01
   Err$="/usr/tmp/limerr.err"
   Status=0
  !
   CALL Fa_chk_files(Rev_flag,Src_lim_dir$,Src_lim$,"lim",Brk_chr$,Stat)
   IF Stat<-1 THEN GOTO File_check_err
  !    CALL Fa_chk_files(Rev_flag,Dst_lim_dir$,Dst_lim$,"lim",Brk_chr$,Stat)
  !    IF Stat<-3 THEN GOTO File_check_err
   Src$=Src_lim$
   Dst$=Dst_lim$
   IF POS(Src$,Brk_chr$)>0 THEN Src$=Src_lim$[1,POS(Src_lim$,Brk_chr$)-1]
   IF POS(Dst$,Brk_chr$)>0 THEN Dst$=Dst_lim$[1,POS(Dst_lim$,Brk_chr$)-1]
   IF POS(Src$,".lim")=0 THEN Src$=Src$&".lim"
   IF POS(Dst$,".lim")=0 THEN Dst$=Dst$&".lim"
  !
   Scr$=Script_dir$&"/"&Script$
   Tmplim$=Src_lim_dir$&"/"&Src$
   Genlim$=Dst_lim_dir$&"/"&Dst$
   IF LEN(Script_dir$)>0 THEN   ! 2005/11/01
     IF Script_dir$[LEN(Script_dir$)]="/" THEN Scr$=Script_dir$&Script$
   END IF
   IF Src_lim_dir$[LEN(Src_lim_dir$)]="/" THEN Tmplim$=Src_lim_dir$&Src$
   IF Dst_lim_dir$[LEN(Dst_lim_dir$)]="/" THEN Genlim$=Dst_lim_dir$&Dst$
  !
   Fmtscr$="/usr/tmp/limscr.tmp"
   ON ERROR GOTO E
   PURGE Fmtscr$
 E:OFF ERROR 
   CREATE Fmtscr$,1
   Fa_bldscr_lim(Scr$,Fmtscr$,Status,Error$)      !! Build format from cust's format
  !    EXECUTE Cmd$&" -cmd "&Scr$&" "&Tmplim$&" > "&Genlim$&" 2> "&Err$;RETURN Stat
  ! PRINT Fmtscr$
   IF LEN(Script_dir$)=0 OR LEN(Script$)=0 THEN    ! 2005/11/01
     EXECUTE Cmd2$&" "&Tmplim$&" > "&Genlim$&" 2> "&Err$;RETURN Stat
   ELSE
     EXECUTE Cmd$&" -cmd "&Fmtscr$&" "&Tmplim$&" > "&Genlim$&" 2> "&Err$;RETURN Stat
   END IF
  ! PRINT Cmd$&" -cmd "&Scr$&" "&Tmplim$&" > "&Genlim$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     ON ERROR GOTO File_check_err
     ASSIGN @E TO Err$;FORMAT ON
     ENTER @E;Error$
     ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
  !
   PURGE Err$
   SUBEXIT
  !
 File_check_err: !
   Status=-1
   Error$="File_check_error "&VAL$(Stat)
   SUBEXIT
 Basic_syserr:  !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
 SUBEND
 Fa_lmp_clearln:SUB Fa_lmp_clearln(INTEGER Linenth,Erasemode,Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_LMP_CLEARLN
 !  Vers : 1
 !  Desc : FA Algorithm: Clear a line of LMP User Value Displayment
 !       : area.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 LineNth         I    -        Line number where to erase
 !      2 EraseMode       I    -        1:ClearAll,2:ClearValue(Not chan
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        GEM Reply
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Event$[256]
   DIM Lnth$[256]
   DIM Label$[256]
   DIM Str$[256]
   DIM Fgc$[256],Bgc$[256]
   IF Linenth<=0 OR Linenth>=9 THEN 
     Status=-1
     SUBEXIT
   END IF
   IF Erasemode<=0 OR Erasemode>=3 THEN 
     Status=-1
     SUBEXIT
   END IF
   Lnth$=VAL$(Linenth)
   Label$=""
   Str$=""
   Fgc$="default"
   Bgc$="default"
   IF Erasemode=1 THEN 
     Event$="DISPLINE"
   ELSE
     Event$="CLEARLINE"
   END IF
   Fa_lmpdisp(Event$,Lnth$,Label$,Str$,Fgc$,Bgc$,Status)
 SUBEND
 Fa_lmp_dispint:SUB Fa_lmp_dispint(INTEGER Linenth,Displabel$,INTEGER Dispvalue,Dispfgc$,Dispbgc$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_LMP_DISPINT
 !  Vers : 1
 !  Desc : FA Algorithm: Display a combination of Label + Value in L
 !       : MP User Value Displayment area.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 LineNth         I    -        Line number where to display
 !      2 DispLabel       S    -        Label String (Max 18 Chars)
 !      3 DispValue       I    -        Value Integer (Max 30 Chars)
 !      4 DispFgc         S    -        Foreground Color of the Value St
 !      5 DispBgc         S    -        Background Color of the Value St
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        GEM Reply
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Lnth$[256]
   DIM Label$[256],Value$[256]
   DIM Event$[256]
   DIM Fgc$[256],Bgc$[256]
   IF Linenth<=0 OR Linenth>=9 THEN 
     Status=-1
     SUBEXIT
   END IF
   Lnth$=VAL$(Linenth)
   IF Displabel$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   L=LEN(Displabel$)
   IF L>=19 THEN 
     Label$=Displabel$[1,18]
   ELSE
     Label$=Displabel$
   END IF
   Value$=VAL$(Dispvalue)
   L=LEN(Dispfgc$)
   IF L=0 OR Dispfgc$="" THEN 
     Fgc$="default"
   ELSE
     Fgc$=Dispfgc$
   END IF
   L=LEN(Dispbgc$)
   IF L=0 OR Dispbgc$="" THEN 
     Bgc$="default"
   ELSE
     Bgc$=Dispbgc$
   END IF
   Event$="DISPLINE"
   Fa_lmpdisp(Event$,Lnth$,Label$,Value$,Fgc$,Bgc$,Status)
 SUBEND
 Fa_lmp_displine:SUB Fa_lmp_displine(INTEGER Linenth,Displabel$,Dispstr$,Dispfgc$,Dispbgc$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_LMP_DISPLINE
 !  Vers : 1
 !  Desc : FA Algorithm: Display a combination of Label + Value in L
 !       : MP User Value Displayment area.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 LineNth         I    -        Line Number where to display
 !      2 DispLabel       S    -        Label String (Max 18 Chars)
 !      3 DispStr         S    -        Value String (Max 30 Chars)
 !      4 DispFgc         S    -        Foreground Color of the Value St
 !      5 DispBgc         S    -        Background Color of the Value St
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        GEM Reply
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Lnth$[256]
   DIM Label$[256],Str$[256]
   DIM Event$[256]
   DIM Fgc$[256],Bgc$[256]
   IF Linenth<=0 OR Linenth>=9 THEN 
     Status=-1
     SUBEXIT
   END IF
   Lnth$=VAL$(Linenth)
   IF Displabel$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   L=LEN(Displabel$)
   IF L>=19 THEN 
     Label$=Displabel$[1,18]
   ELSE
     Label$=Displabel$
   END IF
   IF Dispstr$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   L=LEN(Dispstr$)
   IF L>=31 THEN 
     Str$=Dispstr$[1,30]
   ELSE
     Str$=Dispstr$
   END IF
   L=LEN(Dispfgc$)
   IF L=0 OR Dispfgc$="" THEN 
     Fgc$="default"
   ELSE
     Fgc$=Dispfgc$
   END IF
   L=LEN(Dispbgc$)
   IF L=0 OR Dispbgc$="" THEN 
     Bgc$="default"
   ELSE
     Bgc$=Dispbgc$
   END IF
   Event$="DISPLINE"
   Fa_lmpdisp(Event$,Lnth$,Label$,Str$,Fgc$,Bgc$,Status)
 SUBEND
 Fa_lmp_dispvar:SUB Fa_lmp_dispvar(INTEGER Linenth,Displabel$,INTEGER Dispvar,Dispfgc$,Dispbgc$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_LMP_DISPVAR
 !  Vers : 1
 !  Desc : FA Algorithm: Display a combination of Label + VGEM VAL i
 !       : n LMP User Value Displayment area.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 LineNth         I    -        Line number where to display
 !      2 DispLabel       S    -        Label String (Max 18 Chars)
 !      3 DispVar         I    -        Variable ID
 !      4 DispFgc         S    -        Foreground Color of the Value St
 !      5 DispBgc         S    -        Background Color of the Value St
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        GEM Reply
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Lnum$[256]
   DIM Vlabel$[256]
   DIM Varid$[256]
   DIM Vfgc$[256],Vbgc$[256]
   DIM Vevent$[256]
   IF Linenth<=0 OR Linenth>=9 THEN 
     Status=-1
     SUBEXIT
   END IF
   Lnum$=VAL$(Linenth)
   IF Displabel$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   L=LEN(Displabel$)
   IF L>=19 THEN 
     Vlabel$=Displabel$[1,18]
   ELSE
     Vlabel$=Displabel$
   END IF
   IF Dispvar<=0 THEN 
     Status=-1
     SUBEXIT
   END IF
   Varid$=VAL$(Dispvar)
   L=LEN(Dispfgc$)
   IF L=0 OR Dispfgc$="" THEN 
     Vfgc$="default"
   ELSE
     Vfgc$=Dispfgc$
   END IF
   L=LEN(Dispbgc$)
   IF L=0 OR Dispbgc$="" THEN 
     Vbgc$="default"
   ELSE
     Vbgc$=Dispbgc$
   END IF
   Vevent$="DISPVAR"
   PRINT Vevent$
   PRINT Lnum$
   PRINT Vlabel$
   PRINT Varid$
   PRINT Vfgc$
   PRINT Vbgc$
   Fa_lmpdisp(Vevent$,Lnum$,Vlabel$,Varid$,Vfgc$,Vbgc$,Status)
 SUBEND
 Fa_mk_dataname:SUB Fa_mk_dataname(Dir$,File$,INTEGER Slot,Adtfmt$,Session$,Datadir$,Dataname$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_MK_DATANAME
 !  Vers : 1
 !  Desc : This algorithm generates file name to dump data for a cur
 !       : rent wafer.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Dir             S    -        Data Directory
 !      2 File            S    -        File Directory
 !      3 Slot            I    -        SlotNumber
 !      4 Adtfmt          S    -        Adt Format
 !      5 Session         S    -        SessionID
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Datadir         S    -        Data Directory Path
 !      2 Dataname        S    -        Data File Name
 !      3 Status          I    -        0:OK -1:Error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Outputdir$[255]
   DIM Outputfile$[255]
   DIM Err$[255]
   DIM Adt$[1]
   INTEGER Exist,Read,Write,Exec
   INTEGER I
   INTEGER Stat
  !
   Err$="/tmp/tplbld.err"
   Status=0                              !! Mar.02/01
  !
  !* Check the adt format *!
   SELECT Adtfmt$
   CASE "adt"
     Adt$="2"
   CASE "ad2"
     Adt$="3"
   CASE "ad3"
     Adt$="4"
   CASE "ad5"
     Adt$="5"
   CASE "1"
     Adt$=Adtfmt$
     Adtfmt$="adt"
   CASE "2"
     Adt$=Adtfmt$
     Adtfmt$="adt"
   CASE "3"
     Adt$=Adtfmt$
     Adtfmt$="ad2"
   CASE "4"
     Adt$=Adtfmt$
     Adtfmt$="ad3"
   CASE "5"
     Adt$=Adtfmt$
     Adtfmt$="ad5"
   CASE ELSE
     Status=-1
   END SELECT
   IF Status=-1 THEN SUBEXIT
  !
  !* Verify Directory *!
   Outputdir$=Dir$&"/"&File$
   Datadir$=Outputdir$
   CALL Verify_file(Outputdir$,"Directory",Exist,Read,Write,Exec)
   IF Exist=0 THEN 
     EXECUTE "mkdir "&Outputdir$&" 2> "&Err$;RETURN Stat
     IF Stat THEN Status=-1
   ELSE
     IF Write<>1 AND Exec<>1 THEN Status=-1
   END IF
   IF Status=-1 THEN SUBEXIT
  !
  !* Verify File *!
   I=1
   LOOP
     IF I=1 THEN 
       Outputfile$=Outputdir$&"/"&VAL$(Slot)&"."&Adtfmt$
       Dataname$=VAL$(Slot)
     ELSE
       Outputfile$=Outputdir$&"/"&VAL$(Slot)&"#"&VAL$(I)&"."&Adtfmt$
       Dataname$=VAL$(Slot)&"#"&VAL$(I)
     END IF
     CALL Verify_file(Outputfile$,"Normal",Exist,Read,Write,Exec)
     IF Exist<1 THEN 
       Status=0
     ELSE
       Status=-1
       I=I+1
     END IF
   EXIT IF I>99 OR Status=0
   END LOOP
  !
  !
 SUBEND
 Fa_query_cond:SUB Fa_query_cond(Key$,Level$,Filename$,Tco$(*),Limf$,Dielabel$(*),Dietype$(*),Modlabel$(*),Item$(*),INTEGER Status,Errmsg$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_QUERY_COND
 !  Vers : 1
 !  Desc : Query recipe items in the recipe file from key recipe id.
 !       :   SPECS3.0: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Key             S    -
 !      2 Level           S    -
 !      3 Filename        S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Tco             S    16
 !      2 Limf            S    -
 !      3 DieLabel        S    256
 !      4 DieType         S    256
 !      5 ModLabel        S    256
 !      6 Item            S    32
 !      7 Status          I    -        0: OK, -1: Exec Err, -2: No File
 !      8 Errmsg          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[32767],Spc$[256],Line$[4096],Detail$(10)[256],Spc_nm$[256]
   INTEGER I,N_item,Ndetail,Cmd_ret
  !
   Cmd$="/opt/SPECS/usr/recipe/fa_cond_q.sh"
   Spc$="/var/tmp/spc."&SYSTEM$("PROCESS ID")
  !
   FOR I=1 TO SIZE(Item$,1)
     Item$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tco$,1)
     Tco$(I)=""
   NEXT I
   Limf$=""
   FOR I=1 TO SIZE(Dielabel$,1)
     Dielabel$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Dietype$,1)
     Dietype$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Modlabel$,1)
     Modlabel$(I)=""
   NEXT I
  !
   Cmd$=Cmd$&" "&Filename$&" "&Key$&" "&Level$
   Fa_rcp_exec_cmd(Cmd$,Spc$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
  !
   IF Cmd_ret=1 THEN Status=1
   IF Status=0 OR Status=1 THEN 
     ASSIGN @S TO Spc$;FORMAT ON
     ON END @S GOSUB Eof
  !
     FOR I=1 TO SIZE(Item$,1)
       ENTER @S;Item$(I)
     NEXT I
     Spc_nm$=""
     N_item=0
     ENTER @S;Line$
     WHILE (Line$<>"# EOD")
       IF Line$[1,2]="# " THEN 
         Spc_nm$=Line$[3;LEN(Line$)-2]
         N_item=0
       ELSE
         N_item=N_item+1
         SELECT Spc_nm$
         CASE "TCO"
           IF N_item>SIZE(Tco$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tco$(N_item)=Line$
         CASE "Limit File"
           Limf$=Line$
         CASE "DIE Label"
           IF N_item>SIZE(Dielabel$,1) THEN 
             GOSUB Array_overflow
           END IF
  !          Dielabel$(I)=Line$ 2006/02/10
           Dielabel$(N_item)=Line$
         CASE "DIE Type"
           IF N_item>SIZE(Dietype$,1) THEN 
             GOSUB Array_overflow
           END IF
  !          Dietype$(I)=Line$ 2006/02/10
           Dietype$(N_item)=Line$
         CASE "MOD Label"
           IF N_item>SIZE(Modlabel$,1) THEN 
             GOSUB Arrary_overflow
           END IF
  !          Modlabel$(I)=Line$ 2006/02/10
           Modlabel$(N_item)=Line$
         CASE ELSE
           GOSUB Eof
           SUBEXIT
         END SELECT
       END IF
  !
       ENTER @S;Line$
     END WHILE
  !
     ASSIGN @S TO *
   END IF
  !
   GOSUB Del_spc
   SUBEXIT
  !
 Eof:    !
   Status=-3
   Errmsg$="Cannot find a recipe by the key, """&Key$&"""."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Array_overflow:    !
   Status=-4
   Errmsg$="Subscript of spec name array is out of range."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Del_spc:     !
   ON ERROR GOTO Del_end
   PURGE Spc$
 Del_end:     !
   OFF ERROR 
   RETURN 
  !
 SUBEND
 Fa_query_rcp2:SUB Fa_query_rcp2(V1$,V2$,Waf$,Die$(*),Mod$(*),Tst$(*),Prb$,Lms$(*),Tco$(*),Tpl$,Lim$,Mlb$(*),Rcp$,Lt_id$,Pt_id$,Ps_id$,Item$(*),INTEGER Status,Errmsg$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_QUERY_RCP2
 !  Vers : 1
 !  Desc : Query recipe items in the recipe file from key recipe id.
 !       :   SPECS3.0: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Key             S    -
 !      2 Filename        S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Waf             S    -
 !      2 Die             S    256
 !      3 Mod             S    256
 !      4 Tst             S    256
 !      5 Prb             S    -
 !      6 Lms             S    256
 !      7 Tco             S    16
 !      8 Tpl             S    -
 !      9 Lim             S    -
 !     10 Mlb             S    256
 !     11 Rcp             S    -
 !     12 Lt_id           S    -
 !     13 Pt_id           S    -
 !     14 Ps_id           S    -
 !     15 Item            S    32
 !     16 Status          I    -        0: OK, -1: Exec Err, -2: No File
 !     17 Errmsg          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Key$[255]                                   ! V1
   DIM Filename$[255]                              ! V2
   Key$=V1$
   Filename$=V2$
 !***** DON'T REMOVE THIS LINE *************************************
  !
   DIM Cmd$[32767],Spc$[256],Line$[4096],Detail$(10)[256],Spc_nm$[256]
   INTEGER I,N_item,Ndetail,Cmd_ret
  !
   Cmd$="/opt/SPECS/usr/recipe/fa_recipe_q2.sh"
   Spc$="/var/tmp/spc."&SYSTEM$("PROCESS ID")
  !
   FOR I=1 TO SIZE(Item$,1)
     Item$(I)=""
   NEXT I
   Waf$=""
   FOR I=1 TO SIZE(Die$,1)
     Die$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Mod$,1)
     Mod$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tst$,1)
     Tst$(I)=""
   NEXT I
   Prb$=""
   FOR I=1 TO SIZE(Lms$,1)
     Lms$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tco$,1)
     Tco$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Mlb$,1)
     Mlb$(I)=""
   NEXT I
   Tpl$=""
   Lim$=""
   Rcp$=""
   Lt_id$=""
   Ps_id$=""
   Pt_id$=""
  !
   Cmd$=Cmd$&" "&Filename$&" "&Key$
   PRINT Cmd$
   Fa_rcp_exec_cmd(Cmd$,Spc$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
  !
   IF Cmd_ret=1 THEN Status=1
   IF Status=0 OR Status=1 THEN 
     ASSIGN @S TO Spc$;FORMAT ON
     ON END @S GOSUB Eof
  !
     FOR I=1 TO SIZE(Item$,1)
       ENTER @S;Item$(I)
     NEXT I
     Spc_nm$=""
     N_item=0
     ENTER @S;Line$
     WHILE (Line$<>"# EOD")
       PRINT Line$
       PRINT Spc_nm$
       IF Line$[1,2]="# " THEN 
         Spc_nm$=Line$[3;LEN(Line$)-2]
         N_item=0
       ELSE
         N_item=N_item+1
         SELECT Spc_nm$
         CASE "WAF"
           Waf$=Line$
         CASE "DIE"
           IF N_item>SIZE(Die$,1) THEN 
             GOSUB Array_overflow
           END IF
           Die$(N_item)=Line$
         CASE "MOD"
           IF N_item>SIZE(Mod$,1) THEN 
             GOSUB Array_overflow
           END IF
           Mod$(N_item)=Line$
         CASE "TST"
           IF N_item>SIZE(Tst$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tst$(N_item)=Line$
         CASE "PRB"
           Prb$=Line$
         CASE "LMS"
           IF N_item>SIZE(Lms$,1) THEN 
             GOSUB Array_overflow
           END IF
           Lms$(N_item)=Line$
         CASE "TCO"
           IF N_item>SIZE(Tco$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tco$(N_item)=Line$
         CASE "TPL"
           Tpl$=Line$
         CASE "Limit File"
           Lim$=Line$
         CASE "Prober RCP"
           Rcp$=Line$
         CASE "STEP"
           Lot_id$=Line$
         CASE "PRODUCT"
           Pt_id$=Line$
         CASE "PROCESS"
           Ps_id$=Line$
         CASE "MEASLIBS"
           IF N_item>SIZE(Mlb$,1) THEN 
             GOSUB Array_overflow
           END IF
           Mlb$(N_item)=Line$
         CASE ELSE
           GOSUB Eof
           SUBEXIT
         END SELECT
       END IF
  !
       ENTER @S;Line$
     END WHILE
  !
     ASSIGN @S TO *
   END IF
  !
   GOSUB Del_spc
   SUBEXIT
  !
 Eof:    !
   Status=-3
   Errmsg$="Cannot find a recipe by the key, """&Key$&"""."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Array_overflow:    !
   Status=-4
   Errmsg$="Subscript of spec name array is out of range."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Del_spc:     !
   ON ERROR GOTO Del_end
   PURGE Spc$
 Del_end:     !
   OFF ERROR 
   RETURN 
  !
 SUBEND
 Fa_query_recip:SUB Fa_query_recip(Key$,Filename$,Waf$,Die$(*),Mod$(*),Tst$(*),Prb$,Lms$(*),Tco$(*),Tpl$,Lim$,Rcp$,Lt_id$,Pt_id$,Ps_id$,Item$(*),INTEGER Status,Errmsg$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_QUERY_RECIP
 !  Vers : 1
 !  Desc : 20100820 C.C.Y - Query recipe items in the recipe file fr
 !       : om key recipe id.
 !       : SPECS3.0: Initial revision.
 !  Date : 03/24/2011
 !  Time : 12:57:42
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Key             S    -
 !      2 Filename        S    -        Input Recipe Name from Recipe Ta
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Waf             S    -
 !      2 Die             S    256
 !      3 Mod             S    256
 !      4 Tst             S    256
 !      5 Prb             S    -
 !      6 Lms             S    256
 !      7 Tco             S    16
 !      8 Tpl             S    -
 !      9 Lim             S    -
 !     10 Rcp             S    -
 !     11 Lt_id           S    -
 !     12 Pt_id           S    -
 !     13 Ps_id           S    -
 !     14 Item            S    32
 !     15 Status          I    -        0: OK, -1: Exec Err, -2: No File
 !     16 Errmsg          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[32767],Spc$[256],Line$[4096],Detail$(10)[256],Spc_nm$[256]
   INTEGER I,N_item,Ndetail,Cmd_ret
  !
   Cmd$="/opt/SPECS/usr/recipe/fa_recipe_q.sh"
   Spc$="/var/tmp/spc."&SYSTEM$("PROCESS ID")
  !
   FOR I=1 TO SIZE(Item$,1)
     Item$(I)=""
   NEXT I
   Waf$=""
   FOR I=1 TO SIZE(Die$,1)
     Die$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Mod$,1)
     Mod$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tst$,1)
     Tst$(I)=""
   NEXT I
   Prb$=""
   FOR I=1 TO SIZE(Lms$,1)
     Lms$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tco$,1)
     Tco$(I)=""
   NEXT I
   Tpl$=""
   Lim$=""
   Rcp$=""
   Lt_id$=""
   Ps_id$=""
   Pt_id$=""
  !
   Cmd$=Cmd$&" "&Filename$&" "&Key$
   PRINT "Cmd$";Cmd$
   Fa_rcp_exec_cmd(Cmd$,Spc$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
  !
   PRINT "1=";Cmd$
   PRINT "2=";Spc$
   PRINT "3=";Status
   PRINT "4=";Errmsg$
   PRINT "5=";Ndetail$
   PRINT "6=";Cmd_ret
   IF Cmd_ret=1 THEN Status=1
   IF Status=0 OR Status=1 THEN 
     ASSIGN @S TO Spc$;FORMAT ON
     ON END @S GOSUB Eof
  !
     PRINT SIZE(Item$,1)
     FOR I=1 TO SIZE(Item$,1)
       ENTER @S;Item$(I)
       PRINT Item$(I)
     NEXT I
     Spc_nm$=""
     N_item=0
     ENTER @S;Line$
     WHILE (Line$<>"# EOD")
       PRINT Line$
       PRINT Spc_nm$
       IF Line$[1,2]="# " THEN 
         Spc_nm$=Line$[3;LEN(Line$)-2]
         N_item=0
       ELSE
         N_item=N_item+1
         SELECT Spc_nm$
         CASE "WAF"
           Waf$=Line$
         CASE "DIE"
           IF N_item>SIZE(Die$,1) THEN 
             GOSUB Array_overflow
           END IF
           Die$(N_item)=Line$
         CASE "MOD"
           IF N_item>SIZE(Mod$,1) THEN 
             GOSUB Array_overflow
           END IF
           Mod$(N_item)=Line$
         CASE "TST"
           IF N_item>SIZE(Tst$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tst$(N_item)=Line$
         CASE "PRB"
           Prb$=Line$
         CASE "LMS"
           IF N_item>SIZE(Lms$,1) THEN 
             GOSUB Array_overflow
           END IF
           Lms$(N_item)=Line$
         CASE "TCO"
           IF N_item>SIZE(Tco$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tco$(N_item)=Line$
         CASE "TPL"
           Tpl$=Line$
         CASE "Limit File"
           Lim$=Line$
         CASE "Prober RCP"
           Rcp$=Line$
         CASE "STEP"!shan-li
           Lot_id$=Line$!shan-li
         CASE "PRODUCT"!shan-li
           Pt_id$=Line$
         CASE "PROCESS"
           Ps_id$=Line$
  !CASE ELSE
  ! GOSUB Eof
  !SUBEXIT
         END SELECT
       END IF
  !
       ENTER @S;Line$
     END WHILE
  !
     ASSIGN @S TO *
   END IF
  !
   GOSUB Del_spc
   SUBEXIT
  !
 Eof:     !
   PRINT Spc_nm$
   Status=-3
   Errmsg$="Cannot find a recipe by the key, """&Key$&"""."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Array_overflow:     !
   Status=-4
   Errmsg$="Subscript of spec name array is out of range."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Del_spc:      !
   ON ERROR GOTO Del_end
   PURGE Spc$
 Del_end:      !
   OFF ERROR 
   RETURN 
  !
 SUBEND
 Fa_rcp_exec_cmd:SUB Fa_rcp_exec_cmd(Cmd$,Result$,INTEGER Status,Errmsg$,INTEGER Ndetail,Detail$(*),INTEGER Cmd_ret)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_RCP_EXEC_CMD
 !  Vers : 1
 !  Desc : Execute command file and get result file.
 !       :   SPECS3.0: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Cmd             S    -
 !      2 Result          S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0: OK, -1: Exec Err, -2: No File
 !      2 Errmsg          S    -
 !      3 Ndetail         I    -        # of lines of detail error messa
 !      4 Detail          S    10       Detailed error message
 !      5 Cmd_ret         I    -        Return value from Command
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Err$[256],Cl$[32767]
   DIM Ver$[50]
   INTEGER Arg_max
   INTEGER St,I
  !
   Ndetail=0
   FOR I=1 TO 10
     Detail$(I)=""
   NEXT I
   Cmd_ret=0
  !
   IF Cmd$="" THEN 
     Status=-2
     Errmsg$="No command is specified."
     SUBEXIT
   END IF
  !
   EXECUTE "/usr/bin/touch "&Result$;RETURN St
   IF St THEN 
     Status=-2
     Errmsg$="Cannot store the result. """&Result$&""""
     SUBEXIT
   END IF
  !
   Err$="/var/tmp/rcp_exec_cmd."&SYSTEM$("PROCESS ID")
   Status=0
   Errmsg$=""
  !
   ON ERROR GOTO Str_overflow
   Cl$=Cmd$&" > "&Result$&" 2> "&Err$
   OFF ERROR 
  !
   Ver$=SYSTEM$("VERSION:OS")
   Ver$=Ver$[3;5]
   IF Ver$<="10.20" THEN 
     Arg_max=20478
     IF LEN(Cl$)>Arg_max THEN 
       GOSUB Str_overflow
     END IF
   END IF
  !
   EXECUTE Cl$;RETURN St
  !
   Cmd_ret=SHIFT(St,8) MOD 256
   IF Cmd_ret>=128 THEN Cmd_ret=Cmd_ret-256
  !
   IF St<>0 THEN 
     Status=-1
     ON ERROR GOTO No_errfl
     ASSIGN @E TO Err$;FORMAT ON
     ASSIGN @E TO *
     OFF ERROR 
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO Eof
     FOR I=1 TO 10
       ENTER @E;Detail$(I)
       Ndetail=I
     NEXT I
 Eof:    !
     OFF END @E
     ASSIGN @E TO *
  !
     IF Ndetail>0 THEN 
       Errmsg$=Detail$(1)
     ELSE
       Errmsg$="Error found while executing: "&Cl$
     END IF
   END IF
   PURGE Err$
   SUBEXIT
  !
 Str_overflow:    !
   Status=-1
   Errmsg$="Internal string buffer overflow."
   PURGE Err$
   SUBEXIT
  !
 No_errfl:    !
   OFF ERROR            ! 2005/11/01
   Status=-1
   Errmsg$="Cannot execute command: "&Cl$
   ON ERROR GOTO Exit   ! 2005/11/01
   PURGE Err$
   SUBEXIT
  !
 Exit:                  ! 2005/11/01
   OFF ERROR            ! 2005/11/01
   SUBEXIT              ! 2005/11/01
 SUBEND
 Fa_read_card:SUB Fa_read_card(Cardpath$,Cardid$,Id_sta$,Cardtype$,Cardname$,REAL Totalcount,Limitcount,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_READ_CARD
 !  Vers : 1
 !  Desc : Desc: Read name, type, and count in probe card.
 !       : Date: '00/11/27 1st revision
 !       : Date: '01/10/07 Read file and return the parameters
 !  Date : 01/19/2005
 !  Time : 20:22:07
 !  User : fa
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 CardPath        S    -
 !      2 CardId          S    -
 !      3 Id_sta          S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 CardType        S    -        Card Type
 !      2 CardName        S    -        Card Name
 !      3 TotalCount      R    -        Total Touchdown Count
 !      4 LimitCount      R    -        Limit of Touchdonw Cound
 !      5 Status          I    -        0:OK -1:Error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
   DIM Revision$[255]
   DIM Date$[255]
   DIM Filename$[255]
   DIM Read_file$[255]
   INTEGER Exist,Writable,Readable,Executable
   INTEGER Flag
  !
   Status=0
   Exist=0
   Writable=0
   Cardname$=Cardid$
   Filename$=Cardpath$&"/"&Cardname$
  !
   IF Id_sta$="ERROR" THEN GOTO Read_card_end
  !
   CALL Verify_file(Filename$,"Normal",Exist,Readable,Writable,Executable)
   IF Exist<>1 THEN 
  !
     EXECUTE "touch "&Filename$
     Revision$="Rev. Auto"
     Totalcount=0
     Limitcount=100000
     Date$=DATE$(TIMEDATE)
  !
     ASSIGN @File TO Filename$
     OUTPUT @File USING "-,K";Revision$
     OUTPUT @File USING "-,K";Totalcount
     OUTPUT @File USING "-,K";Limitcount
     OUTPUT @File USING "-,K";Date$
     ASSIGN @File TO *
  !
   END IF
  !
   GOSUB Read_file
   GOSUB Verify_file
   SUBEXIT
  !
  !!!!! Searching a cardname !!!!!
  !!!!! Read parameters from found cardname !!!!!
 Read_file:   !
   ON ERROR GOTO Read_card_end
   ASSIGN @File TO Filename$
   ENTER @File USING "#,K";Revision$
   ENTER @File USING "#,K";Totalcount
   ENTER @File USING "#,K";Limitcount
   ENTER @File USING "#,K";Date$
   ASSIGN @File TO *
   OFF ERROR 
   RETURN 
  !
  !!!!! Check the permission !!!!!
 Verify_file:   !
   CALL Verify_file(Filename$,"Normal",Exist,Readable,Writable,Executable)
   IF Writable<>1 THEN GOTO Read_card_end
   RETURN 
  !
 Read_card_end:    !
   OFF ERROR 
   ASSIGN @File TO *
   Status=-1
   Cardtype$=""
   Cardname$=""
   Totalcount=0
   Limitcount=0
   Date$=""
  !
 SUBEND
 Fa_runp_create:SUB Fa_runp_create(Meas_dir$,Fwk_dir$,Meas$,Fwk$,INTEGER Status,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_RUNP_CREATE
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Meas_dir        S    -
 !      2 Fwk_dir         S    -
 !      3 Meas            S    -
 !      4 Fwk             S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -
 !      2 Error           S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   EXECUTE "rm -f /usr/tmp/param"
   EXECUTE "touch /usr/tmp/param"
   ON ERROR GOTO Err
   ASSIGN @Runfile TO "/usr/tmp/param";FORMAT ON
   ON END @Runfile GOTO Endoffile
   OUTPUT @Runfile USING "-,K";"-f"&Fwk_dir$&Fwk$
   OUTPUT @Runfile USING "-,K";"-a"&Meas_dir$&Meas$
   PRINT USING "-,K";"-f"&Fwk_dir$&"|"&Fwk$
   PRINT USING "-,K";"-a"&Meas_dir$&"|"&Meas$
   ASSIGN @Runfile TO *
   SUBEXIT
  !
 Err:   !
   Status=-9
   SUBEXIT
 Endoffile:  !
   Status=-1
   ASSIGN @Runfile TO *
   Error$="run param file not found."
 SUBEND
 Fa_tpl_run:SUB Fa_tpl_run(Session$,INTEGER Status,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_TPL_RUN
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Command status
 !      2 Error           S    -        Error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   EXECUTE "/opt/SPECS/sys/bin/sslnc -g"&Session$&" -e/usr/tmp/param";RETURN Status
   IF Status=0 THEN 
     Error$=""
   ELSE
     Error$="ERROR"
   END IF
 SUBEND
 Fa_tpl_verify:SUB Fa_tpl_verify(INTEGER Revcont,Revmode,Lib$(*),INTEGER Libnum,Tco$(*),INTEGER Tconum,Tpl$,Delimiter$,INTEGER Status,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_TPL_VERIFY
 !  Vers : 1
 !  Desc : Validate test plan with multi-measurement libraries and t
 !       : est plan constants.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Revcont         I    -        Revision Control Mode
 !      2 Revmode         I    -        Revision Name/Number Option
 !      3 Lib             S    256      Measurement Library File (with R
 !      4 Libnum          I    -        Number of Measurement Library
 !      5 Tco             S    256      Test Plan Constant File (with Re
 !      6 Tconum          I    -        Number of Test Plan Constant
 !      7 Tpl             S    -        Test Plan File (with Revision)
 !      8 Delimiter       S    -        Delimiter between File and Revis
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Error Code
 !      2 Error           S    -        Error Message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Problib$[256],Testlib$[256],Utillib$[256],Devlib$[256],Fwknam$[256]
   DIM Probrev$[256],Testrev$[256],Utilrev$[256],Devrev$[256],Fwkrev$[256]
   INTEGER Probnum,Testnum,Utilnum,Devnum,Fwknum
   DIM Measlib$[256],Tconam$[256],Tplnam$[256]
   DIM Measrev$[256],Tcorev$[256],Tplrev$[256]
   INTEGER Measnum
   INTEGER Cnt,Num,Pos,Rslt
   DIM Tplverify$[32767],Revopen$[32767]
   DIM Exeverify$[256]
  !
   Status=0
   Error$=""
   Tplverify$="/opt/SPECS/sys/bin/tplverify"
   Exeverify$="/var/tmp/tplverify."&SYSTEM$("PROCESS ID")
  !
   Tplfileplib(Problib$,Probrev$,Probnum)
   IF Probnum<>0 THEN 
     Tplverify$=Tplverify$&" -p "&Problib$
   END IF
   Tplfiletlib(Testlib$,Testrev$,Testnum)
   IF Testnum<>0 THEN 
     Tplverify$=Tplverify$&" -t "&Testlib$
   END IF
   Tplfileulib(Utillib$,Utilrev$,Utilnum)
   IF Utilnum<>0 THEN 
     Tplverify$=Tplverify$&" -u "&Utillib$
   END IF
   Tplfiledlib(Devlib$,Devrev$,Devnum)
   IF Devnum<>0 THEN 
     Tplverify$=Tplverify$&" -dvl "&Devlib$
   END IF
   Tplfilefwk(Fwknam$,Fwkrev$,Fwknum)
   IF Fwknum<>0 THEN 
     Tplverify$=Tplverify$&" -fwk "&Fwknam$
   END IF
  !
   FOR Cnt=1 TO Libnum
 Libnext:    !
     IF Cnt>Libnum OR Cnt>256 THEN 
       GOTO Libend
     END IF
     IF LEN(Lib$(Cnt))=0 THEN 
       Cnt=Cnt+1
       GOTO Libnext
     END IF
  !
     Measlib$=Lib$(Cnt)
     IF Revcont<>0 THEN 
       Pos=POS(Measlib$,Delimiter$)
       IF Pos<>0 THEN 
         Measrev$=Measlib$[LEN(Measlib$)-Pos+1,LEN(Measlib$)]
         Measlib$=Measlib$[1,LEN(Measlib$)-Pos]
       END IF
     END IF
     IF Measlib$[1,1]<>"/" THEN 
       Measlib$="/opt/SPECS/usr/alg/"&Measlib$
     END IF
     IF Cnt=1 THEN 
       Tplverify$=Tplverify$&" -m "&Measlib$
     ELSE
       Tplverify$=Tplverify$&","&Measlib$
     END IF
       !
     IF LEN(Measrev$)<>0 THEN 
       IF Revmode<>0 THEN 
         Revopen$="/opt/SPECS/sys/bin/revopen -t lib -n "&Measrev$&" "&Measlib$
       ELSE
         Revopen$="/opt/SPECS/sys/bin/revopen -t lib -a "&Measrev$&" "&Measlib$
       END IF
       EXECUTE Revopen$;RETURN Rslt
       IF Rslt<>0 THEN 
         Status=-2
         Error$="Fail to open measurement library as revision : "&Measlib$&", "&Measrev$
         SUBEXIT
       END IF
     END IF
   NEXT Cnt
  !
   IF Libnum=0 THEN 
     Tplfilenummlib(Num)
     FOR Cnt=1 TO Num
       Tplfilemlibm(Cnt-1,Measlib$,Measrev$,Measnum)
       IF Cnt=1 THEN 
         Tplverify$=Tplverify$&" -m "&Measlib$
       ELSE
         Tplverify$=Tplverify$&","&Measlib$
       END IF
     NEXT Cnt
   END IF
 Libend:    !
  !
   FOR Cnt=1 TO Tconum
 Tconext:    !
     IF Cnt>Tconum OR Cnt>256 THEN 
       GOTO Tcoend
     END IF
     IF LEN(Tco$(Cnt))=0 THEN 
       Cnt=Cnt+1
       GOTO Tconext
     END IF
       !
     Tconam$=Tco$(Cnt)
     IF Revcont<>0 THEN 
       Pos=POS(Tconam$,Delimiter$)
       IF Pos<>0 THEN 
         Tcorev$=Tconam$[LEN(Tconam$)-Pos+1,LEN(Tconam$)]
         Tconam$=Tconam$[1,LEN(Tconam$)-Pos]
       END IF
     END IF
     IF Tconam$[1,1]<>"/" THEN 
       Tconam$="/opt/SPECS/usr/tco/"&Tconam$
     END IF
     Tplverify$=Tplverify$&" -tco "&Tconam$
       !
     IF LEN(Tcorev$)<>0 THEN 
       IF Revmode<>0 THEN 
         Revopen$="/opt/SPECS/sys/bin/revopen -t tco -n "&Tcorev$&" "&Tconam$
       ELSE
         Revopen$="/opt/SPECS/sys/bin/revopen -t tco -a "&Tcorev$&" "&Tconam$
       END IF
       EXECUTE Revopen$;RETURN Rslt
       IF Rslt<>0 THEN 
         Status=-3
         Error$="Fail to open test plan constant as revision : "&Tconam$&", "&Tcorev$
         SUBEXIT
       END IF
     END IF
   NEXT Cnt
  !
   IF Tconum=0 THEN 
     Tplfilenumtco(Num)
     FOR Cnt=1 TO Num
       Tplfiletco(Cnt-1,Tconam$,Tcorev$,Tconum)
       Tplverify$=Tplverify$&" -tco "&Tconam$
     NEXT Cnt
   END IF
 Tcoend:    !
  !
   IF LEN(Tpl$)=0 THEN 
     Status=-5
     Error$="Test plan is not specified"
     SUBEXIT
   END IF
   Tplnam$=Tpl$
   IF Revcont<>0 THEN 
     Pos=POS(Tplnam$,Delimiter$)
     IF Pos<>0 THEN 
       Tplrev$=Tplnam$[LEN(Tplnam$)-Pos+1,LEN(Tplnam$)]
       Tplnam$=Tplnam$[1,LEN(Tplnam$)-Pos]
     END IF
   END IF
   IF Tplnam$[1,1]<>"/" THEN 
     Tplnam$="/opt/SPECS/usr/tpl/"&Tplnam$
   END IF
   Tplverify$=Tplverify$&" "&Tplnam$
   IF Tplverify$[LEN(Tplverify$)-LEN(".tpl")+1,LEN(Tplverify$)]<>".tpl" THEN 
     Tplverify$=Tplverify$&".tpl"
   END IF
  !
   IF LEN(Tplrev$)<>0 THEN 
     IF Revmode<>0 THEN 
       Revopen$="/opt/SPECS/sys/bin/revopen -t tpl -n "&Tplrev$&" "&Tplnam$
     ELSE
       Revopen$="/opt/SPECS/sys/bin/revopen -t tpl -a "&Tplrev$&" "&Tplnam$
     END IF
     EXECUTE Revopen$;RETURN Rslt
     IF Rslt<>0 THEN 
       Status=-4
       Error$="Fail to open test plan as revision : "&Tplnam$&", "&Tplrev$
       SUBEXIT
     END IF
   END IF
 Tplend:    !
  !
   ON ERROR GOTO Nofile
   PURGE Exeverify$
  !
 Nofile:    !
   ON ERROR GOTO Err
   CREATE Exeverify$,1
   ASSIGN @File TO Exeverify$;FORMAT ON
   OUTPUT @File;Tplverify$
   ASSIGN @File TO *
     !
   ASSIGN @Pipe TO "sh "&Exeverify$&" |"
   ON END @Pipe GOTO Norm
   ENTER @Pipe;Error$
   GOTO Norm
  !
 Err:    !
   ASSIGN @File TO *
   OFF ERROR 
   Status=-5
   Error$="Fail to open file"
   PURGE Exeverify$
   SUBEXIT
  !
 Norm:    !
   ASSIGN @File TO *
   OFF END @Pipe
   OFF ERROR 
   IF LEN(Error$)<>0 THEN 
     Status=-1
   END IF
   PURGE Exeverify$
   SUBEXIT
 SUBEND
 Fa_tplbld:SUB Fa_tplbld(INTEGER V1,V2$,V3$,V4$,V5$,V6$,V7$,V8$,V9$,V10$(*),V11$(*),V12$,INTEGER Status,Error$,INTEGER Ndetail,Detail$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_TPLBLD
 !  Vers : 1
 !  Desc : This algorithm generates Test Plan dynamically.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Rev_flag        I    -        0:Revision Control not available
 !      2 Brk_chr         S    -        Connection char between filename
 !      3 Waf_dir         S    -        Wafer spec search directory
 !      4 Prb_dir         S    -        Probe spec search directory
 !      5 Die_dir         S    -        Die spec search directory
 !      6 Tst_dir         S    -        Test spec search directory
 !      7 Tpl_dir         S    -        Testplan directory
 !      8 Waf             S    -        Wafer spec name to read
 !      9 Prb             S    -        Probe spec name to read
 !     10 Die             S    32       Die spec name to read
 !     11 Tst             S    32       Test spec name to read
 !     12 Tpl             S    -        Test Plan name to write
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Command status
 !      2 Error           S    -        Error message
 !      3 Ndetail         I    -        # of lines of detail error messa
 !      4 Detail          S    10       detailed error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Rev_flag                                ! V1
   DIM Brk_chr$[255]                               ! V2
   DIM Waf_dir$[255]                               ! V3
   DIM Prb_dir$[255]                               ! V4
   DIM Die_dir$[255]                               ! V5
   DIM Tst_dir$[255]                               ! V6
   DIM Tpl_dir$[255]                               ! V7
   DIM Waf$[255]                                   ! V8
   DIM Prb$[255]                                   ! V9
   DIM Die$(1:32)[255]                             ! V10
   DIM Tst$(1:32)[255]                             ! V11
   DIM Tpl$[255]                                   ! V12
   Rev_flag=V1
   Brk_chr$=V2$
   Waf_dir$=V3$
   Prb_dir$=V4$
   Die_dir$=V5$
   Tst_dir$=V6$
   Tpl_dir$=V7$
   Waf$=V8$
   Prb$=V9$
   MAT Die$= V10$
   MAT Tst$= V11$
   Tpl$=V12$
 !***** DON'T REMOVE THIS LINE *************************************
   DIM Cmd$[256],Opt$[4096],Err$[256]
   DIM Optdie$[4096],Optdt$[4096],Mopt$[8192]
   DIM Fulltpl$[512]
   DIM W$[256],P$[256],D$[256],T$[256],Tp$[256]
   DIM Wd$[256],Pd$[256],Dd$[256],Td$[256]
   INTEGER I,J,Stat
   INTEGER Dietst_num
  !
   ON ERROR GOTO Basic_syserr
   Dietst_num=SIZE(Die$,1)
   ALLOCATE INTEGER Tstflg(Dietst_num)
  !
   CALL Fa_chk_files(Rev_flag,Waf_dir$,Waf$,"waf",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-11
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Prb_dir$,Prb$,"prb",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-12
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Tpl_dir$,Tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-3 THEN GOTO File_check_err
   W$=Waf$
   P$=Prb$
   Tp$=Tpl$
   IF POS(W$,Brk_chr$)>0 THEN W$=Waf$[1,POS(Waf$,Brk_chr$)-1]
   IF POS(P$,Brk_chr$)>0 THEN P$=Prb$[1,POS(Prb$,Brk_chr$)-1]
   IF POS(Tp$,Brk_chr$)>0 THEN Tp$=Tpl$[1,POS(Tpl$,Brk_chr$)-1]
   Wd$=Waf_dir$
   Pd$=Prb_dir$
   Dd$=Die_dir$
   Td$=Tst_dir$
   IF Wd$[LEN(Wd$)]<>"/" THEN Wd$=Wd$&"/"
   IF Pd$[LEN(Pd$)]<>"/" THEN Pd$=Pd$&"/"
   IF Dd$[LEN(Dd$)]<>"/" THEN Dd$=Dd$&"/"
   IF Td$[LEN(Td$)]<>"/" THEN Td$=Td$&"/"
  !
   Cmd$="/opt/SPECS/sys/bin/tplbuild"
   Opt$=" -waf "&Wd$&W$&" -prb "&Pd$&P$
   MAT Tstflg= (1)
   Optdie$=""
   Optdt$=""
   FOR I=1 TO Dietst_num
     IF Die$(I)<>"" AND Tst$(I)<>"" AND Tstflg(I)=1 THEN 
       CALL Fa_chk_files(Rev_flag,Die_dir$,Die$(I),"die",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-13
         GOTO File_check_err2
       END IF
       CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(I),"tst",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-14
         GOTO File_check_err2
       END IF
       D$=Die$(I)
       T$=Tst$(I)
       IF POS(D$,Brk_chr$)>0 THEN D$=Die$(I)[1,POS(Die$(I),Brk_chr$)-1]
       IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(I)[1,POS(Tst$(I),Brk_chr$)-1]
       Optdie$=Optdie$&" -die "&Dd$&D$
       Optdt$=Optdt$&" -tst "&Dd$&D$&" "&Td$&T$
       IF I<Dietst_num THEN 
         FOR J=I+1 TO Dietst_num
           IF Die$(I)=Die$(J) AND Tstflg(J)=1 THEN 
             CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(J),"tst",Brk_chr$,Stat)
             IF Stat<-1 THEN 
               Status=-14
               GOTO File_check_err
             END IF
             T$=Tst$(J)
             IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(J)[1,POS(Tst$(J),Brk_chr$)-1]
             Optdt$=Optdt$&","&Td$&T$
             Tstflg(J)=0
           END IF
         NEXT J
       END IF
     END IF
   NEXT I
   Err$="/usr/tmp/tplbld.err"
   Fulltpl$=Tpl_dir$
   IF Tpl_dir$[LEN(Tpl_dir$)]<>"/" THEN Fulltpl$=Fulltpl$&"/"
   Fulltpl$=Fulltpl$&Tp$
   IF POS(Fulltpl$,".tpl")=0 THEN Fulltpl$=Fulltpl$&".tpl"
   EXECUTE Cmd$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$;RETURN Stat
  !!PRINT Cmd$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO E
     Error$="ERROR"
     ENTER @E;Error$
     Ndetail=0
     LOOP
       ENTER @E;Detail$(Ndetail+1)
       Ndetail=Ndetail+1
     END LOOP
 E:  ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
   PURGE Err$
   DEALLOCATE Tstflg(*)
   SUBEXIT
 File_check_err: !
   Status=-1
 File_check_err2: !
   Error$="File_check_error "&VAL$(Stat)
   DEALLOCATE Tstflg(*)
   SUBEXIT
 Basic_syserr: !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
   DEALLOCATE Tstflg(*)
 SUBEND
 Fa_tplbld2:SUB Fa_tplbld2(INTEGER V1,V2$,V3$,V4$,V5$,V6$,V7$,V8$,V9$,V10$,V11$(*),V12$(*),V13$(*),V14$,V15$,V16$,V17$,V18$,V19$,INTEGER Status,Error$,INTEGER Ndetail,Detail$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_TPLBLD2
 !  Vers : 1
 !  Desc : This algorithm generates Test Plan dynamically.
 !       : 2010/12/01 - C.C.Y WATre path modification
 !  Date : 03/24/2011
 !  Time : 14:00:31
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Rev_flag        I    -        0:Revision Control not available
 !      2 Brk_chr         S    -        Connection char between filename
 !      3 Waf_dir         S    -        Wafer spec search directory
 !      4 Prb_dir         S    -        Probe spec search directory
 !      5 Die_dir         S    -        Die spec search directory
 !      6 Tst_dir         S    -        Test spec search directory
 !      7 Mod_dir         S    -        Module spec search directory
 !      8 Tpl_dir         S    -        Testplan directory
 !      9 Waf             S    -        Wafer spec name to read
 !     10 Prb             S    -        Probe spec name to read
 !     11 Die             S    256      Die spec name to read
 !     12 Tst             S    256      Test spec name to read
 !     13 Mod             S    256      Module spec name to read
 !     14 Tpl             S    -        Test Plan name to write
 !     15 Meas            S    -        Measurement lib
 !     16 Tester          S    -        Tester lib
 !     17 Prober          S    -        Prober lib
 !     18 Utility         S    -        Utility lib
 !     19 Device          S    -        Device lib
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Command status
 !      2 Error           S    -        Error message
 !      3 Ndetail         I    -        # of lines of detail error messa
 !      4 Detail          S    10       detailed error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Rev_flag                                ! V1
   DIM Brk_chr$[255]                               ! V2
   DIM Waf_dir$[255]                               ! V3
   DIM Prb_dir$[255]                               ! V4
   DIM Die_dir$[255]                               ! V5
   DIM Tst_dir$[255]                               ! V6
   DIM Mod_dir$[255]                               ! V7
   DIM Tpl_dir$[255]                               ! V8
   DIM Waf$[255]                                   ! V9
   DIM Prb$[255]                                   ! V10
   DIM Die$(1:256)[255]                            ! V11
   DIM Tst$(1:256)[255]                            ! V12
   DIM Mod$(1:256)[255]                            ! V13
   DIM Tpl$[255]                                   ! V14
   DIM Meas$[255]                                  ! V15
   DIM Tester$[255]                                ! V16
   DIM Prober$[255]                                ! V17
   DIM Utility$[255]                               ! V18
   DIM Device$[255]                                ! V19
   Rev_flag=V1
   Brk_chr$=V2$
   Waf_dir$=V3$
   Prb_dir$=V4$
   Die_dir$=V5$
   Tst_dir$=V6$
   Mod_dir$=V7$
   Tpl_dir$=V8$
   Waf$=V9$
   Prb$=V10$
   MAT Die$= V11$
   MAT Tst$= V12$
   MAT Mod$= V13$
   Tpl$=V14$
   Meas$=V15$
   Tester$=V16$
   Prober$=V17$
   Utility$=V18$
   Device$=V19$
 !***** DON'T REMOVE THIS LINE *************************************
   DIM Cmd$[256],Opt$[4096],Err$[256]
   DIM Optdie$[4096],Optdt$[4096],Mopt$[4096]
   DIM Fulltpl$[512]
   DIM W$[256],P$[256],D$[256],T$[256],Tp$[256]
   DIM Wd$[256],Pd$[256],Dd$[256],Td$[256]
   DIM Md$[256],M$[256]   ! 2005/11/01
   INTEGER I,J,Stat
   INTEGER Dietst_num,Mod_num
  !
   ON ERROR GOTO Basic_syserr
   Dietst_num=SIZE(Die$,1)
   Mod_num=SIZE(Mod$,1)
   ALLOCATE INTEGER Tstflg(Dietst_num)
  !
   CALL Fa_chk_files(Rev_flag,Waf_dir$,Waf$,"waf",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-11
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Prb_dir$,Prb$,"prb",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-12
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Tpl_dir$,Tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-3 THEN GOTO File_check_err
   W$=Waf$
   P$=Prb$
   Tp$=Tpl$
   IF POS(W$,Brk_chr$)>0 THEN W$=Waf$[1,POS(Waf$,Brk_chr$)-1]
   IF POS(P$,Brk_chr$)>0 THEN P$=Prb$[1,POS(Prb$,Brk_chr$)-1]
   IF POS(Tp$,Brk_chr$)>0 THEN Tp$=Tpl$[1,POS(Tpl$,Brk_chr$)-1]
   Wd$=Waf_dir$
   Pd$=Prb_dir$
   Dd$=Die_dir$
   Td$=Tst_dir$
   Md$=Mod_dir$   ! 2005/11/01
   IF Wd$[LEN(Wd$)]<>"/" THEN Wd$=Wd$&"/"
   IF Pd$[LEN(Pd$)]<>"/" THEN Pd$=Pd$&"/"
   IF Dd$[LEN(Dd$)]<>"/" THEN Dd$=Dd$&"/"
   IF Td$[LEN(Td$)]<>"/" THEN Td$=Td$&"/"
   IF Md$[LEN(Md$)]<>"/" THEN Md$=Md$&"/"   ! 2005/11/01
  !
   Cmd$="/opt/SPECS/sys/bin/tplbuild"
   Opt$=" -waf "&Wd$&W$&" -prb "&Pd$&P$
   Mopt$=""
   FOR I=1 TO Mod_num
     IF Mod$(I)="" THEN 
       GOTO Modloopexit
     END IF
     CALL Fa_chk_files(Rev_flag,Mod_dir$,Mod$(I),"mod",Brk_chr$,Stat)
     IF Stat<-1 THEN 
       Status=-15
       GOTO Filecheck_err2
     END IF
     Mopt$=Mopt$&" -mod "
     M$=Mod$(I)   ! 2005/11/01
     IF POS(M$,Brk_chr$)>0 THEN M$=Mod$(I)[1,POS(Mod$(I),Brk_chr$)-1]   ! 2005/11/01
     Mopt$=Mopt$&Md$&M$
  !   Mopt$=Mopt$&Mod$(I)  ! 2005/11/01
   NEXT I
 Modloopexit:   !
   IF Meas$<>"" THEN 
     Mopt$=Mopt$&" -m "&Meas$
   END IF
   IF Tester$<>"" THEN 
     Mopt$=Mopt$&" -t "&Tester$
   END IF
   IF Prober$<>"" THEN 
     Mopt$=Mopt$&" -p "&Prober$
   END IF
   IF Utility$<>"" THEN 
     Mopt$=Mopt$&" -u "&Utility$
   END IF
   IF Device$<>"" THEN 
     Mopt$=Mopt$&" -dvl "&Device$
   END IF
   MAT Tstflg= (1)
   Optdie$=""
   Optdt$=""
   FOR I=1 TO Dietst_num
     IF Die$(I)<>"" AND Tst$(I)<>"" AND Tstflg(I)=1 THEN 
       CALL Fa_chk_files(Rev_flag,Die_dir$,Die$(I),"die",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-13
         GOTO File_check_err2
       END IF
       CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(I),"tst",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-14
         GOTO File_check_err2
       END IF
       D$=Die$(I)
       T$=Tst$(I)
       IF POS(D$,Brk_chr$)>0 THEN D$=Die$(I)[1,POS(Die$(I),Brk_chr$)-1]
       IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(I)[1,POS(Tst$(I),Brk_chr$)-1]
       Optdie$=Optdie$&" -die "&Dd$&D$
       Optdt$=Optdt$&" -tst "&Dd$&D$&" "&Td$&T$
       IF I<Dietst_num THEN 
         FOR J=I+1 TO Dietst_num
           IF Die$(I)=Die$(J) AND Tstflg(J)=1 THEN 
             CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(J),"tst",Brk_chr$,Stat)
             IF Stat<-1 THEN 
               Status=-14
               GOTO File_check_err
             END IF
             T$=Tst$(J)
             IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(J)[1,POS(Tst$(J),Brk_chr$)-1]
             Optdt$=Optdt$&","&Td$&T$
             Tstflg(J)=0
           END IF
         NEXT J
       END IF
     END IF
   NEXT I
   Err$="/usr/tmp/tplbld.err"
   Fulltpl$=Tpl_dir$
   IF Tpl_dir$[LEN(Tpl_dir$)]<>"/" THEN Fulltpl$=Fulltpl$&"/"
   Fulltpl$=Fulltpl$&Tp$
   IF POS(Fulltpl$,".tpl")=0 THEN Fulltpl$=Fulltpl$&".tpl"
   EXECUTE Cmd$&Mopt$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$;RETURN Stat
  !!PRINT Cmd$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO E
     Error$="ERROR"
     ENTER @E;Error$
     Ndetail=0
     LOOP
       ENTER @E;Detail$(Ndetail+1)
       Ndetail=Ndetail+1
     END LOOP
 E:  ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
   PURGE Err$
   DEALLOCATE Tstflg(*)
   SUBEXIT
 File_check_err: !
   Status=-1
 File_check_err2: !
   Error$="File_check_error "&VAL$(Stat)
   DEALLOCATE Tstflg(*)
   SUBEXIT
 Basic_syserr: !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
   DEALLOCATE Tstflg(*)
 SUBEND
 Fa_tplbld3:SUB Fa_tplbld3(INTEGER V1,V2$,V3$,V4$,V5$,V6$,V7$,V8$,V9$,V10$,V11$(*),V12$(*),V13$(*),V14$,V15$(*),V16$,V17$,V18$,V19$,INTEGER Status,Error$,INTEGER Ndetail,Detail$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_TPLBLD3
 !  Vers : 1
 !  Desc : This algorithm generates Test Plan dynamically.
 !  Date : 11/25/2010
 !  Time : 14:20:59
 !  User : watop
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Rev_flag        I    -        0:Revision Control not available
 !      2 Brk_chr         S    -        Connection char between filename
 !      3 Waf_dir         S    -        Wafer spec search directory
 !      4 Prb_dir         S    -        Probe spec search directory
 !      5 Die_dir         S    -        Die spec search directory
 !      6 Tst_dir         S    -        Test spec search directory
 !      7 Mod_dir         S    -        Module spec search directory
 !      8 Tpl_dir         S    -        Testplan directory
 !      9 Waf             S    -        Wafer spec name to read
 !     10 Prb             S    -        Probe spec name to read
 !     11 Die             S    256      Die spec name to read
 !     12 Tst             S    256      Test spec name to read
 !     13 Mod             S    256      Module spec name to read
 !     14 Tpl             S    -        Test Plan name to write
 !     15 Meas            S    256      Measurement lib
 !     16 Tester          S    -        Tester lib
 !     17 Prober          S    -        Prober lib
 !     18 Utility         S    -        Utility lib
 !     19 Device          S    -        Device lib
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Command status
 !      2 Error           S    -        Error message
 !      3 Ndetail         I    -        # of lines of detail error messa
 !      4 Detail          S    10       Detailed error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Rev_flag                                ! V1
   DIM Brk_chr$[255]                               ! V2
   DIM Waf_dir$[255]                               ! V3
   DIM Prb_dir$[255]                               ! V4
   DIM Die_dir$[255]                               ! V5
   DIM Tst_dir$[255]                               ! V6
   DIM Mod_dir$[255]                               ! V7
   DIM Tpl_dir$[255]                               ! V8
   DIM Waf$[255]                                   ! V9
   DIM Prb$[255]                                   ! V10
   DIM Die$(1:256)[255]                            ! V11
   DIM Tst$(1:256)[255]                            ! V12
   DIM Mod$(1:256)[255]                            ! V13
   DIM Tpl$[255]                                   ! V14
   DIM Meas$(1:256)[255]                           ! V15
   DIM Tester$[255]                                ! V16
   DIM Prober$[255]                                ! V17
   DIM Utility$[255]                               ! V18
   DIM Device$[255]                                ! V19
   Rev_flag=V1
   Brk_chr$=V2$
   Waf_dir$=V3$
   Prb_dir$=V4$
   Die_dir$=V5$
   Tst_dir$=V6$
   Mod_dir$=V7$
   Tpl_dir$=V8$
   Waf$=V9$
   Prb$=V10$
   MAT Die$= V11$
   MAT Tst$= V12$
   MAT Mod$= V13$
   Tpl$=V14$
   MAT Meas$= V15$
   Tester$=V16$
   Prober$=V17$
   Utility$=V18$
   Device$=V19$
 !***** DON'T REMOVE THIS LINE *************************************
   DIM Cmd$[256],Opt$[4096],Err$[256]
   DIM Optdie$[4096],Optdt$[4096],Mopt$[4096]
   DIM Fulltpl$[512]
   DIM W$[256],P$[256],D$[256],T$[256],Tp$[256]
   DIM Wd$[256],Pd$[256],Dd$[256],Td$[256]
   INTEGER I,J,Stat
   INTEGER Dietst_num,Mod_num,Meas_num
     !
   ON ERROR GOTO Basic_syserr
   Dietst_num=SIZE(Die$,1)
   Mod_num=SIZE(Mod$,1)
   Meas_num=SIZE(Meas$,1)
   ALLOCATE INTEGER Tstflg(Dietst_num)
     !
   CALL Fa_chk_files(Rev_flag,Waf_dir$,Waf$,"waf",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-11
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Prb_dir$,Prb$,"prb",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-12
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Tpl_dir$,Tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-3 THEN GOTO File_check_err
   W$=Waf$
   P$=Prb$
   Tp$=Tpl$
   IF POS(W$,Brk_chr$)>0 THEN W$=Waf$[1,POS(Waf$,Brk_chr$)-1]
   IF POS(P$,Brk_chr$)>0 THEN P$=Prb$[1,POS(Prb$,Brk_chr$)-1]
   IF POS(Tp$,Brk_chr$)>0 THEN Tp$=Tpl$[1,POS(Tpl$,Brk_chr$)-1]
   Wd$=Waf_dir$
   Pd$=Prb_dir$
   Dd$=Die_dir$
   Td$=Tst_dir$
   IF Wd$[LEN(Wd$)]<>"/" THEN Wd$=Wd$&"/"
   IF Pd$[LEN(Pd$)]<>"/" THEN Pd$=Pd$&"/"
   IF Dd$[LEN(Dd$)]<>"/" THEN Dd$=Dd$&"/"
   IF Td$[LEN(Td$)]<>"/" THEN Td$=Td$&"/"
     !
   Cmd$="/opt/SPECS/sys/bin/tplbuild"
   Opt$=" -waf "&Wd$&W$&" -prb "&Pd$&P$
   Mopt$=""
   FOR I=1 TO Mod_num
     IF Mod$(I)="" THEN 
       GOTO Modloopexit
     END IF
     CALL Fa_chk_files(Rev_flag,Mod_dir$,Mod$(I),"mod",Brk_chr$,Stat)
     IF Stat<-1 THEN 
       Status=-15
       GOTO Filecheck_err2
     END IF
     Mopt$=Mopt$&" -mod "
     Mopt$=Mopt$&Mod$(I)
   NEXT I
 Modloopexit:       !
   FOR I=1 TO Meas_num
     IF Meas$(I)="" THEN 
       GOTO Measloopexit
     END IF
     IF I=1 THEN 
       Mopt$=Mopt$&" -m "&Meas$(I)
     ELSE
       Mopt$=Mopt$&","&Meas$(I)
     END IF
   NEXT I
 Measloopexit:      !
   IF Tester$<>"" THEN 
     Mopt$=Mopt$&" -t "&Tester$
   END IF
   IF Prober$<>"" THEN 
     Mopt$=Mopt$&" -p "&Prober$
   END IF
   IF Utility$<>"" THEN 
     Mopt$=Mopt$&" -u "&Utility$
   END IF
   IF Device$<>"" THEN 
     Mopt$=Mopt$&" -dvl "&Device$
   END IF
   MAT Tstflg= (1)
   Optdie$=""
   Optdt$=""
   FOR I=1 TO Dietst_num
     IF Die$(I)<>"" AND Tst$(I)<>"" AND Tstflg(I)=1 THEN 
       CALL Fa_chk_files(Rev_flag,Die_dir$,Die$(I),"die",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-13
         GOTO File_check_err2
       END IF
       CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(I),"tst",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-14
         GOTO File_check_err2
       END IF
       D$=Die$(I)
       T$=Tst$(I)
       IF POS(D$,Brk_chr$)>0 THEN D$=Die$(I)[1,POS(Die$(I),Brk_chr$)-1]
       IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(I)[1,POS(Tst$(I),Brk_chr$)-1]
       Optdie$=Optdie$&" -die "&Dd$&D$
       Optdt$=Optdt$&" -tst "&Dd$&D$&" "&Td$&T$
       IF I<Dietst_num THEN 
         FOR J=I+1 TO Dietst_num
           IF Die$(I)=Die$(J) AND Tstflg(J)=1 THEN 
             CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(J),"tst",Brk_chr$,Stat)
             IF Stat<-1 THEN 
               Status=-14
               GOTO File_check_err
             END IF
             T$=Tst$(J)
             IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(J)[1,POS(Tst$(J),Brk_chr$)-1]
             Optdt$=Optdt$&","&Td$&T$
             Tstflg(J)=0
           END IF
         NEXT J
       END IF
     END IF
   NEXT I
   Err$="/usr/tmp/tplbld.err"
   Fulltpl$=Tpl_dir$
   IF Tpl_dir$[LEN(Tpl_dir$)]<>"/" THEN Fulltpl$=Fulltpl$&"/"
   Fulltpl$=Fulltpl$&Tp$
   IF POS(Fulltpl$,".tpl")=0 THEN Fulltpl$=Fulltpl$&".tpl"
   EXECUTE Cmd$&Mopt$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$;RETURN Stat
    !!PRINT Cmd$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO E
     Error$="ERROR"
     ENTER @E;Error$
     Ndetail=0
     LOOP
       ENTER @E;Detail$(Ndetail+1)
       Ndetail=Ndetail+1
     END LOOP
 E:  ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
   PURGE Err$
   DEALLOCATE Tstflg(*)
   SUBEXIT
 File_check_err:     !
   Status=-1
 File_check_err2:     !
   Error$="File_check_error "&VAL$(Stat)
   DEALLOCATE Tstflg(*)
   SUBEXIT
 Basic_syserr:     !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
   DEALLOCATE Tstflg(*)
 SUBEND
 Fa_tplfmt:SUB Fa_tplfmt(INTEGER Rev_flag,Brk_chr$,Src_tpl_dir$,Script_dir$,Dst_tpl_dir$,Src_tpl$,Script$,Dst_tpl$,INTEGER Status,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_TPLFMT
 !  Vers : 1
 !  Desc : This algorithm alters Test Plan according to conditions s
 !       : pecified by external file.
 !  Date : 03/24/2011
 !  Time : 14:59:49
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Rev_flag        I    -        0:Revision Control not available
 !      2 Brk_chr         S    -        Connection char between filename
 !      3 Src_tpl_dir     S    -        Temporary file directory
 !      4 Script_dir      S    -        Script file directory
 !      5 Dst_tpl_dir     S    -        New Testplan file directory
 !      6 Src_tpl         S    -        Temporay Testplan File to read
 !      7 Script          S    -        Specified script file
 !      8 Dst_tpl         S    -        Generated Testplan File to write
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        Command status
 !      2 Error           S    -        Error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Stat
   DIM Cmd$[256],Err$[256]
   DIM Old$[512],New$[512],Scr$[512]
   DIM Src$[256],Dst$[256]
   DIM Fmtscr$[256]
  !
   ON ERROR GOTO Basic_syserr
  !
   Cmd$="/opt/SPECS/sys/bin/tplformat"
   Err$="/usr/tmp/tplfmt.err"
  !
   CALL Fa_chk_files(Rev_flag,Src_tpl_dir$,Src_tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-1 THEN GOTO File_check_err
  !    CALL Fa_chk_files(Rev_flag,Dst_tpl_dir$,Dst_tpl$,"tpl",Brk_chr$,Stat)
  !    IF Stat<-3 THEN GOTO File_check_err
   Src$=Src_tpl$
   Dst$=Dst_tpl$
   IF POS(Src$,Brk_chr$)>0 THEN Src$=Src_tpl$[1,POS(Src_tpl$,Brk_chr$)-1]
   IF POS(Dst$,Brk_chr$)>0 THEN Dst$=Dst_tpl$[1,POS(Dst_tpl$,Brk_chr$)-1]
   IF POS(Src$,".tpl")=0 THEN Src$=Src$&".tpl"
   IF POS(Dst$,".tpl")=0 THEN Dst$=Dst$&".tpl"
   Old$=Src_tpl_dir$&"/"&Src$
   New$=Dst_tpl_dir$&"/"&Dst$
   Scr$=Script_dir$&"/"&Script$
   IF Src_tpl_dir$[LEN(Src_tpl_dir$)]="/" THEN Old$=Src_tpl_dir$&Src$
   IF Dst_tpl_dir$[LEN(Dst_tpl_dir$)]="/" THEN New$=Dst_tpl_dir$&Dst$
   IF Script_dir$[LEN(Script_dir$)]="/" THEN Scr$=Script_dir$&Script$
  !
   Fmtscr$="/usr/tmp/tplscr.tmp"
   ON ERROR GOTO E
   PURGE Fmtscr$
 E:OFF ERROR 
   CREATE Fmtscr$,1
   Fa_bldscr_tpl(Scr$,Fmtscr$,Status,Error$)      !! Build format from cust's format
  !
   PRINT Fmtscr$
   EXECUTE Cmd$&" -cmd "&Fmtscr$&" "&Old$&" > "&New$&" 2> "&Err$;RETURN Stat
  !    EXECUTE Cmd$&" -cmd "&Scr$&" "&Old$&" > "&New$&" 2> "&Err$;RETURN Stat
  ! PRINT Cmd$&" -cmd "&Scr$&" "&Old$&" > "&New$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     ASSIGN @E TO Err$;FORMAT ON
     ENTER @E;Error$
     ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
  !
   PURGE Err$
   SUBEXIT
  !
 File_check_err: !
   Status=-1
   Error$="File_check_error "&VAL$(Stat)
   SUBEXIT
 Basic_syserr: !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
 SUBEND
 Fa_upd_vgemlvar:SUB Fa_upd_vgemlvar(INTEGER Sendceid,Varname$,INTEGER Varnum,Vardata$(*),INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_UPD_VGEMLVAR
 !  Vers : 1
 !  Desc : Update VGEM list type variable
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 SendCEID        I    -        CEID to Host
 !      2 VarName         S    -        Variable Name to update
 !      3 VarNum          I    -        Num of Data
 !      4 VarData         S    32       New Data List(MAX 32 elements)
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        GEM Reply
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Ceid$[256],Num$[256]
   DIM Ptr$(32)[256]
   INTEGER I
   IF Sendceid<0 THEN 
     Status=-1
     SUBEXIT
   END IF
   Ceid$=VAL$(Sendceid)
   IF Varnum<0 OR Varnum>32 THEN 
     Status=-1
     SUBEXIT
   END IF
   Num$=VAL$(Varnum)
   IF Varname$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   IF SIZE(Vardata$,1)<Varnum THEN 
     Status=-1
     SUBEXIT
   END IF
   FOR I=1 TO 32
     Ptr$(I)=""
   NEXT I
   FOR I=1 TO Varnum
     Ptr$(I)=Vardata$(I)
   NEXT I
   Fa_updlistvar(Ceid$,Varname$,Num$,Ptr$(*),Status)
 SUBEND
 Fa_upd_vgemvar:SUB Fa_upd_vgemvar(INTEGER Sendceid,Varname$,Vardata$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_UPD_VGEMVAR
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 SendCEID        I    -        CEID to Host
 !      2 VarName         S    -        Variable Name to update
 !      3 VarData         S    -        New Data
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        GEM Reply
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Ceid$[256]
   IF Sendceid<0 THEN 
     Status=-1
     SUBEXIT
   END IF
   Ceid$=VAL$(Sendceid)
   IF Varname$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   IF Vardata$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   Fa_updvar(Ceid$,Varname$,Vardata$,Status)
 SUBEND
 Fa_update_card:SUB Fa_update_card(Cardpath$,Cardname$,REAL Totalcount,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_UPDATE_CARD
 !  Vers : 1
 !  Desc : FA: Update probecard touchdown counts
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 CardPath        S    -        Card File Directory
 !      2 CardName        S    -        Card File Name
 !      3 TotalCount      R    -        Total Touchdown Count
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0:OK -1:Error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Cardfile$[255]
   DIM A$[255]
   DIM Revision$[255],Date$[255]
   REAL Limitcount
  !
   Cardfile$=Cardpath$&"/"&Cardname$
  !
   ON ERROR GOTO Update_card_end
   ASSIGN @File TO Cardfile$
  !
   ENTER @File USING "#,K";Revision$
   ENTER @File USING "#,K";A$
   ENTER @File USING "#,K";Limitcount
   ENTER @File USING "#,K";Date$
   ASSIGN @File TO *
  !
   EXECUTE "rm "&Cardfile$
   EXECUTE "touch "&Cardfile$
  !
   ASSIGN @File TO Cardfile$
   OUTPUT @File USING "-,K";Revision$
   OUTPUT @File USING "-,K";Totalcount
   OUTPUT @File USING "-,K";Limitcount
   OUTPUT @File USING "-,K";Date$
  !
   Status=0
   SUBEXIT
 Update_card_end:    !
   ASSIGN @File TO *
   OFF ERROR 
   Status=-1
 SUBEND
 Fa_waferdump:SUB Fa_waferdump(Dir$,File$,INTEGER Slot,Adtfmt$,Session$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_WAFERDUMP
 !  Vers : 1
 !  Desc : This algorithm generates adtfile to a current wafer.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Dir             S    -        Data Directory
 !      2 File            S    -        File Directory
 !      3 Slot            I    -        SlotNumber
 !      4 Adtfmt          S    -        Adt Format
 !      5 Session         S    -        SessionID
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0:OK -1:Error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Outputdir$[255]
   DIM Outputfile$[255]
   DIM Err$[255]
   DIM Adt$[1]
   DIM Cmd$[255]
   INTEGER Exist,Read,Write,Exec
   INTEGER I
   INTEGER Stat
  !
   Cmd$="/opt/SPECS/sys/bin/datadump"
   Err$="/tmp/tplbld.err"
   Status=0                              !! Mar.02/01
  !
  !* Check the adt format *!
   SELECT Adtfmt$
   CASE "adt"
     Adt$="2"
   CASE "ad2"
     Adt$="3"
   CASE "ad3"
     Adt$="4"
   CASE "ad5"
     Adt$="5"
   CASE "1"
     Adt$=Adtfmt$
     Adtfmt$="adt"
   CASE "2"
     Adt$=Adtfmt$
     Adtfmt$="adt"
   CASE "3"
     Adt$=Adtfmt$
     Adtfmt$="ad2"
   CASE "4"
     Adt$=Adtfmt$
     Adtfmt$="ad3"
   CASE "5"
     Adt$=Adtfmt$
     Adtfmt$="ad5"
   CASE ELSE
     Status=-1
   END SELECT
   IF Status=-1 THEN SUBEXIT
  !
  !* Verify Directory *!
   Outputdir$=Dir$&"/"&File$
   CALL Verify_file(Outputdir$,"Directory",Exist,Read,Write,Exec)
   IF Exist=0 THEN 
     EXECUTE "mkdir "&Outputdir$&" 2> "&Err$;RETURN Stat
     IF Stat THEN Status=-1
   ELSE
     IF Write<>1 AND Exec<>1 THEN Status=-1
   END IF
   IF Status=-1 THEN SUBEXIT
  !
  !* Verify File *!
   I=1
   LOOP
     IF I=1 THEN 
       Outputfile$=Outputdir$&"/"&VAL$(Slot)&"."&Adtfmt$
     ELSE
       Outputfile$=Outputdir$&"/"&VAL$(Slot)&"#"&VAL$(I)&"."&Adtfmt$
     END IF
     CALL Verify_file(Outputfile$,"Normal",Exist,Read,Write,Exec)
     IF Exist<1 THEN 
       Status=0
     ELSE
       Status=-1
       I=I+1
     END IF
   EXIT IF I>99 OR Status=0
   END LOOP
  !
   IF Status=0 THEN 
     EXECUTE Cmd$&" -"&Session$&" -"&Adt$&" > "&Outputfile$&" 2> "&Err$;RETURN Stat
     IF Stat THEN Status=-1
   END IF
  !
  !
 SUBEND
 Fa_wait:SUB Fa_wait(REAL Wait)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FA_WAIT
 !  Vers : 1
 !  Desc : Waits for the speicifed duration
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Wait            R    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   WAIT Wait
 SUBEND
 File_exist:SUB File_exist(Filename$,Status$,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FILE_EXIST
 !  Vers : 1
 !  Desc : Check file exists or not
 !  Date : 03/05/2002
 !  Time : 21:30:23
 !  User : joy
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Filename        S    -        Filename for check
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          S    -        "OK" or "ERROR"
 !      2 Error           S    -        Error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                 !***** DON'T REMOVE THIS LINE *****
   ON ERROR GOTO Not_exist
   ASSIGN @File TO Filename$
   OFF ERROR 
   Status$="OK"
   Error$=""
   SUBEXIT
 Not_exist:OFF ERROR 
   PRINT Filename$&" doesn't exist."
   Status$="ERROR"
   Error$="FILE"
 SUBEND
 File_hwconfig:SUB File_hwconfig(File$,Config$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FILE_HWCONFIG
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 File            S    -
 !      2 Config          S    50
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER I,Valid
   DIM Tmpfile$[255]
  !
   Tmpfile$=File$&".tmp"
  !
   ON ERROR GOTO Nofile_file
   PURGE File$
   GOTO Noerr_file
 Nofile_file: !
   IF ERRN<>56 THEN 
     PRINT "FILE_HWCONFIG: PURGE "&File$&" causes "&ERRM$
     SUBEXIT
   END IF
 Noerr_file: !
  !
   ON ERROR GOTO Nofile_tmp
   PURGE Tmpfile$
   GOTO Noerr_tmp
 Nofile_tmp: !
   IF ERRN<>56 THEN 
     PRINT "FILE_HWCONFIG: PURGE "&Tmpfile$&" causes "&ERRM$
     SUBEXIT
   END IF
 Noerr_tmp: !
  !
   Valid=0
   FOR I=50 TO 1 STEP -1
     IF LEN(Config$(I))>0 THEN 
       Valid=I
       GOTO Make
     END IF
   NEXT I
  !
 Make: !
   ON ERROR GOTO Err
   CREATE Tmpfile$,1
   ASSIGN @File TO Tmpfile$
   FOR I=1 TO Valid
     OUTPUT @File;Config$(I)&CHR$(10)
   NEXT I
   ASSIGN @File TO *
  !
   EXECUTE "/usr/bin/col -bx < "&Tmpfile$&" > "&File$
   PURGE Tmpfile$
   SUBEXIT
  !
 Err: !
   PRINTER IS CRT
   PRINT "FILE_HWCONFIG: "&ERRM$
 SUBEND
 File_lookup:SUB File_lookup(Dir$,Suffix$,Files$(*),INTEGER Count,Depth)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FILE_LOOKUP
 !  Vers : 1
 !  Desc : Searches for and returns all the file names (in all direc
 !       : tories under a specified directory) that have a specified
 !       :  suffix
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Dir             S    -        Search directory name
 !      2 Suffix          S    -        Suffix
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Files           S    1024     Found files
 !      2 Count           I    -        Number of found files
 !      3 Depth           I    -        Max directory depth + 1
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Script$[255],Buf$[255]
   INTEGER N
   Script$="/var/tmp/dirlook."&SYSTEM$("PROCESS ID")    ! AVPATH_
   ON ERROR GOTO Create
   PURGE Script$
 Create:OFF ERROR 
  !
   ON ERROR GOTO Error
   CREATE Script$,1
   ASSIGN @Script TO Script$
   IF LEN(Suffix$) THEN 
     OUTPUT @Script;"cd "&Dir$&"; find . -name '*."&Suffix$&"' | awk -F '/' '{ print NF - 1 }' | sort -n | uniq | tail -1"&CHR$(10)
     OUTPUT @Script;"cd "&Dir$&"; find . -name '*."&Suffix$&"' | sed -e 's=^./==' -e 's/."&Suffix$&"$//'"&CHR$(10)
   ELSE
     OUTPUT @Script;"cd "&Dir$&"; find . | awk -F '/' '{ print NF - 1 }' | sort -n | uniq | tail -1"&CHR$(10)
     OUTPUT @Script;"cd "&Dir$&"; find . | sed -e 's=^./=='"&CHR$(10)
   END IF
   ASSIGN @Script TO *
   ASSIGN @Pipe TO "sh < "&Script$&" |"
   ON END @Pipe GOTO Eof
   ENTER @Pipe;Depth
   N=0
   LOOP
     ENTER @Pipe;Buf$
     IF LEN(Buf$) THEN 
       IF N<1024 THEN 
         Files$(N+1)=Buf$
       END IF
       N=N+1
     END IF
   END LOOP
 Eof:ASSIGN @Pipe TO *
   Count=N
   PURGE Script$
   SUBEXIT
 Error:OFF ERROR 
   Count=0
   Depth=0
   SUBEXIT
 SUBEND
 Format_path:SUB Format_path(Original$,Path$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : FORMAT_PATH
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Original        S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Path            S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Pos,Head,Length
  !
   Original$=TRIM$(Original$)
   Path$=""
   Length=LEN(Original$)
   IF Length=0 THEN 
     Path$="/"
     SUBEXIT
   END IF
  !
   Head=1
   REPEAT
     Pos=POS(Original$[Head],"/")
     SELECT Pos
     CASE 0
       Path$=Path$&"/"&Original$[Head]
       Head=Length+1
     CASE 1
       Head=Head+1
     CASE ELSE
       Path$=Path$&"/"&Original$[Head,Head+Pos-2]
       Head=Head+Pos-1
     END SELECT
   UNTIL Head>Length
  !
   IF Path$="" THEN    ! Original$="/"
     Path$="/"
   END IF
 SUBEND
 G_cv:SUB G_cv(REAL Vstart,Vstop,Vstep,Delay,Hold,INTEGER Pins(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : G_CV
 !  Vers : 1
 !  Desc : Measures the Capacitance-Voltage characteristics (C-V cha
 !       : racteristics), and displays the measurement results on a
 !       : graph
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Vstart          R    -        Inversion voltage
 !      2 Vstop           R    -        Accumulation voltage
 !      3 Vstep           R    -        Step voltage
 !      4 Delay           R    -        Step delay time
 !      5 Hold            R    -        Hold time
 !
 !    Device Terminals:
 !      1 H               I    -
 !      2 L               I    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   REAL Freq
   INTEGER H,L,N
   H=Pins(1)
   L=Pins(2)
   N=ABS((Vstop-Vstart)/Vstep)+1
   ALLOCATE REAL C(N),G(N),V(N)
  !
   Connect(FNCmh,H)
   Connect(FNCml,L)
   Set_cv84(Vstart,Vstop,N,Hold,Delay)               ! freq is default (1MHz)
   Sweep_cv84(0,C(*),G(*),V(*))
   Connect(FNCmh,0)
   Connect(FNCml,0)
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=Vstart
   Xmax=Vstop
   Ymin=MIN(C(*))
   Ymax=MAX(C(*))
   Lingraph1(Xmin,Xmax,Ymin,Ymax,"Bias [V]","Cap [F]","C-V")
   PEN 1
   MOVE Vstart,C(1)
   FOR I=2 TO N
     V1=Vstart+Vstep*(I-1)
     DRAW V1,C(I)
   NEXT I
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE C(*),G(*),V(*)
 Error:OFF ERROR 
 SUBEND
 G_hfe:SUB G_hfe(REAL Ibestart,Ibestop,INTEGER Ibestep,REAL Vce,INTEGER Pins(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : G_HFE
 !  Vers : 1
 !  Desc : Measures the bipolar transistor Collector Current-hFE cha
 !       : racteristics (Ic-hFE characteristics), and displays the m
 !       : easurement results on a graph
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Ibestart        R    -        Base start current
 !      2 Ibestop         R    -        Base stop current
 !      3 Ibestep         I    -        Base number of steps
 !      4 Vce             R    -        Collector voltage
 !
 !    Device Terminals:
 !      1 E               I    -
 !      2 B               I    -
 !      3 C               I    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   INTEGER Emitter,Base,Collector
   INTEGER N1,N2
   Emitter=Pins(1)
   Base=Pins(2)
   Collector=Pins(3)
   N1=Ibestep
   ALLOCATE REAL Ib(N1),Ic(N1),V(N1),Hfe(N1),Absib(N1),Absic(N1)
  !
   Connect(FNGnd,Emitter)
   Connect(FNSmu(1),Base)
   Connect(FNSmu(2),Collector)
   Force_v(Collector,Vce,20,.1)
   Set_iv(Base,-2,ABS(MAX(Ibestart,Ibestop)),Ibestart,Ibestop,N1,0,0,20)               ! Log
   Sweep_iv(Collector,2,0,Ic(*),Ib(*))
   Disable_port(Collector)
   Disable_port(Base)
   Connect(FNSmu(1),0)
   Connect(FNSmu(2),0)
   Connect(FNGnd,0)
  !
   Icsum=0
   FOR I1=1 TO N1
     Icsum=Ic(I1)+Icsum
   NEXT I1
   IF Icsum>0 THEN 
     Sign=1
   ELSE
     Sign=-1
   END IF
   FOR I1=1 TO N1
     IF Ib(I1)=0 THEN Ib(I1)=Sign*1.E-15
     IF Ic(I1)=0 THEN Ic(I1)=Sign*1.E-15
   NEXT I1
   MAT Absib= ABS(Ib)
   MAT Absic= ABS(Ic)
   MAT Hfe= Absic/Absib
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=MAX(MIN(Absic(*)),1.E-15)*Sign
   Xmax=MAX(MAX(Absic(*)),1.E-14)*Sign*2
   Ymin=MAX(MIN(Hfe(*)),1.E-15)
   Ymax=MAX(MAX(Hfe(*)),1.E-14)*2
   Loggraph1(Xmin,Xmax,Ymin,Ymax,"Ic [A]","hFE","hFE",3)
  !
   PEN 1
   MOVE LGT(Absic(1))*Sign,LGT(Hfe(1))
   FOR I1=2 TO N1
     DRAW LGT(Absic(I1))*Sign,LGT(Hfe(I1))
   NEXT I1
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE Ib(*),Ic(*),V(*),Hfe(*),Absib(*),Absic(*)
 Error:OFF ERROR 
 SUBEND
 G_icvb:SUB G_icvb(REAL Vbestart,Vbestop,Vbestep,INTEGER Pins(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : G_ICVB
 !  Vers : 1
 !  Desc : Measures the bipolar transistor Collector Current-Base Vo
 !       : ltage characteristics (Ic-Vb characteristics), and displa
 !       : ys the measurement results on a graph
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Vbestart        R    -        Base start voltage
 !      2 Vbestop         R    -        Base stop voltage
 !      3 Vbestep         R    -        Base step voltage
 !
 !    Device Terminals:
 !      1 E               I    -
 !      2 B               I    -
 !      3 C               I    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   INTEGER Emitter,Base,Collector
   INTEGER N1,N2,Ports(2)
   REAL Ranges(2)
   Emitter=Pins(1)
   Base=Pins(2)
   Collector=Pins(3)
   N1=ABS((Vbestop-Vbestart)/Vbestep)+1
   ALLOCATE REAL Ib(N1),Ic(N1),V(N1),Absib(N1),Absic(N1)
  !
   Connect(FNSmu(1),Emitter)
   Connect(FNSmu(2),Base)
   Connect(FNSmu(3),Collector)
   Ports(1)=Base
   Ports(2)=Collector
   Ranges(1)=0
   Ranges(2)=0
   Force_v(Collector,0,20,.1)
   Force_v(Base,0,20,.1)
   Set_iv(Emitter,1,ABS(MAX(Vbestart,Vbestop)),-Vbestart,-Vbestop,N1,0,0,.1)                      ! Lin
   Sweep_miv(Ports(*),Ranges(*),Ib(*),Ic(*))                               ! Im
   Disable_port(Base)
   Connect(FNSmu(1),0)
   Connect(FNSmu(2),0)
   Connect(FNSmu(3),0)
  !
   Ibsum=0
   Icsum=0
   FOR I1=1 TO N1
     Ibsum=Ib(I1)+Ibsum
     Icsum=Ic(I1)+Icsum
   NEXT I1
   IF Ibsum+Icsum>0 THEN 
     Sign=1
   ELSE
     Sign=-1
   END IF
   FOR I1=1 TO N1
     IF Ib(I1)=0 THEN Ib(I1)=Sign*1.E-15
     IF Ic(I1)=0 THEN Ic(I1)=Sign*1.E-15
   NEXT I1
   MAT Absib= ABS(Ib)
   MAT Absic= ABS(Ic)
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=Vbestart
   Xmax=Vbestop
   Ymin=MAX(MIN(MIN(Absib(*)),MIN(Absic(*))),1.E-15)*Sign
   Ymax=MAX(MAX(MAX(Absib(*)),MAX(Absic(*))),1.E-14)*Sign
   Loggraph1(Xmin,Xmax,Ymin,Ymax,"Vb [V]","Ic/Ib [A]","Vb - Ic/Ib")
   PEN 1
   MOVE Vbestart,LGT(Absib(1))*Sign
   FOR I1=2 TO N1
     V1=Vbestart+Vbestep*(I1-1)
     DRAW V1,LGT(Absib(I1))*Sign
   NEXT I1
   PEN 2
   MOVE Vbestart,LGT(Absic(1))*Sign
   FOR I1=2 TO N1
     V1=Vbestart+Vbestep*(I1-1)
     DRAW V1,LGT(Absic(I1))*Sign
   NEXT I1
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE Ib(*),Ic(*),V(*),Absib(*),Absic(*)
 Error:OFF ERROR 
 SUBEND
 G_icvc:SUB G_icvc(REAL Vcestart,Vcestop,Vcestep,Ibstart,Ibstop,Ibstep,INTEGER Pins(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : G_ICVC
 !  Vers : 1
 !  Desc : Measures the bipolar transistor Collector Current-Collect
 !       : or Voltage characteristics (Ic-Vc characteristics), and d
 !       : isplays the measurement results on a graph
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Vcestart        R    -        Collector start voltage
 !      2 Vcestop         R    -        Collector stop voltage
 !      3 Vcestep         R    -        Collector step voltage
 !      4 Ibstart         R    -        Base start current
 !      5 Ibstop          R    -        Base stop current
 !      6 Ibstep          R    -        Base step current
 !
 !    Device Terminals:
 !      1 E               I    -
 !      2 B               I    -
 !      3 C               I    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   INTEGER Emitter,Base,Collector
   INTEGER N1,N2
   Emitter=Pins(1)
   Base=Pins(2)
   Collector=Pins(3)
   N1=ABS((Vcestop-Vcestart)/Vcestep)+1
   N2=ABS((Ibstop-Ibstart)/Ibstep)+1
   ALLOCATE REAL Ic(N2,N1),Im(N1),V(N1)
  !
   Connect(FNSmu(1),Emitter)
   Connect(FNSmu(2),Base)
   Connect(FNSmu(3),Collector)
   Force_v(Emitter,0,20,.1)
   FOR I2=1 TO N2
     V2=Ibstart+Ibstep*(I2-1)
     Force_i(Base,V2,V2,20)
     Set_iv(Collector,1,ABS(MAX(Vcestart,Vcestop)),Vcestart,Vcestop,N1,0,0,.1)               ! Lin
     Sweep_iv(Collector,2,0,Im(*),V(*))
     MAT Ic(I2,*)= Im
   NEXT I2
   Disable_port(Collector)
   Disable_port(Base)
   Connect(FNSmu(1),0)
   Connect(FNSmu(2),0)
   Connect(FNSmu(3),0)
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=Vcestart
   Xmax=Vcestop
   Ymin=MIN(Ic(*))
   Ymax=MAX(Ic(*))
   Lingraph1(Xmin,Xmax,Ymin,Ymax,"Vc [V]","Ic [A]","Vc - Ic")
   PEN 1
   FOR I2=1 TO N2
     MOVE Vcestart,Ic(I2,1)
     FOR I1=2 TO N1
       V1=Vcestart+Vcestep*(I1-1)
       DRAW V1,Ic(I2,I1)
     NEXT I1
   NEXT I2
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE Ic(*),Im(*),V(*)
 Error:OFF ERROR 
 SUBEND
 G_idvd:SUB G_idvd(REAL Vdstart,Vdstop,Vdstep,Vgstart,Vgstop,Vgstep,INTEGER Pins(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : G_IDVD
 !  Vers : 1
 !  Desc : Measures the MOSFET Drain Current-Drain Voltage character
 !       : istics (Id-Vd characteristics), and displays the measurem
 !       : ent results on a graph
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Vdstart         R    -        Drain start voltage
 !      2 Vdstop          R    -        Drain stop voltage
 !      3 Vdstep          R    -        Drain step voltage
 !      4 Vgstart         R    -        Gate start voltage
 !      5 Vgstop          R    -        Gate stop voltage
 !      6 Vgstep          R    -        Gate step voltage
 !
 !    Device Terminals:
 !      1 S               I    -
 !      2 G               I    -        Gate terminal
 !      3 D               I    -        Drain terminal
 !      4 Sub             I    -        Substrate terminal
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   INTEGER Source,Gate,Drain,Substrate
   INTEGER N1,N2
   Source=Pins(1)
   Gate=Pins(2)
   Drain=Pins(3)
   Substrate=Pins(4)
   N1=ABS((Vdstop-Vdstart)/Vdstep)+1
   N2=ABS((Vgstop-Vgstart)/Vgstep)+1
   ALLOCATE REAL Id(N2,N1),Im(N1),V(N1)
  !
   Connect(FNSmu(1),Drain)
   Connect(FNGnd,Source)
   Connect(FNSmu(3),Gate)
   Connect(FNSmu(4),Substrate)
   IF Substrate THEN 
     Force_v(Substrate,0,0,.1)
   END IF
   FOR I2=1 TO N2
     V2=Vgstart+Vgstep*(I2-1)
     Force_v(Gate,V2,V2,.1)
     Set_iv(Drain,1,ABS(MAX(Vdstart,Vdstop)),Vdstart,Vdstop,N1,0,0,.1)
     Sweep_iv(Drain,2,0,Im(*),V(*))
     MAT Id(I2,*)= Im
   NEXT I2
   Disable_port(Drain)
   Disable_port(Gate)
   Connect(FNSmu(1),0)
   Connect(FNGnd,0)
   Connect(FNSmu(3),0)
   Connect(FNSmu(4),0)
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=Vdstart
   Xmax=Vdstop
   Ymin=MIN(Id(*))
   Ymax=MAX(Id(*))
   Lingraph1(Xmin,Xmax,Ymin,Ymax,"Vd [V]","Id [A]","Vd - Id")
   PEN 1
   FOR I2=1 TO N2
     MOVE Vdstart,Id(I2,1)
     FOR I1=2 TO N1
       V1=Vdstart+Vdstep*(I1-1)
       DRAW V1,Id(I2,I1)
     NEXT I1
   NEXT I2
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE Id(*),Im(*),V(*)
 Error:OFF ERROR 
 SUBEND
 G_idvg:SUB G_idvg(REAL Vgstart,Vgstop,Vgstep,Vsubstart,Vsubstop,Vsubstep,Vd,INTEGER Pins(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : G_IDVG
 !  Vers : 1
 !  Desc : Measures the MOSFET Drain Current-Gate Voltage characteri
 !       : stics (Id-Vg characteristics), and displays the measureme
 !       : nt results on a graph
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Vgstart         R    -        Gate start voltage
 !      2 Vgstop          R    -        Gate stop voltage
 !      3 Vgstep          R    -        Gate step voltage
 !      4 Vsubstart       R    -        Substrate start voltage
 !      5 Vsubstop        R    -        Substrate stop voltage
 !      6 Vsubstep        R    -        Substrate step voltage
 !      7 Vd              R    -        Drain voltage
 !
 !    Device Terminals:
 !      1 S               I    -
 !      2 G               I    -        Gate terminal
 !      3 D               I    -        Drain terminal
 !      4 Sub             I    -        Substrate terminal
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   INTEGER Source,Gate,Drain,Substrate
   INTEGER N1,N2
   Source=Pins(1)
   Gate=Pins(2)
   Drain=Pins(3)
   Substrate=Pins(4)
   N1=ABS((Vgstop-Vgstart)/Vgstep)+1
   N2=ABS((Vsubstop-Vsubstart)/Vsubstep)+1
   ALLOCATE REAL Id(N2,N1),Im(N1),V(N1)
  !
   Connect(FNSmu(1),Drain)
   Connect(FNGnd,Source)
   Connect(FNSmu(3),Gate)
   Connect(FNSmu(4),Substrate)
   Force_v(Drain,Vd,Vd,.1)
   Force_v(Gate,0,20,.1)
   FOR I2=1 TO N2
     V2=Vsubstart+Vsubstep*(I2-1)
     IF Substrate THEN 
       Force_v(Substrate,V2,V2,.1)
     END IF
     Set_iv(Gate,1,ABS(MAX(Vgstart,Vgstop)),Vgstart,Vgstop,N1,0,0,.1)                ! Lin
     Sweep_iv(Drain,2,0,Im(*),V(*))
     MAT Id(I2,*)= Im
   NEXT I2
   Disable_port(Drain)
   Disable_port(Gate)
   IF Substrate THEN 
     Disable_port(Substrate)
   END IF
   Connect(FNSmu(1),0)
   Connect(FNGnd,0)
   Connect(FNSmu(3),0)
   Connect(FNSmu(4),0)
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=Vgstart
   Xmax=Vgstop
   Ymin=MIN(Id(*))
   Ymax=MAX(Id(*))
   Lingraph1(Xmin,Xmax,Ymin,Ymax,"Vg [V]","Id [A]","Vg - Id")
   PEN 1
   FOR I2=1 TO N2
     MOVE Vgstart,Id(I2,1)
     FOR I1=2 TO N1
       V1=Vgstart+Vgstep*(I1-1)
       DRAW V1,Id(I2,I1)
     NEXT I1
   NEXT I2
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE Id(*),Im(*),V(*)
 Error:OFF ERROR 
 SUBEND
 Gem_getcmd:SUB Gem_getcmd(Cmd$,Rply$,Parms$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GEM_GETCMD
 !  Vers : 1
 !  Desc : Get all of commands for using this algorirthm.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Cmd             S    -        Command
 !      2 Rply            S    -        Reply string
 !      3 Parms           S    500
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Fa_getcmd(Cmd$,Rply$,Parms$(*))
  !!  PRINT Cmd$
  !!  FOR I=1 TO 300
  !!    IF Parms$(I)<>"" THEN
  !!      PRINT I;Parms$(I)
  !!    END IF
  !!  NEXT I
 SUBEND
 Gem_init:SUB Gem_init(INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GEM_INIT
 !  Vers : 1
 !  Desc : Initialize GEM module
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Fa_init(Status)
 SUBEND
 Gem_respond_nok:SUB Gem_respond_nok(Replymailbox$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GEM_RESPOND_NOK
 !  Vers : 1
 !  Desc : GEM_RESPOND_NotOK:
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 ReplyMailbox    S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0:OK -1:Error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Fa_respond_nok(Replymailbox$,Status)
 SUBEND
 Gem_respond_ok:SUB Gem_respond_ok(Replymailbox$,REAL Timeout,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GEM_RESPOND_OK
 !  Vers : 1
 !  Desc : GEM_RESPOND_OK:
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 ReplyMailbox    S    -
 !      2 Timeout         R    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0:OK -1:Error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Fa_respond_ok(Replymailbox$,Timeout,Status)
 SUBEND
 Gem_sendevent:SUB Gem_sendevent(Event$,Parms$(*),INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GEM_SENDEVENT
 !  Vers : 1
 !  Desc : Send all of event for using this command.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Event           S    -        Event name
 !      2 Parms           S    500
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        GEM Reply
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   PRINT Parms$(2)
   Fa_sendevent(Event$,Parms$(*),Status)
 SUBEND
 Get_brk_mod:SUB Get_brk_mod(INTEGER Typeindex,Dieindex,Modindex,Break)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GET_BRK_MOD
 !  Vers : 1
 !  Desc : Return breakpoint flag value of specified module.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER)
 !      2 Dieindex        I    -        Die index in die type (DIE.NUMBE
 !      3 Modindex        I    -        Module index (MODULE.NUMBER)
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Break           I    -        1: Break, 0: Unbreak, -1: Error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos
  !
   Tpldietype2pos(Typeindex-1,Dieindex-1,Diepos)
  !
   Tplgetbrkmod(Diepos,Modindex-1,Break)
 SUBEND
 Get_dielabel:SUB Get_dielabel(Label$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GET_DIELABEL
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Label           S    -        Die Label
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Tmpdiepos
   CALL Tpldiepos(Tmpdiepos)
   CALL Tpldielabel(Tmpdiepos,Label$)
 SUBEND
 Get_dietype:SUB Get_dietype(Type$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GET_DIETYPE
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Type            S    -        Die type
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Tmpdiepos
   CALL Tpldiepos(Tmpdiepos)
   CALL Tpldielabel(Tmpdiepos,Type$)
  ! CALL Tpldietype(Tmpdiepos,Type$) ! 2006/02/10
 SUBEND
 Get_jdg_die:SUB Get_jdg_die(INTEGER Typeindex,Dieindex,Judge,Offsetx,Offsety)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GET_JDG_DIE
 !  Vers : 1
 !  Desc : Return judgement flag value of specified die.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER)
 !      2 Dieindex        I    -        Die index in die type (DIE.NUMBE
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Judge           I    -        Judgement value.
 !      2 Offsetx         I    -        Die X position offset.
 !      3 Offsety         I    -        Die Y position offset.
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos
  !
   Judge=-1
  !
   IF Typeindex<=0 THEN 
     SUBEXIT
   END IF
   IF Dieindex<=0 THEN 
     SUBEXIT
   END IF
  !
   Tpldietype2pos(Typeindex-1,Dieindex-1,Diepos)
   IF Diepos<0 THEN 
     SUBEXIT
   END IF
  !
   Tplgetjdgdie(Diepos,Judge,Offsetx,Offsety)
 SUBEND
 Get_loc_mod:SUB Get_loc_mod(INTEGER Typeindex,Modname$,REAL X,Y,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GET_LOC_MOD
 !  Vers : 1
 !  Desc : Return module position of specified module relative to di
 !       : e.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER).
 !      2 Modname         S    -        Module name.
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 X               R    -        X Position
 !      2 Y               R    -        Y Position
 !      3 Stat            I    -        0:No error, -1:Error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos
  !
   Stat=-1
  !
   IF Typeindex<=0 THEN 
     SUBEXIT
   END IF
   IF LEN(Modname$)<=0 THEN 
     SUBEXIT
   END IF
  !
   Tpldietype2pos(Typeindex-1,0,Diepos)
   IF Diepos<0 THEN 
     SUBEXIT
   END IF
  !
   Tplgetlocmod(Diepos,Modname$,X,Y,Stat)
 SUBEND
 Get_modlabel:SUB Get_modlabel(Label$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GET_MODLABEL
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Label           S    -        Module Label
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Tmpmodpos
   CALL Tplmodulepos(Tmpmodpos)
   CALL Tplmodulelabel(Tmpmodpos,Label$)
 SUBEND
 Get_next_mod:SUB Get_next_mod(INTEGER Typeindex_c,Diex_c,Diey_c,Modname_c$,INTEGER Typeindex,Diex,Diey,Modname$,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GET_NEXT_MOD
 !  Vers : 1
 !  Desc : Search failed module.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Typeindex_c     I    -        Current type index.
 !      2 Diex_c          I    -        Current die x.
 !      3 Diey_c          I    -        Current die y.
 !      4 Modname_c       S    -        Current module name.
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Typeindex       I    -        Next die type w/ failed module.
 !      2 Diex            I    -        Next die x w/ failed module.
 !      3 Diey            I    -        Next die y w/ failed module.
 !      4 Modname         S    -        Next failed module name.
 !      5 Stat            I    -        0:ok/-1:error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Diebegin,Dietotal,Diepos,Dieindex
   INTEGER Modtotal,Modbegin,Modindex
   INTEGER Min_in_mod,Max_in_mod,Min_in_die,Max_in_die,Outindex
   INTEGER Judge,Pass,Fail,Total
   INTEGER Duplicated
   DIM Tmpname$[33]
  !
   Stat=-1
   Typeindex_c=Typeindex_c-1  ! DIE.TYPENUMBER starts from 1 -> 0 based
   IF Typeindex_c<0 THEN 
     Diebegin=0  !default:Typeindex_c=0(Search from the beginning)
   ELSE
     Tpldiexy2pos(Typeindex_c,Diex_c,Diey_c,Diebegin)
     IF Diebegin<0 THEN 
       SUBEXIT
     END IF
   END IF
  !
   Tpldietotal(Dietotal)
   FOR Diepos=Diebegin TO Dietotal-1
     Tpldiepos2type(Diepos,Typeindex,Dieindex)
     Tpldiepos2xy(Diepos,Typeindex,Diex,Diey)
     Tplmoduletotal(Diepos,Modtotal)
  !
     Modbegin=0
     Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
     Tplmodulelabel(Min_in_mod,Modname$)
     IF Typeindex=Typeindex_c AND Diex=Diex_c AND Diey=Diey_c THEN 
       FOR Modindex=0 TO Modtotal-1
         Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
         Tplmodulelabel(Min_in_mod,Modname$)
         IF Modname$=Modname_c$ THEN 
           Modbegin=Modindex+1
           GOTO Search_begin
         END IF
       NEXT Modindex
     END IF
  !
 Search_begin:  !
     FOR Modindex=Modbegin TO Modtotal-1
       Jdg_mod_at_pos(Diepos,Modindex,0,Judge,Pass,Fail,Total)
       IF Judge=0 THEN 
         Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
         Tplmodulelabel(Min_in_mod,Modname$)
  !
         IF Typeindex=Typeindex_c OR Diex=Diex_c OR Diey=Diey_c THEN 
           Stat=0
           Typeindex=Typeindex+1
           SUBEXIT
         END IF
  !
         IF Modname$<>Modname_c$ THEN 
           Tplgetrangedie(Diepos,Min_in_die,Max_in_die)
           Duplicated=0
           FOR Outindex=Min_in_die TO Min_in_mod-1
             Tplmodulelabel(Outindex,Tmpname$)
             IF Modname$=Tmpname$ THEN 
               Duplicated=1
             END IF
           NEXT Outindex
           IF Duplicated=0 THEN 
             Stat=0
             Typeindex=Typeindex+1
             SUBEXIT
           END IF
         END IF
       END IF
     NEXT Modindex
   NEXT Diepos
   SUBEXIT
  !
 SUBEND
 Get_prev_mod:SUB Get_prev_mod(INTEGER Typeindex_c,Diex_c,Diey_c,Modname_c$,INTEGER Typeindex,Diex,Diey,Modname$,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GET_PREV_MOD
 !  Vers : 1
 !  Desc : Search failed module.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Typeindex_c     I    -        Current type index.
 !      2 Diex_c          I    -        Current die x.
 !      3 Diey_c          I    -        Current die y.
 !      4 Modname_c       S    -        Current module name.
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Typeindex       I    -        Prev die type w/ failed module.
 !      2 Diex            I    -        Prev die x w/ failed module.
 !      3 Diey            I    -        Prev die y w/ failed module.
 !      4 Modname         S    -        Prev failed module name.
 !      5 Stat            I    -        0:ok/-1:error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Diebegin,Dieindex,Diepos,Min_in_die,Max_in_die
   INTEGER Modbegin,Modindex,Modtotal,Min_in_mod,Max_in_mod
   INTEGER Outindex
   INTEGER Judge,Pass,Fail,Total
   INTEGER Duplicated
   DIM Tmpname$[33]
  !
   Stat=-1
   Typeindex_c=Typeindex_c-1
   IF Typeindex_c>=0 THEN 
     Tpldiexy2pos(Typeindex_c,Diex_c,Diey_c,Diebegin)
   ELSE
     Tpldietotal(Diebegin)
     Diebegin=Diebegin-1
   END IF
   IF Diebegin<0 THEN 
     SUBEXIT
   END IF
  !
   FOR Diepos=Diebegin TO 0 STEP -1
     Tpldiepos2type(Diepos,Typeindex,Dieindex)
     Tpldiepos2xy(Diepos,Typeindex,Diex,Diey)
     Tplmoduletotal(Diepos,Modtotal)
  !
     Modbegin=Modtotal-1
     Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
     Tplmodulelabel(Min_in_mod,Modname$)
     IF Typeindex=Typeindex_c AND Diex=Diex_c AND Diey=Diey_c THEN 
       FOR Modindex=Modtotal-1 TO 0 STEP -1
         Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
         Tplmodulelabel(Min_in_mod,Modname$)
         IF Modname$=Modname_c$ THEN 
           Modbegin=Modindex-1
           GOTO Search_begin
         END IF
       NEXT Modindex
     END IF
  !
 Search_begin:  !
     FOR Modindex=Modbegin TO 0 STEP -1
       Jdg_mod_at_pos(Diepos,Modindex,0,Judge,Pass,Fail,Total)
       IF Judge=0 THEN 
         Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
         Tplmodulelabel(Min_in_mod,Modname$)
  !
         IF Typeindex<>Typeindex_c OR Diex<>Diex_c OR Diey<>Diey_c THEN 
           Stat=0
           Typeindex=Typeindex+1
           SUBEXIT
         END IF
  !
         IF Modname$<>Modname_c$ THEN 
           Tplgetrangedie(Diepos,Min_in_die,Max_in_die)
           Duplicated=0
           FOR Outindex=Max_in_die TO Max_in_mod+1 STEP -1
             Tplmodulelabel(Outindex,Tmpname$)
             IF Tmname$=Modname$ THEN 
               Duplicated=1
             END IF
           NEXT Outindex
           IF Duplicated=0 THEN 
             Stat=0
             Typeindex=Typeindex+1
             SUBEXIT
           END IF
         END IF
       END IF
     NEXT Modindex
   NEXT Diepos
  !
 SUBEND
 Get_slot_no:SUB Get_slot_no(Lotid$,Waferid$,INTEGER Slotno)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GET_SLOT_NO
 !  Vers : 1
 !  Desc : Get slot number from lot ID and wafer ID.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Lotid           S    -
 !      2 Waferid         S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Slotno          I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Slot_num
  !
   INTEGER Index
   DIM Name$[32]
   INTEGER Type,Dim,Size1,Size2
   DIM Sys_class$[10]
  !
  ! !! initialize
   Slotno=0
   Sys_class$="SYSTEM"
  !
  ! !! total slot number
   Tpltagindex(Sys_class$,"PRB_SLOT_TOTAL_ALL",Index)
   IF Index=-1 THEN SUBEXIT
   Tplgetitag(Sys_class$,Index,0,Slot_num)
  !
  ! !! lot ID index (TST_SLOT_LOT_INDEX)
   Tpltagindex(Sys_class$,"TST_SLOT_LOT_INDEX",Index)
   IF Index=-1 THEN SUBEXIT
   Tpltaginfo(Sys_class$,Index,Name$,Type,Dim,Size1,Size2)
   ALLOCATE INTEGER Lot_index(Size1)
   Tplgetiatag(Sys_class$,Index,0,Lot_index(*))
  !
  ! !! lot ID (TST_LOT_ID)
   Tpltagindex(Sys_class$,"TST_LOT_ID",Index)
   IF Index=-1 THEN GOTO Exit_1
   Tpltaginfo(Sys_class$,Index,Name$,Type,Dim,Size1,Size2)
   ALLOCATE Lot_id$(Size1)[255]
   Tplgetsatag(Sys_class$,Index,0,Lot_id$(*))
  !
  ! !! wafer ID (TST_SLOT_WAFERID)
   Tpltagindex(Sys_class$,"TST_SLOT_WAFERID",Index)
   IF Index=-1 THEN GOTO Exit_2
   Tpltaginfo(Sys_class$,Index,Name$,Type,Dim,Size1,Size2)
   ALLOCATE Wafer_id$(Size1)[255]
   Tplgetsatag(Sys_class$,Index,0,Wafer_id$(*))
  !
  ! !! slot selection (TST_SLOT_SELECT)
   Tpltagindex(Sys_class$,"TST_SLOT_SELECT",Index)
   IF Index=-1 THEN Exit_3
   Tpltaginfo(Sys_class$,Index,Name$,Type,Dim,Size1,Size2)
   ALLOCATE INTEGER Slot_selection(Size1)
   Tplgetiatag(Sys_class$,Index,0,Slot_selection(*))
  !
  ! !! find slot number
   FOR I=1 TO Slot_num
  !
  !  skip unselect slot
     IF Slot_selection(I)<>1 THEN GOTO For_end
  !
  !  !! compare lot ID and wafer ID
     IF Lotid$=Lot_id$(Lot_index(I)) AND Waferid$=Wafer_id$(I) THEN 
       Slotno=I
       GOTO Fin
     END IF
 For_end:    !
   NEXT I
  !
 Fin:    !
   DEALLOCATE Slot_selection(*)
 Exit_3:    !
   DEALLOCATE Wafer_id$(*)
 Exit_2:    !
   DEALLOCATE Lot_id$(*)
 Exit_1:    !
   DEALLOCATE Lot_index(*)
  !
 SUBEND
 Get_vgemdefault:SUB Get_vgemdefault(Rcpmode$,Rcpfilename$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : GET_VGEMDEFAULT
 !  Vers : 1
 !  Desc : Read configuration parameter and apply them.
 !       :   SPECS2.5: Added special parameters.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Rcpmode         S    -
 !      2 Rcpfilename     S    -
 !      3 Status          I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Line$[256],Symbol$[256],Value$[256],Token$[256],Name$[32],Src$[256]
   DIM Subsymbol$[256]
   INTEGER P_col,P_exc,P_comma                 !":", "!" and ","
   INTEGER Idx_tag,Idx_dim1,Typ,Dim,Size1,Size2,Length
   Errno=0
   Errmsg$=""
   ON ERROR GOTO Err
   ASSIGN @Vgemdef TO "/opt/SPECS_FA/dmh/vgem/defaults.ini";FORMAT ON
   ON END @Vgemdef GOTO Endoffile
   LOOP
     Symbol$=""
     Value$=""
  !
     ENTER @Vgemdef;Line$
     Line$=TRIM$(Line$)
     P_exc=POS(Line$,"#")
     SELECT P_exc
     CASE 0
     CASE 1
       Line$=""
     CASE ELSE
       Line$=Line$[1,P_exc-1]
     END SELECT
  !
     P_col=POS(Line$," ")
     IF P_col>=2 THEN 
       Symbol$=Line$[1,P_col-1]
       Symbol$=TRIM$(Symbol$)
       IF Symbol$="VGEM" AND LEN(Line$)>P_col THEN 
         Value$=Line$[P_col+1,LEN(Line$)]
         Value$=TRIM$(Value$)
         P_sep=POS(Value$," ")
         IF P_sep>=2 THEN 
           Subsymbol$=Value$[1,P_sep-1]
           Subsymbol$=TRIM$(Subsymbol$)
           IF Subsymbol$="RecipeFile" AND LEN(Value$)>P_sep THEN 
             Rcpfilename$=Value$[P_sep+1,LEN(Value$)]
             Rcpfilename$=TRIM$(Rcpfilename$)
           END IF
           IF Subsymbol$="CompatibilityMode" AND LEN(Value$)>P_sep THEN 
             Rcpmode$=Value$[P_sep+1,LEN(Value$)]
             Rcpmode$=TRIM$(Rcpmode$)
           END IF
         END IF
       END IF
     END IF
  !
  !
 Loop_next: !
   END LOOP
   SUBEXIT
 Endoffile:                                  !
   ASSIGN @Vgemdef TO *
   SUBEXIT
 Err:                                  !
   ASSIGN @Vgemdef TO *
   Status=-1
 SUBEND
 Init_relay:SUB Init_relay
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : INIT_RELAY
 !  Vers : 1
 !  Desc : initialize relay  Paul/2012-07-03
 !  Date : 07/03/2012
 !  Time : 13:59:57
 !  User : agilent
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
   Init_relay
 SUBEND
 Is_calg:SUB Is_calg(INTEGER Lang)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : IS_CALG
 !  Vers : 1
 !  Desc : Check the lang of algorithm
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Lang            I    -        BASIC:0, C:1
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Lang=0     ! BASIC
 SUBEND
 Is_first:SUB Is_first(INTEGER First)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : IS_FIRST
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 First           I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   First=0
 SUBEND
 Jdg_die:SUB Jdg_die(INTEGER Tgt_yld,Last,Critical,Ignore,Jdg,REAL Yld,INTEGER Pass_cnt,Fail_cnt,Total_cnt)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : JDG_DIE
 !  Vers : 1
 !  Desc : Judge current die by parameter yield.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Tgt_yld         I    -        target parameter yield to be pas
 !      2 Last            I    -        all test are finished or not
 !      3 Critical        I    -        user flag index as "critical" pa
 !      4 Ignore          I    -        user flag index as "ignored" par
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Jdg             I    -        0:fail/1:pass/2:unknown
 !      2 Yld             R    -        parameter yield
 !      3 Pass_cnt        I    -        pass count of parameter
 !      4 Fail_cnt        I    -        fail count of parameter
 !      5 Total_cnt       I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Current_pos
  !
   Tpldiepos(Current_pos)
  !
   CALL Jdg_die_at_pos2(Current_pos,Tgt_yld,Last,Critical,Ignore,Jdg,Yld,Pass_cnt,Fail_cnt,Total_cnt)
 SUBEND
 Jdg_die_at_pos:SUB Jdg_die_at_pos(INTEGER Die_pos,Tgt_yld,Last,Jdg,REAL Yld,INTEGER Pass_cnt,Fail_cnt,Total_cnt)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : JDG_DIE_AT_POS
 !  Vers : 1
 !  Desc : Judge specified die by parameter yield.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Die_pos         I    -        index of die
 !      2 Tgt_yld         I    -        target parameter yield to be pas
 !      3 Last            I    -        all test are finished or not
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Jdg             I    -        0:fail/1:pass/2:unknown
 !      2 Yld             R    -        parameter yield
 !      3 Pass_cnt        I    -        pass count of parameter
 !      4 Fail_cnt        I    -        fail count of parameter
 !      5 Total_cnt       I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Out_cnt,Out_index,Type,Dim,Size1,Size2,Current_jdg,Selected
   DIM Name$[256]
  !
   Jdg=2
   Yld=0
   Pass_cnt=0
   Fail_cnt=0
   Total_cnt=0
   Tploutcount(Out_cnt)
  !
  !  output variable index starts from zero
   FOR Out_index=0 TO Out_cnt-1
     CALL Tploutstat(Out_index,Die_pos,Selected)
     IF Selected<>0 THEN 
       CALL Tploutinfo(Out_index,Name$,Type,Dim,Size1,Size2)
       IF Dim=0 AND (Type=0 OR Type=1) THEN 
         CALL Tploutjudge(Out_index,Die_pos,Current_jdg)
         IF Current_jdg<>2 THEN 
           Total_cnt=Total_cnt+1
         END IF
         SELECT Current_jdg
         CASE 0
           Fail_cnt=Fail_cnt+1
         CASE 1
           Pass_cnt=Pass_cnt+1
         CASE 2          ! Invalid
         CASE 3          ! Untested
         END SELECT
       END IF
     END IF
   NEXT Out_index
  !
   IF Pass_cnt+Fail_cnt>0 THEN 
     IF Last=1 THEN 
       Yld=Pass_cnt/(Pass_cnt+Fail_cnt)*100
       IF Yld>=Tgt_yld THEN 
         Jdg=1
       ELSE
         Jdg=0
       END IF
     ELSE
       Yld=100-Fail_cnt/Total_cnt*100
       IF Yld<Tgt_yld THEN 
         Jdg=0
       END IF
       Yld=Pass_cnt/Total_cnt*100
       IF Jdg<>0 AND Yld>=Tgt_yld THEN 
         Jdg=1
       END IF
     END IF
   ELSE
     Yld=0
   END IF
 SUBEND
 Jdg_die_at_pos2:SUB Jdg_die_at_pos2(INTEGER Die_pos,Tgt_yld,Last,Critical,Ignore,Jdg,REAL Yld,INTEGER Pass_cnt,Fail_cnt,Total_cnt)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : JDG_DIE_AT_POS2
 !  Vers : 1
 !  Desc : Judge specified die by parameter yield.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Die_pos         I    -        index of die
 !      2 Tgt_yld         I    -        target parameter yield to be pas
 !      3 Last            I    -        all test are finished or not
 !      4 Critical        I    -        user flag index as "critical" pa
 !      5 Ignore          I    -        user flag index as "ignored" par
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Jdg             I    -        0:fail/1:pass/2:unknown
 !      2 Yld             R    -        parameter yield
 !      3 Pass_cnt        I    -        pass count of parameter
 !      4 Fail_cnt        I    -        fail count of parameter
 !      5 Total_cnt       I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Out_cnt,Out_index,Type,Dim,Size1,Size2,Current_jdg,Selected
   INTEGER Usrflag,Force_fail
   DIM Name$[256]
  !
   Jdg=2
   Yld=0
   Pass_cnt=0
   Fail_cnt=0
   Total_cnt=0
   Force_fail=0
   Tploutcount(Out_cnt)
  !
  !  output variable index starts from zero
   FOR Out_index=0 TO Out_cnt-1
     CALL Tploutstat(Out_index,Die_pos,Selected)
     IF Selected<>0 THEN 
       IF Ignore<>0 THEN 
         CALL Tplgetusrflag(Out_index,Ignore-1,Usrflag)
         IF Usrflag<>0 THEN Next_var
       END IF
       CALL Tploutinfo(Out_index,Name$,Type,Dim,Size1,Size2)
       IF Dim=0 AND (Type=0 OR Type=1) THEN 
         CALL Tploutjudge(Out_index,Die_pos,Current_jdg)
         IF Current_jdg<>2 THEN 
           Total_cnt=Total_cnt+1
         END IF
         SELECT Current_jdg
         CASE 0
           Fail_cnt=Fail_cnt+1
           IF Critical<>0 THEN 
             CALL Tplgetusrflag(Out_index,Critical-1,Usrflag)
             IF Usrflag<>0 THEN Force_fail=1
           END IF
         CASE 1
           Pass_cnt=Pass_cnt+1
         CASE 2          ! Invalid
         CASE 3          ! Untested
         END SELECT
       END IF
     END IF
 Next_var: !
   NEXT Out_index
  !
   IF Pass_cnt+Fail_cnt>0 THEN 
     IF Last=1 THEN 
       Yld=Pass_cnt/(Pass_cnt+Fail_cnt)*100
       IF Yld>=Tgt_yld THEN 
         Jdg=1
       ELSE
         Jdg=0
       END IF
     ELSE
       Yld=100-Fail_cnt/Total_cnt*100
       IF Yld<Tgt_yld THEN 
         Jdg=0
       END IF
       Yld=Pass_cnt/Total_cnt*100
       IF Jdg<>0 AND Yld>=Tgt_yld THEN 
         Jdg=1
       END IF
     END IF
   ELSE
     Yld=0
   END IF
  !
   IF Force_fail=1 THEN Jdg=0
  !
 SUBEND
 Jdg_mod:SUB Jdg_mod(INTEGER Ignore,Jdg,Pass_cnt,Fail_cnt,Total_cnt)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : JDG_MOD
 !  Vers : 1
 !  Desc : Return if current module has failed outputs.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Ignore          I    -        user flag index as "ignored" par
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Jdg             I    -        0:fail/1:pass/2:unknown
 !      2 Pass_cnt        I    -        pass count of item
 !      3 Fail_cnt        I    -        fail count of item
 !      4 Total_cnt       I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Current_die
   INTEGER Current_mod
  !
   Tpldiepos(Current_die)
   Tplmodulepos(Current_mod)
  !
   Jdg_mod_at_pos(Current_die,Current_mod,Ignore,Jdg,Pass_cnt,Fail_cnt,Total_cnt)
  !
 SUBEND
 Jdg_mod_at_pos:SUB Jdg_mod_at_pos(INTEGER Die_pos,Mod_pos,Ignore,Jdg,Pass_cnt,Fail_cnt,Total_cnt)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : JDG_MOD_AT_POS
 !  Vers : 1
 !  Desc : Return if specified module has failed outputs.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Die_pos         I    -        index of die
 !      2 Mod_pos         I    -        Index of module
 !      3 Ignore          I    -        user flag index as "ignored" par
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Jdg             I    -        0:fail/1:pass/2:unknown
 !      2 Pass_cnt        I    -        pass count of item
 !      3 Fail_cnt        I    -        fail count of item
 !      4 Total_cnt       I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Out_cnt,Out_index,Type,Dim,Size1,Size2,Current_jdg,Selected
   INTEGER Min_in_mod,Max_in_mod,Usrflag
   DIM Name$[256]
  !
   Jdg=2
   Pass_cnt=0
   Fail_cnt=0
   Total_cnt=0
  !
   Tplgetrangemod(Die_pos,Mod_pos,Min_in_mod,Max_in_mod)
   FOR Out_index=Min_in_mod TO Max_in_mod
     IF Ignore<>0 THEN 
       CALL Tplgetusrflag(Out_index,Ignore-1,Usrflag)
       IF Usrflag<>0 THEN Next_var
     END IF
     CALL Tploutstat(Out_index,Die_pos,Selected)
     IF Selected<>0 THEN 
       CALL Tploutinfo(Out_index,Name$,Type,Dim,Size1,Size2)
       IF Dim=0 AND (Type=0 OR Type=1) THEN 
         CALL Tploutjudge(Out_index,Die_pos,Current_jdg)
         IF Current_jdg<>2 THEN 
           Total_cnt=Total_cnt+1
         END IF
         SELECT Current_jdg
         CASE 0
           Fail_cnt=Fail_cnt+1
         CASE 1
           Pass_cnt=Pass_cnt+1
         CASE 2           ! Invalid
         CASE 3           ! Untested
         END SELECT
       END IF
     END IF
 Next_var: !
   NEXT Out_index
  !
   IF Fail_cnt>0 THEN 
     Jdg=0
   ELSE
     IF Pass_cnt>0 THEN 
       Jdg=1
     END IF
   END IF
  !
 SUBEND
 Jdg_waf_by_die:SUB Jdg_waf_by_die(INTEGER Tgt_wafyld,Tgt_dieyld,Last,Jdg,REAL Yld,INTEGER Pass_cnt,Fail_cnt,Total_cnt)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : JDG_WAF_BY_DIE
 !  Vers : 1
 !  Desc : Judge current wafer by die yield.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Tgt_wafyld      I    -        target parameter yield to be pas
 !      2 Tgt_dieyld      I    -
 !      3 Last            I    -        all test are finished or not
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Jdg             I    -        0:fail/1:pass/2:unknown
 !      2 Yld             R    -        die yield
 !      3 Pass_cnt        I    -        pass count of die
 !      4 Fail_cnt        I    -        fail count of die
 !      5 Total_cnt       I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Total_die,Die_pos,Current_jdg,Para_pass,Para_fail,Para_total,Selected
  !
   Jdg=2
   Yld=0
   Pass_cnt=0
   Fail_cnt=0
   Total_cnt=0
   Tpldietotal(Total_die)
  !
  !  die index starts from zero
   FOR Die_pos=0 TO Total_die-1
     CALL Tpldiestat(Die_pos,Selected)
     IF Selected<>0 THEN 
       Total_cnt=Total_cnt+1
       CALL Jdg_die_at_pos(Die_pos,Tgt_dieyld,Last,Current_jdg,Para_yld,Para_pass,Para_fail,Para_total)
       SELECT Current_jdg
       CASE 0
         Fail_cnt=Fail_cnt+1
       CASE 1
         Pass_cnt=Pass_cnt+1
       CASE 2
       END SELECT
     END IF
   NEXT Die_pos
  !
   IF Pass_cnt+Fail_cnt>0 THEN 
     IF Last=1 THEN 
       Yld=Pass_cnt/(Pass_cnt+Fail_cnt)*100
       IF Yld>=Tgt_wafyld THEN 
         Jdg=1
       ELSE
         Jdg=0
       END IF
     ELSE
       Yld=100-Fail_cnt/Total_cnt*100
       IF Yld<Tgt_wafyld THEN 
         Jdg=0
       END IF
       Yld=Pass_cnt/Total_cnt*100
       IF Jdg<>0 AND Yld>=Tgt_wafyld THEN 
         Jdg=1
       END IF
     END IF
   ELSE
     Yld=0
   END IF
 SUBEND
 Jdg_waf_by_para:SUB Jdg_waf_by_para(INTEGER Tgt_yld,Last,Critical,Ignore,Jdg,REAL Yld,INTEGER Pass_cnt,Fail_cnt,Total_cnt)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : JDG_WAF_BY_PARA
 !  Vers : 1
 !  Desc : Judge current wafer by parameter yield.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Tgt_yld         I    -        target parameter yield to be pas
 !      2 Last            I    -        all test are finished or not
 !      3 Critical        I    -        user flag index as "critical" pa
 !      4 Ignore          I    -        user flag index as "ignored" par
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Jdg             I    -        0:fail/1:pass/2:unknown
 !      2 Yld             R    -        parameter yield
 !      3 Pass_cnt        I    -        pass count of parameter
 !      4 Fail_cnt        I    -        fail count of parameter
 !      5 Total_cnt       I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Total_out,Total_die,Die_pos,Out_index
   INTEGER Tgt_item_yld,Item_yld,Current_jdg
   INTEGER Type,Dim,Size1,Size2
   INTEGER Select_die,Select_out,Pass_waf,Fail_waf,Total_waf
   INTEGER Force_fail,Usrflag
   REAL Out_yld
   DIM Name$[256]
  !
   Jdg=2
   Yld=0
   Pass_cnt=0
   Fail_cnt=0
   Total_cnt=0
   Force_fail=0
   Tploutcount(Total_out)
   Tpldietotal(Total_die)
  !
  !  output variable index starts from zero
   IF Last=1 THEN 
     FOR Out_index=0 TO Total_out-1
       IF Ignore<>0 THEN 
         CALL Tplgetusrflag(Out_index,Ignore-1,Usrflag)
         IF Usrflag<>0 THEN Next_var
       END IF
       CALL Tploutinfo(Out_index,Name$,Type,Dim,Size1,Size2)
       IF Dim=0 AND (Type=0 OR Type=1) THEN 
         CALL Tplgetwafjudge(Out_index,Tgt_item_yld,Item_yld,Current_jdg)
         Total_cnt=Total_cnt+1
         SELECT Current_jdg
         CASE 0
           Fail_cnt=Fail_cnt+1
           IF Critical<>0 THEN 
             CALL Tplgetusrflag(Out_index,Critical-1,Usrflag)
             IF Usrflag<>0 THEN Force_fail=1
           END IF
         CASE 1
           Pass_cnt=Pass_cnt+1
         END SELECT
       END IF
 Next_var: !
     NEXT Out_index
     IF Pass_cnt+Fail_cnt>0 THEN 
       Yld=Pass_cnt/(Pass_cnt+Fail_cnt)*100
       IF Yld>=Tgt_yld THEN 
         Jdg=1
       ELSE
         Jdg=0
       END IF
     END IF
   ELSE
     FOR Out_index=0 TO Total_out-1
       Pass_waf=0
       Fail_waf=0
       Total_waf=0
       IF Ignore<>0 THEN 
         CALL Tplgetusrflag(Out_index,Ignore-1,Usrflag)
         IF Usrflag<>0 THEN Next_var2
       END IF
       FOR Die_pos=0 TO Total_die-1
         CALL Tpldiestat(Die_pos,Select_die)
         IF Select_die<>0 THEN 
           CALL Tploutstat(Out_index,Die_pos,Select_out)
           IF Select_out<>0 THEN 
             CALL Tploutinfo(Out_index,Name$,Type,Dim,Size1,Size2)
             IF Dim=0 AND (Type=0 OR Type=1) THEN 
               CALL Tploutjudge(Out_index,Die_pos,Current_jdg)
               IF Current_jdg<>2 THEN           ! if not invalid
                 Total_waf=Total_waf+1
               END IF
               SELECT Current_jdg
               CASE 0
                 Fail_waf=Fail_waf+1
                 IF Critical<>0 THEN 
                   CALL Tplgetusrflag(Out_index,Critical-1,Usrflag)
                   IF Usrflag<>0 THEN Force_fail=1
                 END IF
               CASE 1
                 Pass_waf=Pass_waf+1
               CASE 2           ! Invalid
               CASE 3           ! Untested
               END SELECT
             END IF
           END IF
         END IF
       NEXT Die_pos
       IF Total_waf>0 THEN 
         Total_cnt=Total_cnt+1
       END IF
       IF Pass_waf+Fail_waf>0 THEN 
         CALL Tplgetwafjudge(Out_index,Tgt_item_yld,Item_yld,Current_jdg)
         Out_yld=Pass_waf/Total_waf*100
         IF Out_yld>=Tgt_item_yld THEN 
           Pass_cnt=Pass_cnt+1
         ELSE
           Out_yld=100-Fail_waf/Total_waf*100
           IF Out_yld<Tgt_item_yld THEN 
             Fail_cnt=Fail_cnt+1
           END IF
         END IF
       END IF
 Next_var2: !
     NEXT Out_index
     IF Pass_cnt+Fail_cnt>0 THEN 
       Yld=Pass_cnt/Total_cnt*100
       IF Yld>=Tgt_yld THEN 
         Jdg=1
       ELSE
         Yld=100-Fail_cnt/Total_cnt*100
         IF Yld<Tgt_yld THEN 
           Jdg=0
         END IF
       END IF
     END IF
   END IF
  !
   IF Force_fail=1 THEN Jdg=0
  !
 SUBEND
 Log_lot_begin:SUB Log_lot_begin(Session$,Lotid$,Testplan$,Algorithm$,Limitfile$,Operator$,Date$,Time$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : LOG_LOT_BEGIN
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -
 !      2 Lotid           S    -
 !      3 Testplan        S    -
 !      4 Algorithm       S    -
 !      5 Limitfile       S    -
 !      6 Operator        S    -
 !      7 Date            S    -
 !      8 Time            S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;RPT$("=",31)&" LOT TEST START "&RPT$("=",31)
   OUTPUT @Tmp;""
   OUTPUT @Tmp;"     Lot ID:     "&Lotid$
   OUTPUT @Tmp;"     Test Plan:  "&Testplan$
   OUTPUT @Tmp;"     Algorithm:  "&Algorithm$
   OUTPUT @Tmp;"     Limit File: "&Limitfile$
   OUTPUT @Tmp;"     Operator:   "&Operator$
   OUTPUT @Tmp;"     Date:       "&Date$
   OUTPUT @Tmp;"     Start:      "&Time$
   OUTPUT @Tmp;""
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Log_lot_end:SUB Log_lot_end(Session$,State$,INTEGER Result,Datadir$,Dataname$,Time$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : LOG_LOT_END
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -
 !      2 State           S    -
 !      3 Result          I    -
 !      4 Datadir         S    -
 !      5 Dataname        S    -
 !      6 Time            S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256],Judge$[4]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   SELECT Result
   CASE 0
     Judge$="Fail"
   CASE 1
     Judge$="Pass"
   END SELECT
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;"     End:        "&Time$
   OUTPUT @Tmp;"     State:      "&State$
   OUTPUT @Tmp;"     Result:     "&Judge$
   OUTPUT @Tmp;"     Data File:  "&Datadir$&"/"&Dataname$
   OUTPUT @Tmp;""
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Log_prober:SUB Log_prober(Session$,Message$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : LOG_PROBER
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -
 !      2 Message         S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;"     >>>>> PROBER ERROR "&DATE$(TIMEDATE)&" "&TIME$(TIMEDATE)&" >>>>> "&Message$
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Log_system:SUB Log_system(Session$,Message$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : LOG_SYSTEM
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -
 !      2 Message         S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;"     >>>>> SYSTEM ERROR "&DATE$(TIMEDATE)&" "&TIME$(TIMEDATE)&" >>>>> "&Message$
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Log_wafer_begin:SUB Log_wafer_begin(Session$,Waferid$,Time$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : LOG_WAFER_BEGIN
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -
 !      2 Waferid         S    -
 !      3 Time            S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;"          Wafer ID: "&Waferid$
   OUTPUT @Tmp;"          Start:    "&Time$
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Log_wafer_end:SUB Log_wafer_end(Session$,State$,INTEGER Result,Time$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : LOG_WAFER_END
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -
 !      2 State           S    -
 !      3 Result          I    -
 !      4 Time            S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256],Judge$[4]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   SELECT Result
   CASE 0
     Judge$="Fail"
   CASE 1
     Judge$="Pass"
   END SELECT
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;"          End:      "&Time$
   OUTPUT @Tmp;"          State:    "&State$
   OUTPUT @Tmp;"          Result:   "&Judge$
   OUTPUT @Tmp;""
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Master_lookup:SUB Master_lookup(File$,Key$,INTEGER Fnum,Field$,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : MASTER_LOOKUP
 !  Vers : 1
 !  Desc : Returns specified field of specified line in an ASCII dat
 !       : a file
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 File            S    -        Master filename
 !      2 Key             S    -        Key string
 !      3 Fnum            I    -        Field number, 1 ~ 199
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Field           S    -        Extracted field
 !      2 Stat            I    -        0(ok),-1(no key),-2(invalid),-3(
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Field$=""
   ON ERROR GOTO Nofile
   ASSIGN @Tmp TO File$
   ASSIGN @Tmp TO *
   OFF ERROR 
   ON ERROR GOTO Nofile
   ASSIGN @Pipe TO "grep -v '^#' "&File$&" | awk -F: '{ if($1 == """&Key$&"""){ if("&VAL$(Fnum)&"<=NF){ print $"&VAL$(Fnum)&"; } else { print "":""; }}}'| "
   OFF ERROR 
   ON END @Pipe GOTO Eof
   ON ERROR GOTO Overflow
   ENTER @Pipe;Field$
   ASSIGN @Pipe TO *
   IF Field$=":" THEN 
     Field$=""
     Stat=-2
   ELSE
     Stat=0
   END IF
   SUBEXIT
 Nofile:Stat=-3
   SUBEXIT
 Eof:Stat=-1
   SUBEXIT
 Overflow:Field$=""
   Stat=-2
   SUBEXIT
 SUBEND
 Merge_datafile:SUB Merge_datafile(Original$,New$,Format$,INTEGER Numwaf,Waferid$(*),INTEGER Stat,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : MERGE_DATAFILE
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Original        S    -
 !      2 New             S    -
 !      3 Format          S    -
 !      4 Numwaf          I    -
 !      5 Waferid         S    50
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Stat            I    -
 !      2 Error           S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Merge$[256],Stderr$[256],Tag$[4],Cmd$[1024],Wafer$[1024]
   INTEGER I
  !
   Error$=""
   Tag$="base"
  !
   Wafer$=""
   FOR I=1 TO Numwaf
     Wafer$=Wafer$&Waferid$(I)&" "
   NEXT I
  !
   Merge$=Original$&".mrg"
   Stderr$=Original$&".err"
   Original$=Original$&"."&Format$
   New$=New$&"."&Format$
  !
   ON ERROR GOTO Nofile
   PURGE Stderr$
 Nofile:  !
   IF ERRN<>0 AND ERRN<>56 THEN 
     OFF ERROR 
     Stat=-1
     Error$=ERRM$
     PRINT Error$
     SUBEXIT
   END IF
  !
   ON ERROR GOTO Err
   Cmd$="/opt/SPECS/sys/bin/datamerge -t "&Tag$&" "&Original$&" \"&New$&" "&Wafer$&" 1>"&Merge$&" 2>"&Stderr$    ! AVPATH_
   EXECUTE Cmd$
   ASSIGN @File TO Stderr$
   ON END @File GOTO Eof_stderr
   Error$=""
   ENTER @File;Error$
 Eof_stderr:  !
   OFF END @File
   ASSIGN @File TO *
   PURGE Stderr$
   IF Error$<>"" THEN 
     PURGE Merge$
     Stat=-1
     PRINT Error$
     SUBEXIT
   END IF
  !
   Cmd$="mv \"&Merge$&" "&Original$&" 2>&1 |"
   ASSIGN @Pipe TO Cmd$
   ON END @Pipe GOTO Eof_mv
   ENTER @Pipe;Error$
   OFF END @Pipe
   ASSIGN @Pipe TO *
   OFF ERROR 
   PURGE Merge$
   Stat=-1
   PRINT Error$
   SUBEXIT
  !
 Eof_mv:                            !
   OFF END @Pipe
   ASSIGN @Pipe TO *
   OFF ERROR 
   Stat=0
   SUBEXIT
 Err:                              !
   OFF ERROR 
   Stat=-1
   Error$=ERRM$
   PRINT Error$
 SUBEND
 Name_tmpdata:SUB Name_tmpdata(Basename$,Session$,Tmpname$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : NAME_TMPDATA
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Basename        S    -
 !      2 Session         S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Tmpname         S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Tmpname$="#"&Session$&TRIM$(Basename$)
 SUBEND
 Plotter_is:SUB Plotter_is(INTEGER Sel)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : PLOTTER_IS
 !  Vers : 1
 !  Desc : Changes the PLOTTER IS device
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Sel             I    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   PLOTTER IS Sel,"WINDOW"
 SUBEND
 Prbcount:SUB Prbcount(INTEGER Count)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : PRBCOUNT
 !  Vers : 1
 !  Desc : Return the number of Pins
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Count           I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Tplprbcount(Count)
 SUBEND
 Prbinfo:SUB Prbinfo(INTEGER Index,Pad,Pin)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : PRBINFO
 !  Vers : 1
 !  Desc : Return pin number and pad number.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Index           I    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Pad             I    -
 !      2 Pin             I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Tplprbinfo(Index,Pad,Pin)
 SUBEND
 Print:SUB Print(S$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : PRINT
 !  Vers : 1
 !  Desc : Prints the specified STRING variable to the present PRINT
 !       : ER IS device
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 S               S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   PRINT S$
 SUBEND
 Print_char:SUB Print_char(Format$,Value$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : PRINT_CHAR
 !  Vers : 1
 !  Desc : Writes a CHARACTER value to a STRING variable, then print
 !       : s it to the present PRINTER IS device
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 Value           C    -        Value to convert
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM String$[255]
   INTEGER Length
   Writechar(Format$,Value$,String$,Length)
   PRINT String$
 SUBEND
 Print_integer:SUB Print_integer(Format$,INTEGER Value)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : PRINT_INTEGER
 !  Vers : 1
 !  Desc : Writes an INTEGER value to a STRING variable, then prints
 !       :  it to the present PRINTER IS device
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 Value           I    -        Value to convert
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM String$[255]
   INTEGER Length
   Writeinteger(Format$,Value,String$,Length)
   PRINT String$
 SUBEND
 Print_real:SUB Print_real(Format$,REAL Value)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : PRINT_REAL
 !  Vers : 1
 !  Desc : Writes a REAL value to a STRING variable, then prints it
 !       : to the present PRINTER IS device
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 Value           R    -        Value to convert
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM String$[255]
   INTEGER Length
   Writereal(Format$,Value,String$,Length)
   PRINT String$
 SUBEND
 Print_string:SUB Print_string(Format$,Value$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : PRINT_STRING
 !  Vers : 1
 !  Desc : Writes a STRING value to a STRING variable, then prints i
 !       : t to the present PRINTER IS device
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 Value           S    -        Value to convert
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM String$[255]
   INTEGER Length
   Writestring(Format$,Value$,String$,Length)
   PRINT String$
 SUBEND
 Printer_is:SUB Printer_is(INTEGER Sel)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : PRINTER_IS
 !  Vers : 1
 !  Desc : Changes the PRINTER IS device
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Sel             I    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   PRINTER IS Sel
 SUBEND
 Query_dir:SUB Query_dir(Dir$,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : QUERY_DIR
 !  Vers : 1
 !  Desc : Let Quick Query open specified directory.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Dir             S    -        Opened directory.
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Stat            I    -        0:ok, -1:not found
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Qq_open_dir(Dir$,Stat)
  !
 SUBEND
 Query_file:SUB Query_file(File$,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : QUERY_FILE
 !  Vers : 1
 !  Desc : Let Quick Query open specified file.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 File            S    -        Opened file.
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Stat            I    -        0:ok, -1:not found
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Qq_open_file(File$,Stat)
  !
 SUBEND
 Query_graph:SUB Query_graph(INTEGER Filter,Type,Unit,Variable$,INTEGER Update)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : QUERY_GRAPH
 !  Vers : 1
 !  Desc : Let Quick Query open Graph. Must be executed after QUERY_
 !       : FILE.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Filter          I    -        Filter item.
 !      2 Type            I    -        0:XY, 1:Hist, 2:WaferMap
 !      3 Unit            I    -        0:Lot, 1:Wafer, 2:Die
 !      4 Variable        S    -        Output variable name.
 !      5 Update          I    -        0:New, 1:Update
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   IF Update=0 THEN 
     Qq_graph_start(Filter,Type,Unit,Variable$)
   ELSE
     Qq_graph_update(Filter,Type,Unit,Variable$)
   END IF
  !
 SUBEND
 Query_launch:SUB Query_launch(Session$,Port$,Project$,Hostname$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : QUERY_LAUNCH
 !  Vers : 1
 !  Desc : Start Quick Query.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Session         S    -        Session ID
 !      2 Port            S    -        Port ID
 !      3 Project         S    -        Project ID
 !      4 Hostname        S    -        Hostname
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Buf$(32)[256]
   INTEGER Nopt
  !
   Nopt=0
  !
   Nopt=Nopt+1
   Buf$(Nopt)="-c"&Port$
   Nopt=Nopt+1
   Buf$(Nopt)="-g"&Session$
   Nopt=Nopt+1
   Buf$(Nopt)="-h"&Hostname$
  !
   Qq_init(Buf$(*),Nopt)
  !
 SUBEND
 Query_start:SUB Query_start
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : QUERY_START
 !  Vers : 1
 !  Desc : Popup Quick Query.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Qq_popup
  !
 SUBEND
 Query_stop:SUB Query_stop
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : QUERY_STOP
 !  Vers : 1
 !  Desc : Popdown Quick Query.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Qq_popdown
  !
 SUBEND
 Query_view:SUB Query_view(Variable$,INTEGER Update)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : QUERY_VIEW
 !  Vers : 1
 !  Desc : Let Quick Query open Quick View. Must be executed after Q
 !       : UERY_FILE.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Variable        S    -        Output variable name.
 !      2 Update          I    -        0:New, 1:Update
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   IF Update=0 THEN 
     Qq_view_start(Variable$)
   ELSE
     Qq_view_update(Variable$)
   END IF
  !
 SUBEND
 Rcp_check_key:SUB Rcp_check_key(Filename$,INTEGER Status,Errmsg$,Dupkey$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : RCP_CHECK_KEY
 !  Vers : 1
 !  Desc : Check if recipe file has duplicate key fields.
 !       :   SPECS3.0: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Filename        S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0: OK, -1: Err, -2: No File
 !      2 Errmsg          S    -
 !      3 Dupkey          S    -        Duplicated key
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[8192],Dst$[256],Keylst$[256],Diff$[256],Nullkey$[256],Detail$(10)[256]
   DIM Key$[4096],Key2$[256]
   DIM File_nm$(3)[256],Pat$(3)[256],Rep$(3)[256],Rep_fl$(3)[256],Name$(3)[256]
   INTEGER Cmd_ret,Ndetail,Pos,Rep_fl_len,I,File_name_len
   REAL Line_no
   Tab$=CHR$(9)
  !
   Dst$="/var/tmp/rcp_key."&SYSTEM$("PROCESS ID")
   Keylst$="/var/tmp/rcp_keylst."&SYSTEM$("PROCESS ID")
   Diff$="/var/tmp/rcp_keydif."&SYSTEM$("PROCESS ID")
   Nullkey$="/var/tmp/rcp_nullkey."&SYSTEM$("PROCESS ID")
   Dupkey$=""
   Status=0
  !
   ON ERROR GOTO No_recipe_file
   ASSIGN @Fn TO Filename$
   ASSIGN @Fn TO *
   OFF ERROR 
  !
   Cmd$="/usr/bin/grep -Ee '^[^#][^\t ]*' "&Filename$&" | /usr/bin/cut -f 1"
   Cmd$=Cmd$&" | /usr/bin/grep -Ee '^[^\t]' | /usr/bin/sort"
   Rcp_exec_cmd(Cmd$,Dst$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status THEN 
     GOSUB Remove_file
     SUBEXIT
   END IF
  !
   Cmd$="/usr/bin/awk '/^.+$/{if (!match($0,""^[A-Za-z0-9_]+$"")){print $0;exit}}' "&Dst$
   ASSIGN @Pipe TO Cmd$&" | "
   ON END @Pipe GOTO Invalid_eof
   ENTER @Pipe;Key$
  !
   Status=-1
   Errmsg$="Recipe key must consist of A-Z,a-z,0-9 and '_': """&Key$&""""
   GOSUB Remove_file
   SUBEXIT
 Invalid_eof:     !
   OFF END @Pipe
   ASSIGN @Pipe TO *
  !
   Cmd$="/usr/bin/uniq "&Dst$
   Rcp_exec_cmd(Cmd$,Keylst$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status THEN 
     GOSUB Remove_file
     SUBEXIT
   END IF
  !
   Cmd$="/usr/bin/diff "&Dst$&" "&Keylst$
   Rcp_exec_cmd(Cmd$,Diff$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status THEN 
     IF Cmd_ret=1 THEN 
       Cmd$="/usr/bin/awk '{if (match($1,""^[<>]+"")){print $2;}}' "&Diff$
       ON ERROR GOTO No_exec
       ASSIGN @Pipe TO Cmd$&" | "
       ON END @Pipe GOTO Eof
       ENTER @Pipe;Key$
       Errmsg$="Duplicate key is found, """&Key$&"""."
       Dupkey$=Key$
 Eof:  !
       OFF END @Pipe
       ASSIGN @Pipe TO *
 No_exec:  !
     END IF
     GOSUB Remove_file
     SUBEXIT
   END IF
  !
   Cmd$="/usr/bin/sed -e 's/"&Tab$&"[^"&Tab$&"][^"&Tab$&"]*/"&Tab$&"X/g' "&Filename$
   Cmd$=Cmd$&" | /usr/bin/awk -F'\t' 'BEGIN{ln=0;}"
   Cmd$=Cmd$&"/^[^#]/{ln=ln+1;"
   Cmd$=Cmd$&"if((!match($0,""^[ \t]*$""))&&match($1,""^[ ]*$"")){print ln;exit 0;}}"
   Cmd$=Cmd$&"END{print 0;}'"
   Rcp_exec_cmd(Cmd$,Nullkey$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status THEN 
     GOSUB Remove_file
     SUBEXIT
   END IF
  !
   ON ERROR GOTO No_null_key
   ASSIGN @Pipe TO "/usr/bin/cat "&Nullkey$&" | "
   ON END @Pipe GOTO Eof_null_key
   ENTER @Pipe;Line_no
   IF Line_no>0 THEN 
     Status=-1
     Errmsg$="Null key is found at line "&VAL$(Line_no)&"."
   END IF
 Eof_null_key:  !
   OFF END @Pipe
   ASSIGN @Pipe TO *
 No_null_key:  !
  !
   Name$(1)="RCP_TPL"
   Name$(2)="RCP_LIM"
   Name$(3)=""
   File_nm$(1)=""
   File_nm$(2)=""
   File_nm$(3)=""
   FOR I=1 TO SIZE(Name$,1)-1
     Rcp_sysconf(Name$(I),File_nm$(I),Status)
     IF (Status<>0) THEN 
       Errmsg$=""""&Name$(I)&""""&"is not found in sysconf."
     END IF
   NEXT I
   Pat$(1)="$(RCP)"
   Pat$(2)="$(SI)"
   Pat$(3)=""
   Rep$(1)=""
   Rep$(2)="0"
   Rep$(3)=""
   FOR I=1 TO SIZE(Rep_fl$,1)-1
     Pos=0
     Rep_fl$(I)=""
     String_lookup(File_nm$(I),Pat$(1),Pos)
     IF (Pos>0) THEN 
       Rcp_replace_wd(File_nm$(I),Pat$(*),Rep$(*),Rep_fl$(I))
     END IF
   NEXT I
  !
   ON ERROR GOTO Internal_file
   ASSIGN @Keylst TO Keylst$;FORMAT ON
   ON END @Keylst GOTO Eof_name_check
   File_name_len=32
   LOOP
     ENTER @Keylst;Key$
     Key$=Key$[1;255]
     FOR I=1 TO SIZE(Rep_fl$,1)-1
       Rep_fl_len=LEN(Rep_fl$(I))
       IF Rep_fl_len>0 THEN 
         IF Rep_fl_len+LEN(Key$)>File_name_len THEN 
           Status=-1
           Key2$=Key$[1;File_name_len]
           Errmsg$="Recipe key is too long. (0 < key lenght <= "&VAL$(File_name_len-Rep_fl_len)&")"
           Errmsg$=Errmsg$&CHR$(10)&"It is used as a part of test plan or limit file name. ("&Key2$&")"
           ASSIGN @Keylst TO *
           GOSUB Remove_file
           SUBEXIT
         END IF
       END IF
     NEXT I
   END LOOP
 Internal_file:   !
   OFF ERROR 
   ASSIGN @Keylst TO *
   Status=-1
   Errmsg$="Error on accessing internal file, "&Keylst$
   GOSUB Remove_file
   SUBEXIT
 Eof_name_check:   !
   ASSIGN @Keylst TO *
  !
   GOSUB Remove_file
   SUBEXIT
  !
 Remove_file:  !
   ON ERROR GOTO Rm_nullkey
   PURGE Nullkey$
 Rm_nullkey:  !
   OFF ERROR 
   ON ERROR GOTO Rm_keylst
   PURGE Dst$
 Rm_keylst:  !
   OFF ERROR 
   ON ERROR GOTO Rm_dif
   PURGE Keylst$
 Rm_dif:  !
   OFF ERROR 
   ON ERROR GOTO Rm_end
   PURGE Diff$
 Rm_end:  !
   OFF ERROR 
   RETURN 
  !
 No_recipe_file:  !
   ASSIGN @Fl TO *
   OFF ERROR 
   Status=-2
   Errmsg$="Recipe file is not found."
   SUBEXIT
  !
 SUBEND
 Rcp_dietst:SUB Rcp_dietst(Die$(*),Tst$(*),Rule$,Die_tst$(*),INTEGER Status,Errmsg$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : RCP_DIETST
 !  Vers : 1
 !  Desc : The Algorithm makes a Die Spec-Test Spec list for tplbuil
 !       : d command.
 !       :   SPECS3.0: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Die             S    256
 !      2 Tst             S    256
 !      3 Rule            S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Die_tst         S    256
 !      2 Status          I    -        0: Ok
 !      3 Errmsg          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER I,Die_sz,Tst_sz,Sz
  !
   FOR I=1 TO SIZE(Die_tst$,1)
     Die_tst$(I)=""
   NEXT I
   Status=0
   Errmsg$=""
  !
   I=1
   LOOP
   EXIT IF I>SIZE(Die$,1)
     Die_sz=I
   EXIT IF Die$(I)=""
     I=I+1
   END LOOP
  !
   I=1
   LOOP
   EXIT IF I>SIZE(Tst$,1)
     Tst_sz=I
   EXIT IF Tst$(I)=""
     I=I+1
   END LOOP
  !
   IF (Die_sz<Tst_sz) THEN 
     Status=1
     Errmsg$="Not enough number of die spec files to make die-test pairs."
   END IF
   IF (Die_sz>Tst_sz) THEN 
     Errmsg$="Test spec files that cannot make die-test pairs are skipped."
   END IF
  !
   Sz=MIN(SIZE(Die$,1),SIZE(Tst$,1))
   Sz=MIN(Sz,SIZE(Die_tst$,1))
   I=1
   LOOP
   EXIT IF I>Sz
   EXIT IF Die$(I)="" OR Tst$(I)=""
     Die_tst$(I)=Die$(I)&" "&Tst$(I)
     I=I+1
   END LOOP
  !
 SUBEND
 Rcp_exec_cmd:SUB Rcp_exec_cmd(Cmd$,Result$,INTEGER Status,Errmsg$,INTEGER Ndetail,Detail$(*),INTEGER Cmd_ret)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : RCP_EXEC_CMD
 !  Vers : 1
 !  Desc : Execute command file and get result file.
 !       :   SPECS3.0: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Cmd             S    -
 !      2 Result          S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0: OK, -1: Exec Err, -2: No File
 !      2 Errmsg          S    -
 !      3 Ndetail         I    -        # of lines of detail error messa
 !      4 Detail          S    10       Detailed error message
 !      5 Cmd_ret         I    -        Return value from Command
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Err$[256],Cl$[32767]
   DIM Ver$[50]
   INTEGER Arg_max
   INTEGER St,I
  !
   Ndetail=0
   FOR I=1 TO 10
     Detail$(I)=""
   NEXT I
   Cmd_ret=0
  !
   IF Cmd$="" THEN 
     Status=-2
     Errmsg$="No command is specified."
     SUBEXIT
   END IF
  !
   EXECUTE "/usr/bin/touch "&Result$;RETURN St
   IF St THEN 
     Status=-2
     Errmsg$="Cannot store the result. """&Result$&""""
     SUBEXIT
   END IF
  !
   Err$="/var/tmp/rcp_exec_cmd."&SYSTEM$("PROCESS ID")
   Status=0
   Errmsg$=""
  !
   ON ERROR GOTO Str_overflow
   Cl$=Cmd$&" > "&Result$&" 2> "&Err$
   OFF ERROR 
  !
   Ver$=SYSTEM$("VERSION:OS")
   Ver$=Ver$[3;5]
   IF Ver$<="10.20" THEN 
     Arg_max=20478
     IF LEN(Cl$)>Arg_max THEN 
       GOSUB Str_overflow
     END IF
   END IF
  !
   EXECUTE Cl$;RETURN St
  !
   Cmd_ret=SHIFT(St,8) MOD 256
   IF Cmd_ret>=128 THEN Cmd_ret=Cmd_ret-256
  !
   IF St<>0 THEN 
     Status=-1
     ON ERROR GOTO No_errfl
     ASSIGN @E TO Err$;FORMAT ON
     ASSIGN @E TO *
     OFF ERROR 
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO Eof
     FOR I=1 TO 10
       ENTER @E;Detail$(I)
       Ndetail=I
     NEXT I
 Eof:   !
     OFF END @E
     ASSIGN @E TO *
  !
     IF Ndetail>0 THEN 
       Errmsg$=Detail$(1)
     ELSE
       Errmsg$="Error found while executing: "&Cl$
     END IF
   END IF
   PURGE Err$
   SUBEXIT
  !
 Str_overflow:   !
   Status=-1
   Errmsg$="Internal string buffer overflow."
   PURGE Err$
   SUBEXIT
  !
 No_errfl:   !
   Status=-1
   Errmsg$="Cannot execute command: "&Cl$
   PURGE Err$
   SUBEXIT
  !
 SUBEND
 Rcp_limbld:SUB Rcp_limbld(Tpl_dir$,Lms_dir$,Lim_dir$,Tpl$,Lms$(*),Lim$,INTEGER Status,Errmsg$,INTEGER Ndetail,Detail$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : RCP_LIMBLD
 !  Vers : 1
 !  Desc : This algorithm generates Limit File dynamically.
 !       :   SPECS3.0: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Tpl_dir         S    -
 !      2 Lms_dir         S    -
 !      3 Lim_dir         S    -
 !      4 Tpl             S    -
 !      5 Lms             S    256
 !      6 Lim             S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0: OK, -1: Exec Err, -2: No File
 !      2 Errmsg          S    -
 !      3 Ndetail         I    -        # of lines of detail error messa
 !      4 Detail          S    10       Detailed error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[32767],Opt$[32767],Err$[256]
   DIM T$[256],L$[256]
   INTEGER I,Cmd_ret
  !
   Ndetail=0
   IF Tpl$="" THEN 
     Status=-2
     Errmsg$="No test plan name is specified."
     SUBEXIT
   END IF
   IF Lim$="" THEN 
     Status=-2
     Errmsg$="No limit file name is specified."
     SUBEXIT
   END IF
   Rcp_mk_filename(Tpl_dir$,Tpl$,"",T$)
   Rcp_mk_filename(Lim_dir$,Lim$,".lim",L$)
  !
   ON ERROR GOTO Str_overflow
   Cmd$="/opt/SPECS/sys/bin/limbuild"
   Opt$=""
   I=1
   LOOP
   EXIT IF I>SIZE(Lms$,1)
   EXIT IF Lms$(I)=""
     Opt$=Opt$&" -lms "&Lms$(I)
     I=I+1
   END LOOP
   IF Lms_dir$<>"" THEN 
     Opt$=Opt$&" -lmspath "&Lms_dir$
   END IF
   Opt$=Opt$&" "&T$
  !
   Cmd$=Cmd$&Opt$
   OFF ERROR 
   Rcp_exec_cmd(Cmd$,L$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status<0 THEN 
     GOSUB Remove_file
   END IF
  !
  !
   SUBEXIT
  !
 Remove_file:   !
   ON ERROR GOTO Rm_end
   PURGE L$
 Rm_end:   !
   OFF ERROR 
   RETURN 
  !
 Str_overflow:   !
   Status=-1
   Errmsg$="Internal string buffer overflow."
   SUBEXIT
  !
 SUBEND
 Rcp_mk_filename:SUB Rcp_mk_filename(Dirname$,Filename$,Suffix$,Fullfile$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : RCP_MK_FILENAME
 !  Vers : 1
 !  Desc : Make file name from directory name and file name.
 !       :   SPECS3.0: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Dirname         S    -
 !      2 Filename        S    -
 !      3 Suffix          S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Fullfile        S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Dir$[256],Fil$[256]
   INTEGER Sl,Fl
  !
   IF Dirname$="" OR Filename$[1,1]="/" THEN 
     Fullfile$=Filename$
   ELSE
     Dir$=Dirname$
     IF Dir$[LEN(Dir$)]<>"/" THEN Dir$=Dir$&"/"
     Fullfile$=Dir$&Filename$
   END IF
  !
   Sl=LEN(Suffix$)
   Fl=LEN(Fullfile$)
   IF Sl THEN 
     IF Fl<Sl THEN 
       Fullfile$=Fullfile$&Suffix$
     ELSE
       IF Fullfile$[Fl-Sl+1]<>Suffix$ THEN 
         Fullfile$=Fullfile$&Suffix$
       END IF
     END IF
   END IF
 SUBEND
 Rcp_query_recip:SUB Rcp_query_recip(Key$,Filename$,Waf$,Die$(*),Mod$(*),Tst$(*),Prb$,Lms$(*),Tco$(*),Mlib$(*),Item$(*),INTEGER Status,Errmsg$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : RCP_QUERY_RECIP
 !  Vers : 1
 !  Desc : Query recipe items in the recipe file from key recipe id.
 !       :   SPECS3.1: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Key             S    -
 !      2 Filename        S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Waf             S    -
 !      2 Die             S    256
 !      3 Mod             S    256
 !      4 Tst             S    256
 !      5 Prb             S    -
 !      6 Lms             S    256
 !      7 Tco             S    16
 !      8 Mlib            S    6
 !      9 Item            S    32
 !     10 Status          I    -        0: OK, -1: Exec Err, -2: No File
 !     11 Errmsg          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[32767],Spc$[256],Line$[4096],Detail$(10)[256],Spc_nm$[256]
   INTEGER I,N_item,Ndetail,Cmd_ret
  !
   Cmd$="/opt/SPECS/usr/recipe/recipe_q.sh"
   Spc$="/var/tmp/spc."&SYSTEM$("PROCESS ID")
  !
   FOR I=1 TO SIZE(Item$,1)
     Item$(I)=""
   NEXT I
   Waf$=""
   FOR I=1 TO SIZE(Die$,1)
     Die$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Mod$,1)
     Mod$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tst$,1)
     Tst$(I)=""
   NEXT I
   Prb$=""
   FOR I=1 TO SIZE(Lms$,1)
     Lms$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tco$,1)
     Tco$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Mlib$,1)
     Mlib$(I)=""
   NEXT I
  !
   Cmd$=Cmd$&" "&Filename$&" "&Key$
   Rcp_exec_cmd(Cmd$,Spc$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
  !
   IF Cmd_ret=1 THEN Status=1
   IF Status=0 OR Status=1 THEN 
     ASSIGN @S TO Spc$;FORMAT ON
     ON END @S GOSUB Eof
  !
     Spc_nm$=""
     N_item=0
     ENTER @S;Line$
     WHILE (Line$<>"# EOD")
       IF Line$[1,2]="# " THEN 
         Spc_nm$=Line$[3;LEN(Line$)-2]
         N_item=0
       ELSE
         N_item=N_item+1
         SELECT Spc_nm$
         CASE "WAF"
           IF N_item>1 THEN 
             GOSUB Array_overflow
           END IF
           Waf$=Line$
         CASE "DIE"
           IF N_item>SIZE(Die$,1) THEN 
             GOSUB Array_overflow
           END IF
           Die$(N_item)=Line$
         CASE "MOD"
           IF N_item>SIZE(Mod$,1) THEN 
             GOSUB Array_overflow
           END IF
           Mod$(N_item)=Line$
         CASE "TST"
           IF N_item>SIZE(Tst$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tst$(N_item)=Line$
         CASE "PRB"
           IF N_item>1 THEN 
             GOSUB Array_overflow
           END IF
           Prb$=Line$
         CASE "LMS"
           IF N_item>SIZE(Lms$,1) THEN 
             GOSUB Array_overflow
           END IF
           Lms$(N_item)=Line$
         CASE "TCO"
           IF N_item>SIZE(Tco$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tco$(N_item)=Line$
         CASE "MLIB"
           IF N_item>SIZE(Mlib$,1) THEN 
             GOSUB Array_overflow
           END IF
           Mlib$(N_item)=Line$
         CASE "ITEM"
           IF N_item>SIZE(Item$,1) THEN 
             GOSUB Column_overflow
           END IF
           Item$(N_item)=Line$[1;255]
         CASE ELSE
           GOSUB Eof
           SUBEXIT
         END SELECT
       END IF
  !
       ENTER @S;Line$
     END WHILE
  !
     ASSIGN @S TO *
   END IF
  !
   GOSUB Del_spc
   SUBEXIT
  !
 Eof:   !
   Status=-3
   Errmsg$="Cannot find a recipe by the key, """&Key$&"""."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Array_overflow:   !
   Status=-4
   Errmsg$="Too many file names at the column, """&Spc_nm$&"""."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Column_overflow:   !
   Status=-4
   Errmsg$="Too many columns in the recipe file."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Del_spc:    !
   ON ERROR GOTO Del_end
   PURGE Spc$
 Del_end:    !
   OFF ERROR 
   RETURN 
  !
 SUBEND
 Rcp_replace_wd:SUB Rcp_replace_wd(Format$,Find_wd$(*),Replace_wd$(*),String$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : RCP_REPLACE_WD
 !  Vers : 1
 !  Desc : Replace keyword in Format String.
 !       :   SPECS3.0: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -
 !      2 Find_wd         S    5
 !      3 Replace_wd      S    5
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 String          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Cmd$[4096],Line$[256]
   INTEGER I
  !
   String$=""
  !
   IF Find_wd$(1)="" THEN 
     String$=Format$
     SUBEXIT
   END IF
  !
   Cmd$="/usr/bin/echo '"&Format$&"' | /usr/bin/sed "
   FOR I=1 TO 5
     IF Find_wd$(I)="" THEN 
       GOTO Exec_cmd
     END IF
     Cmd$=Cmd$&"-e 's/"&Find_wd$(I)&"/"&Replace_wd$(I)&"/' "
   NEXT I
  !
 Exec_cmd:   !
   ON ERROR GOTO No_exec
   ASSIGN @Pipe TO Cmd$&" |"
   OFF ERROR 
   ON END @Pipe GOTO Eof
   ENTER @Pipe;Line$
  !
   OFF END @Pipe
   ASSIGN @Pipe TO *
   String$=Line$
   SUBEXIT
  !
 Eof:   !
   OFF END @Pipe
   ASSIGN @Pipe TO *
  !
 No_exec:   !
   SUBEXIT
  !
 SUBEND
 Rcp_sysconf:SUB Rcp_sysconf(Name$,Value$,INTEGER Status)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : RCP_SYSCONF
 !  Vers : 1
 !  Desc : Read a parameter written in sysconf file.
 !       :   SPECS3.0: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Name            S    -        Parameter name for Recipe Manage
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Value           S    -        Parameter value read from syscon
 !      2 Status          I    -        0: Ok, -1: Not found, -2: Exec f
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[1024],Line$[256]
  !
   Status=0
  !
   Cmd$="/usr/bin/grep -Ee '^[ \t]*"&Name$&"[ \t]*=' /opt/SPECS/sys/config/sysconf"
   Cmd$=Cmd$&"| /usr/bin/awk -F '=' '{val=$2;gsub(""^[ \t]*"","""",val);gsub(""[ \t]*$"","""",val); print val;}'"
   ON ERROR GOTO No_exec
   ASSIGN @Pipe TO Cmd$&" |"
   OFF ERROR 
   ON END @Pipe GOTO Eof
   ENTER @Pipe;Value$
  !
   OFF END @Pipe
   ASSIGN @Pipe TO *
   SUBEXIT
  !
 Eof:   !
   OFF END @Pipe
   ASSIGN @Pipe TO *
   Status=-1
   SUBEXIT
  !
 No_exec:   !
   Status=-2
   SUBEXIT
  !
 SUBEND
 Rcp_tplbld:SUB Rcp_tplbld(V1$,V2$,V3$,V4$,V5$,V6$,V7$,V8$,V9$(*),V10$(*),V11$(*),V12$(*),V13$,INTEGER Status,Errmsg$,INTEGER Ndetail,Detail$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : RCP_TPLBLD
 !  Vers : 1
 !  Desc : This algorithm generates Test Plan dynamically.
 !       :   SPECS3.1: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Waf_dir         S    -
 !      2 Prb_dir         S    -
 !      3 Die_dir         S    -
 !      4 Mod_dir         S    -
 !      5 Tst_dir         S    -
 !      6 Tpl_dir         S    -
 !      7 Waf             S    -
 !      8 Prb             S    -
 !      9 Die             S    256
 !     10 Mod             S    256
 !     11 Tst             S    256
 !     12 Mlib            S    6
 !     13 Tpl             S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Status          I    -        0: OK, -1: Exec Err, -2: No File
 !      2 Errmsg          S    -
 !      3 Ndetail         I    -        # of lines of detail error messa
 !      4 Detail          S    10       Detailed error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Waf_dir$[255]                               ! V1
   DIM Prb_dir$[255]                               ! V2
   DIM Die_dir$[255]                               ! V3
   DIM Mod_dir$[255]                               ! V4
   DIM Tst_dir$[255]                               ! V5
   DIM Tpl_dir$[255]                               ! V6
   DIM Waf$[255]                                   ! V7
   DIM Prb$[255]                                   ! V8
   DIM Die$(1:256)[255]                            ! V9
   DIM Mod$(1:256)[255]                            ! V10
   DIM Tst$(1:256)[255]                            ! V11
   DIM Mlib$(1:6)[255]                             ! V12
   DIM Tpl$[255]                                   ! V13
   Waf_dir$=V1$
   Prb_dir$=V2$
   Die_dir$=V3$
   Mod_dir$=V4$
   Tst_dir$=V5$
   Tpl_dir$=V6$
   Waf$=V7$
   Prb$=V8$
   MAT Die$= V9$
   MAT Mod$= V10$
   MAT Tst$= V11$
   MAT Mlib$= V12$
   Tpl$=V13$
 !***** DON'T REMOVE THIS LINE *************************************
   DIM Cmd$[32767],Opt$[32767],Opt_dir$[4096],Die_tst$(256)[256]
   DIM Tmpstr$[32767]
   DIM T$[256]
   INTEGER Cmd_ret
   INTEGER I,J,Die_dup
  !
   Ndetail=0
   IF Tpl$="" THEN 
     Status=-2
     Errmsg$="No test plan name is specified."
     SUBEXIT
   END IF
  !
   Rcp_dietst(Die$(*),Tst$(*),"",Die_tst$(*),Status,Errmsg$)
   IF Status<>0 THEN SUBEXIT
  !
   Rcp_mk_filename(Tpl_dir$,Tpl$,".tpl",T$)
  !
   ON ERROR GOSUB Str_overflow
   Cmd$="/opt/SPECS/sys/bin/tplbuild"
   Opt$=""
   IF Waf$<>"" THEN 
     Opt$=Opt$&" -waf "&Waf$
   END IF
   IF Prb$<>"" THEN 
     Opt$=Opt$&" -prb "&Prb$
   END IF
   I=1
   LOOP
   EXIT IF I>SIZE(Die$,1)
   EXIT IF Die$(I)=""
     Die_dup=0
     J=1
     LOOP
     EXIT IF J>=I
       IF Die$(I)=Die$(J) THEN Die_dup=1
     EXIT IF Die$(I)=Die$(J)
       J=J+1
     END LOOP
  !
     IF Die_dup=0 THEN 
       Opt$=Opt$&" -die "&Die$(I)
     END IF
     I=I+1
   END LOOP
   I=1
   LOOP
   EXIT IF I>SIZE(Mod$,1)
   EXIT IF Mod$(I)=""
     Opt$=Opt$&" -mod "&Mod$(I)
     I=I+1
   END LOOP
   I=1
   LOOP
   EXIT IF I>SIZE(Die_tst$,1)
   EXIT IF Die_tst$(I)=""
     Opt$=Opt$&" -tst "&Die_tst$(I)
     I=I+1
   END LOOP
   I=1
   Tmpstr$=""
   LOOP
   EXIT IF I>SIZE(Mlib$,1)
   EXIT IF Mlib$(I)=""
     IF I<>0 THEN 
       Tmpstr$=Tmpstr$&","
     END IF
     Tmpstr$=Tmpstr$&Mlib$(I)
     I=I+1
   END LOOP
   IF Tmpstr$<>"" THEN 
     Opt$=Opt$&" -m "&Tmpstr$
   END IF
  !
   Opt_dir$=""
   IF Waf_dir$<>"" THEN 
     Opt_dir$=Opt_dir$&" -wafpath "&Waf_dir$
   END IF
   IF Prb_dir$<>"" THEN 
     Opt_dir$=Opt_dir$&" -prbpath "&Prb_dir$
   END IF
   IF Die_dir$<>"" THEN 
     Opt_dir$=Opt_dir$&" -diepath "&Die_dir$
   END IF
   IF Mod_dir$<>"" THEN 
     Opt_dir$=Opt_dir$&" -modpath "&Mod_dir$
   END IF
   IF Tst_dir$<>"" THEN 
     Opt_dir$=Opt_dir$&" -tstpath "&Tst_dir$
   END IF
  !
   Cmd$=Cmd$&Opt$&Opt_dir$
   OFF ERROR 
   Rcp_exec_cmd(Cmd$,T$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status<0 THEN 
     GOSUB Remove_file
   END IF
  !
   SUBEXIT
  !
 Remove_file:    !
   ON ERROR GOTO Rm_end
   PURGE T$
 Rm_end:    !
   OFF ERROR 
   RETURN 
  !
 Str_overflow:   !
   Status=-1
   Errmsg$="Internal string buffer overflow."
   SUBEXIT
  !
 SUBEND
 Read_char:SUB Read_char(Format$,String$,Value$,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : READ_CHAR
 !  Vers : 1
 !  Desc : Reads a character from a STRING variable, and returns it
 !       : to a CHARACTER variable
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 String          S    -        String to read from
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Value           C    -        Read value
 !      2 Stat            I    -        1(ok), 0(no data), -1(EOF)
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Readchar(Format$,String$,Value$,Stat)
 SUBEND
 Read_equipid2:SUB Read_equipid2(File$,Equip_id$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : READ_EQUIPID2
 !  Vers : 1
 !  Desc : Read Equipment ID from File$ to Equip_id$
 !  Date : 03/19/2003
 !  Time : 16:15:22
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 File            S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Equip_id        S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                 !***** DON'T REMOVE THIS LINE *****
                                 !
   ON ERROR GOTO Err
   IF File$="" THEN 
     EXECUTE "hostname > /tmp/host "
     ASSIGN @Host TO "/tmp/host"
   ELSE
     ASSIGN @Host TO File$
   END IF
                                 !
   ENTER @Host USING "K";Equip_id$
   Equip_id$=TRIM$(Equip_id$)
   PRINT " Equipment ID : ";Equip_id$
   ASSIGN @Host TO *
   SUBEXIT
 Err:                               !
   PRINT "ERROR:";ERRM$
 SUBEND
 Read_integer:SUB Read_integer(Format$,String$,INTEGER Value,Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : READ_INTEGER
 !  Vers : 1
 !  Desc : Reads a value from a STRING variable, and returns it to a
 !       : n INTEGER variable
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 String          S    -        String to read from
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Value           I    -        Read value
 !      2 Stat            I    -        1(ok), 0(no data), -1(EOF)
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Readinteger(Format$,String$,Value,Stat)
 SUBEND
 Read_proccond:SUB Read_proccond(Filename$,INTEGER Ret,Readnum)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : READ_PROCCOND
 !  Vers : 1
 !  Desc : Read process condition file.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Filename        S    -        file name
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Ret             I    -        return code
 !      2 Readnum         I    -        the number of read condition
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Idx_tag
   DIM Name$[32]
   INTEGER Type,Dim,Size1,Size2
   INTEGER Cond_val_num,Cond_name_num
   DIM Line$[1025]
   INTEGER Find_header
   DIM Deli$[4]
   DIM Lot_id$[255],Wafer_id$[255],Value$[255]
   INTEGER Slot_no
   INTEGER Cond_no
   INTEGER Max_name_num
   INTEGER Line_num
  !
   Ret=0
   Deli$=","
   Max_name_num=10
  !
  ! check tag variable exists or not
   Tpltagindex("SYSTEM","TST_PROCCOND_VAL",Idx_tag)
   IF Idx_tag=-1 THEN 
     GOTO Other_err
   END IF
  !
  ! tag variable must be type of STRING[5][n]
   Tpltaginfo("SYSTEM",Idx_tag,Name$,Type,Dim,Size1,Size2)
   IF (Type<>3) OR (Dim<>2) OR (Size2<>5) THEN 
     GOTO Other_err
   END IF
  !
  ! open process condition file
   ON ERROR GOTO Nofile
   ASSIGN @File TO Filename$;FORMAT ON
   OFF ERROR 
  !
  ! allocate and initialize buffer
   ALLOCATE Conds$(Size2,Size1)[255]
   FOR I=1 TO Size2
     FOR J=1 TO Size1
       Conds$(I,J)=""
     NEXT J
   NEXT I
   ALLOCATE Names$(Max_name_num)[255]
  !
  ! ============
  !  main loop
  ! ============
  !
   Cond_val_num=0
   Cond_name_num=0
   Find_header=0
   Line_num=0
   ON END @File GOTO Eof
   LOOP
     ENTER @File;Line$
     Line_num=Line_num+1
  !
  !   !! skip empty line
     IF LEN(Line$)=0 THEN GOTO Loop_end
  !
  !   !! check if line length <= 1024
     IF LEN(Line$)=1025 THEN GOTO Bad_format
  !
  !   !! find header line (only 1st)
     IF Find_header=0 AND Line$[1;5]="#lot," THEN 
  !     !! skip 1st and 2nd element
       FOR I=1 TO 2
         Line$=Line$[POS(Line$,Deli$)+1]
       NEXT I
  !
  !     !! read condition names
       LOOP
       EXIT IF LEN(Line$)=0
         Strpos=POS(Line$,Deli$)
  !
  !       !! count up
         Cond_name_num=Cond_name_num+1
  !
  !       !! check max number of condition
         IF Cond_name_num>Max_name_num THEN GOTO Bad_format
  !
  !       !! hold condition name
         IF Strpos=0 THEN 
           Names$(Cond_name_num)=Line$
           Line$=""
         ELSE
           Names$(Cond_name_num)=Line$[1;Strpos-1]
           IF Strpos=LEN(Line$) THEN 
             Line$=""
           ELSE
             Line$=Line$[Strpos+1]
           END IF
         END IF
       END LOOP
  !     !! go to next line
       Find_header=1
       GOTO Loop_end
     END IF
  !
  !   !! skip comment line
     IF Line$[1;1]="#" THEN GOTO Loop_end
  !
  !   !!-------------
  !   !! valid line
  !   !!-------------
  !   !! lot ID
     Strpos=POS(Line$,Deli$)
     IF Strpos=0 THEN GOTO Bad_format
     Lot_id$=Line$[1;Strpos-1]
     IF Strpos=LEN(Line$) THEN GOTO Bad_format
     Line$=Line$[Strpos+1]
  !
  !   !! wafer ID
     Strpos=POS(Line$,Deli$)
     IF Strpos=0 THEN GOTO Bad_format
     Wafer_id$=Line$[1;Strpos-1]
     IF Strpos=LEN(Line$) THEN GOTO Bad_format
     Line$=Line$[Strpos+1]
  !
  !   !! find slot number
     Get_slot_no(Lot_id$,Wafer_id$,Slot_no)
     IF Slot_no=0 THEN GOTO Loop_end
  !
  !   !! read each condition value
     Cond_no=0
     LOOP
     EXIT IF LEN(Line$)=0
       Strpos=POS(Line$,Deli$)
  !
  !     !! count up counter
       Cond_val_num=Cond_val_num+1
       Cond_no=Cond_no+1
  !
  !     !! check limitation
       IF Cond_val_num>Size1 THEN GOTO Too_many
       IF Cond_no>Cond_name_num THEN GOTO Bad_format
  !
  !     !! get value
       IF Strpos=0 THEN 
         Value$=Line$
         Line$=""
       ELSE
         Value$=Line$[1;Strpos-1]
         IF Strpos=LEN(Line$) THEN 
           Line$=""
         ELSE
           Line$=Line$[Strpos+1]
         END IF
       END IF
  !
  !     !! set value
       Conds$(1,Cond_val_num)=VAL$(Slot_no)
       Conds$(2,Cond_val_num)=Lot_id$
       Conds$(3,Cond_val_num)=Wafer_id$
       Conds$(4,Cond_val_num)=Names$(Cond_no)
       Conds$(5,Cond_val_num)=Value$
  !
     END LOOP
  !
 Loop_end:    !
   END LOOP
  !
 Nofile:    !
   Ret=-1
   SUBEXIT
  !
 Bad_format:    !
   Ret=-2
   GOTO Eof
  !
 Too_many:    !
   Ret=-3
   GOTO Eof
  !
 Other_err:    !
   Ret=-4
   SUBEXIT
  !
 Eof:    !
   OFF END @File
  !
   ASSIGN @File TO *
  !
  ! !! set result
   Tplputsatag("SYSTEM",Idx_tag,0,Conds$(*))
   IF Ret=0 THEN Readnum=Cond_val_num
   IF Ret=-2 THEN Readnum=Line_num
  !
   DEALLOCATE Conds$(*)
   DEALLOCATE Names$(*)
  !
 SUBEND
 Read_real:SUB Read_real(Format$,String$,REAL Value,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : READ_REAL
 !  Vers : 1
 !  Desc : Reads a value from a STRING variable, and returns it to a
 !       :  REAL variable
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 String          S    -        String to read from
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Value           R    -        Read value
 !      2 Stat            I    -        1(ok), 0(no data), -1(EOF)
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Readreal(Format$,String$,Value,Stat)
 SUBEND
 Read_string:SUB Read_string(Format$,String$,Value$,INTEGER Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : READ_STRING
 !  Vers : 1
 !  Desc : Reads string data from a STRING variable, and returns it
 !       : to another STRING variable
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 String          S    -        String to read from
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Value           S    -        Read value
 !      2 Stat            I    -        1(ok), 0(no data), -1(EOF)
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Readstring(Format$,String$,Value$,Stat)
 SUBEND
 Real_to_str:SUB Real_to_str(REAL Rvalue,String$,Status$,Error$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : REAL_TO_STR
 !  Vers : 1
 !  Desc : Convert real number to string
 !  Date : 03/19/2003
 !  Time : 16:15:22
 !  User : wat
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Rvalue          R    -        Real Number
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 String          S    -        String requied to convert
 !      2 Status          S    -        "OK" or "ERROR"
 !      3 Error           S    -        Error message
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                 !***** DON'T REMOVE THIS LINE *****
   ON ERROR GOTO Conv_error
   REAL Inta
   Inta=Rvalue
   String$=VAL$(Inta)
   Status$="OK"
   Error$=""
   SUBEXIT
 Conv_error:OFF ERROR 
   PRINT ERRM$
   PRINT ERRN
   Status$="ERROR"
   Error$=ERRM$
   SUBEXIT
 SUBEND
 Save_tmpdata:SUB Save_tmpdata(Path$,Name$,Format$,Session$,INTEGER Stat,Error$,Pubname$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SAVE_TMPDATA
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Path            S    -
 !      2 Name            S    -
 !      3 Format          S    -
 !      4 Session         S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Stat            I    -        0: No temporary file exists 1: S
 !      2 Error           S    -
 !      3 Pubname         S    -        Official name
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpname$[256],Filename$[256],Orgdir$[256],Cmd$[256]
   INTEGER Serial,Last,Pos,Skipmove
  !
   Skipmove=0
   Error$=""
  !
   Orgdir$=SYSTEM$("MSI")
   ON ERROR GOTO No_path
   MASS STORAGE IS Path$
   GOTO Move_path
 No_path:                              !
   OFF ERROR 
   MASS STORAGE IS Orgdir$
   Stat=-1
   Error$="SAVE_TMPDATA: MASS STORAGE IS """&Path$&""",1 failed. ERRN="&VAL$(ERRN)
   PRINT Error$
   SUBEXIT
  !
 Move_path:                              !
   OFF ERROR 
  !
   Name_tmpdata(Name$,Session$,Tmpname$)
   Tmpname$=Tmpname$&"."&Format$
   ON ERROR GOTO Err
   Cmd$="ls \"&Tmpname$&" 2>/dev/null |"
   ASSIGN @Pipe TO Cmd$
   ON END @Pipe GOTO Eof_ls_tmp
   ENTER @Pipe;Filename$
 Eof_ls_tmp:                           !
   OFF END @Pipe
   ASSIGN @Pipe TO *
   OFF ERROR 
   IF Filename$="" THEN 
     Skipmove=1
   END IF
  !
 Scan_pub:                           !
   ON ERROR GOTO Err
   ASSIGN @Pipe TO "ls "&Name$&"_[0-9]*."&Format$&" |"
   ON END @Pipe GOTO Eof_ls_pub
   Last=0
   LOOP
     ENTER @Pipe;Filename$
     Filename$=REV$(Filename$)
     Pos=POS(Filename$,".")
     IF Pos>1 AND REV$(Filename$[1,Pos-1])=Format$ THEN 
       Filename$=Filename$[Pos+1]
       Pos=POS(Filename$,"_")
       IF Pos>1 THEN 
         Serial=VAL(REV$(Filename$[1,Pos-1]))
         IF Serial>Last THEN 
           Last=Serial
         END IF
       END IF
     END IF
   END LOOP
 Eof_ls_pub:                              !
   OFF END @Pipe
   ASSIGN @Pipe TO *
  !
   Last=Last+1
   Pubname$=Name$&"_"&VAL$(Last)
   IF Skipmove=1 THEN 
     GOTO Skip_mv
   END IF
   ASSIGN @Pipe TO "mv \"&Tmpname$&" "&Pubname$&"."&Format$&" 2>&1 |"
   ON END @Pipe GOTO Eof_mv
   ENTER @Pipe;Error$
   MASS STORAGE IS Orgdir$
   OFF END @Pipe
   ASSIGN @Pipe TO *
   OFF ERROR 
   Stat=-1
   PRINT Error$
   SUBEXIT
  !
 Eof_mv:                            !
   MASS STORAGE IS Orgdir$
   OFF END @Pipe
   ASSIGN @Pipe TO *
   OFF ERROR 
   Stat=1
   SUBEXIT
 Skip_mv:                           !
   MASS STORAGE IS Orgdir$
   Stat=1
   SUBEXIT
 Err:                              !
   OFF ERROR 
   MASS STORAGE IS Orgdir$
   Stat=-1
   Error$=ERRM$
   PRINT Error$
 SUBEND
 Set_brk_mod:SUB Set_brk_mod(INTEGER Typeindex,Dieindex,Modindex,Break)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_BRK_MOD
 !  Vers : 1
 !  Desc : Set judgement flag of specified module.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER)
 !      2 Dieindex        I    -        Die index in die type (DIE.NUMBE
 !      3 Modindex        I    -        Module index (MODULE.NUMBER)
 !      4 Break           I    -        Breakpoint flag.
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos
  !
   Tpldietype2pos(Typeindex-1,Dieindex-1,Diepos)
  !
   Tplgetbrkmod(Diepos,Modindex-1,Break)
 SUBEND
 Set_guard_open:SUB Set_guard_open(INTEGER Yes,Stat)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_GUARD_OPEN
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 08/03/2013
 !  Time : 16:45:05
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Yes             I    -        1:open(floating) 0:close
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Stat            I    -        0: OK  -1:Error
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1!***** DON'T REMOVE THIS LINE *****
   INTEGER On
   IF Yes=1 THEN 
     On=0
   ELSE
     On=1
   END IF
   ON ERROR RECOVER E
   CALL Gnd_open_guard(On)
   Stat=0
   SUBEXIT
 E: !
   OFF ERROR 
   Stat=-1
 SUBEND
 Set_jdg_die:SUB Set_jdg_die(INTEGER Typeindex,Dieindex,Judge,Offsetx,Offsety)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_JDG_DIE
 !  Vers : 1
 !  Desc : Set judgement flag of specified die.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER)
 !      2 Dieindex        I    -        Die index in die type (DIE.NUMBE
 !      3 Judge           I    -        Judgement value.
 !      4 Offsetx         I    -        Die X position offset.
 !      5 Offsety         I    -        Die Y position offset.
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos
  !
   IF Typeindex<=0 THEN 
     SUBEXIT
   END IF
   IF Dieindex<=0 THEN 
     SUBEXIT
   END IF
  !
   Tpldietype2pos(Typeindex-1,Dieindex-1,Diepos)
   IF Diepos<0 THEN 
     SUBEXIT
   END IF
  !
   Tplsetjdgdie(Diepos,Judge,Offsetx,Offsety)
 SUBEND
 Set_jdg_die_all:SUB Set_jdg_die_all(INTEGER Judge,Offsetx,Offsety)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_JDG_DIE_ALL
 !  Vers : 1
 !  Desc : Set judgement flag of all dice.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Judge           I    -         Judgement value
 !      2 Offsetx         I    -        Die X position offset.
 !      3 Offsety         I    -        Die Y position offset.
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos,Total
  !
   Tpldietotal(Total)
   IF Total<=0 THEN 
     SUBEXIT
   END IF
  !
   FOR Diepos=0 TO Total-1 STEP 1
     Tplsetjdgdie(Diepos,Judge,Offsetx,Offsety)
   NEXT Diepos
 SUBEND
 Set_jdg_die_typ:SUB Set_jdg_die_typ(INTEGER Typeindex,Judge,Offsetx,Offsety)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_JDG_DIE_TYP
 !  Vers : 1
 !  Desc : Set judgement flag of specified die type.
 !       :   SPECS2.5: Initial revision.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER)
 !      2 Judge           I    -        Judgement value.
 !      3 Offsetx         I    -        Die X position offset.
 !      4 Offsety         I    -        Die Y position offset.
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Typei,Diei,Diepos,Total
  !
   IF Typeindex<=0 THEN 
     SUBEXIT
   END IF
  !
   Tpldietotal(Total)
   IF Total<=0 THEN 
     SUBEXIT
   END IF
  !
   Diepos=-1
   REPEAT
     Diepos=Diepos+1
     IF Diepos>=Total THEN 
       SUBEXIT
     END IF
     Tpldiepos2type(Diepos,Typei,Diei)
   UNTIL Typei=Typeindex-1
  !
   WHILE Diepos<Total
     Tpldiepos2type(Diepos,Typei,Diei)
     IF Typei<>Typeindex-1 THEN 
       SUBEXIT
     END IF
     Tplsetjdgdie(Diepos,Judge,Offsetx,Offsety)
     Diepos=Diepos+1
   END WHILE
 SUBEND
 Set_samelen:SUB Set_samelen(Original$,Reference$,Modified$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_SAMELEN
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Original        S    -
 !      2 Reference       S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Modified        S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Length,Lenref
   Modified$=TRIM$(Original$)
   Length=LEN(Modified$)
   Lenref=LEN(Reference$)
   IF Length<Lenref THEN 
     Modified$=Modified$&RPT$(" ",Lenref-Length)
   END IF
   IF Length>Lenref THEN 
     Modified$=Modified$[1,Lenref]
   END IF
 SUBEND
 Set_samelen20:SUB Set_samelen20(Original$(*),Modified$(*))
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_SAMELEN20
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Original        S    20
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Modified        S    20
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Length,Maxlength,I
  !
   Maxlength=0
   FOR I=1 TO 20
     Modified$(I)=TRIM$(Original$(I))
     Length=LEN(Modified$(I))
     IF Length>Maxlength THEN 
       Maxlength=Length
     END IF
   NEXT I
  !
   FOR I=1 TO 20
     Length=LEN(Modified$(I))
     Modified$(I)=Modified$(I)&RPT$(" ",Maxlength-Length)
   NEXT I
 SUBEND
 Set_tag_char:SUB Set_tag_char(Name$,Value$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_TAG_CHAR
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Name            S    -
 !      2 Value           C    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Idx,Typ,Dim,Size1,Size2,I,J
   ON ERROR GOTO Err
   Tpltagindex("SYSTEM",Name$,Idx)
   IF Idx=-1 THEN 
     SUBEXIT
   END IF
   Tpltaginfo("SYSTEM",Idx,Name$,Typ,Dim,Size1,Size2)
   IF Typ<>2 THEN 
     SUBEXIT
   END IF
   SELECT Dim
   CASE 0
     Tplputctag("SYSTEM",Idx,0,Value$[1,1])
   CASE 1
     ALLOCATE Array$(Size1)[1]
     FOR I=1 TO Size1
       Array$(I)=Value$[1,1]
     NEXT I
     Tplputcatag("SYSTEM",Idx,0,Array$(*))
     DEALLOCATE Array$(*)
   CASE 2
     ALLOCATE Array2$(Size2,Size1)[1]
     FOR I=1 TO Size2
       FOR J=1 TO Size1
         Array2$(I,J)=Value$[1,1]
       NEXT J
     NEXT I
     Tplputcatag("SYSTEM",Idx,0,Array2$(*))
     DEALLOCATE Array2$(*)
   END SELECT
 Err:                                  !
   OFF ERROR 
 SUBEND
 Set_tag_integer:SUB Set_tag_integer(Name$,INTEGER Value)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_TAG_INTEGER
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Name            S    -
 !      2 Value           I    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Idx,Typ,Dim,Size1,Size2,I,J
   ON ERROR GOTO Err
   Tpltagindex("SYSTEM",Name$,Idx)
   IF Idx=-1 THEN 
     SUBEXIT
   END IF
   Tpltaginfo("SYSTEM",Idx,Name$,Typ,Dim,Size1,Size2)
   IF Typ<>1 THEN 
     SUBEXIT
   END IF
   SELECT Dim
   CASE 0
     Tplputitag("SYSTEM",Idx,0,Value)
   CASE 1
     ALLOCATE INTEGER Array(Size1)
     FOR I=1 TO Size1
       Array(I)=Value
     NEXT I
     Tplputiatag("SYSTEM",Idx,0,Array(*))
     DEALLOCATE Array(*)
   CASE 2
     ALLOCATE INTEGER Array2(Size2,Size1)
     FOR I=1 TO Size2
       FOR J=1 TO Size1
         Array2(I,J)=Value
       NEXT J
     NEXT I
     Tplputiatag("SYSTEM",Idx,0,Array2(*))
     DEALLOCATE Array2(*)
   END SELECT
 Err:                                  !
   OFF ERROR 
 SUBEND
 Set_tag_real:SUB Set_tag_real(Name$,REAL Value)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_TAG_REAL
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Name            S    -
 !      2 Value           R    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Idx,Typ,Dim,Size1,Size2,I,J
   ON ERROR GOTO Err
   Tpltagindex("SYSTEM",Name$,Idx)
   IF Idx=-1 THEN 
     SUBEXIT
   END IF
   Tpltaginfo("SYSTEM",Idx,Name$,Typ,Dim,Size1,Size2)
   IF Typ<>0 THEN 
     SUBEXIT
   END IF
   SELECT Dim
   CASE 0
     Tplputrtag("SYSTEM",Idx,0,Value)
   CASE 1
     ALLOCATE REAL Array(Size1)
     FOR I=1 TO Size1
       Array(I)=Value
     NEXT I
     Tplputratag("SYSTEM",Idx,0,Array(*))
     DEALLOCATE Array(*)
   CASE 2
     ALLOCATE REAL Array2(Size2,Size1)
     FOR I=1 TO Size2
       FOR J=1 TO Size1
         Array2(I,J)=Value
       NEXT J
     NEXT I
     Tplputratag("SYSTEM",Idx,0,Array2(*))
     DEALLOCATE Array2(*)
   END SELECT
 Err:                                  !
   OFF ERROR 
 SUBEND
 Set_tag_string:SUB Set_tag_string(Name$,Value$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SET_TAG_STRING
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Name            S    -
 !      2 Value           S    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Idx,Typ,Dim,Size1,Size2,I,J
   ON ERROR GOTO Err
   Tpltagindex("SYSTEM",Name$,Idx)
   IF Idx=-1 THEN 
     SUBEXIT
   END IF
   Tpltaginfo("SYSTEM",Idx,Name$,Typ,Dim,Size1,Size2)
   IF Typ<>3 THEN 
     SUBEXIT
   END IF
   SELECT Dim
   CASE 0
     Tplputstag("SYSTEM",Idx,0,Value$)
   CASE 1
     ALLOCATE Array$(Size1)[255]
     FOR I=1 TO Size1
       Array$(I)=Value$
     NEXT I
     Tplputsatag("SYSTEM",Idx,0,Array$(*))
     DEALLOCATE Array$(*)
   CASE 2
     ALLOCATE Array2$(Size2,Size1)[255]
     FOR I=1 TO Size2
       FOR J=1 TO Size1
         Array2$(I,J)=Value$
       NEXT J
     NEXT I
     Tplputsatag("SYSTEM",Idx,0,Array2$(*))
     DEALLOCATE Array2$(*)
   END SELECT
 Err:                                  !
   OFF ERROR 
 SUBEND
 Setusrbin_lpbgn:SUB Setusrbin_lpbgn(INTEGER Waftgt,Lottgt)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SETUSRBIN_LPBGN
 !  Vers : 1
 !  Desc : Initializes "user bin" condition.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Waftgt          I    -        Wafer-level yield target.
 !      2 Lottgt          I    -        Lot-level yield target.
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Outcount                 ! Output variable total
   INTEGER Type,Dim,S1,S2           ! Variable information
   INTEGER Bin(11)                  ! Bin
   INTEGER Binc,Limc,Limtmp         !
   INTEGER Lolim(5),Uplim(5)        ! Limit index
   INTEGER I,J
   REAL Lim(10)                     ! Limit value
   DIM Name$[256]
   ON ERROR GOTO Errored
  !
   Tploutcount(Outcount)
   FOR I=0 TO Outcount-1
     Tploutinfo(I,Name$,Type,Dim,S1,S2)
     IF (Type<>0 OR Type<>1) AND Dim=0 THEN 
       Tplgetwafbin(I,Binc,Lim(*),Bin(*),Limc)
       Limtmp=Limc DIV 2
       IF (Limc MOD 2)=0 THEN 
         FOR J=1 TO Limtmp
           Lolim(J)=Limtmp-J+1
           Uplim(J)=Limtmp+J
         NEXT J
       ELSE
         FOR J=1 TO Limtmp
           Lolim(J)=Limtmp-J+1
           Uplim(J)=Limtmp+J+1
         NEXT J
       END IF
       Tplsetusrbin(I,Limtmp,Lolim(*),Uplim(*),1,Limtmp,Waftgt,Lottgt)
     END IF
   NEXT I
 Errored: !
 SUBEND
 Sizeofdisplay:SUB Sizeofdisplay(INTEGER Width,Height)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : SIZEOFDISPLAY
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Width           I    -
 !      2 Height          I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Wid$[16],Hei$[16]
  !
   ASSIGN @Pipe TO "/opt/SPECS/sys/bin/xrootsize |"
   ENTER @Pipe;Wid$
   ENTER @Pipe;Hei$
   ASSIGN @Pipe TO *
   Width=INT(VAL(TRIM$(Wid$)))
   Height=INT(VAL(TRIM$(Hei$)))
 SUBEND
 Statlog_dieend:SUB Statlog_dieend(Filename$,INTEGER Mode)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : STATLOG_DIEEND
 !  Vers : 1
 !  Desc : logs statistics on the specified file. This users user bi
 !       : n.
 !       :
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Filename        S    -        Filename.
 !      2 Mode            I    -        All(0), Failed only(1)
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Diepos,Diex,Diey            ! Current die position
   INTEGER Windex                      ! System variable index
   INTEGER Mini,Maxi                   ! Output variable range
   INTEGER Type,Dim,S1,S2              ! Variable information
   INTEGER Outjudge                    ! Pass=1,Fail=0,Invalid=2
   INTEGER Bin(6)                      ! Binning limit
   INTEGER Bc,Num,Den                  ! Statical calculation condition
   INTEGER I
   INTEGER Ival                        ! Integer-type output value
   REAL Lolim(6),Uplim(6)              ! Limit
   REAL Mean,Stdv,Minval,Maxval        ! Statistics
   REAL Rval                           ! Real-type output value
   DIM Wafid$[256]                     ! Wafer ID
   DIM Outname$[256]                   ! Output variable name
   DIM Sp$[8],Info$[1024]
  !
   ON ERROR GOTO Errored
   Sp$=CHR$(9)
   Tpldiepos(Diepos)
   Tpldieinfo(Diepos,Diex,Diey)
   IF Diepos=0 THEN 
     ON ERROR GOTO No_file
     PURGE Filename$
 No_file: !
     OFF ERROR 
   END IF
   ON ERROR GOTO Exist
   CREATE Filename$,1
   EXECUTE "chmod 666 "&Filename$
 Exist: !
   ON ERROR GOTO Errored
   ASSIGN @File TO Filename$;FORMAT ON,APPEND
   ON ERROR GOTO Endalg
  !
   Tpltagindex("WAFER","SYS_WAFERID",Windex)
   Tplgetstag("WAFER",Windex,Diepos,Wafid$)
   Tplgetrangedie(Diepos,Mini,Maxi)
   IF Mini<0 OR Maxi<0 THEN Endalg
  !
   I=Mini
   FOR I=Mini TO Maxi
     Tploutinfo(I,Outname$,Type,Dim,S1,S2)
     Tploutjudge(I,Diepos,Outjudge)
     Tplgetwafubin(I,Bc,Lolim(*),Uplim(*),Bin(*),Num,Den)
     IF (Dim=0) AND (Mode=0 OR Outjudge=0) AND (Bc>0) THEN 
       Tplmodulelabel(I,Modlabel$)
       Tpldevicelabel(I,Devlabel$)
       Tplgetwafustat(I,Den,Mean,Stdv,Minval,Maxval)
       OUTPUT @File USING "#,K";Wafid$;Sp$;Diex;Sp$;Diey;Sp$;Modlabel$;Sp$
       OUTPUT @File USING "#,K";Devlabel$;Sp$;Outname$;Sp$
       SELECT (Type)
       CASE 0
         Tplgetrout(I,Diepos,Rval)
         OUTPUT @File USING "#,SD.3DE";Rval
       CASE 1
         Tplgetiout(I,Diepos,Ival)
         OUTPUT @File USING "#,K";Ival
       CASE ELSE
       END SELECT
       OUTPUT @File USING "-,K,SD.4DE,K,SD.3DE,K,SD.3DE,K,SD.3DE";Sp$;Minval;Sp$;Maxval;Sp$;Mean;Sp$;Stdv
     END IF
   NEXT I
   ASSIGN @File TO *
   OFF ERROR 
   SUBEXIT
  !
 Endalg: !
   OFF ERROR 
   OUTPUT @File USING "-,K";Sp$
   ASSIGN @File TO *
   SUBEXIT
 Errored: !
   OFF ERROR 
 SUBEND
 String_lookup:SUB String_lookup(Src$,Pat$,INTEGER Pos)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : STRING_LOOKUP
 !  Vers : 1
 !  Desc : Returns the position of specified character(s) in a STRIN
 !       : G variable
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Src             S    -        Source string
 !      2 Pat             S    -        Pattern string
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Pos             I    -        Position (>0 position, 0 not fou
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Pos=POS(Src$,Pat$)
 SUBEND
 String_split:SUB String_split(Src$,Del$,Elem$(*),INTEGER Count)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : STRING_SPLIT
 !  Vers : 1
 !  Desc : Returns data (without separators) from a STRING variable,
 !       :  which contains data separated by data separators
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Src             S    -        Source string
 !      2 Del             S    -        Delimiter
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Elem            S    128      Substrings
 !      2 Count           I    -        Number of substrings
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM S$[511]
   INTEGER P,D
   S$=Src$&Del$
   D=LEN(Del$)
   Count=1
   P=POS(S$,Del$)
   IF P>=1 THEN 
     WHILE P>0
       Elem$(Count)=S$[1,P-1]
       S$=S$[P+D]
       P=POS(S$,Del$)
       Count=Count+1
     END WHILE
     Count=Count-1
   ELSE
     Count=1
   END IF
 SUBEND
 String_time:SUB String_time(REAL Time,Symbol$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : STRING_TIME
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Time            R    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Symbol          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   REAL Hour,Minu,Seco
   DIM Buf$[2]
   Hour=INT(Time/3600)
   Time=Time-3600*Hour
   Minu=INT(Time/60)
   Time=Time-60*Minu
   Seco=INT(Time)
   Symbol$=VAL$(Hour)&":"
   Buf$=VAL$(Minu)
   IF LEN(Buf$)=1 THEN Symbol$=Symbol$&"0"
   Symbol$=Symbol$&Buf$&":"
   Buf$=VAL$(Seco)
   IF LEN(Buf$)=1 THEN Symbol$=Symbol$&"0"
   Symbol$=Symbol$&Buf$
 SUBEND
 Timedate:SUB Timedate(INTEGER Digit,Date$,Time$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : TIMEDATE
 !  Vers : 1
 !  Desc : Returns the present date and time
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Digit           I    -        # digits to represent a year
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Date            S    -        mm/dd/yy or mm/dd/yyyy
 !      2 Time            S    -        hh:mm:ss
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF Digit=4 THEN 
     ASSIGN @Pipe TO "date +'%m/%d/%C%y'; date '+%H:%M:%S' |"
   ELSE
     ASSIGN @Pipe TO "date +'%m/%d/%y'; date '+%H:%M:%S' |"
   END IF
   ENTER @Pipe;Date$
   ENTER @Pipe;Time$
   ASSIGN @Pipe TO *
 SUBEND
 Update_fwkconf:SUB Update_fwkconf(File$,INTEGER Type,Errno,Errmsg$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : UPDATE_FWKCONF
 !  Vers : 1
 !  Desc : Store current configuration parameters.
 !       :   SPECS2.5: Added type parameter.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 File            S    -
 !      2 Type            I    -        0:All vars, 1:Normal vars only,
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Errno           I    -
 !      2 Errmsg          S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Line$[8196],Org$[8196],Symbol$[8196],Value$[8196],Name$[32],Tmpfile$[256],Bakfile$[256],Src$[256]
   INTEGER P_col,P_exc,I                                                       !":", "!"
   INTEGER Idx_tag,Idx_dim1,Typ,Dim,Size1,Size2,Length
   INTEGER Int0
   REAL Real0
   DIM Str0$[255],Char0$[1]
  !
   Errno=0
   Errmsg$=""
   Tmpfile$=File$&".tmp"
   Bakfile$=File$&"~"
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:                  !
   IF ERRN<>56 THEN                    ! File name is undefined
     Errno=ERRN
     Errmsg$=ERRM$
     SUBEXIT
   END IF
  !
   ON ERROR GOTO Err
   CREATE Tmpfile$,1
   ASSIGN @Fwkconf TO File$;FORMAT ON
   PRINTER IS Tmpfile$
   ON END @Fwkconf GOTO Eof
  !
   LOOP
     Symbol$=""
     Value$=""
  !
     ENTER @Fwkconf;Line$
     Org$=Line$
     Line$=TRIM$(Line$)
     P_exc=POS(Line$,"!")
     SELECT P_exc
     CASE 0
     CASE 1
       Line$=""
     CASE ELSE
       Line$=Line$[1,P_exc-1]
     END SELECT
  !
     P_col=POS(Line$,":")
     IF P_col>=2 THEN 
       Symbol$=Line$[1,P_col-1]
       Symbol$=TRIM$(Symbol$)
       IF Symbol$<>"" AND LEN(Line$)>P_col THEN 
         Value$=Line$[P_col+1,LEN(Line$)]
         Value$=TRIM$(Value$)
       END IF
     END IF
  !
     IF Symbol$<>"" THEN 
       IF (Type=1 AND Symbol$[1,1]="*") OR (Type=2 AND Symbol$[1,1]<>"*") THEN 
         Symbol$=Org$
       ELSE
         IF Symbol$[1,1]="*" THEN 
           Src$=Symbol$[2,LEN(Symbol$)]
         ELSE
           Src$=Symbol$
         END IF
  !
         Line$=""
         Tpltagindex("SYSTEM",Src$,Idx_tag)
         IF Idx_tag=-1 THEN 
           Errno=1
           Errmsg$=Src$&" is not defined as TAG variable"
           GOTO Eof
         END IF
         Tpltaginfo("SYSTEM",Idx_tag,Name$,Typ,Dim,Size1,Size2)
         Line$=Symbol$&":"
         IF Dim=0 THEN 
           SELECT Typ
           CASE 0
             Tplgetrtag("SYSTEM",Idx_tag,0,Real0)
             Line$=Line$&VAL$(Real0)
           CASE 1
             Tplgetitag("SYSTEM",Idx_tag,0,Int0)
             Line$=Line$&VAL$(Int0)
           CASE 2
             IF LEN(Value$)>0 THEN 
               Tplgetctag("SYSTEM",Idx_tag,0,Char0$)
               Line$=Line$&Char0$
             END IF
           CASE 3
             Tplgetstag("SYSTEM",Idx_tag,0,Str0$)
             Line$=Line$&Str0$
           END SELECT
         END IF
         IF Dim=1 THEN 
           SELECT Typ
           CASE 0
             ALLOCATE REAL Real1(Size1)
             Tplgetratag("SYSTEM",Idx_tag,0,Real1(*))
             Line$=Line$&VAL$(Real1(1))
             FOR I=2 TO Size1-1
               Line$=Line$&","&VAL$(Real1(I))
             NEXT I
             IF Size1>1 THEN 
               Line$=Line$&","&VAL$(Real1(Size1))
             END IF
             DEALLOCATE Real1(*)
           CASE 1
             ALLOCATE INTEGER Int1(Size1)
             Tplgetiatag("SYSTEM",Idx_tag,0,Int1(*))
             Line$=Line$&VAL$(Int1(1))
             FOR I=2 TO Size1-1
               Line$=Line$&","&VAL$(Int1(I))
             NEXT I
             IF Size1>1 THEN 
               Line$=Line$&","&VAL$(Int1(Size1))
             END IF
             DEALLOCATE Int1(*)
           CASE 2
             ALLOCATE Char1$(Size1)[1]
             Tplgetcatag("SYSTEM",Idx_tag,0,Char1$(*))
             Line$=Line$&Char1$(1)
             FOR I=2 TO Size1-1
               Line$=Line$&","&Char1$(I)
             NEXT I
             IF Size1>1 THEN 
               Line$=Line$&","&Char1$(Size1)
             END IF
             DEALLOCATE Char1$(*)
           CASE 3
             ALLOCATE Str1$(Size1)[255]
             Tplgetsatag("SYSTEM",Idx_tag,0,Str1$(*))
             Line$=Line$&Str1$(1)
             FOR I=2 TO Size1-1
               Line$=Line$&","&Str1$(I)
             NEXT I
             IF Size1>1 THEN 
               Line$=Line$&","&Str1$(Size1)
             END IF
             DEALLOCATE Str1$(*)
           END SELECT
         END IF
         IF Dim=2 THEN 
           SELECT Typ
           CASE 0
             ALLOCATE REAL Real1(Size1*Size2)
             Tplgetratag("SYSTEM",Idx_tag,0,Real1(*))
             Counter=0
             FOR J=1 TO Size2
               FOR I=1 TO Size1
                 Counter=Counter+1
                 IF Counter=1 THEN 
                   Line$=Line$&VAL$(Real1(Counter))
                 ELSE
                   Line$=Line$&","&VAL$(Real1(Counter))
                 END IF
               NEXT I
             NEXT J
             DEALLOCATE Real1(*)
           CASE 1
             ALLOCATE INTEGER Int1(Size1*Size2)
             Tplgetiatag("SYSTEM",Idx_tag,0,Int1(*))
             Counter=0
             FOR J=1 TO Size2
               FOR I=1 TO Size1
                 Counter=Counter+1
                 IF Counter=1 THEN 
                   Line$=Line$&VAL$(Int1(Counter))
                 ELSE
                   Line$=Line$&","&VAL$(Int1(Counter))
                 END IF
               NEXT I
             NEXT J
             DEALLOCATE Int1(*)
           CASE 2
             ALLOCATE Char1$(Size1*Size2)[1]
             Tplgetcatag("SYSTEM",Idx_tag,0,Char1$(*))
             Counter=0
             FOR J=1 TO Size2
               FOR I=1 TO Size1
                 Counter=Counter+1
                 IF Counter=1 THEN 
                   Line$=Line$&Char1$(Counter)
                 ELSE
                   Line$=Line$&","&Char1$(Counter)
                 END IF
               NEXT I
             NEXT J
             DEALLOCATE Char1$(*)
           CASE 3
             ALLOCATE Str1$(Size1*Size2)[255]
             Tplgetsatag("SYSTEM",Idx_tag,0,Str1$(*))
             Counter=0
             FOR J=1 TO Size2
               FOR I=1 TO Size1
                 Counter=Counter+1
                 IF Counter=1 THEN 
                   Line$=Line$&Str1$(Counter)
                 ELSE
                   Line$=Line$&","&Str1$(Counter)
                 END IF
               NEXT I
             NEXT J
             DEALLOCATE Str1$(*)
           END SELECT
         END IF
       END IF
     ELSE
       Line$=Org$
     END IF
  !
     PRINT Line$
   END LOOP
 Eof:                   !                    !
   PRINTER IS CRT
   ASSIGN @Fwkconf TO *
  !
   ON ERROR GOTO No_bckfile
   PURGE Bakfile$
 No_bckfile:                  !
   IF ERRN<>56 THEN                    ! File name is undefined
     Errno=ERRN
     Errmsg$=ERRM$
     SUBEXIT
   END IF
  !
   ON ERROR GOTO Err
   COPY File$ TO Bakfile$
   PURGE File$
   EXECUTE "/opt/SPECS/sys/bin/dos2unix.sh "&File$&".tmp "&File$
   PURGE Tmpfile$
   SUBEXIT
 Err:                           !
   PRINTER IS CRT
   ASSIGN @Fwkconf TO *
   Errno=ERRN
   Errmsg$=ERRM$
 SUBEND
 Verify_file:SUB Verify_file(Filename$,Type$,INTEGER Exist,Readable,Writable,Executable)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : VERIFY_FILE
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Filename        S    -
 !      2 Type            S    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Exist           I    -
 !      2 Readable        I    -
 !      3 Writable        I    -
 !      4 Executable      I    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Dumfile$[32]
   DIM Mode$[11],Usr_own$[256],Grp_own$[256],Usr_file$[256],Grp_file$[256]
  !
  ! Check mode of target file
  !
   Exist=0
   Readable=0
   Writable=0
   Executable=0
   ON ERROR GOTO Err
   ASSIGN @Pipe TO "ls -l -d "&Filename$&" 2>/dev/null | cut -c -10 |"
   ON END @Pipe GOTO Nomode
   ENTER @Pipe;Mode$
   GOTO Check_file
 Nomode:   !
   OFF END @Pipe
   OFF ERROR 
   PRINT "VERIFY_FILE ERROR: "&Filename$&" is not accessible."
   SUBEXIT
  !
 Check_file:   !
   OFF END @Pipe
   OFF ERROR 
  !
   SELECT Type$
   CASE "Normal"
     IF Mode$[1,1]<>"-" AND Mode$[1,1]<>"l" THEN SUBEXIT
   CASE "Directory"
     IF Mode$[1,1]<>"d" THEN SUBEXIT
   CASE "Special"
     IF Mode$[1,1]="-" OR Mode$[1,1]="l" OR Mode$[1,1]="d" THEN SUBEXIT
   END SELECT
  !
   Exist=1
  !
  ! Check user/group of target file
  !
   IF Type$="Directory" THEN 
     ASSIGN @Pipe TO "ls -l -d "&Filename$&"| awk '{print $3}'|"
     ENTER @Pipe;Usr_file$
     ASSIGN @Pipe TO "ls -l -d "&Filename$&"| awk '{print $4}'|"
     ENTER @Pipe;Grp_file$
   ELSE
     ASSIGN @Pipe TO "ls -l "&Filename$&"| awk '{print $3}'|"
     ENTER @Pipe;Usr_file$
     ASSIGN @Pipe TO "ls -l "&Filename$&"| awk '{print $4}'|"
     ENTER @Pipe;Grp_file$
   END IF
   OFF ERROR 
  !
  ! Check user/group of myself
  !
   Dumfile$="/var/tmp/VERIFY"&SYSTEM$("PROCESS ID")    ! AVPATH_
   ON ERROR GOTO Ignore
   PURGE Dumfile$
 Ignore:                                  !
   ON ERROR GOTO Err
   CREATE Dumfile$,1
   ASSIGN @Pipe TO "ls -l "&Dumfile$&"| awk '{print $3}'|"
   ENTER @Pipe;Usr_own$
   ASSIGN @Pipe TO "ls -l "&Dumfile$&"| awk '{print $4}'|"
   ENTER @Pipe;Grp_own$
   PURGE Dumfile$
   OFF ERROR 
  !
   IF Usr_own$=Usr_file$ THEN 
     IF Mode$[2,2]="r" THEN Readable=1
     IF Mode$[3,3]="w" THEN Writable=1
     IF Mode$[4,4]="x" OR Mode$[4,4]="s" THEN Executable=1
   ELSE
     IF Grp_own$=Grp_file$ THEN 
       IF Mode$[5,5]="r" THEN Readable=1
       IF Mode$[6,6]="w" THEN Writable=1
       IF Mode$[7,7]="x" OR Mode$[7,7]="s" THEN Executable=1
     ELSE
       IF Mode$[8,8]="r" THEN Readable=1
       IF Mode$[9,9]="w" THEN Writable=1
       IF Mode$[10,10]="x" OR Mode$[10,10]="t" THEN Executable=1
     END IF
   END IF
   SUBEXIT
 Err:   !
   PRINT "VERIFY_FILE ERROR: "&ERRM$
   OFF END @Pipe
   OFF ERROR 
 SUBEND
 Wait:SUB Wait(REAL Wait)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : WAIT
 !  Vers : 1
 !  Desc : Waits for the speicifed duration
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Wait            R    -
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   WAIT Wait
 SUBEND
 Write_char:SUB Write_char(Format$,Value$,String$,INTEGER Length)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : WRITE_CHAR
 !  Vers : 1
 !  Desc : Writes a CHARACTER value to a STRING variable
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 Value           C    -        Value to convert
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 String          S    -        Formatted to string
 !      2 Length          I    -        Length of string
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Writechar(Format$,Value$,String$,Length)
 SUBEND
 Write_integer:SUB Write_integer(Format$,INTEGER Value,String$,INTEGER Length)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : WRITE_INTEGER
 !  Vers : 1
 !  Desc : Writes an INTEGER value to a STRING variable
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 Value           I    -        Value to convert
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 String          S    -        Formatted to string
 !      2 Length          I    -        Length of string
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Writeinteger(Format$,Value,String$,Length)
 SUBEND
 Write_real:SUB Write_real(Format$,REAL Value,String$,INTEGER Length)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : WRITE_REAL
 !  Vers : 1
 !  Desc : Writes a REAL value to a STRING variable
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 Value           R    -        Value to convert
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 String          S    -        Formatted to string
 !      2 Length          I    -        Length of string
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Writereal(Format$,Value,String$,Length)
 SUBEND
 Write_string:SUB Write_string(Format$,Value$,String$,INTEGER Length)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : WRITE_STRING
 !  Vers : 1
 !  Desc : Writes a STRING value to a STRING variable
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Format          S    -        Format string
 !      2 Value           S    -        Value to convert
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 String          S    -        Formatted to string
 !      2 Length          I    -        Length of string
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Writestring(Format$,Value$,String$,Length)
 SUBEND
 Write_wafer_sum:SUB Write_wafer_sum(INTEGER Slot,Lot$,Wafer$,REAL Yld_item,Yld_die,INTEGER Judge,Summary$)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : WRITE_WAFER_SUM
 !  Vers : 1
 !  Desc : Description for this Algorithm spec.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Slot            I    -
 !      2 Lot             S    -
 !      3 Wafer           S    -
 !      4 Yld_item        R    -
 !      5 Yld_die         R    -
 !      6 Judge           I    -
 !
 !  Output Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Output Parameters:
 !      1 Summary         S    -
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Length
   DIM Yield$[255]
  ! Slot
   Summary$=" "&VAL$(Slot)
   Summary$=Summary$&RPT$(" ",10-LEN(Summary$))
  ! Lot ID
   IF LEN(Lot$)>24 THEN 
     Lot$=Lot$[1,24]
   END IF
   Summary$=Summary$&Lot$
   Summary$=Summary$&RPT$(" ",35-LEN(Summary$))
  !
   IF LEN(Wafer$)>10 THEN 
     Wafer$=Wafer$[1,10]
   END IF
   Summary$=Summary$&Wafer$
   Summary$=Summary$&RPT$(" ",46-LEN(Summary$))
  !
   IF Judge<0 THEN 
     SUBEXIT
   END IF
  !
   Writereal("%5.2f",Yld_item,Yield$,Length)
   IF LEN(Yield$)>10 THEN 
     Yield$=Yield$[1,10]
   END IF
   Summary$=Summary$&Yield$
   Summary$=Summary$&RPT$(" ",57-LEN(Summary$))
  !
   Writereal("%5.2f",Yld_die,Yield$,Length)
   IF LEN(Yield$)>10 THEN 
     Yield$=Yield$[1,10]
   END IF
   Summary$=Summary$&Yield$
   Summary$=Summary$&RPT$(" ",68-LEN(Summary$))
  !
   SELECT Judge
   CASE 0
     Summary$=Summary$&"Fail"
   CASE 1
     Summary$=Summary$&"Pass"
   END SELECT
 SUBEND
 Xwud:SUB Xwud(File$,INTEGER Xpos,Ypos,Noclick)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : XWUD
 !  Vers : 1
 !  Desc : Executes the xwud(1) command to display a window image, w
 !       : hich is stored in the specified dump file
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 File            S    -        xwd dump file (see xwd(1))
 !      2 Xpos            I    -        X position
 !      3 Ypos            I    -        Y position
 !      4 Noclick         I    -        1 to ignore mouse click
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Str$[80],Click$[80]
   Pos$="+"&VAL$(Xpos)&"+"&VAL$(Ypos)
   IF Noclick=1 THEN Click$=" -noclick"
   Str$=" -in "&File$&" -geometry "&Pos$&Click$
   EXECUTE "/usr/bin/X11/xwud "&Str$&" &"
 SUBEND
 Yieldlog_wafend:SUB Yieldlog_wafend(Filename$,INTEGER Dieyield)
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Type : Algorithm
 !  Name : YIELDLOG_WAFEND
 !  Vers : 1
 !  Desc : Logs yield on the specified file. This uses user bin.
 !  Date : 11/15/2006
 !  Time : 03:40:00
 !  User : root
 !
 !***** DON'T REMOVE THIS LINE *************************************
 !
 !  Input Variables:
 !
 !     #  Name            Type Size     Description
 !    --- --------------- ---- -------- --------------------------------
 !    Measurement Parameters:
 !      1 Filename        S    -        Filename.
 !      2 Dieyield        I    -        Die yield target value.
 !
 !  Output Variables:
 !
 !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Windex                      ! System variable index
   INTEGER Dietotal                    ! Total # of die
   INTEGER Itemtotal                   ! Total # of output variable
   INTEGER Itemyield                   ! Item yield
   INTEGER Target,Yield,Judge          ! Yield and Pass/Fail
   INTEGER Diepass,Diefail             ! Die count
   INTEGER Dieyldrslt                  ! Calculated die yield
   INTEGER Wafnum                      ! Wafer number
   INTEGER Mini,Maxi
   INTEGER I,J
   DIM Wafid$[256]                     ! Wafer ID
   DIM Jdg$[256],Sp$[8]
  !
   ON ERROR GOTO Errored
  !
   Sp$=CHR$(9)
   Tpltagindex("WAFER","SYS_WAFERID",Windex)
   Tplgetstag("WAFER",Windex,0,Wafid$)
   Tpldietotal(Dietotal)
   Tploutcount(Itemtotal)
  !
   Itemyield=100
   FOR I=0 TO Itemtotal-1
     Tplgetwafjudge(I,Target,Yield,Judge)
     IF Yield<Itemyield THEN 
       Itemyield=Yield
     END IF
   NEXT I
  !
   Diepass=0
   Diefail=0
   Dieyldrslt=100
   FOR I=0 TO Dietotal-1
     F=0
     Tplgetrangedie(I,Mini,Maxi)
     FOR J=Mini TO Maxi
       Tploutjudge(J,I,Judge)
       IF Judge=0 THEN 
         F=1
       END IF
     NEXT J
     IF F=1 THEN 
       Diefail=Diefail+1
     ELSE
       Diepass=Diepass+1
     END IF
   NEXT I
   IF Diepass+Diefail>0 THEN 
     Dieyldrslt=(Diepass*100)/(Diepass+Diefail)
   END IF
   IF Dieyldrslt>=Dieyield THEN 
     Jdg$="PASS"
   ELSE
     Jdg$="FAIL!!"
   END IF
  !
   Tplsysindex("WAFER","NUMBER",Windex)
   Tplgetisys("WAFER",Windex,Wafnum)
   IF Wafnum=1 THEN 
     ON ERROR GOTO No_file
     PURGE Filename$
 No_file: !
     OFF ERROR 
   END IF
   ON ERROR GOTO Exist
   CREATE Filename$,1
   EXECUTE "chmod 666 "&Filename$
 Exist: !
   ASSIGN @File TO Filename$;FORMAT ON,APPEND
   ON ERROR GOTO Endalg
   OUTPUT @File USING "-,K";Wafid$;Sp$;Itemyield;Sp$;Dieyldrslt;Sp$;Jdg$
   ASSIGN @File TO Filename$
   OFF ERROR 
   SUBEXIT
 Endalg: !
   OFF ERROR 
   ASSIGN @File TO *
   SUBEXIT
 Errored: !
   OFF ERROR 
 SUBEND
 Algo_tail:SUB Algo_tail !**** DON'T REMOVE THIS SUBPROGRAM ****
 SUBEND
 Direct_algo:SUB Direct_algo
   COM /Intprt4/ INTEGER Slcted,Logging
   DIM Algoname$[256]
   INTEGER Numrpt
     !
   ON ERROR CALL Dir_err_handler
   ON SIGNAL 6 RECOVER Dir_loop_head     ! Dir_err_handler generates SIGNAL 6
   Slcted=0
   Logging=1
     !
 Dir_loop_head:  !
   PRINTER IS CRT
   LOOP
     Select_algo(Algoname$)      ! Select algorithm to execute directly
   EXIT IF Algoname$=""
     Set_input(Algoname$)        ! Set input/device parameters
     Set_term(Algoname$)         ! Set terminal number
     Set_repeat(Numrpt)          ! Set number to repeat
     IF Numrpt>0 THEN 
         ! Execute and show result
       Exec_and_show(Algoname$,Numrpt)
       Wait_action
     END IF
   END LOOP
 SUBEND
   !
 Select_algo:SUB Select_algo(Name$)
   OPTION BASE 1
   COM /Intprt4/ INTEGER Slcted,Logging
   DIM Algoname$(1024)[256],Ans$[256]
   DIM Return$[20],Logon$[20],Logoff$[20],Prev$[20],Next$[20],Log_or_meas$[20]
   INTEGER Number,Top,Paging,Loop_exit
     !
     ! Number: Indicates number of algorithm. Return value from Get_alg_all.
     ! Slcted: User specified algorithm number.
     ! Top: Indicates the first position of array items to be shown.
     ! Paging: 0 No paging
     !         1 Both direction (+/-)
     !         2 Next only (+)
     !         3 Previous only (-)
     ! Loop_exit: Flag
     !
   Return$="0 Return to BASIC/UX"
   Logon$="% Logging (ON)"
   Logoff$="% Logging (OFF)"
   Meas$="% Execution time"
   Prev$="- Previous"
   Next$="+ Next"
     !
   Get_alg_all(Algoname$(*),Number)
   Top=1
   LOOP
       !
       ! Decide paging mode
       !
     IF Number>60 THEN 
       IF Top<61 THEN 
         Paging=2
       ELSE
         IF Number-Top<60 THEN 
           Paging=3
         ELSE
           Paging=1
         END IF
       END IF
     ELSE
       Paging=0
     END IF
       !
     IF Logging=1 THEN 
       Log_or_meas$=Logon$
     ELSE
       Log_or_meas$=Logoff$
     END IF
       !
     PRINT TAB(1);"[Algorithm List]"
     PRINT 
     SELECT Paging
     CASE 0
       PRINT TAB(1);Return$,TAB(26);Log_or_meas$
       PRINT 
       Show_algo(Algoname$(*),Top,Number)
       PRINT 
     CASE 1
       PRINT TAB(1);Return$,TAB(26);Log_or_meas$,TAB(41);Next$,TAB(61);Prev$
       PRINT 
       Show_algo(Algoname$(*),Top,Top+59)
       PRINT 
     CASE 2
       PRINT TAB(1);Return$,TAB(26);Log_or_meas$,TAB(41);Next$
       PRINT 
       Show_algo(Algoname$(*),Top,Top+59)
       PRINT 
     CASE 3
       PRINT TAB(1);Return$,TAB(26);Log_or_meas$,TAB(41);Prev$
       PRINT 
       Show_algo(Algoname$(*),Top,Number)
       PRINT 
     END SELECT
       !
     Loop_exit=0
 Input_num:  !
     OUTPUT KBD;VAL$(Slcted);
     INPUT "Enter algorithm number to execute.",Ans$
       !
     IF Ans$="%" THEN 
       Logging=NOT Logging
       GOTO Loop_tail
     END IF
       !
     SELECT Paging
     CASE 0
     CASE 1
       IF Ans$="+" THEN 
         Top=Top+60
         GOTO Loop_tail
       ELSE
         IF Ans$="-" THEN 
           Top=Top-60
           GOTO Loop_tail
         END IF
       END IF
     CASE 2
       IF Ans$="+" THEN 
         Top=Top+60
         GOTO Loop_tail
       END IF
     CASE 3
       IF Ans$="-" THEN 
         Top=Top-60
         GOTO Loop_tail
       END IF
     END SELECT
       !
     ON ERROR GOTO Not_numeric
     Slcted=VAL(Ans$)
     ON ERROR CALL Dir_err_handler
     IF Slcted<0 OR Slcted>Number THEN 
       GOTO Input_num
     END IF
     Loop_exit=1
     GOTO Loop_tail
       !
 Not_numeric:  !
     ON ERROR CALL Dir_err_handler
     BEEP 
     GOTO Input_num
       !
 Loop_tail:  !
   EXIT IF Loop_exit=1
   END LOOP
     !
   IF Slcted=0 THEN 
     Name$=""
   ELSE
     Name$=Algoname$(Slcted)
     PRINT "[";Name$;"]"
     PRINT 
   END IF
 SUBEND
   !
 Show_algo:SUB Show_algo(Algoname$(*),INTEGER Top,Tail)
   INTEGER I,Next_top
     !
   I=Top
   Next_top=Tail+1
     !
   WHILE (I+4)<=Next_top
     PRINT TAB(1);VAL$(I);" ";Algoname$(I),TAB(21);VAL$(I+1);" ";Algoname$(I+1),TAB(41);VAL$(I+2);" ";Algoname$(I+2),TAB(61);VAL$(I+3);" ";Algoname$(I+3)
     I=I+4
   END WHILE
     !
   SELECT Next_top-I
   CASE 0
   CASE 1
     PRINT TAB(1);VAL$(I);" ";Algoname$(I)
   CASE 2
     PRINT TAB(1);VAL$(I);" ";Algoname$(I),TAB(21);VAL$(I+1);" ";Algoname$(I+1)
   CASE 3
     PRINT TAB(1);VAL$(I);" ";Algoname$(I),TAB(21);VAL$(I+1);" ";Algoname$(I+1),TAB(41);VAL$(I+2);" ";Algoname$(I+2)
   END SELECT
 SUBEND
   !
 Set_input:SUB Set_input(Algoname$)
   DIM Params$[8192]   ! 8192=256*32
   INTEGER Exist
     !
   Show_input(Algoname$,Params$,Exist)
   IF Exist=0 THEN SUBEXIT
   Accept_input(Params$)
   Assign_input(Algoname$,Params$)
   Show_input(Algoname$,Params$,Exist)
 SUBEND
   !
 Show_input:SUB Show_input(Algoname$,Default$,INTEGER Exist)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
   DIM Param$[256],Value$[256]
   INTEGER Num,Type,Sizedim,Pos,Column,I,J
   INTEGER Param_int(32)
   REAL Param_real(32)
   DIM Param_str$(32)[256],Param_char$(32)[4]
     !
   Column=61
   Default$=""
   Exist=0
     !
   PRINT "[Input Parameters]"
   PRINT 
     !
   FOR I=0 TO 2 STEP 2  !INPUT and DEVICE
     Get_param_num(Algoname$,I,Num)
     Get_alg_int(Algoname$,I,0,0,Param_int(*))
     Get_alg_real(Algoname$,I,0,0,Param_real(*))
     Get_alg_string(Algoname$,I,0,0,Param_str$(*))
     Get_alg_char(Algoname$,I,0,0,Param_char$(*))
       !
     IF Num>0 THEN Exist=1
       !
     Num=Num-1
     FOR J=0 TO Num
       IF Column>60 THEN 
         Column=1
       ELSE
         Column=Column+20
       END IF
       Get_param_attr(Algoname$,I,J,Param$,Type,Sizedim,Pos)
       IF Sizedim>0 THEN 
         PRINT TAB(Column);Param$;" = (*)";
         Default$=Default$&","
       ELSE
         SELECT Type
         CASE Type_int
           Value$=VAL$(Param_int(Pos))
         CASE Type_real
           Value$=VAL$(DROUND(Param_real(Pos),6))
         CASE Type_str
           Value$=Param_str$(Pos)
         CASE Type_char
           Value$=Param_char$(Pos)
         END SELECT
         PRINT TAB(Column);Param$;" = ";Value$[1,19-LEN(Param$)-3];
         Default$=Default$&Value$&","
       END IF
     NEXT J
   NEXT I
     !
   IF Default$<>"" THEN 
     PRINT   ! Line feed
     PRINT 
       !
       ! Eliminate the last ",".
       !
     Default$=Default$[1,LEN(Default$)-1]
     IF LEN(Default$)>160 THEN 
       Default$=Default$[1,160]
     END IF
   END IF
 SUBEND
   !
 Accept_input:SUB Accept_input(Params$)
   OUTPUT KBD;Params$;
   LINPUT "Enter input parameters.",Params$
 SUBEND
   !
 Assign_input:SUB Assign_input(Algoname$,Assign$)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
   DIM Param$[256],Value$[256],Type_var$[10]
   INTEGER Num,Type,Sizedim,Pos,I,J,Pos_period
   INTEGER Valid_int,Valid_real,Valid_str,Valid_char
   INTEGER Param_int(32)
   REAL Param_real(32)
   DIM Param_str$(32)[256],Param_char$(32)[4]
     !
   Assign$=TRIM$(Assign$)
     !
   FOR I=0 TO 2 STEP 2  !INPUT or DEVICE
     Valid_int=0
     Valid_real=0
     Valid_str=0
     Valid_char=0
     Get_param_num(Algoname$,I,Num)
     Num=Num-1
       !
     FOR J=0 TO Num
       Get_param_attr(Algoname$,I,J,Param$,Type,Sizedim,Pos)
       Pos_period=POS(Assign$,",")
       IF Pos_period>0 THEN 
         Value$=Assign$[1,Pos_period-1]
         IF Pos_period<LEN(Assign$) THEN 
           Assign$=TRIM$(Assign$[Pos_period+1,LEN(Assign$)])
         ELSE
           Assign$=""
         END IF
       ELSE
         Value$=Assign$
         Assign$=""
       END IF
         !
       IF Sizedim=0 AND Value$<>"" THEN 
         SELECT Type
         CASE Type_int
           IF Valid_int=0 THEN 
             Get_alg_int(Algoname$,I,0,0,Param_int(*))
             Valid_int=1
           END IF
           ON ERROR GOTO Found_error
           Param_int(Pos)=VAL(Value$)
         CASE Type_real
           IF Valid_real=0 THEN 
             Get_alg_real(Algoname$,I,0,0,Param_real(*))
             Valid_real=1
           END IF
           ON ERROR GOTO Found_error
           Param_real(Pos)=VAL(Value$)
         CASE Type_str
           IF Valid_str=0 THEN 
             Get_alg_string(Algoname$,I,0,0,Param_str$(*))
             Valid_str=1
           END IF
           Param_str$(Pos)=Value$
         CASE Type_char
           IF Valid_char=0 THEN 
             Get_alg_char(Algoname$,I,0,0,Param_char$(*))
             Valid_char=1
           END IF
           IF LEN(Value$)>1 THEN GOTO Found_error
           Param_char$(Pos)=Value$
         END SELECT
       END IF
         !
       ON ERROR CALL Dir_err_handler
       GOTO Tail_for_j
         !
 Found_error:  !
       ON ERROR CALL Dir_err_handler
       SELECT Type
       CASE Type_int
         Type_var$="INTEGER"
       CASE Type_real
         Type_var$="REAL"
       CASE Type_str
         Type_var$="STRING"
       CASE Type_char
         Type_var$="CHARACTER"
       END SELECT
       PRINT "Invalid value ";Value$;" to ";Param$;" (";Type_var$;") is ignored."
 Tail_for_j:  !
     NEXT J
       !
     IF Valid_int=1 THEN CALL Put_alg_int(Algoname$,I,0,0,Param_int(*))
     IF Valid_real=1 THEN CALL Put_alg_real(Algoname$,I,0,0,Param_real(*))
     IF Valid_str=1 THEN CALL Put_alg_string(Algoname$,I,0,0,Param_str$(*))
     IF Valid_char=1 THEN CALL Put_alg_char(Algoname$,I,0,0,Param_char$(*))
   NEXT I
 SUBEND
   !
 Set_term:SUB Set_term(Algoname$)
   DIM Term$[8192]
     !
   Show_term(Algoname$,Term$)
   IF Term$="" THEN SUBEXIT
   Accept_term(Term$)
   Assign_term(Algoname$,Term$)
   Show_term(Algoname$,Term$)
 SUBEND
   !
 Show_term:SUB Show_term(Algoname$,Term$)
   INTEGER Num,Terminal(256),I,Column,Type,Sizedim,Pos
   DIM Param$[256]
     !
   Column=61
   Term$=""
     !
   PRINT "[Pins]"
   PRINT 
     !
   Get_param_num(Algoname$,1,Num)
   IF Num>0 THEN 
     Get_alg_int(Algoname$,1,0,0,Terminal(*))
     Num=Num-1
     FOR I=0 TO Num
       IF Column>60 THEN 
         Column=1
       ELSE
         Column=Column+20
       END IF
       Get_param_attr(Algoname$,1,I,Param$,Type,Sizedim,Pos)
       Term$=Term$&VAL$(Terminal(I))&","
       PRINT TAB(Column);Param$;" = ";VAL$(Terminal(I));
     NEXT I
     Term$=Term$[1,LEN(Term$)-1]
     PRINT   ! Line feed
     PRINT 
   END IF
 SUBEND
   !
 Accept_term:SUB Accept_term(Params$)
   OUTPUT KBD;Params$;
   LINPUT "Enter pin number.",Params$
 SUBEND
   !
 Assign_term:SUB Assign_term(Algoname$,Term$)
   INTEGER Num,Terminal(256),I,Pos_period
   DIM Value$[256]
     !
   Get_param_num(Algoname$,1,Num)
   IF Num>0 THEN 
     Get_alg_int(Algoname$,1,0,0,Terminal(*))
     Term$=TRIM$(Term$)
     Num=Num-1
     FOR I=0 TO Num
       Pos_period=POS(Term$,",")
       IF Pos_period>0 THEN 
         Value$=Term$[1,Pos_period-1]
         IF Pos_period<LEN(Term$) THEN 
           Term$=TRIM$(Term$[Pos_period+1,LEN(Term$)])
         ELSE
           Term$=""
         END IF
       ELSE
         Value$=Term$[1,LEN(Term$)]
         Term$=""
       END IF
         !
       ON ERROR GOTO Found_error
       Terminal(I)=VAL(Value$)
       ON ERROR CALL Dir_err_handler
       GOTO Tail_for_i
         !
 Found_error:  !
       ON ERROR CALL Dir_err_handler
       PRINT "Invalid value ";Value$;" is ignored."
 Tail_for_i:  !
     NEXT I
       !
     Put_alg_int(Algoname$,1,0,0,Terminal(*))
   END IF
 SUBEND
   !
 Set_repeat:SUB Set_repeat(INTEGER Numrpt)
 Begin_enter:  !
   ON ERROR GOTO Begin_enter
   OUTPUT KBD;"1";
   INPUT "Enter number to repeat.",Numrpt
   ON ERROR CALL Dir_err_handler
 SUBEND
   !
 Exec_and_show:SUB Exec_and_show(Algoname$,INTEGER Numrpt)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
   COM /Intprt4/ INTEGER Slcted,Logging
   INTEGER I,J,Num_all,Num_real,Allocated,Type,Sizedim,Pos
   DIM Param$[256],Buffile$[32],Resfile$[32]
   REAL Output_real0(32)
     !
   Allocated=0
   Get_param_num(Algoname$,3,Num_all)
     !
   IF Numrpt>1 THEN 
     Num_real=0
     Num_all=Num_all-1
     FOR I=0 TO Num_all   ! Equivalent to FOR I=1 TO Num_all(Original)-1
       Get_param_attr(Algoname$,3,I,Param$,Type,Sizedim,Pos)
       IF Type=Type_real THEN Num_real=Num_real+1
     NEXT I
     Num_all=Num_all+1    ! Restore
     IF Num_real>0 THEN 
       ON ERROR GOTO Alloc_std_fail
       ALLOCATE REAL Std_real(Num_real)
       ON ERROR GOTO Alloc_hist_fail
       ALLOCATE REAL Hist_real(Num_real,Numrpt)
       ON ERROR GOTO Alloc_ave_fail
       ALLOCATE REAL Ave_real(Num_real)
       Allocated=1
       GOTO End_dealloc
         !
 Alloc_ave_fail:  !
       DEALLOCATE Ave_real(*)
 Alloc_hist_fail:  !
       DEALLOCATE Hist_real(*)
 Alloc_std_fail:  !
       Allocated=0
 End_dealloc:  !
       ON ERROR CALL Dir_err_handler
     END IF
   END IF
   ALLOCATE REAL T_begin(Numrpt)
   ALLOCATE REAL T_end(Numrpt)
     !
     ! Execute alogorithm
     !
   IF Logging THEN 
     Name_tmpfile(Buffile$)
     CREATE Buffile$,1
     PRINTER IS Buffile$;APPEND
     PRINT 
     PRINT "========================================================== ";DATE$(TIMEDATE);" ";TIME$(TIMEDATE)
     PRINT "[Algorithm]"
     PRINT 
     PRINT Algoname$
     PRINT 
     Show_input(Algoname$,Param$,I)
     PRINT "[Output Parameters]"
     PRINT 
     PRINTER IS CRT
   END IF
   FOR I=1 TO Numrpt
     T_begin(I)=TIMEDATE
     Exec_direc(Algoname$)
     T_end(I)=TIMEDATE
     IF Allocated=1 THEN 
       Get_alg_real(Algoname$,3,0,0,Output_real0(*))
       FOR J=0 TO Num_real
         Hist_real(J,I)=Output_real0(J)
       NEXT J
     END IF
     IF Logging THEN 
       PRINTER IS Buffile$;APPEND
       IF Numrpt>1 THEN 
         PRINT "---------------------------------------------------------- #";I
       END IF
       Print_result(Algoname$,Num_all)
       PRINT 
       PRINTER IS CRT
     END IF
   NEXT I
     !
     ! Show result
     !
   IF Allocated=1 THEN 
     FOR I=0 TO Num_real
       Ave_real(I)=0
       FOR J=1 TO Numrpt
         Ave_real(I)=Ave_real(I)+Hist_real(I,J)
       NEXT J
       Ave_real(I)=Ave_real(I)/Numrpt
       Std_real(I)=0
       FOR J=1 TO Numrpt
         Std_real(I)=Std_real(I)+(Hist_real(I,J)-Ave_real(I))^2
       NEXT J
       Std_real(I)=(Std_real(I)/(Numrpt-1))^.5
     NEXT I
   END IF
     !
   PRINT "[Output Parameters]"
   PRINT 
     !
   IF Allocated=1 THEN 
     Print_result(Algoname$,Num_all,Ave_real(*),Std_real(*))
     PRINT "Time = ";VAL$((SUM(T_end)-SUM(T_begin))/Numrpt)
     IF Logging THEN 
       PRINTER IS Buffile$;APPEND
       PRINT "[Average (Standard Deviation)]"
       PRINT 
       Print_result(Algoname$,Num_all,Ave_real(*),Std_real(*))
       PRINT 
       PRINT "[Time]"
       PRINT 
       PRINT "Time = ";VAL$((SUM(T_end)-SUM(T_begin))/Numrpt)
       PRINTER IS CRT
     END IF
   ELSE
     Print_result(Algoname$,Num_all)
     PRINT "Time = ";VAL$((SUM(T_end)-SUM(T_begin))/Numrpt)
     IF Logging THEN 
       PRINTER IS Buffile$;APPEND
       PRINT "[Average (Standard Deviation)]"
       PRINT 
       Print_result(Algoname$,Num_all)
       PRINT 
       PRINT "[Time]"
       PRINT 
       PRINT "Time = ";VAL$((SUM(T_end)-SUM(T_begin))/Numrpt)
       PRINTER IS CRT
     END IF
   END IF
     !
   IF Logging THEN 
     Name_tmpfile(Resfile$)
     EXECUTE "/opt/SPECS/sys/bin/dos2unix.sh "&Buffile$&" "&Resfile$
     EXECUTE "cat "&Resfile$&" >> /var/opt/SPECS/log/alglog"   !AVPATH_
     PURGE Buffile$
     EXECUTE "(/opt/SPECS/sys/bin/quick_view -f "&Resfile$&"; rm "&Resfile$&") &"   !AVPATH_
   END IF
   PRINT 
     !
   IF Allocated=1 THEN 
     DEALLOCATE Hist_real(*)
     DEALLOCATE Ave_real(*)
     DEALLOCATE Std_real(*)
   END IF
   DEALLOCATE T_begin(*)
   DEALLOCATE T_end(*)
 SUBEND
   !
 Print_result:SUB Print_result(Algoname$,INTEGER Num_all,OPTIONAL REAL Ave_real(*),Std_real(*))
   OPTION BASE 1
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
   INTEGER I,Type,Sizedim,Pos,Dim1,Dim2
   DIM Param$[256]
   INTEGER Output_int0(0:32)
   REAL Output_real0(0:32)
   DIM Output_str0$(0:32)[256]
   DIM Output_char0$(0:32)[1]
     !
   Get_alg_int(Algoname$,3,0,0,Output_int0(*))
   Get_alg_real(Algoname$,3,0,0,Output_real0(*))
   Get_alg_string(Algoname$,3,0,0,Output_str0$(*))
   Get_alg_char(Algoname$,3,0,0,Output_char0$(*))
     !
   Num_all=Num_all-1
   FOR I=0 TO Num_all
     Get_param_attr(Algoname$,3,I,Param$,Type,Sizedim,Pos)
     PRINT Param$;" = ";
     SELECT Type
     CASE Type_int
       SELECT Sizedim
       CASE 0
         PRINT Output_int0(Pos)
       CASE 1,2
         PRINT "(*)"
       END SELECT
     CASE Type_real
       SELECT Sizedim
       CASE 0
         IF NPAR=4 THEN 
           PRINT Ave_real(Pos);" (";Std_real(Pos);")"
         ELSE
           PRINT Output_real0(Pos)
         END IF
       CASE 1,2
         PRINT "(*)"
       END SELECT
     CASE Type_str
       SELECT Sizedim
       CASE 0
         PRINT Output_str0$(Pos)
       CASE 1,2
         PRINT "(*)"
       END SELECT
     CASE Type_char
       SELECT Sizedim
       CASE 0
         PRINT Output_char0$(Pos)
       CASE 1,2
         PRINT "(*)"
       END SELECT
     CASE Type_var1,Type_var2
       PRINT "(*)"
     END SELECT
   NEXT I
   Num_all=Num_all+1
 SUBEND
   !
 Wait_action:SUB Wait_action
   DIM Buffer$[256]
   INPUT "Press <return> to continue.",Buffer$
 SUBEND
   !
 Dir_err_handler:SUB Dir_err_handler
   DIM Level$[32],Tismsg$[255]
   INTEGER Tiserr(1:4)
      !
   BEEP 
   IF ERRN=449 THEN 
     Error_info(Tiserr(*),Tismsg$)
     PRINT 
     PRINT "******** TIS ERROR ********"
     PRINT "   LINE:",VAL$(ERRLN)
     PRINT "MESSAGE:",Tismsg$
   ELSE
     PRINT 
     PRINT "********** ERROR **********"
     PRINT "   LINE:",VAL$(ERRLN)
     PRINT "MESSAGE:",ERRM$
   END IF
      !
   Wait_action
   SIGNAL 6
 SUBEND
 Get_alg_all:SUB Get_alg_all(Algname$(*),INTEGER Number)
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   Number=Alg
   MAT Algname$= Nam$
   MAT SORT Algname$
 SUBEND
 Get_param_num:SUB Get_param_num(Algoname$,INTEGER I,Nums)
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Nums=Num(Indx,I)
 SUBEND
 Get_param_attr:SUB Get_param_attr(Algoname$,INTEGER Dire,Posi,Param$,INTEGER Type,Dime,Locp)
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Param$=Var$(Indx,Dire,Posi)
   Type=Typ(Indx,Dire,Posi)
   Dime=Dim(Indx,Dire,Posi)
   Locp=Loc(Indx,Dire,Posi)
 SUBEND
 Get_alg_int:SUB Get_alg_int(Algoname$,INTEGER Dire,Dime,Posi,INTEGER Value(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_int THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 0
           Get_alg_int1(Vali(*),Indx,Dire,V,Value(*),Val)
           Val=Val+1
         CASE 1,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Get_alg_real:SUB Get_alg_real(Algoname$,INTEGER Dire,Dime,Posi,REAL Value(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_real THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 0
           Get_alg_real1(Valr(*),Indx,Dire,V,Value(*),Val)
           Val=Val+1
         CASE 1,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Get_alg_cpx:SUB Get_alg_cpx(Algoname$,INTEGER Dire,Dime,Posi,COMPLEX Value(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
     !
     ! Complex is always either array[] or array[][]
     ! (Dim(Index,Dire,V) is 1 or 2). Therefore no parameter value is passed.
     !
     ! INTEGER Indx,V,Val
     ! REAL Re, Im
     ! MAT SEARCH Nam$,LOC(Algoname$);Indx
     ! Val=BASE(Value,1)
     ! FOR V=0 TO Num(Indx,Dire)-1
     !   SELECT Dim(Indx,Dire,V)
     !   CASE 0,1,2
     !        Val=Val+1
     !   END SELECT
     ! NEXT V
 SUBEND
 Get_alg_char:SUB Get_alg_char(Algoname$,INTEGER Dire,Dime,Posi,Value$(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value$,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_char THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 0
           Get_alg_char1(Valc$(*),Indx,Dire,V,Value$(*),Val)
           Val=Val+1
         CASE 1,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Get_alg_string:SUB Get_alg_string(Algoname$,INTEGER Dire,Dime,Posi,Value$(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value$,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_str THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 0
           Get_alg_string1(Vals$(*),Indx,Dire,V,Value$(*),Val)
           Val=Val+1
         CASE 1,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Get_alg_var1:SUB Get_alg_var1(Algoname$,INTEGER Dire,Dime,Posi,REAL Value(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_var1 THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 1
           Val=Val+1
         CASE 0,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Get_alg_var2:SUB Get_alg_var2(Algoname$,INTEGER Dire,Dime,Posi,REAL Value(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_var2 THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 1
           Val=Val+1
         CASE 0,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Put_alg_int:SUB Put_alg_int(Algoname$,INTEGER Dire,Dime,Posi,INTEGER Value(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_int THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 0
           Put_alg_int1(Vali(*),Indx,Dire,V,Value(*),Val)
           Val=Val+1
         CASE 1,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Put_alg_real:SUB Put_alg_real(Algoname$,INTEGER Dire,Dime,Posi,REAL Value(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_real THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 0
           Put_alg_real1(Valr(*),Indx,Dire,V,Value(*),Val)
           Val=Val+1
         CASE 1,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Put_alg_real:SUB Put_alg_cpx(Algoname$,INTEGER Dire,Dime,Posi,COMPLEX Value(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_real THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 0
  !
  ! do nothing (COMPLEX is always array)
  !            Put_alg_real1(Valr(*),Indx,Dire,V,Value(*),Val)
           Val=Val+1
         CASE 1,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Put_alg_char:SUB Put_alg_char(Algoname$,INTEGER Dire,Dime,Posi,Value$(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value$,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_char THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 0
           Put_alg_char1(Valc$(*),Indx,Dire,V,Value$(*),Val)
           Val=Val+1
         CASE 1,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Put_alg_string:SUB Put_alg_string(Algoname$,INTEGER Dire,Dime,Posi,Value$(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value$,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_str THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 0
           Put_alg_string1(Vals$(*),Indx,Dire,V,Value$(*),Val)
           Val=Val+1
         CASE 1,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Put_alg_var1:SUB Put_alg_var1(Algoname$,INTEGER Dire,Dime,Posi,REAL Value(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_var1 THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 1
           Val=Val+1
         CASE 0,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Put_alg_var2:SUB Put_alg_var2(Algoname$,INTEGER Dire,Dime,Posi,REAL Value(*))
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
    !
   INTEGER Indx,V,Val
   MAT SEARCH Nam$,LOC(Algoname$);Indx
   Val=BASE(Value,1)
   FOR V=0 TO Num(Indx,Dire)-1
     IF Typ(Indx,Dire,V)=Type_var2 THEN 
       IF Dim(Indx,Dire,V)=Dime THEN 
         SELECT Dim(Indx,Dire,V)
         CASE 1
           Val=Val+1
         CASE 0,2
           Val=Val+1
         END SELECT
       END IF
     END IF
   NEXT V
 SUBEND
 Get_alg_int1:SUB Get_alg_int1(INTEGER Value(*),INTEGER Idx,Dir,Var,INTEGER Val(*),INTEGER V1)
   Val(V1)=Value(Idx,Dir,Var)
 SUBEND
 Put_alg_int1:SUB Put_alg_int1(INTEGER Value(*),INTEGER Idx,Dir,Var,INTEGER Val(*),INTEGER V1)
   Value(Idx,Dir,Var)=Val(V1)
 SUBEND
 Get_alg_real1:SUB Get_alg_real1(REAL Value(*),INTEGER Idx,Dir,Var,REAL Val(*),INTEGER V1)
   Val(V1)=Value(Idx,Dir,Var)
 SUBEND
 Put_alg_real1:SUB Put_alg_real1(REAL Value(*),INTEGER Idx,Dir,Var,REAL Val(*),INTEGER V1)
   Value(Idx,Dir,Var)=Val(V1)
 SUBEND
 Get_alg_char1:SUB Get_alg_char1(Value$(*),INTEGER Idx,Dir,Var,Val$(*),INTEGER V1)
   Val$(V1)=Value$(Idx,Dir,Var)
 SUBEND
 Put_alg_char1:SUB Put_alg_char1(Value$(*),INTEGER Idx,Dir,Var,Val$(*),INTEGER V1)
   Value$(Idx,Dir,Var)=Val$(V1)
 SUBEND
 Get_alg_string1:SUB Get_alg_string1(Value$(*),INTEGER Idx,Dir,Var,Val$(*),INTEGER V1)
   Val$(V1)=Value$(Idx,Dir,Var)
 SUBEND
 Put_alg_string1:SUB Put_alg_string1(Value$(*),INTEGER Idx,Dir,Var,Val$(*),INTEGER V1)
   Value$(Idx,Dir,Var)=Val$(V1)
 SUBEND
 Error_handler:SUB Error_handler
   DIM Level$[32]
   BEEP 
   PRINT 
   PRINT "********** ERROR **********"
   PRINT "   LINE:",VAL$(ERRLN)
   PRINT "MESSAGE:",ERRM$
 SUBEND
 SUB Name_tmpfile(File$)
   ASSIGN @P TO "/opt/SPECS/sys/bin/mktemp.sh /var/tmp |"  !AVPATH_
   ENTER @P;File$
   ASSIGN @P TO *
 SUBEND
 Direct_data:SUB Direct_data
   COM /Alglib/ INTEGER Alg
   COM /Alglib/ Nam$(*)
   COM /Alglib/ INTEGER Num(*)
   COM /Alglib/ Var$(*)
   COM /Alglib/ INTEGER Typ(*)
   COM /Alglib/ INTEGER Dim(*)
   COM /Alglib/ INTEGER Loc(*)
   COM /Alglib/ INTEGER Vali(*)
   COM /Alglib/ REAL Valr(*)
   COM /Alglib/ Valc$(*)
   COM /Alglib/ Vals$(*)
   COM /Intprt4/ INTEGER Slcted,Logging
   COM /Intprt3/ INTEGER Type_int,Type_real,Type_str,Type_char,Type_var1,Type_var2
 !
   Type_real=0
   Type_int=1
   Type_char=2
   Type_str=3
   Type_var1=4
   Type_var2=5
 !
 Algdat:!
   DATA 189
   DATA "G_IDVD"
   DATA 6
   DATA "Vdstart",0,0,0,0
   DATA "Vdstop",0,0,1,20
   DATA "Vdstep",0,0,2,0.25
   DATA "Vgstart",0,0,3,3
   DATA "Vgstop",0,0,4,6
   DATA "Vgstep",0,0,5,1
   DATA 4
   DATA "S"
   DATA "G"
   DATA "D"
   DATA "Sub"
   DATA 0
   DATA 0
   DATA "G_IDVG"
   DATA 7
   DATA "Vgstart",0,0,0,0
   DATA "Vgstop",0,0,1,5
   DATA "Vgstep",0,0,2,0.05
   DATA "Vsubstart",0,0,3,0
   DATA "Vsubstop",0,0,4,-1.2
   DATA "Vsubstep",0,0,5,-0.4
   DATA "Vd",0,0,6,5
   DATA 4
   DATA "S"
   DATA "G"
   DATA "D"
   DATA "Sub"
   DATA 0
   DATA 0
   DATA "G_ICVC"
   DATA 6
   DATA "Vcestart",0,0,0,0
   DATA "Vcestop",0,0,1,5
   DATA "Vcestep",0,0,2,0.1
   DATA "Ibstart",0,0,3,1E-05
   DATA "Ibstop",0,0,4,5E-05
   DATA "Ibstep",0,0,5,1E-05
   DATA 3
   DATA "E"
   DATA "B"
   DATA "C"
   DATA 0
   DATA 0
   DATA "G_ICVB"
   DATA 3
   DATA "Vbestart",0,0,0,0
   DATA "Vbestop",0,0,1,1
   DATA "Vbestep",0,0,2,0.01
   DATA 3
   DATA "E"
   DATA "B"
   DATA "C"
   DATA 0
   DATA 0
   DATA "G_HFE"
   DATA 4
   DATA "Ibestart",0,0,0,1E-12
   DATA "Ibestop",0,0,1,0.0005
   DATA "Ibestep",1,0,0,25
   DATA "Vce",0,0,2,5
   DATA 3
   DATA "E"
   DATA "B"
   DATA "C"
   DATA 0
   DATA 0
   DATA "G_CV"
   DATA 5
   DATA "Vstart",0,0,0,-5
   DATA "Vstop",0,0,1,5
   DATA "Vstep",0,0,2,0.1
   DATA "Delay",0,0,3,0.1
   DATA "Hold",0,0,4,30
   DATA 2
   DATA "H"
   DATA "L"
   DATA 0
   DATA 0
   DATA "ALGPANEL_LAUNCH"
   DATA 4
   DATA "Session",3,0,0,"1"
   DATA "Port",3,0,1,"14062"
   DATA "Project",3,0,2,"v"
   DATA "Hostname",3,0,3,""
   DATA 0
   DATA 0
   DATA 0
   DATA "ALGPANEL_START"
   DATA 1
   DATA "Mode",1,0,0,0
   DATA 0
   DATA 0
   DATA 0
   DATA "ALGPANEL_STOP"
   DATA 0
   DATA 0
   DATA 0
   DATA 0
   DATA "APPLY_FWKCONF"
   DATA 2
   DATA "File",3,0,0,""
   DATA "Type",1,0,0,0
   DATA 0
   DATA 0
   DATA 2
   DATA "Errno",1,0,0,0
   DATA "Errmsg",3,0,0,""
   DATA "ARRAY_LOOKUP1"
   DATA 2
   DATA "Src",3,1,0,""
   DATA "Pat",3,0,0,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Pos",1,0,0,0
   DATA "ARRAY_LOOKUP2"
   DATA 2
   DATA "Src",3,1,0,""
   DATA "Pat",3,1,1,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Pos",1,1,0,""
   DATA "ARRAY_LOOKUP3"
   DATA 2
   DATA "Src",3,1,0,""
   DATA "Pos",1,1,0,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Sub",3,1,0,""
   DATA "ATTRIB_FILE"
   DATA 1
   DATA "Filename",3,0,0,""
   DATA 0
   DATA 0
   DATA 3
   DATA "Permission",3,0,0,""
   DATA "Owner",3,0,1,""
   DATA "Group",3,0,2,""
   DATA "BEEP"
   DATA 2
   DATA "Freq",0,0,0,2000
   DATA "Dur",0,0,1,0.1
   DATA 0
   DATA 0
   DATA 0
   DATA "CALL_ERRHANDLER"
   DATA 3
   DATA "ErrorNo",3,0,0,""
   DATA "Message",3,0,1,""
   DATA "MoreInfo",3,0,2,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,0,""
   DATA "CHECK_DATAFILE"
   DATA 1
   DATA "Filename",3,0,0,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Valid",1,0,0,1
   DATA "CHECK_FILE"
   DATA 2
   DATA "Testplan",3,0,0,""
   DATA "Limit",3,0,1,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Result",1,0,0,0
   DATA "CHECK_PASSWD"
   DATA 2
   DATA "Name",3,0,0,""
   DATA "Command",3,0,1,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Result",1,0,0,0
   DATA "CHECK_PROBER"
   DATA 1
   DATA "Symbol",3,0,0,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Vendor",3,0,0,""
   DATA "Model",3,0,1,""
   DATA "CHECK_PROFILE"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "Result",1,0,0,0
   DATA "CHECK_SYSCONF"
   DATA 0
   DATA 0
   DATA 0
   DATA 11
   DATA "ERRNO",1,0,0,0
   DATA "ERRMSG",3,0,0,""
   DATA "SMODE",3,0,1,""
   DATA "OP_LANG",3,0,2,""
   DATA "ADTFORMAT",3,0,3,""
   DATA "CLEARONRETEST",3,0,4,""
   DATA "CLEARONREJECT",3,0,5,""
   DATA "PORTID",3,0,6,""
   DATA "PROJID",3,0,7,""
   DATA "HOSTNAME",3,0,8,""
   DATA "ADTLOGGING",3,0,9,""
   DATA "CHECK_TIME"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "Time",0,0,0,0
   DATA "CLOCK"
   DATA 1
   DATA "Digit",1,0,0,2
   DATA 0
   DATA 0
   DATA 7
   DATA "Year",1,0,0,0
   DATA "Month",1,0,1,0
   DATA "Day",1,0,2,0
   DATA "Hour",1,0,3,0
   DATA "Minute",1,0,4,0
   DATA "Second",1,0,5,0
   DATA "Value",0,0,0,0
   DATA "CREATE_WINDOW"
   DATA 6
   DATA "Window",1,0,0,601
   DATA "X",1,0,1,0
   DATA "Y",1,0,2,0
   DATA "W",1,0,3,640
   DATA "H",1,0,4,400
   DATA "Label",3,0,0,"HP BASIC"
   DATA 0
   DATA 0
   DATA 0
   DATA "DATALOG_DIEEND"
   DATA 2
   DATA "Filename",3,0,0,"/var/opt/SPECS/log/datalog.log"
   DATA "Mode",1,0,0,0
   DATA 0
   DATA 0
   DATA 0
   DATA "DESTROY_WINDOW"
   DATA 1
   DATA "Window",1,0,0,601
   DATA 0
   DATA 0
   DATA 0
   DATA "FA_BLDSCR_LIM"
   DATA 2
   DATA "Masscr",3,0,0,"/tmp/sample_lim.scr"
   DATA "Fmtscr",3,0,1,"/opt/SPECS/demo/lim.scr"
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "FA_BLDSCR_TPL"
   DATA 2
   DATA "Masscr",3,0,0,"/opt/SPECS/demo/sample_tpl.scr"
   DATA "Fmtscr",3,0,1,"/opt/SPECS/demo/tpl.scr"
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "FA_CHKRUN_FWK"
   DATA 2
   DATA "Name",3,0,0,"FA_"
   DATA "Status",3,0,1,"running"
   DATA 0
   DATA 0
   DATA 2
   DATA "numFile",1,0,0,0
   DATA "numRunning",1,0,1,0
   DATA "FA_CHK_FILES"
   DATA 5
   DATA "Rev_flag",1,0,0,0
   DATA "Dir",3,0,0,"/opt/SPECS/demo"
   DATA "Filename_rev",3,0,1,""
   DATA "Suffix",3,0,2,"tpl"
   DATA "Brk_chr",3,0,3,"#"
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "FA_CHK_FILES2"
   DATA 5
   DATA "Rev_flag",1,0,0,0
   DATA "Dir",3,0,0,"/opt/SPECS/demo"
   DATA "Filename_rev",3,0,1,""
   DATA "Suffix",3,0,2,"tpl"
   DATA "Brk_chr",3,0,3,"#"
   DATA 0
   DATA 0
   DATA 3
   DATA "Status",1,0,0,0
   DATA "File_name",3,0,0,""
   DATA "Rev",3,0,1,""
   DATA "FA_CHK_LIBPATH"
   DATA 1
   DATA "Orig",3,0,0,""
   DATA 0
   DATA 0
   DATA 4
   DATA "Status",1,0,0,0
   DATA "Pathflug",1,0,1,0
   DATA "Path",3,0,0,""
   DATA "Filename",3,0,1,""
   DATA "FA_CHK_MEASLIB"
   DATA 4
   DATA "Revcont",1,0,0,0
   DATA "Lib",3,1,0,""
   DATA "Libnum",1,0,1,6
   DATA "Delimiter",3,0,0,"#"
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "FA_CHK_REV"
   DATA 2
   DATA "Session",3,0,0,""
   DATA "Kinds",3,0,1,"MEAS"
   DATA 0
   DATA 0
   DATA 5
   DATA "Status",1,0,0,0
   DATA "Filename",3,0,0,""
   DATA "Rev",3,0,1,""
   DATA "Path",3,0,2,""
   DATA "BasicPath",3,0,3,""
   DATA "FA_CHK_REV2"
   DATA 3
   DATA "Session",3,0,0,""
   DATA "Kinds",3,0,1,"MEAS"
   DATA "Count",1,0,0,0
   DATA 0
   DATA 0
   DATA 5
   DATA "Status",1,0,0,0
   DATA "Filename",3,0,0,""
   DATA "Rev",3,0,1,""
   DATA "Path",3,0,2,""
   DATA "BasicPath",3,0,3,""
   DATA "FA_GETKEY_ITEMS"
   DATA 2
   DATA "Key",3,0,0,""
   DATA "Filename",3,0,1,"/opt/SPECS_FA/fapt/facomcore/recipe.txt"
   DATA 0
   DATA 0
   DATA 11
   DATA "Waf",3,0,0,"TAC394.waf"
   DATA "Die",3,0,1,"TAC394.die"
   DATA "Tst",3,0,2,"TAC394.tst"
   DATA "Prb",3,0,3,"PRB2X6.prb"
   DATA "Tpl",3,0,4,"DEMO.tpl"
   DATA "Lim",3,0,5,"DEMO.lim"
   DATA "Rcp",3,0,6,"Recipe"
   DATA "Lot_id",3,0,7,""
   DATA "Product_id",3,0,8,""
   DATA "Process_id",3,0,9,""
   DATA "Status",1,0,0,0
   DATA "FA_LIMBLD"
   DATA 6
   DATA "Rev_flag",1,0,0,0
   DATA "Brk_chr",3,0,0,"#"
   DATA "Tpl_dir",3,0,1,"/opt/SPECS/demo"
   DATA "Lim_dir",3,0,2,"/opt/SPECS/demo"
   DATA "Tpl",3,0,3,"newtpl.tpl"
   DATA "Lim",3,0,4,"newlim.lim"
   DATA 0
   DATA 0
   DATA 4
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "Ndetail",1,0,1,0
   DATA "Detail",3,1,0,""
   DATA "FA_LIMBLD2"
   DATA 8
   DATA "Rev_flag",1,0,0,0
   DATA "Brk_chr",3,0,0,"#"
   DATA "Tpl_dir",3,0,1,"/opt/SPECS/demo"
   DATA "Lim_dir",3,0,2,"/opt/SPECS/demo"
   DATA "Lms_dir",3,0,3,""
   DATA "Tpl",3,0,4,"newtpl.tpl"
   DATA "Lim",3,0,5,"newlim.lim"
   DATA "Lms",3,1,0,""
   DATA 0
   DATA 0
   DATA 4
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "Ndetail",1,0,1,0
   DATA "Detail",3,1,0,""
   DATA "FA_LIMFMT"
   DATA 8
   DATA "Rev_flag",1,0,0,0
   DATA "Brk_chr",3,0,0,"#"
   DATA "Src_lim_dir",3,0,1,"/tmp"
   DATA "Script_dir",3,0,2,"/tmp"
   DATA "Dst_lim_dir",3,0,3,"/tmp"
   DATA "Src_lim",3,0,4,"tempbld.lim"
   DATA "Script",3,0,5,"sample_lim.scr"
   DATA "Dst_lim",3,0,6,"tempfmt.lim"
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "FA_LMP_CLEARLN"
   DATA 2
   DATA "LineNth",1,0,0,1
   DATA "EraseMode",1,0,1,1
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "FA_LMP_DISPINT"
   DATA 5
   DATA "LineNth",1,0,0,1
   DATA "DispLabel",3,0,0,""
   DATA "DispValue",1,0,1,0
   DATA "DispFgc",3,0,1,"default"
   DATA "DispBgc",3,0,2,"default"
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "FA_LMP_DISPLINE"
   DATA 5
   DATA "LineNth",1,0,0,1
   DATA "DispLabel",3,0,0,""
   DATA "DispStr",3,0,1,""
   DATA "DispFgc",3,0,2,""
   DATA "DispBgc",3,0,3,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "FA_LMP_DISPVAR"
   DATA 5
   DATA "LineNth",1,0,0,1
   DATA "DispLabel",3,0,0,""
   DATA "DispVar",1,0,1,0
   DATA "DispFgc",3,0,1,""
   DATA "DispBgc",3,0,2,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "FA_MK_DATANAME"
   DATA 5
   DATA "Dir",3,0,0,"/var/opt/SPECS/data"
   DATA "File",3,0,1,"WAT01"
   DATA "Slot",1,0,0,1
   DATA "Adtfmt",3,0,2,"ad3"
   DATA "Session",3,0,3,"1"
   DATA 0
   DATA 0
   DATA 3
   DATA "Datadir",3,0,0,""
   DATA "Dataname",3,0,1,""
   DATA "Status",1,0,0,0
   DATA "FA_QUERY_COND"
   DATA 3
   DATA "Key",3,0,0,""
   DATA "Level",3,0,1,""
   DATA "Filename",3,0,2,"/opt/SPECS/usr/tpl/recipe.rec"
   DATA 0
   DATA 0
   DATA 8
   DATA "Tco",3,1,0,""
   DATA "Limf",3,0,0,""
   DATA "DieLabel",3,1,1,""
   DATA "DieType",3,1,2,""
   DATA "ModLabel",3,1,3,""
   DATA "Item",3,1,4,""
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,1,""
   DATA "FA_QUERY_RCP2"
   DATA 2
   DATA "Key",3,0,0,""
   DATA "Filename",3,0,1,"/opt/SPECS/usr/tpl/FA_recipe.rec"
   DATA 0
   DATA 0
   DATA 17
   DATA "Waf",3,0,0,""
   DATA "Die",3,1,0,""
   DATA "Mod",3,1,1,""
   DATA "Tst",3,1,2,""
   DATA "Prb",3,0,1,""
   DATA "Lms",3,1,3,""
   DATA "Tco",3,1,4,""
   DATA "Tpl",3,0,2,""
   DATA "Lim",3,0,3,""
   DATA "Mlb",3,1,5,""
   DATA "Rcp",3,0,4,""
   DATA "Lt_id",3,0,5,""
   DATA "Pt_id",3,0,6,""
   DATA "Ps_id",3,0,7,""
   DATA "Item",3,1,6,""
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,8,""
   DATA "FA_RCP_EXEC_CMD"
   DATA 2
   DATA "Cmd",3,0,0,""
   DATA "Result",3,0,1,"/var/tmp/algresult"
   DATA 0
   DATA 0
   DATA 5
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,0,""
   DATA "Ndetail",1,0,1,0
   DATA "Detail",3,1,0,""
   DATA "Cmd_ret",1,0,2,0
   DATA "FA_RUNP_CREATE"
   DATA 4
   DATA "Meas_dir",3,0,0,""
   DATA "Fwk_dir",3,0,1,""
   DATA "Meas",3,0,2,""
   DATA "Fwk",3,0,3,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "FA_TPLFMT"
   DATA 8
   DATA "Rev_flag",1,0,0,0
   DATA "Brk_chr",3,0,0,"#"
   DATA "Src_tpl_dir",3,0,1,"/"
   DATA "Script_dir",3,0,2,"/tmp"
   DATA "Dst_tpl_dir",3,0,3,"/tmp"
   DATA "Src_tpl",3,0,4,"tempbld.tpl"
   DATA "Script",3,0,5,"sample_tpl.scr"
   DATA "Dst_tpl",3,0,6,"tempfmt.tpl"
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "FA_TPLBLD"
   DATA 12
   DATA "Rev_flag",1,0,0,0
   DATA "Brk_chr",3,0,0,"#"
   DATA "Waf_dir",3,0,1,"/opt/SPECS/demo"
   DATA "Prb_dir",3,0,2,"/opt/SPECS/demo"
   DATA "Die_dir",3,0,3,"/opt/SPECS/demo"
   DATA "Tst_dir",3,0,4,"/opt/SPECS/demo"
   DATA "Tpl_dir",3,0,5,"/opt/SPECS/demo"
   DATA "Waf",3,0,6,"TAC394.waf"
   DATA "Prb",3,0,7,"PRB2X6.prb"
   DATA "Die",3,1,0,""
   DATA "Tst",3,1,1,""
   DATA "Tpl",3,0,8,"newtpl.tpl"
   DATA 0
   DATA 0
   DATA 4
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "Ndetail",1,0,1,0
   DATA "Detail",3,1,0,""
   DATA "FA_TPLBLD2"
   DATA 19
   DATA "Rev_flag",1,0,0,0
   DATA "Brk_chr",3,0,0,"#"
   DATA "Waf_dir",3,0,1,"/WATSERV/RCP/WAF"
   DATA "Prb_dir",3,0,2,"/WATSERV/RCP/PRB"
   DATA "Die_dir",3,0,3,"/WATSERV/RCP/DIE"
   DATA "Tst_dir",3,0,4,"/WATSERV/RCP/TST"
   DATA "Mod_dir",3,0,5,"/opt/SPECS/demo"
   DATA "Tpl_dir",3,0,6,"/tmp"
   DATA "Waf",3,0,7,"TAC394.waf"
   DATA "Prb",3,0,8,"PRB2X6.prb"
   DATA "Die",3,1,0,""
   DATA "Tst",3,1,1,""
   DATA "Mod",3,1,2,""
   DATA "Tpl",3,0,9,"tempbld.tpl"
   DATA "Meas",3,0,10,""
   DATA "Tester",3,0,11,""
   DATA "Prober",3,0,12,""
   DATA "Utility",3,0,13,""
   DATA "Device",3,0,14,""
   DATA 0
   DATA 0
   DATA 4
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "Ndetail",1,0,1,0
   DATA "Detail",3,1,0,""
   DATA "FA_TPLBLD3"
   DATA 19
   DATA "Rev_flag",1,0,0,0
   DATA "Brk_chr",3,0,0,"#"
   DATA "Waf_dir",3,0,1,"/WATre/prog/waf"
   DATA "Prb_dir",3,0,2,"/WATre/prog/prb"
   DATA "Die_dir",3,0,3,"/WATre/prog/die"
   DATA "Tst_dir",3,0,4,"/WATre/prog/tst"
   DATA "Mod_dir",3,0,5,"/WATre/prog/mod"
   DATA "Tpl_dir",3,0,6,"/opt/SPECS/demo"
   DATA "Waf",3,0,7,"TAC394.waf"
   DATA "Prb",3,0,8,"PRB2X6.prb"
   DATA "Die",3,1,0,""
   DATA "Tst",3,1,1,""
   DATA "Mod",3,1,2,""
   DATA "Tpl",3,0,9,"CCYBD.tpl"
   DATA "Meas",3,1,3,""
   DATA "Tester",3,0,10,""
   DATA "Prober",3,0,11,""
   DATA "Utility",3,0,12,""
   DATA "Device",3,0,13,""
   DATA 0
   DATA 0
   DATA 4
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "Ndetail",1,0,1,0
   DATA "Detail",3,1,0,""
   DATA "FA_TPL_RUN"
   DATA 1
   DATA "Session",3,0,0,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "FA_TPL_VERIFY"
   DATA 8
   DATA "Revcont",1,0,0,0
   DATA "Revmode",1,0,1,0
   DATA "Lib",3,1,0,""
   DATA "Libnum",1,0,2,6
   DATA "Tco",3,1,1,""
   DATA "Tconum",1,0,3,16
   DATA "Tpl",3,0,0,""
   DATA "Delimiter",3,0,1,"#"
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "FA_UPDATE_CARD"
   DATA 3
   DATA "CardPath",3,0,0,"/opt/SPECS_FA/fapt/sample"
   DATA "CardName",3,0,1,"cardfile"
   DATA "TotalCount",0,0,0,255
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "FA_UPD_VGEMLVAR"
   DATA 4
   DATA "SendCEID",1,0,0,0
   DATA "VarName",3,0,0,""
   DATA "VarNum",1,0,1,0
   DATA "VarData",3,1,0,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "FA_UPD_VGEMVAR"
   DATA 3
   DATA "SendCEID",1,0,0,0
   DATA "VarName",3,0,0,""
   DATA "VarData",3,0,1,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "FA_WAFERDUMP"
   DATA 5
   DATA "Dir",3,0,0,"/var/opt/SPECS/data"
   DATA "File",3,0,1,"WAT01"
   DATA "Slot",1,0,0,1
   DATA "Adtfmt",3,0,2,"ad3"
   DATA "Session",3,0,3,"1"
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "FA_WAIT"
   DATA 1
   DATA "Wait",0,0,0,1
   DATA 0
   DATA 0
   DATA 0
   DATA "FILE_HWCONFIG"
   DATA 2
   DATA "File",3,0,0,""
   DATA "Config",3,1,0,""
   DATA 0
   DATA 0
   DATA 0
   DATA "FILE_LOOKUP"
   DATA 2
   DATA "Dir",3,0,0,""
   DATA "Suffix",3,0,1,"tpl"
   DATA 0
   DATA 0
   DATA 3
   DATA "Files",3,1,0,""
   DATA "Count",1,0,0,0
   DATA "Depth",1,0,1,0
   DATA "FORMAT_PATH"
   DATA 1
   DATA "Original",3,0,0,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Path",3,0,0,""
   DATA "GEM_GETCMD"
   DATA 0
   DATA 0
   DATA 0
   DATA 3
   DATA "Cmd",3,0,0,""
   DATA "Rply",3,0,1,""
   DATA "Parms",3,1,0,""
   DATA "GEM_INIT"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "GEM_RESPOND_NOK"
   DATA 1
   DATA "ReplyMailbox",3,0,0,"Reply"
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "GEM_RESPOND_OK"
   DATA 2
   DATA "ReplyMailbox",3,0,0,"Reply"
   DATA "Timeout",0,0,0,10
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "GEM_SENDEVENT"
   DATA 2
   DATA "Event",3,0,0,""
   DATA "Parms",3,1,0,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",1,0,0,0
   DATA "GET_BRK_MOD"
   DATA 3
   DATA "Typeindex",1,0,0,1
   DATA "Dieindex",1,0,1,1
   DATA "Modindex",1,0,2,1
   DATA 0
   DATA 0
   DATA 1
   DATA "Break",1,0,0,0
   DATA "GET_DIELABEL"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "Label",3,0,0,""
   DATA "GET_DIETYPE"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "Type",3,0,0,""
   DATA "GET_JDG_DIE"
   DATA 2
   DATA "Typeindex",1,0,0,1
   DATA "Dieindex",1,0,1,1
   DATA 0
   DATA 0
   DATA 3
   DATA "Judge",1,0,0,1
   DATA "Offsetx",1,0,1,0
   DATA "Offsety",1,0,2,0
   DATA "GET_LOC_MOD"
   DATA 2
   DATA "Typeindex",1,0,0,1
   DATA "Modname",3,0,0,""
   DATA 0
   DATA 0
   DATA 3
   DATA "X",0,0,0,0
   DATA "Y",0,0,1,0
   DATA "Stat",1,0,0,0
   DATA "GET_MODLABEL"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "Label",3,0,0,""
   DATA "GET_NEXT_MOD"
   DATA 4
   DATA "Typeindex_c",1,0,0,0
   DATA "Diex_c",1,0,1,0
   DATA "Diey_c",1,0,2,0
   DATA "Modname_c",3,0,0,""
   DATA 0
   DATA 0
   DATA 5
   DATA "Typeindex",1,0,0,0
   DATA "Diex",1,0,1,0
   DATA "Diey",1,0,2,0
   DATA "Modname",3,0,0,""
   DATA "Stat",1,0,3,0
   DATA "GET_PREV_MOD"
   DATA 4
   DATA "Typeindex_c",1,0,0,0
   DATA "Diex_c",1,0,1,0
   DATA "Diey_c",1,0,2,0
   DATA "Modname_c",3,0,0,""
   DATA 0
   DATA 0
   DATA 5
   DATA "Typeindex",1,0,0,0
   DATA "Diex",1,0,1,0
   DATA "Diey",1,0,2,0
   DATA "Modname",3,0,0,""
   DATA "Stat",1,0,3,0
   DATA "GET_SLOT_NO"
   DATA 2
   DATA "Lotid",3,0,0,""
   DATA "Waferid",3,0,1,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Slotno",1,0,0,0
   DATA "GET_VGEMDEFAULT"
   DATA 0
   DATA 0
   DATA 0
   DATA 3
   DATA "Rcpmode",3,0,0,""
   DATA "Rcpfilename",3,0,1,""
   DATA "Status",1,0,0,0
   DATA "IS_CALG"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "Lang",1,0,0,0
   DATA "IS_FIRST"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "First",1,0,0,1
   DATA "JDG_DIE"
   DATA 4
   DATA "Tgt_yld",1,0,0,100
   DATA "Last",1,0,1,0
   DATA "Critical",1,0,2,0
   DATA "Ignore",1,0,3,0
   DATA 0
   DATA 0
   DATA 5
   DATA "Jdg",1,0,0,0
   DATA "Yld",0,0,0,0
   DATA "Pass_cnt",1,0,1,0
   DATA "Fail_cnt",1,0,2,0
   DATA "Total_cnt",1,0,3,0
   DATA "JDG_DIE_AT_POS"
   DATA 3
   DATA "Die_pos",1,0,0,0
   DATA "Tgt_yld",1,0,1,100
   DATA "Last",1,0,2,0
   DATA 0
   DATA 0
   DATA 5
   DATA "Jdg",1,0,0,0
   DATA "Yld",0,0,0,0
   DATA "Pass_cnt",1,0,1,0
   DATA "Fail_cnt",1,0,2,0
   DATA "Total_cnt",1,0,3,0
   DATA "JDG_DIE_AT_POS2"
   DATA 5
   DATA "Die_pos",1,0,0,0
   DATA "Tgt_yld",1,0,1,100
   DATA "Last",1,0,2,0
   DATA "Critical",1,0,3,0
   DATA "Ignore",1,0,4,0
   DATA 0
   DATA 0
   DATA 5
   DATA "Jdg",1,0,0,0
   DATA "Yld",0,0,0,0
   DATA "Pass_cnt",1,0,1,0
   DATA "Fail_cnt",1,0,2,0
   DATA "Total_cnt",1,0,3,0
   DATA "JDG_MOD"
   DATA 1
   DATA "Ignore",1,0,0,0
   DATA 0
   DATA 0
   DATA 4
   DATA "Jdg",1,0,0,0
   DATA "Pass_cnt",1,0,1,0
   DATA "Fail_cnt",1,0,2,0
   DATA "Total_cnt",1,0,3,0
   DATA "JDG_MOD_AT_POS"
   DATA 3
   DATA "Die_pos",1,0,0,0
   DATA "Mod_pos",1,0,1,0
   DATA "Ignore",1,0,2,0
   DATA 0
   DATA 0
   DATA 4
   DATA "Jdg",1,0,0,0
   DATA "Pass_cnt",1,0,1,0
   DATA "Fail_cnt",1,0,2,0
   DATA "Total_cnt",1,0,3,0
   DATA "JDG_WAF_BY_DIE"
   DATA 3
   DATA "Tgt_wafyld",1,0,0,100
   DATA "Tgt_dieyld",1,0,1,100
   DATA "Last",1,0,2,0
   DATA 0
   DATA 0
   DATA 5
   DATA "Jdg",1,0,0,0
   DATA "Yld",0,0,0,0
   DATA "Pass_cnt",1,0,1,0
   DATA "Fail_cnt",1,0,2,0
   DATA "Total_cnt",1,0,3,0
   DATA "JDG_WAF_BY_PARA"
   DATA 4
   DATA "Tgt_yld",1,0,0,100
   DATA "Last",1,0,1,0
   DATA "Critical",1,0,2,0
   DATA "Ignore",1,0,3,0
   DATA 0
   DATA 0
   DATA 5
   DATA "Jdg",1,0,0,0
   DATA "Yld",0,0,0,0
   DATA "Pass_cnt",1,0,1,0
   DATA "Fail_cnt",1,0,2,0
   DATA "Total_cnt",1,0,3,0
   DATA "LOG_LOT_BEGIN"
   DATA 8
   DATA "Session",3,0,0,""
   DATA "Lotid",3,0,1,""
   DATA "Testplan",3,0,2,""
   DATA "Algorithm",3,0,3,""
   DATA "Limitfile",3,0,4,""
   DATA "Operator",3,0,5,""
   DATA "Date",3,0,6,""
   DATA "Time",3,0,7,""
   DATA 0
   DATA 0
   DATA 0
   DATA "LOG_LOT_END"
   DATA 6
   DATA "Session",3,0,0,""
   DATA "State",3,0,1,""
   DATA "Result",1,0,0,0
   DATA "Datadir",3,0,2,""
   DATA "Dataname",3,0,3,""
   DATA "Time",3,0,4,""
   DATA 0
   DATA 0
   DATA 0
   DATA "LOG_PROBER"
   DATA 2
   DATA "Session",3,0,0,""
   DATA "Message",3,0,1,""
   DATA 0
   DATA 0
   DATA 0
   DATA "LOG_SYSTEM"
   DATA 2
   DATA "Session",3,0,0,""
   DATA "Message",3,0,1,""
   DATA 0
   DATA 0
   DATA 0
   DATA "LOG_WAFER_BEGIN"
   DATA 3
   DATA "Session",3,0,0,""
   DATA "Waferid",3,0,1,""
   DATA "Time",3,0,2,""
   DATA 0
   DATA 0
   DATA 0
   DATA "LOG_WAFER_END"
   DATA 4
   DATA "Session",3,0,0,""
   DATA "State",3,0,1,""
   DATA "Result",1,0,0,0
   DATA "Time",3,0,2,""
   DATA 0
   DATA 0
   DATA 0
   DATA "MASTER_LOOKUP"
   DATA 3
   DATA "File",3,0,0,""
   DATA "Key",3,0,1,""
   DATA "Fnum",1,0,0,1
   DATA 0
   DATA 0
   DATA 2
   DATA "Field",3,0,0,""
   DATA "Stat",1,0,0,0
   DATA "MERGE_DATAFILE"
   DATA 5
   DATA "Original",3,0,0,""
   DATA "New",3,0,1,""
   DATA "Format",3,0,2,""
   DATA "Numwaf",1,0,0,0
   DATA "Waferid",3,1,0,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Stat",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "NAME_TMPDATA"
   DATA 2
   DATA "Basename",3,0,0,""
   DATA "Session",3,0,1,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Tmpname",3,0,0,""
   DATA "PLOTTER_IS"
   DATA 1
   DATA "Sel",1,0,0,1
   DATA 0
   DATA 0
   DATA 0
   DATA "PRBCOUNT"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "Count",1,0,0,0
   DATA "PRBINFO"
   DATA 1
   DATA "Index",1,0,0,0
   DATA 0
   DATA 0
   DATA 2
   DATA "Pad",1,0,0,-1
   DATA "Pin",1,0,1,-1
   DATA "PRINT"
   DATA 1
   DATA "S",3,0,0,""
   DATA 0
   DATA 0
   DATA 0
   DATA "PRINTER_IS"
   DATA 1
   DATA "Sel",1,0,0,1
   DATA 0
   DATA 0
   DATA 0
   DATA "PRINT_CHAR"
   DATA 2
   DATA "Format",3,0,0,"%c"
   DATA "Value",2,0,0," "
   DATA 0
   DATA 0
   DATA 0
   DATA "PRINT_INTEGER"
   DATA 2
   DATA "Format",3,0,0,"%d"
   DATA "Value",1,0,0,0
   DATA 0
   DATA 0
   DATA 0
   DATA "PRINT_REAL"
   DATA 2
   DATA "Format",3,0,0,"%e"
   DATA "Value",0,0,0,0
   DATA 0
   DATA 0
   DATA 0
   DATA "PRINT_STRING"
   DATA 2
   DATA "Format",3,0,0,"%s"
   DATA "Value",3,0,1,""
   DATA 0
   DATA 0
   DATA 0
   DATA "QUERY_DIR"
   DATA 1
   DATA "Dir",3,0,0,"/var/opt/SPECS/data"
   DATA 0
   DATA 0
   DATA 1
   DATA "Stat",1,0,0,0
   DATA "QUERY_FILE"
   DATA 1
   DATA "File",3,0,0,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Stat",1,0,0,0
   DATA "QUERY_GRAPH"
   DATA 5
   DATA "Filter",1,0,0,0
   DATA "Type",1,0,1,0
   DATA "Unit",1,0,2,0
   DATA "Variable",3,0,0,""
   DATA "Update",1,0,3,0
   DATA 0
   DATA 0
   DATA 0
   DATA "QUERY_LAUNCH"
   DATA 4
   DATA "Session",3,0,0,"1"
   DATA "Port",3,0,1,"14062"
   DATA "Project",3,0,2,"v"
   DATA "Hostname",3,0,3,""
   DATA 0
   DATA 0
   DATA 0
   DATA "QUERY_START"
   DATA 0
   DATA 0
   DATA 0
   DATA 0
   DATA "QUERY_STOP"
   DATA 0
   DATA 0
   DATA 0
   DATA 0
   DATA "QUERY_VIEW"
   DATA 2
   DATA "Variable",3,0,0,""
   DATA "Update",1,0,0,0
   DATA 0
   DATA 0
   DATA 0
   DATA "RCP_CHECK_KEY"
   DATA 1
   DATA "Filename",3,0,0,"/opt/SPECS/usr/tpl/recipe.rec"
   DATA 0
   DATA 0
   DATA 3
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,0,""
   DATA "Dupkey",3,0,1,""
   DATA "RCP_DIETST"
   DATA 3
   DATA "Die",3,1,0,""
   DATA "Tst",3,1,1,""
   DATA "Rule",3,0,0,""
   DATA 0
   DATA 0
   DATA 3
   DATA "Die_tst",3,1,0,""
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,0,""
   DATA "RCP_EXEC_CMD"
   DATA 2
   DATA "Cmd",3,0,0,""
   DATA "Result",3,0,1,"/var/tmp/algresult"
   DATA 0
   DATA 0
   DATA 5
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,0,""
   DATA "Ndetail",1,0,1,0
   DATA "Detail",3,1,0,""
   DATA "Cmd_ret",1,0,2,0
   DATA "RCP_LIMBLD"
   DATA 6
   DATA "Tpl_dir",3,0,0,"/var/opt/SPECS/recipe"
   DATA "Lms_dir",3,0,1,"/opt/SPECS/demo"
   DATA "Lim_dir",3,0,2,"/var/opt/SPECS/recipe"
   DATA "Tpl",3,0,3,"testplan.tpl"
   DATA "Lms",3,1,0,""
   DATA "Lim",3,0,4,"limit.lim"
   DATA 0
   DATA 0
   DATA 4
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,0,""
   DATA "Ndetail",1,0,1,0
   DATA "Detail",3,1,0,""
   DATA "RCP_MK_FILENAME"
   DATA 3
   DATA "Dirname",3,0,0,""
   DATA "Filename",3,0,1,""
   DATA "Suffix",3,0,2,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Fullfile",3,0,0,""
   DATA "RCP_QUERY_RECIP"
   DATA 2
   DATA "Key",3,0,0,""
   DATA "Filename",3,0,1,"/opt/SPECS/usr/tpl/recipe.rec"
   DATA 0
   DATA 0
   DATA 11
   DATA "Waf",3,0,0,""
   DATA "Die",3,1,0,""
   DATA "Mod",3,1,1,""
   DATA "Tst",3,1,2,""
   DATA "Prb",3,0,1,""
   DATA "Lms",3,1,3,""
   DATA "Tco",3,1,4,""
   DATA "Mlib",3,1,5,""
   DATA "Item",3,1,6,""
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,2,""
   DATA "RCP_REPLACE_WD"
   DATA 3
   DATA "Format",3,0,0,"$(RCP)_$(SI)"
   DATA "Find_wd",3,1,0,""
   DATA "Replace_wd",3,1,1,""
   DATA 0
   DATA 0
   DATA 1
   DATA "String",3,0,0,""
   DATA "RCP_SYSCONF"
   DATA 1
   DATA "Name",3,0,0,"RCP_TPL"
   DATA 0
   DATA 0
   DATA 2
   DATA "Value",3,0,0,""
   DATA "Status",1,0,0,0
   DATA "RCP_TPLBLD"
   DATA 13
   DATA "Waf_dir",3,0,0,"/opt/SPECS/demo"
   DATA "Prb_dir",3,0,1,"/opt/SPECS/demo"
   DATA "Die_dir",3,0,2,"/opt/SPECS/demo"
   DATA "Mod_dir",3,0,3,"/opt/SPECS/demo"
   DATA "Tst_dir",3,0,4,"/opt/SPECS/demo"
   DATA "Tpl_dir",3,0,5,"/var/opt/SPECS/recipe"
   DATA "Waf",3,0,6,""
   DATA "Prb",3,0,7,""
   DATA "Die",3,1,0,""
   DATA "Mod",3,1,1,""
   DATA "Tst",3,1,2,""
   DATA "Mlib",3,1,3,""
   DATA "Tpl",3,0,8,"testplan.tpl"
   DATA 0
   DATA 0
   DATA 4
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,0,""
   DATA "Ndetail",1,0,1,0
   DATA "Detail",3,1,0,""
   DATA "READ_CHAR"
   DATA 2
   DATA "Format",3,0,0,"%c"
   DATA "String",3,0,1,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Value",2,0,0," "
   DATA "Stat",1,0,0,0
   DATA "READ_INTEGER"
   DATA 2
   DATA "Format",3,0,0,"%d"
   DATA "String",3,0,1,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Value",1,0,0,0
   DATA "Stat",1,0,1,0
   DATA "READ_PROCCOND"
   DATA 1
   DATA "Filename",3,0,0,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Ret",1,0,0,0
   DATA "Readnum",1,0,1,0
   DATA "READ_REAL"
   DATA 2
   DATA "Format",3,0,0,"%e"
   DATA "String",3,0,1,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Value",0,0,0,0
   DATA "Stat",1,0,0,0
   DATA "READ_STRING"
   DATA 2
   DATA "Format",3,0,0,"%s"
   DATA "String",3,0,1,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Value",3,0,0,""
   DATA "Stat",1,0,0,0
   DATA "SAVE_TMPDATA"
   DATA 4
   DATA "Path",3,0,0,""
   DATA "Name",3,0,1,""
   DATA "Format",3,0,2,"adt"
   DATA "Session",3,0,3,""
   DATA 0
   DATA 0
   DATA 3
   DATA "Stat",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "Pubname",3,0,1,""
   DATA "SETUSRBIN_LPBGN"
   DATA 2
   DATA "Waftgt",1,0,0,0
   DATA "Lottgt",1,0,1,0
   DATA 0
   DATA 0
   DATA 0
   DATA "SET_BRK_MOD"
   DATA 4
   DATA "Typeindex",1,0,0,1
   DATA "Dieindex",1,0,1,1
   DATA "Modindex",1,0,2,1
   DATA "Break",1,0,3,1
   DATA 0
   DATA 0
   DATA 0
   DATA "SET_JDG_DIE"
   DATA 5
   DATA "Typeindex",1,0,0,1
   DATA "Dieindex",1,0,1,1
   DATA "Judge",1,0,2,1
   DATA "Offsetx",1,0,3,0
   DATA "Offsety",1,0,4,0
   DATA 0
   DATA 0
   DATA 0
   DATA "SET_JDG_DIE_ALL"
   DATA 3
   DATA "Judge",1,0,0,1
   DATA "Offsetx",1,0,1,0
   DATA "Offsety",1,0,2,0
   DATA 0
   DATA 0
   DATA 0
   DATA "SET_JDG_DIE_TYP"
   DATA 4
   DATA "Typeindex",1,0,0,1
   DATA "Judge",1,0,1,1
   DATA "Offsetx",1,0,2,0
   DATA "Offsety",1,0,3,0
   DATA 0
   DATA 0
   DATA 0
   DATA "SET_SAMELEN"
   DATA 2
   DATA "Original",3,0,0,""
   DATA "Reference",3,0,1,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Modified",3,0,0,""
   DATA "SET_SAMELEN20"
   DATA 1
   DATA "Original",3,1,0,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Modified",3,1,0,""
   DATA "SET_TAG_CHAR"
   DATA 2
   DATA "Name",3,0,0,""
   DATA "Value",2,0,0," "
   DATA 0
   DATA 0
   DATA 0
   DATA "SET_TAG_INTEGER"
   DATA 2
   DATA "Name",3,0,0,""
   DATA "Value",1,0,0,0
   DATA 0
   DATA 0
   DATA 0
   DATA "SET_TAG_REAL"
   DATA 2
   DATA "Name",3,0,0,""
   DATA "Value",0,0,0,0
   DATA 0
   DATA 0
   DATA 0
   DATA "SET_TAG_STRING"
   DATA 2
   DATA "Name",3,0,0,""
   DATA "Value",3,0,1,""
   DATA 0
   DATA 0
   DATA 0
   DATA "SIZEOFDISPLAY"
   DATA 0
   DATA 0
   DATA 0
   DATA 2
   DATA "Width",1,0,0,0
   DATA "Height",1,0,1,0
   DATA "STATLOG_DIEEND"
   DATA 2
   DATA "Filename",3,0,0,"/var/opt/SPECS/log/statlog.log"
   DATA "Mode",1,0,0,0
   DATA 0
   DATA 0
   DATA 0
   DATA "STRING_LOOKUP"
   DATA 2
   DATA "Src",3,0,0,""
   DATA "Pat",3,0,1,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Pos",1,0,0,0
   DATA "STRING_SPLIT"
   DATA 2
   DATA "Src",3,0,0,""
   DATA "Del",3,0,1," "
   DATA 0
   DATA 0
   DATA 2
   DATA "Elem",3,1,0,""
   DATA "Count",1,0,0,0
   DATA "STRING_TIME"
   DATA 1
   DATA "Time",0,0,0,0
   DATA 0
   DATA 0
   DATA 1
   DATA "Symbol",3,0,0,""
   DATA "TIMEDATE"
   DATA 1
   DATA "Digit",1,0,0,2
   DATA 0
   DATA 0
   DATA 2
   DATA "Date",3,0,0,""
   DATA "Time",3,0,1,""
   DATA "UPDATE_FWKCONF"
   DATA 2
   DATA "File",3,0,0,""
   DATA "Type",1,0,0,0
   DATA 0
   DATA 0
   DATA 2
   DATA "Errno",1,0,0,0
   DATA "Errmsg",3,0,0,""
   DATA "VERIFY_FILE"
   DATA 2
   DATA "Filename",3,0,0,""
   DATA "Type",3,0,1,"Normal"
   DATA 0
   DATA 0
   DATA 4
   DATA "Exist",1,0,0,0
   DATA "Readable",1,0,1,0
   DATA "Writable",1,0,2,0
   DATA "Executable",1,0,3,0
   DATA "WAIT"
   DATA 1
   DATA "Wait",0,0,0,1
   DATA 0
   DATA 0
   DATA 0
   DATA "WRITE_CHAR"
   DATA 2
   DATA "Format",3,0,0,"%c"
   DATA "Value",2,0,0," "
   DATA 0
   DATA 0
   DATA 2
   DATA "String",3,0,0,""
   DATA "Length",1,0,0,0
   DATA "WRITE_INTEGER"
   DATA 2
   DATA "Format",3,0,0,"%d"
   DATA "Value",1,0,0,0
   DATA 0
   DATA 0
   DATA 2
   DATA "String",3,0,0,""
   DATA "Length",1,0,0,0
   DATA "WRITE_REAL"
   DATA 2
   DATA "Format",3,0,0,"%e"
   DATA "Value",0,0,0,0
   DATA 0
   DATA 0
   DATA 2
   DATA "String",3,0,0,""
   DATA "Length",1,0,0,0
   DATA "WRITE_STRING"
   DATA 2
   DATA "Format",3,0,0,"%s"
   DATA "Value",3,0,1,""
   DATA 0
   DATA 0
   DATA 2
   DATA "String",3,0,0,""
   DATA "Length",1,0,0,0
   DATA "WRITE_WAFER_SUM"
   DATA 6
   DATA "Slot",1,0,0,0
   DATA "Lot",3,0,0,""
   DATA "Wafer",3,0,1,""
   DATA "Yld_item",0,0,0,0
   DATA "Yld_die",0,0,1,0
   DATA "Judge",1,0,1,0
   DATA 0
   DATA 0
   DATA 1
   DATA "Summary",3,0,0,""
   DATA "XWUD"
   DATA 4
   DATA "File",3,0,0,""
   DATA "Xpos",1,0,0,0
   DATA "Ypos",1,0,1,0
   DATA "Noclick",1,0,2,1
   DATA 0
   DATA 0
   DATA 0
   DATA "YIELDLOG_WAFEND"
   DATA 2
   DATA "Filename",3,0,0,"/var/opt/SPECS/log/yieldlog.log"
   DATA "Dieyield",1,0,0,0
   DATA 0
   DATA 0
   DATA 0
   DATA "FA_READ_CARD"
   DATA 3
   DATA "CardPath",3,0,0,"/opt/SPECS_FA/fapt/sample"
   DATA "CardId",3,0,1,"Offline_card"
   DATA "Id_sta",3,0,2,"OK"
   DATA 0
   DATA 0
   DATA 5
   DATA "CardType",3,0,0,""
   DATA "CardName",3,0,1,""
   DATA "TotalCount",0,0,0,0
   DATA "LimitCount",0,0,1,0
   DATA "Status",1,0,0,0
   DATA "FA_QUERY_RECIP"
   DATA 2
   DATA "Key",3,0,0,""
   DATA "Filename",3,0,1,"/WATSERV/ETC/PIL_PROD.rec"
   DATA 0
   DATA 0
   DATA 16
   DATA "Waf",3,0,0,""
   DATA "Die",3,1,0,""
   DATA "Mod",3,1,1,""
   DATA "Tst",3,1,2,""
   DATA "Prb",3,0,1,""
   DATA "Lms",3,1,3,""
   DATA "Tco",3,1,4,""
   DATA "Tpl",3,0,2,""
   DATA "Lim",3,0,3,""
   DATA "Rcp",3,0,4,""
   DATA "Lt_id",3,0,5,""
   DATA "Pt_id",3,0,6,""
   DATA "Ps_id",3,0,7,""
   DATA "Item",3,1,5,""
   DATA "Status",1,0,0,0
   DATA "Errmsg",3,0,8,""
   DATA "CTM_PCIL_ACCESo"
   DATA 7
   DATA "Check",1,0,0,1
   DATA "Pcil_file",3,0,0,"/WATSERV/ETC/PCIL"
   DATA "Hi",1,0,1,1
   DATA "Lo",1,0,2,2
   DATA "Vf",0,0,0,0.1
   DATA "Dev",0,0,1,0
   DATA "Ip_file",3,0,1,"/WAT/ETC/IP_RFID"
   DATA 0
   DATA 0
   DATA 6
   DATA "Pcard_type",3,0,0,""
   DATA "Pcard_id",3,0,1,""
   DATA "Pcard_spec",3,0,2,""
   DATA "St",3,0,3,""
   DATA "Err",3,0,4,""
   DATA "Pcard_st",1,0,0,0
   DATA "CTM_TELP8_INFO"
   DATA 0
   DATA 0
   DATA 0
   DATA 3
   DATA "Overdrive",3,0,0,""
   DATA "Status",3,0,1,""
   DATA "Error",3,0,2,""
   DATA "READ_EQUIPID2"
   DATA 1
   DATA "File",3,0,0,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Equip_id",3,0,0,""
   DATA "REAL_TO_STR"
   DATA 1
   DATA "Rvalue",0,0,0,0
   DATA 0
   DATA 0
   DATA 3
   DATA "String",3,0,0,""
   DATA "Status",3,0,1,""
   DATA "Error",3,0,2,""
   DATA "CTM_RFID"
   DATA 4
   DATA "IP_FILE",3,0,0,"/WAT/ETC/IP_RFID"
   DATA "PAGE",1,0,0,1
   DATA "RW",1,0,1,0
   DATA "WRITE_INFO",3,0,1,""
   DATA 0
   DATA 0
   DATA 2
   DATA "ITEM",3,1,0,""
   DATA "STATUS",1,0,0,0
   DATA "CTM_PC_COUNT"
   DATA 1
   DATA "Prb_adr",1,0,0,2505
   DATA 0
   DATA 0
   DATA 1
   DATA "Count",0,0,0,0
   DATA "CTM_PURGE_DISP"
   DATA 2
   DATA "Purge_file",3,0,0,"/tmp/display"
   DATA "Create_file",3,0,1,"/tmp/display"
   DATA 0
   DATA 0
   DATA 0
   DATA "CTM_TEST_LOG"
   DATA 1
   DATA "Testlog",3,0,0,"/WATSERV/LOG/Testlog.txt"
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",1,0,0,0
   DATA "Error",3,0,0,""
   DATA "CTM_POSold"
   DATA 2
   DATA "Original",3,0,0,""
   DATA "Search",3,0,1,""
   DATA 0
   DATA 0
   DATA 4
   DATA "Length",1,0,0,0
   DATA "Position",1,0,1,0
   DATA "Prefix",3,0,0,""
   DATA "Postfix",3,0,1,""
   DATA "FILE_EXIST"
   DATA 1
   DATA "Filename",3,0,0,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",3,0,0,""
   DATA "Error",3,0,1,""
   DATA "COPY_FILE"
   DATA 3
   DATA "Source_file",3,0,0,""
   DATA "Desti_file",3,0,1,""
   DATA "Mode",1,0,0,0
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",3,0,0,""
   DATA "Error",3,0,1,""
   DATA "CTM_MON_CONV"
   DATA 1
   DATA "Month",1,0,0,3
   DATA 0
   DATA 0
   DATA 1
   DATA "Mon",3,0,0,""
   DATA "CTM_TIMEDATE"
   DATA 0
   DATA 0
   DATA 0
   DATA 2
   DATA "Time",3,0,0,""
   DATA "Time2",3,0,1,""
   DATA "CTM_TIME_CAL"
   DATA 2
   DATA "Start_time",3,0,0,"2012/03/14_13:21:45"
   DATA "End_time",3,0,1,"2012/03/14_13:22:45"
   DATA 0
   DATA 0
   DATA 1
   DATA "Timespend",0,0,0,0
   DATA "CTM_POS"
   DATA 2
   DATA "Original",3,0,0,""
   DATA "Search",3,0,1,""
   DATA 0
   DATA 0
   DATA 4
   DATA "Length",1,0,0,0
   DATA "Position",1,0,1,0
   DATA "Prefix",3,0,0,""
   DATA "Postfix",3,0,1,""
   DATA "CTM_FILE_LOOKUP"
   DATA 2
   DATA "File",3,0,0,""
   DATA "Key",3,0,1,""
   DATA 0
   DATA 0
   DATA 3
   DATA "Field",3,0,0,""
   DATA "Position",1,0,0,0
   DATA "Stat",1,0,1,0
   DATA "CTM_CLR_XTERM"
   DATA 2
   DATA "Title",3,0,0,"WAT_TEST"
   DATA "Proc_kill",3,0,1,"proc_kill"
   DATA 0
   DATA 0
   DATA 0
   DATA "INIT_RELAY"
   DATA 0
   DATA 0
   DATA 0
   DATA 0
   DATA "CTM_PCID_LOG"
   DATA 3
   DATA "File",3,0,0,"/WATSERV/LOG/EQ_PCID.log"
   DATA "Eqid",3,0,1,"WAT01"
   DATA "Pcid",3,0,2,"1A"
   DATA 0
   DATA 0
   DATA 3
   DATA "Rep_eqid",3,0,0,""
   DATA "Rep_pcid",3,0,1,""
   DATA "Stat",1,0,0,0
   DATA "SET_GUARD_OPEN"
   DATA 1
   DATA "Yes",1,0,0,0
   DATA 0
   DATA 0
   DATA 1
   DATA "Stat",1,0,0,0
   DATA "DISCHARGE_ALL"
   DATA 2
   DATA "Port",1,0,0,3
   DATA "Hold",0,0,0,0.1
   DATA 0
   DATA 0
   DATA 1
   DATA "Stat",1,0,0,0
   DATA "CTM_DIESIZE_CHK"
   DATA 0
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",3,0,0,""
   DATA "Error",3,0,1,""
   DATA "CTM_LAST_WAF"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "Last_waf_no",1,0,0,0
   DATA "CTM_PCIL_ACCESS"
   DATA 7
   DATA "Check",1,0,0,1
   DATA "Pcil_file",3,0,0,"/WATSERV/ETC/PCIL"
   DATA "Hi",1,0,1,1
   DATA "Lo",1,0,2,2
   DATA "Vf",0,0,0,0.1
   DATA "Dev",0,0,1,0
   DATA "Ip_file",3,0,1,"/WAT/ETC/IP_RFID"
   DATA 0
   DATA 0
   DATA 6
   DATA "Pcard_type",3,0,0,""
   DATA "Pcard_id",3,0,1,""
   DATA "Pcard_spec",3,0,2,""
   DATA "St",3,0,3,""
   DATA "Err",3,0,4,""
   DATA "Pcard_st",1,0,0,0
   DATA "CTM_PC_LEAK"
   DATA 8
   DATA "Vbias",0,0,0,3.3
   DATA "Ifail",0,0,1,1
   DATA "Pcard_type",3,0,0,"12"
   DATA "Pcard_spec_dir",3,0,1,"/WATSERV/RCP/PRB"
   DATA "Wd",0,0,2,3
   DATA "Wt",0,0,3,0.3
   DATA "ADC",1,0,0,1
   DATA "INTEG",1,0,1,3
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",3,0,0,""
   DATA "Msg",3,0,1,""
   DATA "CTM_PC_LEAK_DIS"
   DATA 9
   DATA "Vbias",0,0,0,3.3
   DATA "Ifail",0,0,1,1
   DATA "Pcard_type",3,0,0,"IS12W"
   DATA "Pcard_spec_dir",3,0,1,"/WATSERV/RCP/PRB"
   DATA "Wd",0,0,2,3
   DATA "Wt",0,0,3,0.3
   DATA "ADC",1,0,0,1
   DATA "INTEG",1,0,1,3
   DATA "Pcard_id",3,0,2,""
   DATA 0
   DATA 0
   DATA 2
   DATA "Status",3,0,0,""
   DATA "Msg",3,0,1,""
   DATA "CTM_PC_MGR"
   DATA 5
   DATA "Pcil_mgr",3,0,0,"/WATSERV/LOG/PRBC_LIFE"
   DATA "Pcard_type",3,0,1,"22"
   DATA "Pcard_id",3,0,2,"A"
   DATA "Count",0,0,0,100
   DATA "Leak_pin",3,0,3,""
   DATA 0
   DATA 0
   DATA 2
   DATA "St",3,0,0,""
   DATA "Err",3,0,1,""
   DATA "CTM_UPDATE_INFO"
   DATA 8
   DATA "Info_file",3,0,0,"/WATSERV/LOG/TEST_INFO.txt"
   DATA "Lot_id",3,0,1,""
   DATA "Pc_id",3,0,2,""
   DATA "Recipe",3,0,3,""
   DATA "Start_time",3,0,4,""
   DATA "End_time",3,0,5,""
   DATA "Waf_done",3,0,6,""
   DATA "Waf_untest",3,0,7,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",3,0,0,""
   DATA "ESD_ABSORB"
   DATA 1
   DATA "MODE",3,0,0,""
   DATA 0
   DATA 0
   DATA 0
   DATA "CTM_UPD_INFO"
   DATA 8
   DATA "Info_file",3,0,0,"/WATSERV/LOG/TEST_INFO.txt"
   DATA "Lot_id",3,0,1,""
   DATA "Pc_id",3,0,2,""
   DATA "Recipe",3,0,3,""
   DATA "Start_time",3,0,4,""
   DATA "End_time",3,0,5,""
   DATA "Waf_done",3,0,6,""
   DATA "Waf_untest",3,0,7,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Status",3,0,0,""
   DATA "CTM_EXESHELL"
   DATA 1
   DATA "Cmd",3,0,0,""
   DATA 0
   DATA 0
   DATA 1
   DATA "Rst",1,0,0,0
   DATA "CTM_PCID_UPD"
   DATA 5
   DATA "Equip_id",3,0,0,""
   DATA "Pcard_type",3,0,1,""
   DATA "Pcard_id",3,0,2,""
   DATA "Dir_pcfile",3,0,3,"/WATSERV/ETC/ProbeCard_Info/"
   DATA "Upd_syslog",1,0,0,1
   DATA 0
   DATA 0
   DATA 1
   DATA "Stat",3,0,0,""
   DATA "CTM_CHK_LOG4070"
   DATA 0
   DATA 0
   DATA 0
   DATA 1
   DATA "Fixture_status",1,0,0,0
 !
   RESTORE Algdat
   READ Alg
   FOR A=1 TO Alg
     READ Nam$(A)
     FOR T=0 TO 3
       READ Num(A,T)
       FOR V=0 TO Num(A,T)-1
         READ Var$(A,T,V)
         SELECT T
         CASE 1
           Typ(A,T,V)=Type_int
           Dim(A,T,V)=0
           Loc(A,T,V)=0
         CASE 0,2,3
           READ Typ(A,T,V)
           READ Dim(A,T,V)
           READ Loc(A,T,V)
           IF Dim(A,T,V)=0 THEN 
             SELECT Typ(A,T,V)
             CASE 0
               READ Valr(A,T,V)
             CASE 1
               READ Vali(A,T,V)
             CASE 2
               READ Valc$(A,T,V)
             CASE 3
               READ Vals$(A,T,V)
             END SELECT
           ELSE
             READ Dummy$
           END IF
         END SELECT
       NEXT V
     NEXT T
   NEXT A
 SUBEND
 Exec_direc:SUB Exec_direc(Algoname$)
   SELECT Algoname$
   CASE "G_IDVD"
     Direc_0(Algoname$)
   CASE "G_IDVG"
     Direc_1(Algoname$)
   CASE "G_ICVC"
     Direc_2(Algoname$)
   CASE "G_ICVB"
     Direc_3(Algoname$)
   CASE "G_HFE"
     Direc_4(Algoname$)
   CASE "G_CV"
     Direc_5(Algoname$)
   CASE "ALGPANEL_LAUNCH"
     Direc_6(Algoname$)
   CASE "ALGPANEL_START"
     Direc_7(Algoname$)
   CASE "ALGPANEL_STOP"
     Direc_8(Algoname$)
   CASE "APPLY_FWKCONF"
     Direc_9(Algoname$)
   CASE "ARRAY_LOOKUP1"
     Direc_10(Algoname$)
   CASE "ARRAY_LOOKUP2"
     Direc_11(Algoname$)
   CASE "ARRAY_LOOKUP3"
     Direc_12(Algoname$)
   CASE "ATTRIB_FILE"
     Direc_13(Algoname$)
   CASE "BEEP"
     Direc_14(Algoname$)
   CASE "CALL_ERRHANDLER"
     Direc_15(Algoname$)
   CASE "CHECK_DATAFILE"
     Direc_16(Algoname$)
   CASE "CHECK_FILE"
     Direc_17(Algoname$)
   CASE "CHECK_PASSWD"
     Direc_18(Algoname$)
   CASE "CHECK_PROBER"
     Direc_19(Algoname$)
   CASE "CHECK_PROFILE"
     Direc_20(Algoname$)
   CASE "CHECK_SYSCONF"
     Direc_21(Algoname$)
   CASE "CHECK_TIME"
     Direc_22(Algoname$)
   CASE "CLOCK"
     Direc_23(Algoname$)
   CASE "CREATE_WINDOW"
     Direc_24(Algoname$)
   CASE "DATALOG_DIEEND"
     Direc_25(Algoname$)
   CASE "DESTROY_WINDOW"
     Direc_26(Algoname$)
   CASE "FA_BLDSCR_LIM"
     Direc_27(Algoname$)
   CASE "FA_BLDSCR_TPL"
     Direc_28(Algoname$)
   CASE "FA_CHKRUN_FWK"
     Direc_29(Algoname$)
   CASE "FA_CHK_FILES"
     Direc_30(Algoname$)
   CASE "FA_CHK_FILES2"
     Direc_31(Algoname$)
   CASE "FA_CHK_LIBPATH"
     Direc_32(Algoname$)
   CASE "FA_CHK_MEASLIB"
     Direc_33(Algoname$)
   CASE "FA_CHK_REV"
     Direc_34(Algoname$)
   CASE "FA_CHK_REV2"
     Direc_35(Algoname$)
   CASE "FA_GETKEY_ITEMS"
     Direc_36(Algoname$)
   CASE "FA_LIMBLD"
     Direc_37(Algoname$)
   CASE "FA_LIMBLD2"
     Direc_38(Algoname$)
   CASE "FA_LIMFMT"
     Direc_39(Algoname$)
   CASE "FA_LMP_CLEARLN"
     Direc_40(Algoname$)
   CASE "FA_LMP_DISPINT"
     Direc_41(Algoname$)
   CASE "FA_LMP_DISPLINE"
     Direc_42(Algoname$)
   CASE "FA_LMP_DISPVAR"
     Direc_43(Algoname$)
   CASE "FA_MK_DATANAME"
     Direc_44(Algoname$)
   CASE "FA_QUERY_COND"
     Direc_45(Algoname$)
   CASE "FA_QUERY_RCP2"
     Direc_46(Algoname$)
   CASE "FA_RCP_EXEC_CMD"
     Direc_47(Algoname$)
   CASE "FA_RUNP_CREATE"
     Direc_48(Algoname$)
   CASE "FA_TPLFMT"
     Direc_49(Algoname$)
   CASE "FA_TPLBLD"
     Direc_50(Algoname$)
   CASE "FA_TPLBLD2"
     Direc_51(Algoname$)
   CASE "FA_TPLBLD3"
     Direc_52(Algoname$)
   CASE "FA_TPL_RUN"
     Direc_53(Algoname$)
   CASE "FA_TPL_VERIFY"
     Direc_54(Algoname$)
   CASE "FA_UPDATE_CARD"
     Direc_55(Algoname$)
   CASE "FA_UPD_VGEMLVAR"
     Direc_56(Algoname$)
   CASE "FA_UPD_VGEMVAR"
     Direc_57(Algoname$)
   CASE "FA_WAFERDUMP"
     Direc_58(Algoname$)
   CASE "FA_WAIT"
     Direc_59(Algoname$)
   CASE "FILE_HWCONFIG"
     Direc_60(Algoname$)
   CASE "FILE_LOOKUP"
     Direc_61(Algoname$)
   CASE "FORMAT_PATH"
     Direc_62(Algoname$)
   CASE "GEM_GETCMD"
     Direc_63(Algoname$)
   CASE "GEM_INIT"
     Direc_64(Algoname$)
   CASE "GEM_RESPOND_NOK"
     Direc_65(Algoname$)
   CASE "GEM_RESPOND_OK"
     Direc_66(Algoname$)
   CASE "GEM_SENDEVENT"
     Direc_67(Algoname$)
   CASE "GET_BRK_MOD"
     Direc_68(Algoname$)
   CASE "GET_DIELABEL"
     Direc_69(Algoname$)
   CASE "GET_DIETYPE"
     Direc_70(Algoname$)
   CASE "GET_JDG_DIE"
     Direc_71(Algoname$)
   CASE "GET_LOC_MOD"
     Direc_72(Algoname$)
   CASE "GET_MODLABEL"
     Direc_73(Algoname$)
   CASE "GET_NEXT_MOD"
     Direc_74(Algoname$)
   CASE "GET_PREV_MOD"
     Direc_75(Algoname$)
   CASE "GET_SLOT_NO"
     Direc_76(Algoname$)
   CASE "GET_VGEMDEFAULT"
     Direc_77(Algoname$)
   CASE "IS_CALG"
     Direc_78(Algoname$)
   CASE "IS_FIRST"
     Direc_79(Algoname$)
   CASE "JDG_DIE"
     Direc_80(Algoname$)
   CASE "JDG_DIE_AT_POS"
     Direc_81(Algoname$)
   CASE "JDG_DIE_AT_POS2"
     Direc_82(Algoname$)
   CASE "JDG_MOD"
     Direc_83(Algoname$)
   CASE "JDG_MOD_AT_POS"
     Direc_84(Algoname$)
   CASE "JDG_WAF_BY_DIE"
     Direc_85(Algoname$)
   CASE "JDG_WAF_BY_PARA"
     Direc_86(Algoname$)
   CASE "LOG_LOT_BEGIN"
     Direc_87(Algoname$)
   CASE "LOG_LOT_END"
     Direc_88(Algoname$)
   CASE "LOG_PROBER"
     Direc_89(Algoname$)
   CASE "LOG_SYSTEM"
     Direc_90(Algoname$)
   CASE "LOG_WAFER_BEGIN"
     Direc_91(Algoname$)
   CASE "LOG_WAFER_END"
     Direc_92(Algoname$)
   CASE "MASTER_LOOKUP"
     Direc_93(Algoname$)
   CASE "MERGE_DATAFILE"
     Direc_94(Algoname$)
   CASE "NAME_TMPDATA"
     Direc_95(Algoname$)
   CASE "PLOTTER_IS"
     Direc_96(Algoname$)
   CASE "PRBCOUNT"
     Direc_97(Algoname$)
   CASE "PRBINFO"
     Direc_98(Algoname$)
   CASE "PRINT"
     Direc_99(Algoname$)
   CASE "PRINTER_IS"
     Direc_100(Algoname$)
   CASE "PRINT_CHAR"
     Direc_101(Algoname$)
   CASE "PRINT_INTEGER"
     Direc_102(Algoname$)
   CASE "PRINT_REAL"
     Direc_103(Algoname$)
   CASE "PRINT_STRING"
     Direc_104(Algoname$)
   CASE "QUERY_DIR"
     Direc_105(Algoname$)
   CASE "QUERY_FILE"
     Direc_106(Algoname$)
   CASE "QUERY_GRAPH"
     Direc_107(Algoname$)
   CASE "QUERY_LAUNCH"
     Direc_108(Algoname$)
   CASE "QUERY_START"
     Direc_109(Algoname$)
   CASE "QUERY_STOP"
     Direc_110(Algoname$)
   CASE "QUERY_VIEW"
     Direc_111(Algoname$)
   CASE "RCP_CHECK_KEY"
     Direc_112(Algoname$)
   CASE "RCP_DIETST"
     Direc_113(Algoname$)
   CASE "RCP_EXEC_CMD"
     Direc_114(Algoname$)
   CASE "RCP_LIMBLD"
     Direc_115(Algoname$)
   CASE "RCP_MK_FILENAME"
     Direc_116(Algoname$)
   CASE "RCP_QUERY_RECIP"
     Direc_117(Algoname$)
   CASE "RCP_REPLACE_WD"
     Direc_118(Algoname$)
   CASE "RCP_SYSCONF"
     Direc_119(Algoname$)
   CASE "RCP_TPLBLD"
     Direc_120(Algoname$)
   CASE "READ_CHAR"
     Direc_121(Algoname$)
   CASE "READ_INTEGER"
     Direc_122(Algoname$)
   CASE "READ_PROCCOND"
     Direc_123(Algoname$)
   CASE "READ_REAL"
     Direc_124(Algoname$)
   CASE "READ_STRING"
     Direc_125(Algoname$)
   CASE "SAVE_TMPDATA"
     Direc_126(Algoname$)
   CASE "SETUSRBIN_LPBGN"
     Direc_127(Algoname$)
   CASE "SET_BRK_MOD"
     Direc_128(Algoname$)
   CASE "SET_JDG_DIE"
     Direc_129(Algoname$)
   CASE "SET_JDG_DIE_ALL"
     Direc_130(Algoname$)
   CASE "SET_JDG_DIE_TYP"
     Direc_131(Algoname$)
   CASE "SET_SAMELEN"
     Direc_132(Algoname$)
   CASE "SET_SAMELEN20"
     Direc_133(Algoname$)
   CASE "SET_TAG_CHAR"
     Direc_134(Algoname$)
   CASE "SET_TAG_INTEGER"
     Direc_135(Algoname$)
   CASE "SET_TAG_REAL"
     Direc_136(Algoname$)
   CASE "SET_TAG_STRING"
     Direc_137(Algoname$)
   CASE "SIZEOFDISPLAY"
     Direc_138(Algoname$)
   CASE "STATLOG_DIEEND"
     Direc_139(Algoname$)
   CASE "STRING_LOOKUP"
     Direc_140(Algoname$)
   CASE "STRING_SPLIT"
     Direc_141(Algoname$)
   CASE "STRING_TIME"
     Direc_142(Algoname$)
   CASE "TIMEDATE"
     Direc_143(Algoname$)
   CASE "UPDATE_FWKCONF"
     Direc_144(Algoname$)
   CASE "VERIFY_FILE"
     Direc_145(Algoname$)
   CASE "WAIT"
     Direc_146(Algoname$)
   CASE "WRITE_CHAR"
     Direc_147(Algoname$)
   CASE "WRITE_INTEGER"
     Direc_148(Algoname$)
   CASE "WRITE_REAL"
     Direc_149(Algoname$)
   CASE "WRITE_STRING"
     Direc_150(Algoname$)
   CASE "WRITE_WAFER_SUM"
     Direc_151(Algoname$)
   CASE "XWUD"
     Direc_152(Algoname$)
   CASE "YIELDLOG_WAFEND"
     Direc_153(Algoname$)
   CASE "FA_READ_CARD"
     Direc_154(Algoname$)
   CASE "FA_QUERY_RECIP"
     Direc_155(Algoname$)
   CASE "CTM_PCIL_ACCESo"
     Direc_156(Algoname$)
   CASE "CTM_TELP8_INFO"
     Direc_157(Algoname$)
   CASE "READ_EQUIPID2"
     Direc_158(Algoname$)
   CASE "REAL_TO_STR"
     Direc_159(Algoname$)
   CASE "CTM_RFID"
     Direc_160(Algoname$)
   CASE "CTM_PC_COUNT"
     Direc_161(Algoname$)
   CASE "CTM_PURGE_DISP"
     Direc_162(Algoname$)
   CASE "CTM_TEST_LOG"
     Direc_163(Algoname$)
   CASE "CTM_POSold"
     Direc_164(Algoname$)
   CASE "FILE_EXIST"
     Direc_165(Algoname$)
   CASE "COPY_FILE"
     Direc_166(Algoname$)
   CASE "CTM_MON_CONV"
     Direc_167(Algoname$)
   CASE "CTM_TIMEDATE"
     Direc_168(Algoname$)
   CASE "CTM_TIME_CAL"
     Direc_169(Algoname$)
   CASE "CTM_POS"
     Direc_170(Algoname$)
   CASE "CTM_FILE_LOOKUP"
     Direc_171(Algoname$)
   CASE "CTM_CLR_XTERM"
     Direc_172(Algoname$)
   CASE "INIT_RELAY"
     Direc_173(Algoname$)
   CASE "CTM_PCID_LOG"
     Direc_174(Algoname$)
   CASE "SET_GUARD_OPEN"
     Direc_175(Algoname$)
   CASE "DISCHARGE_ALL"
     Direc_176(Algoname$)
   CASE "CTM_DIESIZE_CHK"
     Direc_177(Algoname$)
   CASE "CTM_LAST_WAF"
     Direc_178(Algoname$)
   CASE "CTM_PCIL_ACCESS"
     Direc_179(Algoname$)
   CASE "CTM_PC_LEAK"
     Direc_180(Algoname$)
   CASE "CTM_PC_LEAK_DIS"
     Direc_181(Algoname$)
   CASE "CTM_PC_MGR"
     Direc_182(Algoname$)
   CASE "CTM_UPDATE_INFO"
     Direc_183(Algoname$)
   CASE "ESD_ABSORB"
     Direc_184(Algoname$)
   CASE "CTM_UPD_INFO"
     Direc_185(Algoname$)
   CASE "CTM_EXESHELL"
     Direc_186(Algoname$)
   CASE "CTM_PCID_UPD"
     Direc_187(Algoname$)
   CASE "CTM_CHK_LOG4070"
     Direc_188(Algoname$)
   CASE ELSE
   END SELECT
 SUBEND
 Exec_algo:SUB Exec_algo(Spectype$,Specname$)
   INTEGER Id_alg
   REAL Id_buf
   Get_alg_curr(Spectype$,Specname$,Id_alg)
   Id_buf=INT(Id_alg/30)+1
   ON Id_buf GOTO D0,D1,D2,D3,D4,D5,D6
 D0:Id_buf=Id_alg-30*0+1
   ON Id_buf GOTO A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,A16,A17,A18,A19,A20,A21,A22,A23,A24,A25,A26,A27,A28,A29
 D1:Id_buf=Id_alg-30*1+1
   ON Id_buf GOTO A30,A31,A32,A33,A34,A35,A36,A37,A38,A39,A40,A41,A42,A43,A44,A45,A46,A47,A48,A49,A50,A51,A52,A53,A54,A55,A56,A57,A58,A59
 D2:Id_buf=Id_alg-30*2+1
   ON Id_buf GOTO A60,A61,A62,A63,A64,A65,A66,A67,A68,A69,A70,A71,A72,A73,A74,A75,A76,A77,A78,A79,A80,A81,A82,A83,A84,A85,A86,A87,A88,A89
 D3:Id_buf=Id_alg-30*3+1
   ON Id_buf GOTO A90,A91,A92,A93,A94,A95,A96,A97,A98,A99,A100,A101,A102,A103,A104,A105,A106,A107,A108,A109,A110,A111,A112,A113,A114,A115,A116,A117,A118,A119
 D4:Id_buf=Id_alg-30*4+1
   ON Id_buf GOTO A120,A121,A122,A123,A124,A125,A126,A127,A128,A129,A130,A131,A132,A133,A134,A135,A136,A137,A138,A139,A140,A141,A142,A143,A144,A145,A146,A147,A148,A149
 D5:Id_buf=Id_alg-30*5+1
   ON Id_buf GOTO A150,A151,A152,A153,A154,A155,A156,A157,A158,A159,A160,A161,A162,A163,A164,A165,A166,A167,A168,A169,A170,A171,A172,A173,A174,A175,A176,A177,A178,A179
 D6:Id_buf=Id_alg-30*6+1
   ON Id_buf GOTO A180,A181,A182,A183,A184,A185,A186,A187,A188
 A0:Algo_0(Spectype$,Specname$)
   SUBEXIT
 A1:Algo_1(Spectype$,Specname$)
   SUBEXIT
 A2:Algo_2(Spectype$,Specname$)
   SUBEXIT
 A3:Algo_3(Spectype$,Specname$)
   SUBEXIT
 A4:Algo_4(Spectype$,Specname$)
   SUBEXIT
 A5:Algo_5(Spectype$,Specname$)
   SUBEXIT
 A6:Algo_6(Spectype$,Specname$)
   SUBEXIT
 A7:Algo_7(Spectype$,Specname$)
   SUBEXIT
 A8:Algo_8(Spectype$,Specname$)
   SUBEXIT
 A9:Algo_9(Spectype$,Specname$)
   SUBEXIT
 A10:Algo_10(Spectype$,Specname$)
   SUBEXIT
 A11:Algo_11(Spectype$,Specname$)
   SUBEXIT
 A12:Algo_12(Spectype$,Specname$)
   SUBEXIT
 A13:Algo_13(Spectype$,Specname$)
   SUBEXIT
 A14:Algo_14(Spectype$,Specname$)
   SUBEXIT
 A15:Algo_15(Spectype$,Specname$)
   SUBEXIT
 A16:Algo_16(Spectype$,Specname$)
   SUBEXIT
 A17:Algo_17(Spectype$,Specname$)
   SUBEXIT
 A18:Algo_18(Spectype$,Specname$)
   SUBEXIT
 A19:Algo_19(Spectype$,Specname$)
   SUBEXIT
 A20:Algo_20(Spectype$,Specname$)
   SUBEXIT
 A21:Algo_21(Spectype$,Specname$)
   SUBEXIT
 A22:Algo_22(Spectype$,Specname$)
   SUBEXIT
 A23:Algo_23(Spectype$,Specname$)
   SUBEXIT
 A24:Algo_24(Spectype$,Specname$)
   SUBEXIT
 A25:Algo_25(Spectype$,Specname$)
   SUBEXIT
 A26:Algo_26(Spectype$,Specname$)
   SUBEXIT
 A27:Algo_27(Spectype$,Specname$)
   SUBEXIT
 A28:Algo_28(Spectype$,Specname$)
   SUBEXIT
 A29:Algo_29(Spectype$,Specname$)
   SUBEXIT
 A30:Algo_30(Spectype$,Specname$)
   SUBEXIT
 A31:Algo_31(Spectype$,Specname$)
   SUBEXIT
 A32:Algo_32(Spectype$,Specname$)
   SUBEXIT
 A33:Algo_33(Spectype$,Specname$)
   SUBEXIT
 A34:Algo_34(Spectype$,Specname$)
   SUBEXIT
 A35:Algo_35(Spectype$,Specname$)
   SUBEXIT
 A36:Algo_36(Spectype$,Specname$)
   SUBEXIT
 A37:Algo_37(Spectype$,Specname$)
   SUBEXIT
 A38:Algo_38(Spectype$,Specname$)
   SUBEXIT
 A39:Algo_39(Spectype$,Specname$)
   SUBEXIT
 A40:Algo_40(Spectype$,Specname$)
   SUBEXIT
 A41:Algo_41(Spectype$,Specname$)
   SUBEXIT
 A42:Algo_42(Spectype$,Specname$)
   SUBEXIT
 A43:Algo_43(Spectype$,Specname$)
   SUBEXIT
 A44:Algo_44(Spectype$,Specname$)
   SUBEXIT
 A45:Algo_45(Spectype$,Specname$)
   SUBEXIT
 A46:Algo_46(Spectype$,Specname$)
   SUBEXIT
 A47:Algo_47(Spectype$,Specname$)
   SUBEXIT
 A48:Algo_48(Spectype$,Specname$)
   SUBEXIT
 A49:Algo_49(Spectype$,Specname$)
   SUBEXIT
 A50:Algo_50(Spectype$,Specname$)
   SUBEXIT
 A51:Algo_51(Spectype$,Specname$)
   SUBEXIT
 A52:Algo_52(Spectype$,Specname$)
   SUBEXIT
 A53:Algo_53(Spectype$,Specname$)
   SUBEXIT
 A54:Algo_54(Spectype$,Specname$)
   SUBEXIT
 A55:Algo_55(Spectype$,Specname$)
   SUBEXIT
 A56:Algo_56(Spectype$,Specname$)
   SUBEXIT
 A57:Algo_57(Spectype$,Specname$)
   SUBEXIT
 A58:Algo_58(Spectype$,Specname$)
   SUBEXIT
 A59:Algo_59(Spectype$,Specname$)
   SUBEXIT
 A60:Algo_60(Spectype$,Specname$)
   SUBEXIT
 A61:Algo_61(Spectype$,Specname$)
   SUBEXIT
 A62:Algo_62(Spectype$,Specname$)
   SUBEXIT
 A63:Algo_63(Spectype$,Specname$)
   SUBEXIT
 A64:Algo_64(Spectype$,Specname$)
   SUBEXIT
 A65:Algo_65(Spectype$,Specname$)
   SUBEXIT
 A66:Algo_66(Spectype$,Specname$)
   SUBEXIT
 A67:Algo_67(Spectype$,Specname$)
   SUBEXIT
 A68:Algo_68(Spectype$,Specname$)
   SUBEXIT
 A69:Algo_69(Spectype$,Specname$)
   SUBEXIT
 A70:Algo_70(Spectype$,Specname$)
   SUBEXIT
 A71:Algo_71(Spectype$,Specname$)
   SUBEXIT
 A72:Algo_72(Spectype$,Specname$)
   SUBEXIT
 A73:Algo_73(Spectype$,Specname$)
   SUBEXIT
 A74:Algo_74(Spectype$,Specname$)
   SUBEXIT
 A75:Algo_75(Spectype$,Specname$)
   SUBEXIT
 A76:Algo_76(Spectype$,Specname$)
   SUBEXIT
 A77:Algo_77(Spectype$,Specname$)
   SUBEXIT
 A78:Algo_78(Spectype$,Specname$)
   SUBEXIT
 A79:Algo_79(Spectype$,Specname$)
   SUBEXIT
 A80:Algo_80(Spectype$,Specname$)
   SUBEXIT
 A81:Algo_81(Spectype$,Specname$)
   SUBEXIT
 A82:Algo_82(Spectype$,Specname$)
   SUBEXIT
 A83:Algo_83(Spectype$,Specname$)
   SUBEXIT
 A84:Algo_84(Spectype$,Specname$)
   SUBEXIT
 A85:Algo_85(Spectype$,Specname$)
   SUBEXIT
 A86:Algo_86(Spectype$,Specname$)
   SUBEXIT
 A87:Algo_87(Spectype$,Specname$)
   SUBEXIT
 A88:Algo_88(Spectype$,Specname$)
   SUBEXIT
 A89:Algo_89(Spectype$,Specname$)
   SUBEXIT
 A90:Algo_90(Spectype$,Specname$)
   SUBEXIT
 A91:Algo_91(Spectype$,Specname$)
   SUBEXIT
 A92:Algo_92(Spectype$,Specname$)
   SUBEXIT
 A93:Algo_93(Spectype$,Specname$)
   SUBEXIT
 A94:Algo_94(Spectype$,Specname$)
   SUBEXIT
 A95:Algo_95(Spectype$,Specname$)
   SUBEXIT
 A96:Algo_96(Spectype$,Specname$)
   SUBEXIT
 A97:Algo_97(Spectype$,Specname$)
   SUBEXIT
 A98:Algo_98(Spectype$,Specname$)
   SUBEXIT
 A99:Algo_99(Spectype$,Specname$)
   SUBEXIT
 A100:Algo_100(Spectype$,Specname$)
   SUBEXIT
 A101:Algo_101(Spectype$,Specname$)
   SUBEXIT
 A102:Algo_102(Spectype$,Specname$)
   SUBEXIT
 A103:Algo_103(Spectype$,Specname$)
   SUBEXIT
 A104:Algo_104(Spectype$,Specname$)
   SUBEXIT
 A105:Algo_105(Spectype$,Specname$)
   SUBEXIT
 A106:Algo_106(Spectype$,Specname$)
   SUBEXIT
 A107:Algo_107(Spectype$,Specname$)
   SUBEXIT
 A108:Algo_108(Spectype$,Specname$)
   SUBEXIT
 A109:Algo_109(Spectype$,Specname$)
   SUBEXIT
 A110:Algo_110(Spectype$,Specname$)
   SUBEXIT
 A111:Algo_111(Spectype$,Specname$)
   SUBEXIT
 A112:Algo_112(Spectype$,Specname$)
   SUBEXIT
 A113:Algo_113(Spectype$,Specname$)
   SUBEXIT
 A114:Algo_114(Spectype$,Specname$)
   SUBEXIT
 A115:Algo_115(Spectype$,Specname$)
   SUBEXIT
 A116:Algo_116(Spectype$,Specname$)
   SUBEXIT
 A117:Algo_117(Spectype$,Specname$)
   SUBEXIT
 A118:Algo_118(Spectype$,Specname$)
   SUBEXIT
 A119:Algo_119(Spectype$,Specname$)
   SUBEXIT
 A120:Algo_120(Spectype$,Specname$)
   SUBEXIT
 A121:Algo_121(Spectype$,Specname$)
   SUBEXIT
 A122:Algo_122(Spectype$,Specname$)
   SUBEXIT
 A123:Algo_123(Spectype$,Specname$)
   SUBEXIT
 A124:Algo_124(Spectype$,Specname$)
   SUBEXIT
 A125:Algo_125(Spectype$,Specname$)
   SUBEXIT
 A126:Algo_126(Spectype$,Specname$)
   SUBEXIT
 A127:Algo_127(Spectype$,Specname$)
   SUBEXIT
 A128:Algo_128(Spectype$,Specname$)
   SUBEXIT
 A129:Algo_129(Spectype$,Specname$)
   SUBEXIT
 A130:Algo_130(Spectype$,Specname$)
   SUBEXIT
 A131:Algo_131(Spectype$,Specname$)
   SUBEXIT
 A132:Algo_132(Spectype$,Specname$)
   SUBEXIT
 A133:Algo_133(Spectype$,Specname$)
   SUBEXIT
 A134:Algo_134(Spectype$,Specname$)
   SUBEXIT
 A135:Algo_135(Spectype$,Specname$)
   SUBEXIT
 A136:Algo_136(Spectype$,Specname$)
   SUBEXIT
 A137:Algo_137(Spectype$,Specname$)
   SUBEXIT
 A138:Algo_138(Spectype$,Specname$)
   SUBEXIT
 A139:Algo_139(Spectype$,Specname$)
   SUBEXIT
 A140:Algo_140(Spectype$,Specname$)
   SUBEXIT
 A141:Algo_141(Spectype$,Specname$)
   SUBEXIT
 A142:Algo_142(Spectype$,Specname$)
   SUBEXIT
 A143:Algo_143(Spectype$,Specname$)
   SUBEXIT
 A144:Algo_144(Spectype$,Specname$)
   SUBEXIT
 A145:Algo_145(Spectype$,Specname$)
   SUBEXIT
 A146:Algo_146(Spectype$,Specname$)
   SUBEXIT
 A147:Algo_147(Spectype$,Specname$)
   SUBEXIT
 A148:Algo_148(Spectype$,Specname$)
   SUBEXIT
 A149:Algo_149(Spectype$,Specname$)
   SUBEXIT
 A150:Algo_150(Spectype$,Specname$)
   SUBEXIT
 A151:Algo_151(Spectype$,Specname$)
   SUBEXIT
 A152:Algo_152(Spectype$,Specname$)
   SUBEXIT
 A153:Algo_153(Spectype$,Specname$)
   SUBEXIT
 A154:Algo_154(Spectype$,Specname$)
   SUBEXIT
 A155:Algo_155(Spectype$,Specname$)
   SUBEXIT
 A156:Algo_156(Spectype$,Specname$)
   SUBEXIT
 A157:Algo_157(Spectype$,Specname$)
   SUBEXIT
 A158:Algo_158(Spectype$,Specname$)
   SUBEXIT
 A159:Algo_159(Spectype$,Specname$)
   SUBEXIT
 A160:Algo_160(Spectype$,Specname$)
   SUBEXIT
 A161:Algo_161(Spectype$,Specname$)
   SUBEXIT
 A162:Algo_162(Spectype$,Specname$)
   SUBEXIT
 A163:Algo_163(Spectype$,Specname$)
   SUBEXIT
 A164:Algo_164(Spectype$,Specname$)
   SUBEXIT
 A165:Algo_165(Spectype$,Specname$)
   SUBEXIT
 A166:Algo_166(Spectype$,Specname$)
   SUBEXIT
 A167:Algo_167(Spectype$,Specname$)
   SUBEXIT
 A168:Algo_168(Spectype$,Specname$)
   SUBEXIT
 A169:Algo_169(Spectype$,Specname$)
   SUBEXIT
 A170:Algo_170(Spectype$,Specname$)
   SUBEXIT
 A171:Algo_171(Spectype$,Specname$)
   SUBEXIT
 A172:Algo_172(Spectype$,Specname$)
   SUBEXIT
 A173:Algo_173(Spectype$,Specname$)
   SUBEXIT
 A174:Algo_174(Spectype$,Specname$)
   SUBEXIT
 A175:Algo_175(Spectype$,Specname$)
   SUBEXIT
 A176:Algo_176(Spectype$,Specname$)
   SUBEXIT
 A177:Algo_177(Spectype$,Specname$)
   SUBEXIT
 A178:Algo_178(Spectype$,Specname$)
   SUBEXIT
 A179:Algo_179(Spectype$,Specname$)
   SUBEXIT
 A180:Algo_180(Spectype$,Specname$)
   SUBEXIT
 A181:Algo_181(Spectype$,Specname$)
   SUBEXIT
 A182:Algo_182(Spectype$,Specname$)
   SUBEXIT
 A183:Algo_183(Spectype$,Specname$)
   SUBEXIT
 A184:Algo_184(Spectype$,Specname$)
   SUBEXIT
 A185:Algo_185(Spectype$,Specname$)
   SUBEXIT
 A186:Algo_186(Spectype$,Specname$)
   SUBEXIT
 A187:Algo_187(Spectype$,Specname$)
   SUBEXIT
 A188:Algo_188(Spectype$,Specname$)
   SUBEXIT
 SUBEND
 Direc_0:SUB Direc_0(Algoname$)
   OPTION BASE 1
   INTEGER G(4)
   REAL K(6)
   Get_alg_real("G_IDVD",0,0,0,K(*))
   Get_alg_int("G_IDVD",1,0,0,G(*))
   K(1)=DROUND(K(1),6)
   G_idvd(K(1),K(2),K(3),K(4),K(5),K(6),G(*))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_1:SUB Direc_1(Algoname$)
   OPTION BASE 1
   INTEGER G(4)
   REAL K(7)
   Get_alg_real("G_IDVG",0,0,0,K(*))
   Get_alg_int("G_IDVG",1,0,0,G(*))
   K(1)=DROUND(K(1),6)
   G_idvg(K(1),K(2),K(3),K(4),K(5),K(6),K(7),G(*))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_2:SUB Direc_2(Algoname$)
   OPTION BASE 1
   INTEGER G(3)
   REAL K(6)
   Get_alg_real("G_ICVC",0,0,0,K(*))
   Get_alg_int("G_ICVC",1,0,0,G(*))
   K(1)=DROUND(K(1),6)
   G_icvc(K(1),K(2),K(3),K(4),K(5),K(6),G(*))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_3:SUB Direc_3(Algoname$)
   OPTION BASE 1
   INTEGER G(3)
   REAL K(3)
   Get_alg_real("G_ICVB",0,0,0,K(*))
   Get_alg_int("G_ICVB",1,0,0,G(*))
   K(1)=DROUND(K(1),6)
   G_icvb(K(1),K(2),K(3),G(*))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_4:SUB Direc_4(Algoname$)
   OPTION BASE 1
   INTEGER A(1),G(3)
   REAL K(3)
   Get_alg_int("G_HFE",0,0,0,A(*))
   Get_alg_real("G_HFE",0,0,0,K(*))
   Get_alg_int("G_HFE",1,0,0,G(*))
   K(1)=DROUND(K(1),6)
   G_hfe(K(1),K(2),A(1),K(3),G(*))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_5:SUB Direc_5(Algoname$)
   OPTION BASE 1
   INTEGER G(2)
   REAL K(5)
   Get_alg_real("G_CV",0,0,0,K(*))
   Get_alg_int("G_CV",1,0,0,G(*))
   K(1)=DROUND(K(1),6)
   G_cv(K(1),K(2),K(3),K(4),K(5),G(*))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_6:SUB Direc_6(Algoname$)
   OPTION BASE 1
   DIM A$(4)[256]
   Get_alg_string("ALGPANEL_LAUNCH",0,0,0,A$(*))
   Algpanel_launch(A$(1),A$(2),A$(3),A$(4))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_7:SUB Direc_7(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   Get_alg_int("ALGPANEL_START",0,0,0,A(*))
   Algpanel_start(A(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_8:SUB Direc_8(Algoname$)
   OPTION BASE 1
   Algpanel_stop
   ON ERROR CALL Error_handler
 SUBEND
 Direc_9:SUB Direc_9(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(1)[256],G$(1)[256]
   Get_alg_int("APPLY_FWKCONF",0,0,0,A(*))
   Get_alg_string("APPLY_FWKCONF",0,0,0,A$(*))
   Get_alg_int("APPLY_FWKCONF",3,0,0,H(*))
   Get_alg_string("APPLY_FWKCONF",3,0,0,G$(*))
   Apply_fwkconf(A$(1),A(1),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("APPLY_FWKCONF",3,0,0,H(*))
   Put_alg_string("APPLY_FWKCONF",3,0,0,G$(*))
 SUBEND
 Direc_10:SUB Direc_10(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256],B0$(256)[256]
   Get_alg_string("ARRAY_LOOKUP1",0,0,0,A$(*))
   Get_alg_string("ARRAY_LOOKUP1",0,1,0,B0$(*))
   Get_alg_int("ARRAY_LOOKUP1",3,0,0,H(*))
   Array_lookup1(B0$(*),A$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("ARRAY_LOOKUP1",3,0,0,H(*))
 SUBEND
 Direc_11:SUB Direc_11(Algoname$)
   OPTION BASE 1
   INTEGER I0(256)
   DIM B0$(256)[256],B1$(256)[256]
   Get_alg_string("ARRAY_LOOKUP2",0,1,0,B0$(*))
   Get_alg_string("ARRAY_LOOKUP2",0,1,1,B1$(*))
   Get_alg_int("ARRAY_LOOKUP2",3,1,0,I0(*))
   Array_lookup2(B0$(*),B1$(*),I0(*))
   ON ERROR CALL Error_handler
   Put_alg_int("ARRAY_LOOKUP2",3,1,0,I0(*))
 SUBEND
 Direc_12:SUB Direc_12(Algoname$)
   OPTION BASE 1
   INTEGER B0(256)
   DIM B0$(256)[256],H0$(256)[256]
   Get_alg_int("ARRAY_LOOKUP3",0,1,0,B0(*))
   Get_alg_string("ARRAY_LOOKUP3",0,1,0,B0$(*))
   Get_alg_string("ARRAY_LOOKUP3",3,1,0,H0$(*))
   Array_lookup3(B0$(*),B0(*),H0$(*))
   ON ERROR CALL Error_handler
   Put_alg_string("ARRAY_LOOKUP3",3,1,0,H0$(*))
 SUBEND
 Direc_13:SUB Direc_13(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256],G$(3)[256]
   Get_alg_string("ATTRIB_FILE",0,0,0,A$(*))
   Get_alg_string("ATTRIB_FILE",3,0,0,G$(*))
   Attrib_file(A$(1),G$(1),G$(2),G$(3))
   ON ERROR CALL Error_handler
   Put_alg_string("ATTRIB_FILE",3,0,0,G$(*))
 SUBEND
 Direc_14:SUB Direc_14(Algoname$)
   OPTION BASE 1
   REAL K(2)
   Get_alg_real("BEEP",0,0,0,K(*))
   K(1)=DROUND(K(1),6)
   Beep(K(1),K(2))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_15:SUB Direc_15(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(3)[256],G$(1)[256]
   Get_alg_string("CALL_ERRHANDLER",0,0,0,A$(*))
   Get_alg_int("CALL_ERRHANDLER",3,0,0,H(*))
   Get_alg_string("CALL_ERRHANDLER",3,0,0,G$(*))
   Call_errhandler(A$(1),A$(2),A$(3),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CALL_ERRHANDLER",3,0,0,H(*))
   Put_alg_string("CALL_ERRHANDLER",3,0,0,G$(*))
 SUBEND
 Direc_16:SUB Direc_16(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256]
   Get_alg_string("CHECK_DATAFILE",0,0,0,A$(*))
   Get_alg_int("CHECK_DATAFILE",3,0,0,H(*))
   Check_datafile(A$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CHECK_DATAFILE",3,0,0,H(*))
 SUBEND
 Direc_17:SUB Direc_17(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256]
   Get_alg_string("CHECK_FILE",0,0,0,A$(*))
   Get_alg_int("CHECK_FILE",3,0,0,H(*))
   Check_file(A$(1),A$(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CHECK_FILE",3,0,0,H(*))
 SUBEND
 Direc_18:SUB Direc_18(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256]
   Get_alg_string("CHECK_PASSWD",0,0,0,A$(*))
   Get_alg_int("CHECK_PASSWD",3,0,0,H(*))
   Check_passwd(A$(1),A$(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CHECK_PASSWD",3,0,0,H(*))
 SUBEND
 Direc_19:SUB Direc_19(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256],G$(2)[256]
   Get_alg_string("CHECK_PROBER",0,0,0,A$(*))
   Get_alg_string("CHECK_PROBER",3,0,0,G$(*))
   Check_prober(A$(1),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_string("CHECK_PROBER",3,0,0,G$(*))
 SUBEND
 Direc_20:SUB Direc_20(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   Get_alg_int("CHECK_PROFILE",3,0,0,H(*))
   Check_profile(H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CHECK_PROFILE",3,0,0,H(*))
 SUBEND
 Direc_21:SUB Direc_21(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM G$(10)[256]
   Get_alg_int("CHECK_SYSCONF",3,0,0,H(*))
   Get_alg_string("CHECK_SYSCONF",3,0,0,G$(*))
   Check_sysconf(H(1),G$(1),G$(2),G$(3),G$(4),G$(5),G$(6),G$(7),G$(8),G$(9),G$(10))
   ON ERROR CALL Error_handler
   Put_alg_int("CHECK_SYSCONF",3,0,0,H(*))
   Put_alg_string("CHECK_SYSCONF",3,0,0,G$(*))
 SUBEND
 Direc_22:SUB Direc_22(Algoname$)
   OPTION BASE 1
   REAL Q(1)
   Get_alg_real("CHECK_TIME",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Check_time(Q(1))
   ON ERROR CALL Error_handler
   Put_alg_real("CHECK_TIME",3,0,0,Q(*))
 SUBEND
 Direc_23:SUB Direc_23(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(6)
   REAL Q(1)
   Get_alg_int("CLOCK",0,0,0,A(*))
   Get_alg_int("CLOCK",3,0,0,H(*))
   Get_alg_real("CLOCK",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Clock(A(1),H(1),H(2),H(3),H(4),H(5),H(6),Q(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CLOCK",3,0,0,H(*))
   Put_alg_real("CLOCK",3,0,0,Q(*))
 SUBEND
 Direc_24:SUB Direc_24(Algoname$)
   OPTION BASE 1
   INTEGER A(5)
   DIM A$(1)[256]
   Get_alg_int("CREATE_WINDOW",0,0,0,A(*))
   Get_alg_string("CREATE_WINDOW",0,0,0,A$(*))
   Create_window(A(1),A(2),A(3),A(4),A(5),A$(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_25:SUB Direc_25(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM A$(1)[256]
   Get_alg_int("DATALOG_DIEEND",0,0,0,A(*))
   Get_alg_string("DATALOG_DIEEND",0,0,0,A$(*))
   Datalog_dieend(A$(1),A(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_26:SUB Direc_26(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   Get_alg_int("DESTROY_WINDOW",0,0,0,A(*))
   Destroy_window(A(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_27:SUB Direc_27(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256],G$(1)[256]
   Get_alg_string("FA_BLDSCR_LIM",0,0,0,A$(*))
   Get_alg_int("FA_BLDSCR_LIM",3,0,0,H(*))
   Get_alg_string("FA_BLDSCR_LIM",3,0,0,G$(*))
   Fa_bldscr_lim(A$(1),A$(2),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_BLDSCR_LIM",3,0,0,H(*))
   Put_alg_string("FA_BLDSCR_LIM",3,0,0,G$(*))
 SUBEND
 Direc_28:SUB Direc_28(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256],G$(1)[256]
   Get_alg_string("FA_BLDSCR_TPL",0,0,0,A$(*))
   Get_alg_int("FA_BLDSCR_TPL",3,0,0,H(*))
   Get_alg_string("FA_BLDSCR_TPL",3,0,0,G$(*))
   Fa_bldscr_tpl(A$(1),A$(2),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_BLDSCR_TPL",3,0,0,H(*))
   Put_alg_string("FA_BLDSCR_TPL",3,0,0,G$(*))
 SUBEND
 Direc_29:SUB Direc_29(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   DIM A$(2)[256]
   Get_alg_string("FA_CHKRUN_FWK",0,0,0,A$(*))
   Get_alg_int("FA_CHKRUN_FWK",3,0,0,H(*))
   Fa_chkrun_fwk(A$(1),A$(2),H(1),H(2))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_CHKRUN_FWK",3,0,0,H(*))
 SUBEND
 Direc_30:SUB Direc_30(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(4)[256]
   Get_alg_int("FA_CHK_FILES",0,0,0,A(*))
   Get_alg_string("FA_CHK_FILES",0,0,0,A$(*))
   Get_alg_int("FA_CHK_FILES",3,0,0,H(*))
   Fa_chk_files(A(1),A$(1),A$(2),A$(3),A$(4),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_CHK_FILES",3,0,0,H(*))
 SUBEND
 Direc_31:SUB Direc_31(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(4)[256],G$(2)[256]
   Get_alg_int("FA_CHK_FILES2",0,0,0,A(*))
   Get_alg_string("FA_CHK_FILES2",0,0,0,A$(*))
   Get_alg_int("FA_CHK_FILES2",3,0,0,H(*))
   Get_alg_string("FA_CHK_FILES2",3,0,0,G$(*))
   Fa_chk_files2(A(1),A$(1),A$(2),A$(3),A$(4),H(1),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_CHK_FILES2",3,0,0,H(*))
   Put_alg_string("FA_CHK_FILES2",3,0,0,G$(*))
 SUBEND
 Direc_32:SUB Direc_32(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   DIM A$(1)[256],G$(2)[256]
   Get_alg_string("FA_CHK_LIBPATH",0,0,0,A$(*))
   Get_alg_int("FA_CHK_LIBPATH",3,0,0,H(*))
   Get_alg_string("FA_CHK_LIBPATH",3,0,0,G$(*))
   Fa_chk_libpath(A$(1),H(1),H(2),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_CHK_LIBPATH",3,0,0,H(*))
   Put_alg_string("FA_CHK_LIBPATH",3,0,0,G$(*))
 SUBEND
 Direc_33:SUB Direc_33(Algoname$)
   OPTION BASE 1
   INTEGER A(2),H(1)
   DIM A$(1)[256],B0$(256)[256],G$(1)[256]
   Get_alg_int("FA_CHK_MEASLIB",0,0,0,A(*))
   Get_alg_string("FA_CHK_MEASLIB",0,0,0,A$(*))
   Get_alg_string("FA_CHK_MEASLIB",0,1,0,B0$(*))
   Get_alg_int("FA_CHK_MEASLIB",3,0,0,H(*))
   Get_alg_string("FA_CHK_MEASLIB",3,0,0,G$(*))
   Fa_chk_measlib(A(1),B0$(*),A(2),A$(1),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_CHK_MEASLIB",3,0,0,H(*))
   Put_alg_string("FA_CHK_MEASLIB",3,0,0,G$(*))
 SUBEND
 Direc_34:SUB Direc_34(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256],G$(4)[256]
   Get_alg_string("FA_CHK_REV",0,0,0,A$(*))
   Get_alg_int("FA_CHK_REV",3,0,0,H(*))
   Get_alg_string("FA_CHK_REV",3,0,0,G$(*))
   Fa_chk_rev(A$(1),A$(2),H(1),G$(1),G$(2),G$(3),G$(4))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_CHK_REV",3,0,0,H(*))
   Put_alg_string("FA_CHK_REV",3,0,0,G$(*))
 SUBEND
 Direc_35:SUB Direc_35(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(2)[256],G$(4)[256]
   Get_alg_int("FA_CHK_REV2",0,0,0,A(*))
   Get_alg_string("FA_CHK_REV2",0,0,0,A$(*))
   Get_alg_int("FA_CHK_REV2",3,0,0,H(*))
   Get_alg_string("FA_CHK_REV2",3,0,0,G$(*))
   Fa_chk_rev2(A$(1),A$(2),A(1),H(1),G$(1),G$(2),G$(3),G$(4))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_CHK_REV2",3,0,0,H(*))
   Put_alg_string("FA_CHK_REV2",3,0,0,G$(*))
 SUBEND
 Direc_36:SUB Direc_36(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256],G$(10)[256]
   Get_alg_string("FA_GETKEY_ITEMS",0,0,0,A$(*))
   Get_alg_int("FA_GETKEY_ITEMS",3,0,0,H(*))
   Get_alg_string("FA_GETKEY_ITEMS",3,0,0,G$(*))
   Fa_getkey_items(A$(1),A$(2),G$(1),G$(2),G$(3),G$(4),G$(5),G$(6),G$(7),G$(8),G$(9),G$(10),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_GETKEY_ITEMS",3,0,0,H(*))
   Put_alg_string("FA_GETKEY_ITEMS",3,0,0,G$(*))
 SUBEND
 Direc_37:SUB Direc_37(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(2)
   DIM A$(5)[256],G$(1)[256],H0$(10)[256]
   Get_alg_int("FA_LIMBLD",0,0,0,A(*))
   Get_alg_string("FA_LIMBLD",0,0,0,A$(*))
   Get_alg_int("FA_LIMBLD",3,0,0,H(*))
   Get_alg_string("FA_LIMBLD",3,0,0,G$(*))
   Get_alg_string("FA_LIMBLD",3,1,0,H0$(*))
   Fa_limbld(A(1),A$(1),A$(2),A$(3),A$(4),A$(5),H(1),G$(1),H(2),H0$(*))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_LIMBLD",3,0,0,H(*))
   Put_alg_string("FA_LIMBLD",3,0,0,G$(*))
   Put_alg_string("FA_LIMBLD",3,1,0,H0$(*))
 SUBEND
 Direc_38:SUB Direc_38(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(2)
   DIM A$(6)[256],B0$(256)[256],G$(1)[256],H0$(10)[256]
   Get_alg_int("FA_LIMBLD2",0,0,0,A(*))
   Get_alg_string("FA_LIMBLD2",0,0,0,A$(*))
   Get_alg_string("FA_LIMBLD2",0,1,0,B0$(*))
   Get_alg_int("FA_LIMBLD2",3,0,0,H(*))
   Get_alg_string("FA_LIMBLD2",3,0,0,G$(*))
   Get_alg_string("FA_LIMBLD2",3,1,0,H0$(*))
   Fa_limbld2(A(1),A$(1),A$(2),A$(3),A$(4),A$(5),A$(6),B0$(*),H(1),G$(1),H(2),H0$(*))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_LIMBLD2",3,0,0,H(*))
   Put_alg_string("FA_LIMBLD2",3,0,0,G$(*))
   Put_alg_string("FA_LIMBLD2",3,1,0,H0$(*))
 SUBEND
 Direc_39:SUB Direc_39(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(7)[256],G$(1)[256]
   Get_alg_int("FA_LIMFMT",0,0,0,A(*))
   Get_alg_string("FA_LIMFMT",0,0,0,A$(*))
   Get_alg_int("FA_LIMFMT",3,0,0,H(*))
   Get_alg_string("FA_LIMFMT",3,0,0,G$(*))
   Fa_limfmt(A(1),A$(1),A$(2),A$(3),A$(4),A$(5),A$(6),A$(7),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_LIMFMT",3,0,0,H(*))
   Put_alg_string("FA_LIMFMT",3,0,0,G$(*))
 SUBEND
 Direc_40:SUB Direc_40(Algoname$)
   OPTION BASE 1
   INTEGER A(2),H(1)
   Get_alg_int("FA_LMP_CLEARLN",0,0,0,A(*))
   Get_alg_int("FA_LMP_CLEARLN",3,0,0,H(*))
   Fa_lmp_clearln(A(1),A(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_LMP_CLEARLN",3,0,0,H(*))
 SUBEND
 Direc_41:SUB Direc_41(Algoname$)
   OPTION BASE 1
   INTEGER A(2),H(1)
   DIM A$(3)[256]
   Get_alg_int("FA_LMP_DISPINT",0,0,0,A(*))
   Get_alg_string("FA_LMP_DISPINT",0,0,0,A$(*))
   Get_alg_int("FA_LMP_DISPINT",3,0,0,H(*))
   Fa_lmp_dispint(A(1),A$(1),A(2),A$(2),A$(3),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_LMP_DISPINT",3,0,0,H(*))
 SUBEND
 Direc_42:SUB Direc_42(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(4)[256]
   Get_alg_int("FA_LMP_DISPLINE",0,0,0,A(*))
   Get_alg_string("FA_LMP_DISPLINE",0,0,0,A$(*))
   Get_alg_int("FA_LMP_DISPLINE",3,0,0,H(*))
   Fa_lmp_displine(A(1),A$(1),A$(2),A$(3),A$(4),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_LMP_DISPLINE",3,0,0,H(*))
 SUBEND
 Direc_43:SUB Direc_43(Algoname$)
   OPTION BASE 1
   INTEGER A(2),H(1)
   DIM A$(3)[256]
   Get_alg_int("FA_LMP_DISPVAR",0,0,0,A(*))
   Get_alg_string("FA_LMP_DISPVAR",0,0,0,A$(*))
   Get_alg_int("FA_LMP_DISPVAR",3,0,0,H(*))
   Fa_lmp_dispvar(A(1),A$(1),A(2),A$(2),A$(3),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_LMP_DISPVAR",3,0,0,H(*))
 SUBEND
 Direc_44:SUB Direc_44(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(4)[256],G$(2)[256]
   Get_alg_int("FA_MK_DATANAME",0,0,0,A(*))
   Get_alg_string("FA_MK_DATANAME",0,0,0,A$(*))
   Get_alg_int("FA_MK_DATANAME",3,0,0,H(*))
   Get_alg_string("FA_MK_DATANAME",3,0,0,G$(*))
   Fa_mk_dataname(A$(1),A$(2),A(1),A$(3),A$(4),G$(1),G$(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_MK_DATANAME",3,0,0,H(*))
   Put_alg_string("FA_MK_DATANAME",3,0,0,G$(*))
 SUBEND
 Direc_45:SUB Direc_45(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(3)[256],G$(2)[256],H0$(16)[256],H1$(256)[256],H2$(256)[256],H3$(256)[256],H4$(32)[256]
   Get_alg_string("FA_QUERY_COND",0,0,0,A$(*))
   Get_alg_int("FA_QUERY_COND",3,0,0,H(*))
   Get_alg_string("FA_QUERY_COND",3,0,0,G$(*))
   Get_alg_string("FA_QUERY_COND",3,1,0,H0$(*))
   Get_alg_string("FA_QUERY_COND",3,1,1,H1$(*))
   Get_alg_string("FA_QUERY_COND",3,1,2,H2$(*))
   Get_alg_string("FA_QUERY_COND",3,1,3,H3$(*))
   Get_alg_string("FA_QUERY_COND",3,1,4,H4$(*))
   Fa_query_cond(A$(1),A$(2),A$(3),H0$(*),G$(1),H1$(*),H2$(*),H3$(*),H4$(*),H(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_QUERY_COND",3,0,0,H(*))
   Put_alg_string("FA_QUERY_COND",3,0,0,G$(*))
   Put_alg_string("FA_QUERY_COND",3,1,0,H0$(*))
   Put_alg_string("FA_QUERY_COND",3,1,1,H1$(*))
   Put_alg_string("FA_QUERY_COND",3,1,2,H2$(*))
   Put_alg_string("FA_QUERY_COND",3,1,3,H3$(*))
   Put_alg_string("FA_QUERY_COND",3,1,4,H4$(*))
 SUBEND
 Direc_46:SUB Direc_46(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256],G$(9)[256],H0$(256)[256],H1$(256)[256],H2$(256)[256],H3$(256)[256],H4$(16)[256],H5$(256)[256],H6$(32)[256]
   Get_alg_string("FA_QUERY_RCP2",0,0,0,A$(*))
   Get_alg_int("FA_QUERY_RCP2",3,0,0,H(*))
   Get_alg_string("FA_QUERY_RCP2",3,0,0,G$(*))
   Get_alg_string("FA_QUERY_RCP2",3,1,0,H0$(*))
   Get_alg_string("FA_QUERY_RCP2",3,1,1,H1$(*))
   Get_alg_string("FA_QUERY_RCP2",3,1,2,H2$(*))
   Get_alg_string("FA_QUERY_RCP2",3,1,3,H3$(*))
   Get_alg_string("FA_QUERY_RCP2",3,1,4,H4$(*))
   Get_alg_string("FA_QUERY_RCP2",3,1,5,H5$(*))
   Get_alg_string("FA_QUERY_RCP2",3,1,6,H6$(*))
   Fa_query_rcp2(A$(1),A$(2),G$(1),H0$(*),H1$(*),H2$(*),G$(2),H3$(*),H4$(*),G$(3),G$(4),H5$(*),G$(5),G$(6),G$(7),G$(8),H6$(*),H(1),G$(9))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_QUERY_RCP2",3,0,0,H(*))
   Put_alg_string("FA_QUERY_RCP2",3,0,0,G$(*))
   Put_alg_string("FA_QUERY_RCP2",3,1,0,H0$(*))
   Put_alg_string("FA_QUERY_RCP2",3,1,1,H1$(*))
   Put_alg_string("FA_QUERY_RCP2",3,1,2,H2$(*))
   Put_alg_string("FA_QUERY_RCP2",3,1,3,H3$(*))
   Put_alg_string("FA_QUERY_RCP2",3,1,4,H4$(*))
   Put_alg_string("FA_QUERY_RCP2",3,1,5,H5$(*))
   Put_alg_string("FA_QUERY_RCP2",3,1,6,H6$(*))
 SUBEND
 Direc_47:SUB Direc_47(Algoname$)
   OPTION BASE 1
   INTEGER H(3)
   DIM A$(2)[256],G$(1)[256],H0$(10)[256]
   Get_alg_string("FA_RCP_EXEC_CMD",0,0,0,A$(*))
   Get_alg_int("FA_RCP_EXEC_CMD",3,0,0,H(*))
   Get_alg_string("FA_RCP_EXEC_CMD",3,0,0,G$(*))
   Get_alg_string("FA_RCP_EXEC_CMD",3,1,0,H0$(*))
   Fa_rcp_exec_cmd(A$(1),A$(2),H(1),G$(1),H(2),H0$(*),H(3))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_RCP_EXEC_CMD",3,0,0,H(*))
   Put_alg_string("FA_RCP_EXEC_CMD",3,0,0,G$(*))
   Put_alg_string("FA_RCP_EXEC_CMD",3,1,0,H0$(*))
 SUBEND
 Direc_48:SUB Direc_48(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(4)[256],G$(1)[256]
   Get_alg_string("FA_RUNP_CREATE",0,0,0,A$(*))
   Get_alg_int("FA_RUNP_CREATE",3,0,0,H(*))
   Get_alg_string("FA_RUNP_CREATE",3,0,0,G$(*))
   Fa_runp_create(A$(1),A$(2),A$(3),A$(4),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_RUNP_CREATE",3,0,0,H(*))
   Put_alg_string("FA_RUNP_CREATE",3,0,0,G$(*))
 SUBEND
 Direc_49:SUB Direc_49(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(7)[256],G$(1)[256]
   Get_alg_int("FA_TPLFMT",0,0,0,A(*))
   Get_alg_string("FA_TPLFMT",0,0,0,A$(*))
   Get_alg_int("FA_TPLFMT",3,0,0,H(*))
   Get_alg_string("FA_TPLFMT",3,0,0,G$(*))
   Fa_tplfmt(A(1),A$(1),A$(2),A$(3),A$(4),A$(5),A$(6),A$(7),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_TPLFMT",3,0,0,H(*))
   Put_alg_string("FA_TPLFMT",3,0,0,G$(*))
 SUBEND
 Direc_50:SUB Direc_50(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(2)
   DIM A$(9)[256],B0$(32)[256],B1$(32)[256],G$(1)[256],H0$(10)[256]
   Get_alg_int("FA_TPLBLD",0,0,0,A(*))
   Get_alg_string("FA_TPLBLD",0,0,0,A$(*))
   Get_alg_string("FA_TPLBLD",0,1,0,B0$(*))
   Get_alg_string("FA_TPLBLD",0,1,1,B1$(*))
   Get_alg_int("FA_TPLBLD",3,0,0,H(*))
   Get_alg_string("FA_TPLBLD",3,0,0,G$(*))
   Get_alg_string("FA_TPLBLD",3,1,0,H0$(*))
   Fa_tplbld(A(1),A$(1),A$(2),A$(3),A$(4),A$(5),A$(6),A$(7),A$(8),B0$(*),B1$(*),A$(9),H(1),G$(1),H(2),H0$(*))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_TPLBLD",3,0,0,H(*))
   Put_alg_string("FA_TPLBLD",3,0,0,G$(*))
   Put_alg_string("FA_TPLBLD",3,1,0,H0$(*))
 SUBEND
 Direc_51:SUB Direc_51(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(2)
   DIM A$(15)[256],B0$(256)[256],B1$(256)[256],B2$(256)[256],G$(1)[256],H0$(10)[256]
   Get_alg_int("FA_TPLBLD2",0,0,0,A(*))
   Get_alg_string("FA_TPLBLD2",0,0,0,A$(*))
   Get_alg_string("FA_TPLBLD2",0,1,0,B0$(*))
   Get_alg_string("FA_TPLBLD2",0,1,1,B1$(*))
   Get_alg_string("FA_TPLBLD2",0,1,2,B2$(*))
   Get_alg_int("FA_TPLBLD2",3,0,0,H(*))
   Get_alg_string("FA_TPLBLD2",3,0,0,G$(*))
   Get_alg_string("FA_TPLBLD2",3,1,0,H0$(*))
   Fa_tplbld2(A(1),A$(1),A$(2),A$(3),A$(4),A$(5),A$(6),A$(7),A$(8),A$(9),B0$(*),B1$(*),B2$(*),A$(10),A$(11),A$(12),A$(13),A$(14),A$(15),H(1),G$(1),H(2),H0$(*))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_TPLBLD2",3,0,0,H(*))
   Put_alg_string("FA_TPLBLD2",3,0,0,G$(*))
   Put_alg_string("FA_TPLBLD2",3,1,0,H0$(*))
 SUBEND
 Direc_52:SUB Direc_52(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(2)
   DIM A$(14)[256],B0$(256)[256],B1$(256)[256],B2$(256)[256],B3$(256)[256],G$(1)[256],H0$(10)[256]
   Get_alg_int("FA_TPLBLD3",0,0,0,A(*))
   Get_alg_string("FA_TPLBLD3",0,0,0,A$(*))
   Get_alg_string("FA_TPLBLD3",0,1,0,B0$(*))
   Get_alg_string("FA_TPLBLD3",0,1,1,B1$(*))
   Get_alg_string("FA_TPLBLD3",0,1,2,B2$(*))
   Get_alg_string("FA_TPLBLD3",0,1,3,B3$(*))
   Get_alg_int("FA_TPLBLD3",3,0,0,H(*))
   Get_alg_string("FA_TPLBLD3",3,0,0,G$(*))
   Get_alg_string("FA_TPLBLD3",3,1,0,H0$(*))
   Fa_tplbld3(A(1),A$(1),A$(2),A$(3),A$(4),A$(5),A$(6),A$(7),A$(8),A$(9),B0$(*),B1$(*),B2$(*),A$(10),B3$(*),A$(11),A$(12),A$(13),A$(14),H(1),G$(1),H(2),H0$(*))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_TPLBLD3",3,0,0,H(*))
   Put_alg_string("FA_TPLBLD3",3,0,0,G$(*))
   Put_alg_string("FA_TPLBLD3",3,1,0,H0$(*))
 SUBEND
 Direc_53:SUB Direc_53(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256],G$(1)[256]
   Get_alg_string("FA_TPL_RUN",0,0,0,A$(*))
   Get_alg_int("FA_TPL_RUN",3,0,0,H(*))
   Get_alg_string("FA_TPL_RUN",3,0,0,G$(*))
   Fa_tpl_run(A$(1),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_TPL_RUN",3,0,0,H(*))
   Put_alg_string("FA_TPL_RUN",3,0,0,G$(*))
 SUBEND
 Direc_54:SUB Direc_54(Algoname$)
   OPTION BASE 1
   INTEGER A(4),H(1)
   DIM A$(2)[256],B0$(256)[256],B1$(256)[256],G$(1)[256]
   Get_alg_int("FA_TPL_VERIFY",0,0,0,A(*))
   Get_alg_string("FA_TPL_VERIFY",0,0,0,A$(*))
   Get_alg_string("FA_TPL_VERIFY",0,1,0,B0$(*))
   Get_alg_string("FA_TPL_VERIFY",0,1,1,B1$(*))
   Get_alg_int("FA_TPL_VERIFY",3,0,0,H(*))
   Get_alg_string("FA_TPL_VERIFY",3,0,0,G$(*))
   Fa_tpl_verify(A(1),A(2),B0$(*),A(3),B1$(*),A(4),A$(1),A$(2),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_TPL_VERIFY",3,0,0,H(*))
   Put_alg_string("FA_TPL_VERIFY",3,0,0,G$(*))
 SUBEND
 Direc_55:SUB Direc_55(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   REAL K(1)
   DIM A$(2)[256]
   Get_alg_real("FA_UPDATE_CARD",0,0,0,K(*))
   Get_alg_string("FA_UPDATE_CARD",0,0,0,A$(*))
   Get_alg_int("FA_UPDATE_CARD",3,0,0,H(*))
   K(1)=DROUND(K(1),6)
   Fa_update_card(A$(1),A$(2),K(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_UPDATE_CARD",3,0,0,H(*))
 SUBEND
 Direc_56:SUB Direc_56(Algoname$)
   OPTION BASE 1
   INTEGER A(2),H(1)
   DIM A$(1)[256],B0$(32)[256]
   Get_alg_int("FA_UPD_VGEMLVAR",0,0,0,A(*))
   Get_alg_string("FA_UPD_VGEMLVAR",0,0,0,A$(*))
   Get_alg_string("FA_UPD_VGEMLVAR",0,1,0,B0$(*))
   Get_alg_int("FA_UPD_VGEMLVAR",3,0,0,H(*))
   Fa_upd_vgemlvar(A(1),A$(1),A(2),B0$(*),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_UPD_VGEMLVAR",3,0,0,H(*))
 SUBEND
 Direc_57:SUB Direc_57(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(2)[256]
   Get_alg_int("FA_UPD_VGEMVAR",0,0,0,A(*))
   Get_alg_string("FA_UPD_VGEMVAR",0,0,0,A$(*))
   Get_alg_int("FA_UPD_VGEMVAR",3,0,0,H(*))
   Fa_upd_vgemvar(A(1),A$(1),A$(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_UPD_VGEMVAR",3,0,0,H(*))
 SUBEND
 Direc_58:SUB Direc_58(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(4)[256]
   Get_alg_int("FA_WAFERDUMP",0,0,0,A(*))
   Get_alg_string("FA_WAFERDUMP",0,0,0,A$(*))
   Get_alg_int("FA_WAFERDUMP",3,0,0,H(*))
   Fa_waferdump(A$(1),A$(2),A(1),A$(3),A$(4),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_WAFERDUMP",3,0,0,H(*))
 SUBEND
 Direc_59:SUB Direc_59(Algoname$)
   OPTION BASE 1
   REAL K(1)
   Get_alg_real("FA_WAIT",0,0,0,K(*))
   K(1)=DROUND(K(1),6)
   Fa_wait(K(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_60:SUB Direc_60(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256],B0$(50)[256]
   Get_alg_string("FILE_HWCONFIG",0,0,0,A$(*))
   Get_alg_string("FILE_HWCONFIG",0,1,0,B0$(*))
   File_hwconfig(A$(1),B0$(*))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_61:SUB Direc_61(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   DIM A$(2)[256],H0$(1024)[256]
   Get_alg_string("FILE_LOOKUP",0,0,0,A$(*))
   Get_alg_int("FILE_LOOKUP",3,0,0,H(*))
   Get_alg_string("FILE_LOOKUP",3,1,0,H0$(*))
   File_lookup(A$(1),A$(2),H0$(*),H(1),H(2))
   ON ERROR CALL Error_handler
   Put_alg_int("FILE_LOOKUP",3,0,0,H(*))
   Put_alg_string("FILE_LOOKUP",3,1,0,H0$(*))
 SUBEND
 Direc_62:SUB Direc_62(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256],G$(1)[256]
   Get_alg_string("FORMAT_PATH",0,0,0,A$(*))
   Get_alg_string("FORMAT_PATH",3,0,0,G$(*))
   Format_path(A$(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("FORMAT_PATH",3,0,0,G$(*))
 SUBEND
 Direc_63:SUB Direc_63(Algoname$)
   OPTION BASE 1
   DIM G$(2)[256],H0$(500)[256]
   Get_alg_string("GEM_GETCMD",3,0,0,G$(*))
   Get_alg_string("GEM_GETCMD",3,1,0,H0$(*))
   Gem_getcmd(G$(1),G$(2),H0$(*))
   ON ERROR CALL Error_handler
   Put_alg_string("GEM_GETCMD",3,0,0,G$(*))
   Put_alg_string("GEM_GETCMD",3,1,0,H0$(*))
 SUBEND
 Direc_64:SUB Direc_64(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   Get_alg_int("GEM_INIT",3,0,0,H(*))
   Gem_init(H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("GEM_INIT",3,0,0,H(*))
 SUBEND
 Direc_65:SUB Direc_65(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256]
   Get_alg_string("GEM_RESPOND_NOK",0,0,0,A$(*))
   Get_alg_int("GEM_RESPOND_NOK",3,0,0,H(*))
   Gem_respond_nok(A$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("GEM_RESPOND_NOK",3,0,0,H(*))
 SUBEND
 Direc_66:SUB Direc_66(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   REAL K(1)
   DIM A$(1)[256]
   Get_alg_real("GEM_RESPOND_OK",0,0,0,K(*))
   Get_alg_string("GEM_RESPOND_OK",0,0,0,A$(*))
   Get_alg_int("GEM_RESPOND_OK",3,0,0,H(*))
   K(1)=DROUND(K(1),6)
   Gem_respond_ok(A$(1),K(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("GEM_RESPOND_OK",3,0,0,H(*))
 SUBEND
 Direc_67:SUB Direc_67(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256],B0$(500)[256]
   Get_alg_string("GEM_SENDEVENT",0,0,0,A$(*))
   Get_alg_string("GEM_SENDEVENT",0,1,0,B0$(*))
   Get_alg_int("GEM_SENDEVENT",3,0,0,H(*))
   Gem_sendevent(A$(1),B0$(*),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("GEM_SENDEVENT",3,0,0,H(*))
 SUBEND
 Direc_68:SUB Direc_68(Algoname$)
   OPTION BASE 1
   INTEGER A(3),H(1)
   Get_alg_int("GET_BRK_MOD",0,0,0,A(*))
   Get_alg_int("GET_BRK_MOD",3,0,0,H(*))
   Get_brk_mod(A(1),A(2),A(3),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("GET_BRK_MOD",3,0,0,H(*))
 SUBEND
 Direc_69:SUB Direc_69(Algoname$)
   OPTION BASE 1
   DIM G$(1)[256]
   Get_alg_string("GET_DIELABEL",3,0,0,G$(*))
   Get_dielabel(G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("GET_DIELABEL",3,0,0,G$(*))
 SUBEND
 Direc_70:SUB Direc_70(Algoname$)
   OPTION BASE 1
   DIM G$(1)[256]
   Get_alg_string("GET_DIETYPE",3,0,0,G$(*))
   Get_dietype(G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("GET_DIETYPE",3,0,0,G$(*))
 SUBEND
 Direc_71:SUB Direc_71(Algoname$)
   OPTION BASE 1
   INTEGER A(2),H(3)
   Get_alg_int("GET_JDG_DIE",0,0,0,A(*))
   Get_alg_int("GET_JDG_DIE",3,0,0,H(*))
   Get_jdg_die(A(1),A(2),H(1),H(2),H(3))
   ON ERROR CALL Error_handler
   Put_alg_int("GET_JDG_DIE",3,0,0,H(*))
 SUBEND
 Direc_72:SUB Direc_72(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   REAL Q(2)
   DIM A$(1)[256]
   Get_alg_int("GET_LOC_MOD",0,0,0,A(*))
   Get_alg_string("GET_LOC_MOD",0,0,0,A$(*))
   Get_alg_int("GET_LOC_MOD",3,0,0,H(*))
   Get_alg_real("GET_LOC_MOD",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Get_loc_mod(A(1),A$(1),Q(1),Q(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("GET_LOC_MOD",3,0,0,H(*))
   Put_alg_real("GET_LOC_MOD",3,0,0,Q(*))
 SUBEND
 Direc_73:SUB Direc_73(Algoname$)
   OPTION BASE 1
   DIM G$(1)[256]
   Get_alg_string("GET_MODLABEL",3,0,0,G$(*))
   Get_modlabel(G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("GET_MODLABEL",3,0,0,G$(*))
 SUBEND
 Direc_74:SUB Direc_74(Algoname$)
   OPTION BASE 1
   INTEGER A(3),H(4)
   DIM A$(1)[256],G$(1)[256]
   Get_alg_int("GET_NEXT_MOD",0,0,0,A(*))
   Get_alg_string("GET_NEXT_MOD",0,0,0,A$(*))
   Get_alg_int("GET_NEXT_MOD",3,0,0,H(*))
   Get_alg_string("GET_NEXT_MOD",3,0,0,G$(*))
   Get_next_mod(A(1),A(2),A(3),A$(1),H(1),H(2),H(3),G$(1),H(4))
   ON ERROR CALL Error_handler
   Put_alg_int("GET_NEXT_MOD",3,0,0,H(*))
   Put_alg_string("GET_NEXT_MOD",3,0,0,G$(*))
 SUBEND
 Direc_75:SUB Direc_75(Algoname$)
   OPTION BASE 1
   INTEGER A(3),H(4)
   DIM A$(1)[256],G$(1)[256]
   Get_alg_int("GET_PREV_MOD",0,0,0,A(*))
   Get_alg_string("GET_PREV_MOD",0,0,0,A$(*))
   Get_alg_int("GET_PREV_MOD",3,0,0,H(*))
   Get_alg_string("GET_PREV_MOD",3,0,0,G$(*))
   Get_prev_mod(A(1),A(2),A(3),A$(1),H(1),H(2),H(3),G$(1),H(4))
   ON ERROR CALL Error_handler
   Put_alg_int("GET_PREV_MOD",3,0,0,H(*))
   Put_alg_string("GET_PREV_MOD",3,0,0,G$(*))
 SUBEND
 Direc_76:SUB Direc_76(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256]
   Get_alg_string("GET_SLOT_NO",0,0,0,A$(*))
   Get_alg_int("GET_SLOT_NO",3,0,0,H(*))
   Get_slot_no(A$(1),A$(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("GET_SLOT_NO",3,0,0,H(*))
 SUBEND
 Direc_77:SUB Direc_77(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM G$(2)[256]
   Get_alg_int("GET_VGEMDEFAULT",3,0,0,H(*))
   Get_alg_string("GET_VGEMDEFAULT",3,0,0,G$(*))
   Get_vgemdefault(G$(1),G$(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("GET_VGEMDEFAULT",3,0,0,H(*))
   Put_alg_string("GET_VGEMDEFAULT",3,0,0,G$(*))
 SUBEND
 Direc_78:SUB Direc_78(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   Get_alg_int("IS_CALG",3,0,0,H(*))
   Is_calg(H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("IS_CALG",3,0,0,H(*))
 SUBEND
 Direc_79:SUB Direc_79(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   Get_alg_int("IS_FIRST",3,0,0,H(*))
   Is_first(H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("IS_FIRST",3,0,0,H(*))
 SUBEND
 Direc_80:SUB Direc_80(Algoname$)
   OPTION BASE 1
   INTEGER A(4),H(4)
   REAL Q(1)
   Get_alg_int("JDG_DIE",0,0,0,A(*))
   Get_alg_int("JDG_DIE",3,0,0,H(*))
   Get_alg_real("JDG_DIE",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Jdg_die(A(1),A(2),A(3),A(4),H(1),Q(1),H(2),H(3),H(4))
   ON ERROR CALL Error_handler
   Put_alg_int("JDG_DIE",3,0,0,H(*))
   Put_alg_real("JDG_DIE",3,0,0,Q(*))
 SUBEND
 Direc_81:SUB Direc_81(Algoname$)
   OPTION BASE 1
   INTEGER A(3),H(4)
   REAL Q(1)
   Get_alg_int("JDG_DIE_AT_POS",0,0,0,A(*))
   Get_alg_int("JDG_DIE_AT_POS",3,0,0,H(*))
   Get_alg_real("JDG_DIE_AT_POS",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Jdg_die_at_pos(A(1),A(2),A(3),H(1),Q(1),H(2),H(3),H(4))
   ON ERROR CALL Error_handler
   Put_alg_int("JDG_DIE_AT_POS",3,0,0,H(*))
   Put_alg_real("JDG_DIE_AT_POS",3,0,0,Q(*))
 SUBEND
 Direc_82:SUB Direc_82(Algoname$)
   OPTION BASE 1
   INTEGER A(5),H(4)
   REAL Q(1)
   Get_alg_int("JDG_DIE_AT_POS2",0,0,0,A(*))
   Get_alg_int("JDG_DIE_AT_POS2",3,0,0,H(*))
   Get_alg_real("JDG_DIE_AT_POS2",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Jdg_die_at_pos2(A(1),A(2),A(3),A(4),A(5),H(1),Q(1),H(2),H(3),H(4))
   ON ERROR CALL Error_handler
   Put_alg_int("JDG_DIE_AT_POS2",3,0,0,H(*))
   Put_alg_real("JDG_DIE_AT_POS2",3,0,0,Q(*))
 SUBEND
 Direc_83:SUB Direc_83(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(4)
   Get_alg_int("JDG_MOD",0,0,0,A(*))
   Get_alg_int("JDG_MOD",3,0,0,H(*))
   Jdg_mod(A(1),H(1),H(2),H(3),H(4))
   ON ERROR CALL Error_handler
   Put_alg_int("JDG_MOD",3,0,0,H(*))
 SUBEND
 Direc_84:SUB Direc_84(Algoname$)
   OPTION BASE 1
   INTEGER A(3),H(4)
   Get_alg_int("JDG_MOD_AT_POS",0,0,0,A(*))
   Get_alg_int("JDG_MOD_AT_POS",3,0,0,H(*))
   Jdg_mod_at_pos(A(1),A(2),A(3),H(1),H(2),H(3),H(4))
   ON ERROR CALL Error_handler
   Put_alg_int("JDG_MOD_AT_POS",3,0,0,H(*))
 SUBEND
 Direc_85:SUB Direc_85(Algoname$)
   OPTION BASE 1
   INTEGER A(3),H(4)
   REAL Q(1)
   Get_alg_int("JDG_WAF_BY_DIE",0,0,0,A(*))
   Get_alg_int("JDG_WAF_BY_DIE",3,0,0,H(*))
   Get_alg_real("JDG_WAF_BY_DIE",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Jdg_waf_by_die(A(1),A(2),A(3),H(1),Q(1),H(2),H(3),H(4))
   ON ERROR CALL Error_handler
   Put_alg_int("JDG_WAF_BY_DIE",3,0,0,H(*))
   Put_alg_real("JDG_WAF_BY_DIE",3,0,0,Q(*))
 SUBEND
 Direc_86:SUB Direc_86(Algoname$)
   OPTION BASE 1
   INTEGER A(4),H(4)
   REAL Q(1)
   Get_alg_int("JDG_WAF_BY_PARA",0,0,0,A(*))
   Get_alg_int("JDG_WAF_BY_PARA",3,0,0,H(*))
   Get_alg_real("JDG_WAF_BY_PARA",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Jdg_waf_by_para(A(1),A(2),A(3),A(4),H(1),Q(1),H(2),H(3),H(4))
   ON ERROR CALL Error_handler
   Put_alg_int("JDG_WAF_BY_PARA",3,0,0,H(*))
   Put_alg_real("JDG_WAF_BY_PARA",3,0,0,Q(*))
 SUBEND
 Direc_87:SUB Direc_87(Algoname$)
   OPTION BASE 1
   DIM A$(8)[256]
   Get_alg_string("LOG_LOT_BEGIN",0,0,0,A$(*))
   Log_lot_begin(A$(1),A$(2),A$(3),A$(4),A$(5),A$(6),A$(7),A$(8))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_88:SUB Direc_88(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM A$(5)[256]
   Get_alg_int("LOG_LOT_END",0,0,0,A(*))
   Get_alg_string("LOG_LOT_END",0,0,0,A$(*))
   Log_lot_end(A$(1),A$(2),A(1),A$(3),A$(4),A$(5))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_89:SUB Direc_89(Algoname$)
   OPTION BASE 1
   DIM A$(2)[256]
   Get_alg_string("LOG_PROBER",0,0,0,A$(*))
   Log_prober(A$(1),A$(2))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_90:SUB Direc_90(Algoname$)
   OPTION BASE 1
   DIM A$(2)[256]
   Get_alg_string("LOG_SYSTEM",0,0,0,A$(*))
   Log_system(A$(1),A$(2))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_91:SUB Direc_91(Algoname$)
   OPTION BASE 1
   DIM A$(3)[256]
   Get_alg_string("LOG_WAFER_BEGIN",0,0,0,A$(*))
   Log_wafer_begin(A$(1),A$(2),A$(3))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_92:SUB Direc_92(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM A$(3)[256]
   Get_alg_int("LOG_WAFER_END",0,0,0,A(*))
   Get_alg_string("LOG_WAFER_END",0,0,0,A$(*))
   Log_wafer_end(A$(1),A$(2),A(1),A$(3))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_93:SUB Direc_93(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(2)[256],G$(1)[256]
   Get_alg_int("MASTER_LOOKUP",0,0,0,A(*))
   Get_alg_string("MASTER_LOOKUP",0,0,0,A$(*))
   Get_alg_int("MASTER_LOOKUP",3,0,0,H(*))
   Get_alg_string("MASTER_LOOKUP",3,0,0,G$(*))
   Master_lookup(A$(1),A$(2),A(1),G$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("MASTER_LOOKUP",3,0,0,H(*))
   Put_alg_string("MASTER_LOOKUP",3,0,0,G$(*))
 SUBEND
 Direc_94:SUB Direc_94(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(3)[256],B0$(50)[256],G$(1)[256]
   Get_alg_int("MERGE_DATAFILE",0,0,0,A(*))
   Get_alg_string("MERGE_DATAFILE",0,0,0,A$(*))
   Get_alg_string("MERGE_DATAFILE",0,1,0,B0$(*))
   Get_alg_int("MERGE_DATAFILE",3,0,0,H(*))
   Get_alg_string("MERGE_DATAFILE",3,0,0,G$(*))
   Merge_datafile(A$(1),A$(2),A$(3),A(1),B0$(*),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("MERGE_DATAFILE",3,0,0,H(*))
   Put_alg_string("MERGE_DATAFILE",3,0,0,G$(*))
 SUBEND
 Direc_95:SUB Direc_95(Algoname$)
   OPTION BASE 1
   DIM A$(2)[256],G$(1)[256]
   Get_alg_string("NAME_TMPDATA",0,0,0,A$(*))
   Get_alg_string("NAME_TMPDATA",3,0,0,G$(*))
   Name_tmpdata(A$(1),A$(2),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("NAME_TMPDATA",3,0,0,G$(*))
 SUBEND
 Direc_96:SUB Direc_96(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   Get_alg_int("PLOTTER_IS",0,0,0,A(*))
   Plotter_is(A(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_97:SUB Direc_97(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   Get_alg_int("PRBCOUNT",3,0,0,H(*))
   Prbcount(H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("PRBCOUNT",3,0,0,H(*))
 SUBEND
 Direc_98:SUB Direc_98(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(2)
   Get_alg_int("PRBINFO",0,0,0,A(*))
   Get_alg_int("PRBINFO",3,0,0,H(*))
   Prbinfo(A(1),H(1),H(2))
   ON ERROR CALL Error_handler
   Put_alg_int("PRBINFO",3,0,0,H(*))
 SUBEND
 Direc_99:SUB Direc_99(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256]
   Get_alg_string("PRINT",0,0,0,A$(*))
   Print(A$(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_100:SUB Direc_100(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   Get_alg_int("PRINTER_IS",0,0,0,A(*))
   Printer_is(A(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_101:SUB Direc_101(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256]
   DIM K$(1)[4]
   Get_alg_string("PRINT_CHAR",0,0,0,A$(*))
   Get_alg_char("PRINT_CHAR",0,0,0,K$(*))
   Print_char(A$(1),K$(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_102:SUB Direc_102(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM A$(1)[256]
   Get_alg_int("PRINT_INTEGER",0,0,0,A(*))
   Get_alg_string("PRINT_INTEGER",0,0,0,A$(*))
   Print_integer(A$(1),A(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_103:SUB Direc_103(Algoname$)
   OPTION BASE 1
   REAL K(1)
   DIM A$(1)[256]
   Get_alg_real("PRINT_REAL",0,0,0,K(*))
   Get_alg_string("PRINT_REAL",0,0,0,A$(*))
   K(1)=DROUND(K(1),6)
   Print_real(A$(1),K(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_104:SUB Direc_104(Algoname$)
   OPTION BASE 1
   DIM A$(2)[256]
   Get_alg_string("PRINT_STRING",0,0,0,A$(*))
   Print_string(A$(1),A$(2))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_105:SUB Direc_105(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256]
   Get_alg_string("QUERY_DIR",0,0,0,A$(*))
   Get_alg_int("QUERY_DIR",3,0,0,H(*))
   Query_dir(A$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("QUERY_DIR",3,0,0,H(*))
 SUBEND
 Direc_106:SUB Direc_106(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256]
   Get_alg_string("QUERY_FILE",0,0,0,A$(*))
   Get_alg_int("QUERY_FILE",3,0,0,H(*))
   Query_file(A$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("QUERY_FILE",3,0,0,H(*))
 SUBEND
 Direc_107:SUB Direc_107(Algoname$)
   OPTION BASE 1
   INTEGER A(4)
   DIM A$(1)[256]
   Get_alg_int("QUERY_GRAPH",0,0,0,A(*))
   Get_alg_string("QUERY_GRAPH",0,0,0,A$(*))
   Query_graph(A(1),A(2),A(3),A$(1),A(4))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_108:SUB Direc_108(Algoname$)
   OPTION BASE 1
   DIM A$(4)[256]
   Get_alg_string("QUERY_LAUNCH",0,0,0,A$(*))
   Query_launch(A$(1),A$(2),A$(3),A$(4))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_109:SUB Direc_109(Algoname$)
   OPTION BASE 1
   Query_start
   ON ERROR CALL Error_handler
 SUBEND
 Direc_110:SUB Direc_110(Algoname$)
   OPTION BASE 1
   Query_stop
   ON ERROR CALL Error_handler
 SUBEND
 Direc_111:SUB Direc_111(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM A$(1)[256]
   Get_alg_int("QUERY_VIEW",0,0,0,A(*))
   Get_alg_string("QUERY_VIEW",0,0,0,A$(*))
   Query_view(A$(1),A(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_112:SUB Direc_112(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256],G$(2)[256]
   Get_alg_string("RCP_CHECK_KEY",0,0,0,A$(*))
   Get_alg_int("RCP_CHECK_KEY",3,0,0,H(*))
   Get_alg_string("RCP_CHECK_KEY",3,0,0,G$(*))
   Rcp_check_key(A$(1),H(1),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_int("RCP_CHECK_KEY",3,0,0,H(*))
   Put_alg_string("RCP_CHECK_KEY",3,0,0,G$(*))
 SUBEND
 Direc_113:SUB Direc_113(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256],B0$(256)[256],B1$(256)[256],G$(1)[256],H0$(256)[256]
   Get_alg_string("RCP_DIETST",0,0,0,A$(*))
   Get_alg_string("RCP_DIETST",0,1,0,B0$(*))
   Get_alg_string("RCP_DIETST",0,1,1,B1$(*))
   Get_alg_int("RCP_DIETST",3,0,0,H(*))
   Get_alg_string("RCP_DIETST",3,0,0,G$(*))
   Get_alg_string("RCP_DIETST",3,1,0,H0$(*))
   Rcp_dietst(B0$(*),B1$(*),A$(1),H0$(*),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("RCP_DIETST",3,0,0,H(*))
   Put_alg_string("RCP_DIETST",3,0,0,G$(*))
   Put_alg_string("RCP_DIETST",3,1,0,H0$(*))
 SUBEND
 Direc_114:SUB Direc_114(Algoname$)
   OPTION BASE 1
   INTEGER H(3)
   DIM A$(2)[256],G$(1)[256],H0$(10)[256]
   Get_alg_string("RCP_EXEC_CMD",0,0,0,A$(*))
   Get_alg_int("RCP_EXEC_CMD",3,0,0,H(*))
   Get_alg_string("RCP_EXEC_CMD",3,0,0,G$(*))
   Get_alg_string("RCP_EXEC_CMD",3,1,0,H0$(*))
   Rcp_exec_cmd(A$(1),A$(2),H(1),G$(1),H(2),H0$(*),H(3))
   ON ERROR CALL Error_handler
   Put_alg_int("RCP_EXEC_CMD",3,0,0,H(*))
   Put_alg_string("RCP_EXEC_CMD",3,0,0,G$(*))
   Put_alg_string("RCP_EXEC_CMD",3,1,0,H0$(*))
 SUBEND
 Direc_115:SUB Direc_115(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   DIM A$(5)[256],B0$(256)[256],G$(1)[256],H0$(10)[256]
   Get_alg_string("RCP_LIMBLD",0,0,0,A$(*))
   Get_alg_string("RCP_LIMBLD",0,1,0,B0$(*))
   Get_alg_int("RCP_LIMBLD",3,0,0,H(*))
   Get_alg_string("RCP_LIMBLD",3,0,0,G$(*))
   Get_alg_string("RCP_LIMBLD",3,1,0,H0$(*))
   Rcp_limbld(A$(1),A$(2),A$(3),A$(4),B0$(*),A$(5),H(1),G$(1),H(2),H0$(*))
   ON ERROR CALL Error_handler
   Put_alg_int("RCP_LIMBLD",3,0,0,H(*))
   Put_alg_string("RCP_LIMBLD",3,0,0,G$(*))
   Put_alg_string("RCP_LIMBLD",3,1,0,H0$(*))
 SUBEND
 Direc_116:SUB Direc_116(Algoname$)
   OPTION BASE 1
   DIM A$(3)[256],G$(1)[256]
   Get_alg_string("RCP_MK_FILENAME",0,0,0,A$(*))
   Get_alg_string("RCP_MK_FILENAME",3,0,0,G$(*))
   Rcp_mk_filename(A$(1),A$(2),A$(3),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("RCP_MK_FILENAME",3,0,0,G$(*))
 SUBEND
 Direc_117:SUB Direc_117(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256],G$(3)[256],H0$(256)[256],H1$(256)[256],H2$(256)[256],H3$(256)[256],H4$(16)[256],H5$(6)[256],H6$(32)[256]
   Get_alg_string("RCP_QUERY_RECIP",0,0,0,A$(*))
   Get_alg_int("RCP_QUERY_RECIP",3,0,0,H(*))
   Get_alg_string("RCP_QUERY_RECIP",3,0,0,G$(*))
   Get_alg_string("RCP_QUERY_RECIP",3,1,0,H0$(*))
   Get_alg_string("RCP_QUERY_RECIP",3,1,1,H1$(*))
   Get_alg_string("RCP_QUERY_RECIP",3,1,2,H2$(*))
   Get_alg_string("RCP_QUERY_RECIP",3,1,3,H3$(*))
   Get_alg_string("RCP_QUERY_RECIP",3,1,4,H4$(*))
   Get_alg_string("RCP_QUERY_RECIP",3,1,5,H5$(*))
   Get_alg_string("RCP_QUERY_RECIP",3,1,6,H6$(*))
   Rcp_query_recip(A$(1),A$(2),G$(1),H0$(*),H1$(*),H2$(*),G$(2),H3$(*),H4$(*),H5$(*),H6$(*),H(1),G$(3))
   ON ERROR CALL Error_handler
   Put_alg_int("RCP_QUERY_RECIP",3,0,0,H(*))
   Put_alg_string("RCP_QUERY_RECIP",3,0,0,G$(*))
   Put_alg_string("RCP_QUERY_RECIP",3,1,0,H0$(*))
   Put_alg_string("RCP_QUERY_RECIP",3,1,1,H1$(*))
   Put_alg_string("RCP_QUERY_RECIP",3,1,2,H2$(*))
   Put_alg_string("RCP_QUERY_RECIP",3,1,3,H3$(*))
   Put_alg_string("RCP_QUERY_RECIP",3,1,4,H4$(*))
   Put_alg_string("RCP_QUERY_RECIP",3,1,5,H5$(*))
   Put_alg_string("RCP_QUERY_RECIP",3,1,6,H6$(*))
 SUBEND
 Direc_118:SUB Direc_118(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256],B0$(5)[256],B1$(5)[256],G$(1)[256]
   Get_alg_string("RCP_REPLACE_WD",0,0,0,A$(*))
   Get_alg_string("RCP_REPLACE_WD",0,1,0,B0$(*))
   Get_alg_string("RCP_REPLACE_WD",0,1,1,B1$(*))
   Get_alg_string("RCP_REPLACE_WD",3,0,0,G$(*))
   Rcp_replace_wd(A$(1),B0$(*),B1$(*),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("RCP_REPLACE_WD",3,0,0,G$(*))
 SUBEND
 Direc_119:SUB Direc_119(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256],G$(1)[256]
   Get_alg_string("RCP_SYSCONF",0,0,0,A$(*))
   Get_alg_int("RCP_SYSCONF",3,0,0,H(*))
   Get_alg_string("RCP_SYSCONF",3,0,0,G$(*))
   Rcp_sysconf(A$(1),G$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("RCP_SYSCONF",3,0,0,H(*))
   Put_alg_string("RCP_SYSCONF",3,0,0,G$(*))
 SUBEND
 Direc_120:SUB Direc_120(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   DIM A$(9)[256],B0$(256)[256],B1$(256)[256],B2$(256)[256],B3$(6)[256],G$(1)[256],H0$(10)[256]
   Get_alg_string("RCP_TPLBLD",0,0,0,A$(*))
   Get_alg_string("RCP_TPLBLD",0,1,0,B0$(*))
   Get_alg_string("RCP_TPLBLD",0,1,1,B1$(*))
   Get_alg_string("RCP_TPLBLD",0,1,2,B2$(*))
   Get_alg_string("RCP_TPLBLD",0,1,3,B3$(*))
   Get_alg_int("RCP_TPLBLD",3,0,0,H(*))
   Get_alg_string("RCP_TPLBLD",3,0,0,G$(*))
   Get_alg_string("RCP_TPLBLD",3,1,0,H0$(*))
   Rcp_tplbld(A$(1),A$(2),A$(3),A$(4),A$(5),A$(6),A$(7),A$(8),B0$(*),B1$(*),B2$(*),B3$(*),A$(9),H(1),G$(1),H(2),H0$(*))
   ON ERROR CALL Error_handler
   Put_alg_int("RCP_TPLBLD",3,0,0,H(*))
   Put_alg_string("RCP_TPLBLD",3,0,0,G$(*))
   Put_alg_string("RCP_TPLBLD",3,1,0,H0$(*))
 SUBEND
 Direc_121:SUB Direc_121(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256]
   DIM Q$(1)[4]
   Get_alg_string("READ_CHAR",0,0,0,A$(*))
   Get_alg_int("READ_CHAR",3,0,0,H(*))
   Get_alg_char("READ_CHAR",3,0,0,Q$(*))
   Read_char(A$(1),A$(2),Q$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("READ_CHAR",3,0,0,H(*))
   Put_alg_char("READ_CHAR",3,0,0,Q$(*))
 SUBEND
 Direc_122:SUB Direc_122(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   DIM A$(2)[256]
   Get_alg_string("READ_INTEGER",0,0,0,A$(*))
   Get_alg_int("READ_INTEGER",3,0,0,H(*))
   Read_integer(A$(1),A$(2),H(1),H(2))
   ON ERROR CALL Error_handler
   Put_alg_int("READ_INTEGER",3,0,0,H(*))
 SUBEND
 Direc_123:SUB Direc_123(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   DIM A$(1)[256]
   Get_alg_string("READ_PROCCOND",0,0,0,A$(*))
   Get_alg_int("READ_PROCCOND",3,0,0,H(*))
   Read_proccond(A$(1),H(1),H(2))
   ON ERROR CALL Error_handler
   Put_alg_int("READ_PROCCOND",3,0,0,H(*))
 SUBEND
 Direc_124:SUB Direc_124(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   REAL Q(1)
   DIM A$(2)[256]
   Get_alg_string("READ_REAL",0,0,0,A$(*))
   Get_alg_int("READ_REAL",3,0,0,H(*))
   Get_alg_real("READ_REAL",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Read_real(A$(1),A$(2),Q(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("READ_REAL",3,0,0,H(*))
   Put_alg_real("READ_REAL",3,0,0,Q(*))
 SUBEND
 Direc_125:SUB Direc_125(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256],G$(1)[256]
   Get_alg_string("READ_STRING",0,0,0,A$(*))
   Get_alg_int("READ_STRING",3,0,0,H(*))
   Get_alg_string("READ_STRING",3,0,0,G$(*))
   Read_string(A$(1),A$(2),G$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("READ_STRING",3,0,0,H(*))
   Put_alg_string("READ_STRING",3,0,0,G$(*))
 SUBEND
 Direc_126:SUB Direc_126(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(4)[256],G$(2)[256]
   Get_alg_string("SAVE_TMPDATA",0,0,0,A$(*))
   Get_alg_int("SAVE_TMPDATA",3,0,0,H(*))
   Get_alg_string("SAVE_TMPDATA",3,0,0,G$(*))
   Save_tmpdata(A$(1),A$(2),A$(3),A$(4),H(1),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_int("SAVE_TMPDATA",3,0,0,H(*))
   Put_alg_string("SAVE_TMPDATA",3,0,0,G$(*))
 SUBEND
 Direc_127:SUB Direc_127(Algoname$)
   OPTION BASE 1
   INTEGER A(2)
   Get_alg_int("SETUSRBIN_LPBGN",0,0,0,A(*))
   Setusrbin_lpbgn(A(1),A(2))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_128:SUB Direc_128(Algoname$)
   OPTION BASE 1
   INTEGER A(4)
   Get_alg_int("SET_BRK_MOD",0,0,0,A(*))
   Set_brk_mod(A(1),A(2),A(3),A(4))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_129:SUB Direc_129(Algoname$)
   OPTION BASE 1
   INTEGER A(5)
   Get_alg_int("SET_JDG_DIE",0,0,0,A(*))
   Set_jdg_die(A(1),A(2),A(3),A(4),A(5))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_130:SUB Direc_130(Algoname$)
   OPTION BASE 1
   INTEGER A(3)
   Get_alg_int("SET_JDG_DIE_ALL",0,0,0,A(*))
   Set_jdg_die_all(A(1),A(2),A(3))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_131:SUB Direc_131(Algoname$)
   OPTION BASE 1
   INTEGER A(4)
   Get_alg_int("SET_JDG_DIE_TYP",0,0,0,A(*))
   Set_jdg_die_typ(A(1),A(2),A(3),A(4))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_132:SUB Direc_132(Algoname$)
   OPTION BASE 1
   DIM A$(2)[256],G$(1)[256]
   Get_alg_string("SET_SAMELEN",0,0,0,A$(*))
   Get_alg_string("SET_SAMELEN",3,0,0,G$(*))
   Set_samelen(A$(1),A$(2),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("SET_SAMELEN",3,0,0,G$(*))
 SUBEND
 Direc_133:SUB Direc_133(Algoname$)
   OPTION BASE 1
   DIM B0$(20)[256],H0$(20)[256]
   Get_alg_string("SET_SAMELEN20",0,1,0,B0$(*))
   Get_alg_string("SET_SAMELEN20",3,1,0,H0$(*))
   Set_samelen20(B0$(*),H0$(*))
   ON ERROR CALL Error_handler
   Put_alg_string("SET_SAMELEN20",3,1,0,H0$(*))
 SUBEND
 Direc_134:SUB Direc_134(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256]
   DIM K$(1)[4]
   Get_alg_string("SET_TAG_CHAR",0,0,0,A$(*))
   Get_alg_char("SET_TAG_CHAR",0,0,0,K$(*))
   Set_tag_char(A$(1),K$(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_135:SUB Direc_135(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM A$(1)[256]
   Get_alg_int("SET_TAG_INTEGER",0,0,0,A(*))
   Get_alg_string("SET_TAG_INTEGER",0,0,0,A$(*))
   Set_tag_integer(A$(1),A(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_136:SUB Direc_136(Algoname$)
   OPTION BASE 1
   REAL K(1)
   DIM A$(1)[256]
   Get_alg_real("SET_TAG_REAL",0,0,0,K(*))
   Get_alg_string("SET_TAG_REAL",0,0,0,A$(*))
   K(1)=DROUND(K(1),6)
   Set_tag_real(A$(1),K(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_137:SUB Direc_137(Algoname$)
   OPTION BASE 1
   DIM A$(2)[256]
   Get_alg_string("SET_TAG_STRING",0,0,0,A$(*))
   Set_tag_string(A$(1),A$(2))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_138:SUB Direc_138(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   Get_alg_int("SIZEOFDISPLAY",3,0,0,H(*))
   Sizeofdisplay(H(1),H(2))
   ON ERROR CALL Error_handler
   Put_alg_int("SIZEOFDISPLAY",3,0,0,H(*))
 SUBEND
 Direc_139:SUB Direc_139(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM A$(1)[256]
   Get_alg_int("STATLOG_DIEEND",0,0,0,A(*))
   Get_alg_string("STATLOG_DIEEND",0,0,0,A$(*))
   Statlog_dieend(A$(1),A(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_140:SUB Direc_140(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256]
   Get_alg_string("STRING_LOOKUP",0,0,0,A$(*))
   Get_alg_int("STRING_LOOKUP",3,0,0,H(*))
   String_lookup(A$(1),A$(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("STRING_LOOKUP",3,0,0,H(*))
 SUBEND
 Direc_141:SUB Direc_141(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256],H0$(128)[256]
   Get_alg_string("STRING_SPLIT",0,0,0,A$(*))
   Get_alg_int("STRING_SPLIT",3,0,0,H(*))
   Get_alg_string("STRING_SPLIT",3,1,0,H0$(*))
   String_split(A$(1),A$(2),H0$(*),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("STRING_SPLIT",3,0,0,H(*))
   Put_alg_string("STRING_SPLIT",3,1,0,H0$(*))
 SUBEND
 Direc_142:SUB Direc_142(Algoname$)
   OPTION BASE 1
   REAL K(1)
   DIM G$(1)[256]
   Get_alg_real("STRING_TIME",0,0,0,K(*))
   Get_alg_string("STRING_TIME",3,0,0,G$(*))
   K(1)=DROUND(K(1),6)
   String_time(K(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("STRING_TIME",3,0,0,G$(*))
 SUBEND
 Direc_143:SUB Direc_143(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM G$(2)[256]
   Get_alg_int("TIMEDATE",0,0,0,A(*))
   Get_alg_string("TIMEDATE",3,0,0,G$(*))
   Timedate(A(1),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_string("TIMEDATE",3,0,0,G$(*))
 SUBEND
 Direc_144:SUB Direc_144(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(1)[256],G$(1)[256]
   Get_alg_int("UPDATE_FWKCONF",0,0,0,A(*))
   Get_alg_string("UPDATE_FWKCONF",0,0,0,A$(*))
   Get_alg_int("UPDATE_FWKCONF",3,0,0,H(*))
   Get_alg_string("UPDATE_FWKCONF",3,0,0,G$(*))
   Update_fwkconf(A$(1),A(1),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("UPDATE_FWKCONF",3,0,0,H(*))
   Put_alg_string("UPDATE_FWKCONF",3,0,0,G$(*))
 SUBEND
 Direc_145:SUB Direc_145(Algoname$)
   OPTION BASE 1
   INTEGER H(4)
   DIM A$(2)[256]
   Get_alg_string("VERIFY_FILE",0,0,0,A$(*))
   Get_alg_int("VERIFY_FILE",3,0,0,H(*))
   Verify_file(A$(1),A$(2),H(1),H(2),H(3),H(4))
   ON ERROR CALL Error_handler
   Put_alg_int("VERIFY_FILE",3,0,0,H(*))
 SUBEND
 Direc_146:SUB Direc_146(Algoname$)
   OPTION BASE 1
   REAL K(1)
   Get_alg_real("WAIT",0,0,0,K(*))
   K(1)=DROUND(K(1),6)
   Wait(K(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_147:SUB Direc_147(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256],G$(1)[256]
   DIM K$(1)[4]
   Get_alg_string("WRITE_CHAR",0,0,0,A$(*))
   Get_alg_char("WRITE_CHAR",0,0,0,K$(*))
   Get_alg_int("WRITE_CHAR",3,0,0,H(*))
   Get_alg_string("WRITE_CHAR",3,0,0,G$(*))
   Write_char(A$(1),K$(1),G$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("WRITE_CHAR",3,0,0,H(*))
   Put_alg_string("WRITE_CHAR",3,0,0,G$(*))
 SUBEND
 Direc_148:SUB Direc_148(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   DIM A$(1)[256],G$(1)[256]
   Get_alg_int("WRITE_INTEGER",0,0,0,A(*))
   Get_alg_string("WRITE_INTEGER",0,0,0,A$(*))
   Get_alg_int("WRITE_INTEGER",3,0,0,H(*))
   Get_alg_string("WRITE_INTEGER",3,0,0,G$(*))
   Write_integer(A$(1),A(1),G$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("WRITE_INTEGER",3,0,0,H(*))
   Put_alg_string("WRITE_INTEGER",3,0,0,G$(*))
 SUBEND
 Direc_149:SUB Direc_149(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   REAL K(1)
   DIM A$(1)[256],G$(1)[256]
   Get_alg_real("WRITE_REAL",0,0,0,K(*))
   Get_alg_string("WRITE_REAL",0,0,0,A$(*))
   Get_alg_int("WRITE_REAL",3,0,0,H(*))
   Get_alg_string("WRITE_REAL",3,0,0,G$(*))
   K(1)=DROUND(K(1),6)
   Write_real(A$(1),K(1),G$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("WRITE_REAL",3,0,0,H(*))
   Put_alg_string("WRITE_REAL",3,0,0,G$(*))
 SUBEND
 Direc_150:SUB Direc_150(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256],G$(1)[256]
   Get_alg_string("WRITE_STRING",0,0,0,A$(*))
   Get_alg_int("WRITE_STRING",3,0,0,H(*))
   Get_alg_string("WRITE_STRING",3,0,0,G$(*))
   Write_string(A$(1),A$(2),G$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("WRITE_STRING",3,0,0,H(*))
   Put_alg_string("WRITE_STRING",3,0,0,G$(*))
 SUBEND
 Direc_151:SUB Direc_151(Algoname$)
   OPTION BASE 1
   INTEGER A(2)
   REAL K(2)
   DIM A$(2)[256],G$(1)[256]
   Get_alg_int("WRITE_WAFER_SUM",0,0,0,A(*))
   Get_alg_real("WRITE_WAFER_SUM",0,0,0,K(*))
   Get_alg_string("WRITE_WAFER_SUM",0,0,0,A$(*))
   Get_alg_string("WRITE_WAFER_SUM",3,0,0,G$(*))
   K(1)=DROUND(K(1),6)
   Write_wafer_sum(A(1),A$(1),A$(2),K(1),K(2),A(2),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("WRITE_WAFER_SUM",3,0,0,G$(*))
 SUBEND
 Direc_152:SUB Direc_152(Algoname$)
   OPTION BASE 1
   INTEGER A(3)
   DIM A$(1)[256]
   Get_alg_int("XWUD",0,0,0,A(*))
   Get_alg_string("XWUD",0,0,0,A$(*))
   Xwud(A$(1),A(1),A(2),A(3))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_153:SUB Direc_153(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM A$(1)[256]
   Get_alg_int("YIELDLOG_WAFEND",0,0,0,A(*))
   Get_alg_string("YIELDLOG_WAFEND",0,0,0,A$(*))
   Yieldlog_wafend(A$(1),A(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_154:SUB Direc_154(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   REAL Q(2)
   DIM A$(3)[256],G$(2)[256]
   Get_alg_string("FA_READ_CARD",0,0,0,A$(*))
   Get_alg_int("FA_READ_CARD",3,0,0,H(*))
   Get_alg_real("FA_READ_CARD",3,0,0,Q(*))
   Get_alg_string("FA_READ_CARD",3,0,0,G$(*))
   Q(1)=DROUND(Q(1),6)
   Fa_read_card(A$(1),A$(2),A$(3),G$(1),G$(2),Q(1),Q(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_READ_CARD",3,0,0,H(*))
   Put_alg_real("FA_READ_CARD",3,0,0,Q(*))
   Put_alg_string("FA_READ_CARD",3,0,0,G$(*))
 SUBEND
 Direc_155:SUB Direc_155(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(2)[256],G$(9)[256],H0$(256)[256],H1$(256)[256],H2$(256)[256],H3$(256)[256],H4$(16)[256],H5$(32)[256]
   Get_alg_string("FA_QUERY_RECIP",0,0,0,A$(*))
   Get_alg_int("FA_QUERY_RECIP",3,0,0,H(*))
   Get_alg_string("FA_QUERY_RECIP",3,0,0,G$(*))
   Get_alg_string("FA_QUERY_RECIP",3,1,0,H0$(*))
   Get_alg_string("FA_QUERY_RECIP",3,1,1,H1$(*))
   Get_alg_string("FA_QUERY_RECIP",3,1,2,H2$(*))
   Get_alg_string("FA_QUERY_RECIP",3,1,3,H3$(*))
   Get_alg_string("FA_QUERY_RECIP",3,1,4,H4$(*))
   Get_alg_string("FA_QUERY_RECIP",3,1,5,H5$(*))
   Fa_query_recip(A$(1),A$(2),G$(1),H0$(*),H1$(*),H2$(*),G$(2),H3$(*),H4$(*),G$(3),G$(4),G$(5),G$(6),G$(7),G$(8),H5$(*),H(1),G$(9))
   ON ERROR CALL Error_handler
   Put_alg_int("FA_QUERY_RECIP",3,0,0,H(*))
   Put_alg_string("FA_QUERY_RECIP",3,0,0,G$(*))
   Put_alg_string("FA_QUERY_RECIP",3,1,0,H0$(*))
   Put_alg_string("FA_QUERY_RECIP",3,1,1,H1$(*))
   Put_alg_string("FA_QUERY_RECIP",3,1,2,H2$(*))
   Put_alg_string("FA_QUERY_RECIP",3,1,3,H3$(*))
   Put_alg_string("FA_QUERY_RECIP",3,1,4,H4$(*))
   Put_alg_string("FA_QUERY_RECIP",3,1,5,H5$(*))
 SUBEND
 Direc_156:SUB Direc_156(Algoname$)
   OPTION BASE 1
   INTEGER A(3),H(1)
   REAL K(2)
   DIM A$(2)[256],G$(5)[256]
   Get_alg_int("CTM_PCIL_ACCESo",0,0,0,A(*))
   Get_alg_real("CTM_PCIL_ACCESo",0,0,0,K(*))
   Get_alg_string("CTM_PCIL_ACCESo",0,0,0,A$(*))
   Get_alg_int("CTM_PCIL_ACCESo",3,0,0,H(*))
   Get_alg_string("CTM_PCIL_ACCESo",3,0,0,G$(*))
   K(1)=DROUND(K(1),6)
   Ctm_pcil_acceso(A(1),A$(1),A(2),A(3),K(1),K(2),A$(2),G$(1),G$(2),G$(3),G$(4),G$(5),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_PCIL_ACCESo",3,0,0,H(*))
   Put_alg_string("CTM_PCIL_ACCESo",3,0,0,G$(*))
 SUBEND
 Direc_157:SUB Direc_157(Algoname$)
   OPTION BASE 1
   DIM G$(3)[256]
   Get_alg_string("CTM_TELP8_INFO",3,0,0,G$(*))
   Ctm_telp8_info(G$(1),G$(2),G$(3))
   ON ERROR CALL Error_handler
   Put_alg_string("CTM_TELP8_INFO",3,0,0,G$(*))
 SUBEND
 Direc_158:SUB Direc_158(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256],G$(1)[256]
   Get_alg_string("READ_EQUIPID2",0,0,0,A$(*))
   Get_alg_string("READ_EQUIPID2",3,0,0,G$(*))
   Read_equipid2(A$(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("READ_EQUIPID2",3,0,0,G$(*))
 SUBEND
 Direc_159:SUB Direc_159(Algoname$)
   OPTION BASE 1
   REAL K(1)
   DIM G$(3)[256]
   Get_alg_real("REAL_TO_STR",0,0,0,K(*))
   Get_alg_string("REAL_TO_STR",3,0,0,G$(*))
   K(1)=DROUND(K(1),6)
   Real_to_str(K(1),G$(1),G$(2),G$(3))
   ON ERROR CALL Error_handler
   Put_alg_string("REAL_TO_STR",3,0,0,G$(*))
 SUBEND
 Direc_160:SUB Direc_160(Algoname$)
   OPTION BASE 1
   INTEGER A(2),H(1)
   DIM A$(2)[256],H0$(10)[256]
   Get_alg_int("CTM_RFID",0,0,0,A(*))
   Get_alg_string("CTM_RFID",0,0,0,A$(*))
   Get_alg_int("CTM_RFID",3,0,0,H(*))
   Get_alg_string("CTM_RFID",3,1,0,H0$(*))
   Ctm_rfid(A$(1),A(1),A(2),A$(2),H0$(*),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_RFID",3,0,0,H(*))
   Put_alg_string("CTM_RFID",3,1,0,H0$(*))
 SUBEND
 Direc_161:SUB Direc_161(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   REAL Q(1)
   Get_alg_int("CTM_PC_COUNT",0,0,0,A(*))
   Get_alg_real("CTM_PC_COUNT",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Ctm_pc_count(A(1),Q(1))
   ON ERROR CALL Error_handler
   Put_alg_real("CTM_PC_COUNT",3,0,0,Q(*))
 SUBEND
 Direc_162:SUB Direc_162(Algoname$)
   OPTION BASE 1
   DIM A$(2)[256]
   Get_alg_string("CTM_PURGE_DISP",0,0,0,A$(*))
   Ctm_purge_disp(A$(1),A$(2))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_163:SUB Direc_163(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256],G$(1)[256]
   Get_alg_string("CTM_TEST_LOG",0,0,0,A$(*))
   Get_alg_int("CTM_TEST_LOG",3,0,0,H(*))
   Get_alg_string("CTM_TEST_LOG",3,0,0,G$(*))
   Ctm_test_log(A$(1),H(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_TEST_LOG",3,0,0,H(*))
   Put_alg_string("CTM_TEST_LOG",3,0,0,G$(*))
 SUBEND
 Direc_164:SUB Direc_164(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   DIM A$(2)[256],G$(2)[256]
   Get_alg_string("CTM_POSold",0,0,0,A$(*))
   Get_alg_int("CTM_POSold",3,0,0,H(*))
   Get_alg_string("CTM_POSold",3,0,0,G$(*))
   Ctm_posold(A$(1),A$(2),H(1),H(2),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_POSold",3,0,0,H(*))
   Put_alg_string("CTM_POSold",3,0,0,G$(*))
 SUBEND
 Direc_165:SUB Direc_165(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256],G$(2)[256]
   Get_alg_string("FILE_EXIST",0,0,0,A$(*))
   Get_alg_string("FILE_EXIST",3,0,0,G$(*))
   File_exist(A$(1),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_string("FILE_EXIST",3,0,0,G$(*))
 SUBEND
 Direc_166:SUB Direc_166(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM A$(2)[256],G$(2)[256]
   Get_alg_int("COPY_FILE",0,0,0,A(*))
   Get_alg_string("COPY_FILE",0,0,0,A$(*))
   Get_alg_string("COPY_FILE",3,0,0,G$(*))
   Copy_file(A$(1),A$(2),A(1),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_string("COPY_FILE",3,0,0,G$(*))
 SUBEND
 Direc_167:SUB Direc_167(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM G$(1)[256]
   Get_alg_int("CTM_MON_CONV",0,0,0,A(*))
   Get_alg_string("CTM_MON_CONV",3,0,0,G$(*))
   Ctm_mon_conv(A(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("CTM_MON_CONV",3,0,0,G$(*))
 SUBEND
 Direc_168:SUB Direc_168(Algoname$)
   OPTION BASE 1
   DIM G$(2)[256]
   Get_alg_string("CTM_TIMEDATE",3,0,0,G$(*))
   Ctm_timedate(G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_string("CTM_TIMEDATE",3,0,0,G$(*))
 SUBEND
 Direc_169:SUB Direc_169(Algoname$)
   OPTION BASE 1
   REAL Q(1)
   DIM A$(2)[256]
   Get_alg_string("CTM_TIME_CAL",0,0,0,A$(*))
   Get_alg_real("CTM_TIME_CAL",3,0,0,Q(*))
   Q(1)=DROUND(Q(1),6)
   Ctm_time_cal(A$(1),A$(2),Q(1))
   ON ERROR CALL Error_handler
   Put_alg_real("CTM_TIME_CAL",3,0,0,Q(*))
 SUBEND
 Direc_170:SUB Direc_170(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   DIM A$(2)[256],G$(2)[256]
   Get_alg_string("CTM_POS",0,0,0,A$(*))
   Get_alg_int("CTM_POS",3,0,0,H(*))
   Get_alg_string("CTM_POS",3,0,0,G$(*))
   Ctm_pos(A$(1),A$(2),H(1),H(2),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_POS",3,0,0,H(*))
   Put_alg_string("CTM_POS",3,0,0,G$(*))
 SUBEND
 Direc_171:SUB Direc_171(Algoname$)
   OPTION BASE 1
   INTEGER H(2)
   DIM A$(2)[256],G$(1)[256]
   Get_alg_string("CTM_FILE_LOOKUP",0,0,0,A$(*))
   Get_alg_int("CTM_FILE_LOOKUP",3,0,0,H(*))
   Get_alg_string("CTM_FILE_LOOKUP",3,0,0,G$(*))
   Ctm_file_lookup(A$(1),A$(2),G$(1),H(1),H(2))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_FILE_LOOKUP",3,0,0,H(*))
   Put_alg_string("CTM_FILE_LOOKUP",3,0,0,G$(*))
 SUBEND
 Direc_172:SUB Direc_172(Algoname$)
   OPTION BASE 1
   DIM A$(2)[256]
   Get_alg_string("CTM_CLR_XTERM",0,0,0,A$(*))
   Ctm_clr_xterm(A$(1),A$(2))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_173:SUB Direc_173(Algoname$)
   OPTION BASE 1
   Init_relay
   ON ERROR CALL Error_handler
 SUBEND
 Direc_174:SUB Direc_174(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(3)[256],G$(2)[256]
   Get_alg_string("CTM_PCID_LOG",0,0,0,A$(*))
   Get_alg_int("CTM_PCID_LOG",3,0,0,H(*))
   Get_alg_string("CTM_PCID_LOG",3,0,0,G$(*))
   Ctm_pcid_log(A$(1),A$(2),A$(3),G$(1),G$(2),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_PCID_LOG",3,0,0,H(*))
   Put_alg_string("CTM_PCID_LOG",3,0,0,G$(*))
 SUBEND
 Direc_175:SUB Direc_175(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   Get_alg_int("SET_GUARD_OPEN",0,0,0,A(*))
   Get_alg_int("SET_GUARD_OPEN",3,0,0,H(*))
   Set_guard_open(A(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("SET_GUARD_OPEN",3,0,0,H(*))
 SUBEND
 Direc_176:SUB Direc_176(Algoname$)
   OPTION BASE 1
   INTEGER A(1),H(1)
   REAL K(1)
   Get_alg_int("DISCHARGE_ALL",0,0,0,A(*))
   Get_alg_real("DISCHARGE_ALL",0,0,0,K(*))
   Get_alg_int("DISCHARGE_ALL",3,0,0,H(*))
   K(1)=DROUND(K(1),6)
   Discharge_all(A(1),K(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("DISCHARGE_ALL",3,0,0,H(*))
 SUBEND
 Direc_177:SUB Direc_177(Algoname$)
   OPTION BASE 1
   DIM G$(2)[256]
   Get_alg_string("CTM_DIESIZE_CHK",3,0,0,G$(*))
   Ctm_diesize_chk(G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_string("CTM_DIESIZE_CHK",3,0,0,G$(*))
 SUBEND
 Direc_178:SUB Direc_178(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   Get_alg_int("CTM_LAST_WAF",3,0,0,H(*))
   Ctm_last_waf(H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_LAST_WAF",3,0,0,H(*))
 SUBEND
 Direc_179:SUB Direc_179(Algoname$)
   OPTION BASE 1
   INTEGER A(3),H(1)
   REAL K(2)
   DIM A$(2)[256],G$(5)[256]
   Get_alg_int("CTM_PCIL_ACCESS",0,0,0,A(*))
   Get_alg_real("CTM_PCIL_ACCESS",0,0,0,K(*))
   Get_alg_string("CTM_PCIL_ACCESS",0,0,0,A$(*))
   Get_alg_int("CTM_PCIL_ACCESS",3,0,0,H(*))
   Get_alg_string("CTM_PCIL_ACCESS",3,0,0,G$(*))
   K(1)=DROUND(K(1),6)
   Ctm_pcil_access(A(1),A$(1),A(2),A(3),K(1),K(2),A$(2),G$(1),G$(2),G$(3),G$(4),G$(5),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_PCIL_ACCESS",3,0,0,H(*))
   Put_alg_string("CTM_PCIL_ACCESS",3,0,0,G$(*))
 SUBEND
 Direc_180:SUB Direc_180(Algoname$)
   OPTION BASE 1
   INTEGER A(2)
   REAL K(4)
   DIM A$(2)[256],G$(2)[256]
   Get_alg_int("CTM_PC_LEAK",0,0,0,A(*))
   Get_alg_real("CTM_PC_LEAK",0,0,0,K(*))
   Get_alg_string("CTM_PC_LEAK",0,0,0,A$(*))
   Get_alg_string("CTM_PC_LEAK",3,0,0,G$(*))
   K(1)=DROUND(K(1),6)
   Ctm_pc_leak(K(1),K(2),A$(1),A$(2),K(3),K(4),A(1),A(2),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_string("CTM_PC_LEAK",3,0,0,G$(*))
 SUBEND
 Direc_181:SUB Direc_181(Algoname$)
   OPTION BASE 1
   INTEGER A(2)
   REAL K(4)
   DIM A$(3)[256],G$(2)[256]
   Get_alg_int("CTM_PC_LEAK_DIS",0,0,0,A(*))
   Get_alg_real("CTM_PC_LEAK_DIS",0,0,0,K(*))
   Get_alg_string("CTM_PC_LEAK_DIS",0,0,0,A$(*))
   Get_alg_string("CTM_PC_LEAK_DIS",3,0,0,G$(*))
   K(1)=DROUND(K(1),6)
   Ctm_pc_leak_dis(K(1),K(2),A$(1),A$(2),K(3),K(4),A(1),A(2),A$(3),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_string("CTM_PC_LEAK_DIS",3,0,0,G$(*))
 SUBEND
 Direc_182:SUB Direc_182(Algoname$)
   OPTION BASE 1
   REAL K(1)
   DIM A$(4)[256],G$(2)[256]
   Get_alg_real("CTM_PC_MGR",0,0,0,K(*))
   Get_alg_string("CTM_PC_MGR",0,0,0,A$(*))
   Get_alg_string("CTM_PC_MGR",3,0,0,G$(*))
   K(1)=DROUND(K(1),6)
   Ctm_pc_mgr(A$(1),A$(2),A$(3),K(1),A$(4),G$(1),G$(2))
   ON ERROR CALL Error_handler
   Put_alg_string("CTM_PC_MGR",3,0,0,G$(*))
 SUBEND
 Direc_183:SUB Direc_183(Algoname$)
   OPTION BASE 1
   DIM A$(8)[256],G$(1)[256]
   Get_alg_string("CTM_UPDATE_INFO",0,0,0,A$(*))
   Get_alg_string("CTM_UPDATE_INFO",3,0,0,G$(*))
   Ctm_update_info(A$(1),A$(2),A$(3),A$(4),A$(5),A$(6),A$(7),A$(8),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("CTM_UPDATE_INFO",3,0,0,G$(*))
 SUBEND
 Direc_184:SUB Direc_184(Algoname$)
   OPTION BASE 1
   DIM A$(1)[256]
   Get_alg_string("ESD_ABSORB",0,0,0,A$(*))
   Esd_absorb(A$(1))
   ON ERROR CALL Error_handler
 SUBEND
 Direc_185:SUB Direc_185(Algoname$)
   OPTION BASE 1
   DIM A$(8)[256],G$(1)[256]
   Get_alg_string("CTM_UPD_INFO",0,0,0,A$(*))
   Get_alg_string("CTM_UPD_INFO",3,0,0,G$(*))
   Ctm_upd_info(A$(1),A$(2),A$(3),A$(4),A$(5),A$(6),A$(7),A$(8),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("CTM_UPD_INFO",3,0,0,G$(*))
 SUBEND
 Direc_186:SUB Direc_186(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   DIM A$(1)[256]
   Get_alg_string("CTM_EXESHELL",0,0,0,A$(*))
   Get_alg_int("CTM_EXESHELL",3,0,0,H(*))
   Ctm_exeshell(A$(1),H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_EXESHELL",3,0,0,H(*))
 SUBEND
 Direc_187:SUB Direc_187(Algoname$)
   OPTION BASE 1
   INTEGER A(1)
   DIM A$(4)[256],G$(1)[256]
   Get_alg_int("CTM_PCID_UPD",0,0,0,A(*))
   Get_alg_string("CTM_PCID_UPD",0,0,0,A$(*))
   Get_alg_string("CTM_PCID_UPD",3,0,0,G$(*))
   Ctm_pcid_upd(A$(1),A$(2),A$(3),A$(4),A(1),G$(1))
   ON ERROR CALL Error_handler
   Put_alg_string("CTM_PCID_UPD",3,0,0,G$(*))
 SUBEND
 Direc_188:SUB Direc_188(Algoname$)
   OPTION BASE 1
   INTEGER H(1)
   Get_alg_int("CTM_CHK_LOG4070",3,0,0,H(*))
   Ctm_chk_log4070(H(1))
   ON ERROR CALL Error_handler
   Put_alg_int("CTM_CHK_LOG4070",3,0,0,H(*))
 SUBEND
 Libs_tail:SUB Libs_tail
 SUBEND
 Direct_init:SUB Direct_init
   OPTION BASE 1
   INTEGER Start_flg1,Start_flg2
   INTEGER Mode,Stat
   DIM Message$[255],Config$(1:20)[255]
   CALL Direct_keystore
   INPUT "Run TESTER_START (1: Yes, 0: No) ?",Start_flg1
   IF Start_flg1 THEN 
     INPUT "Select online (1) or offline (0).",Start_flg2
     IF Start_flg2=1 OR Start_flg2=0 THEN 
       IF NOT INMEM("A4070_start") THEN 
         LOADSUB ALL FROM "/opt/SPECS/usr/alg/tester/A4070.bas"  !AVPATH_
       END IF
       A4070_start(Start_flg2,Stat,Message$,Config$(*))
       A4070_init(Stat)
     END IF
   END IF
   CALL Direct_keyload
 SUBEND
 Direct_uninit:SUB Direct_uninit
   OPTION BASE 1
   INTEGER Start_flg1,Start_flg2
   INTEGER Mode,Stat
   INPUT "Run TESTER_STOP (1: Yes, 0: No) ?",Start_flg1
   IF Start_flg1 THEN 
     IF NOT INMEM("A4070_stop") THEN 
       LOADSUB ALL FROM "/opt/SPECS/usr/alg/tester/A4070.bas"  !AVPATH_
     END IF
     A4070_stop(Stat)
   END IF
   CALL Direct_keyload
   CALL Direct_keypurge
   OUTPUT KBD;CHR$(255)&"%"&CHR$(255)&"P"&"EDIT"&CHR$(255)&"E";
 SUBEND
 Direct_keystore:SUB Direct_keystore
   RE-STORE KEY "/var/tmp/key."&SYSTEM$("PROCESS ID")  !AVPATH_
 SUBEND
 Direct_keyload:SUB Direct_keyload
   LOAD KEY "/var/tmp/key."&SYSTEM$("PROCESS ID")  !AVPATH_
 SUBEND
 Direct_keypurge:SUB Direct_keypurge
   PURGE "/var/tmp/key."&SYSTEM$("PROCESS ID")  !AVPATH_
 SUBEND
 Direct_tail:SUB Direct_tail
 SUBEND
