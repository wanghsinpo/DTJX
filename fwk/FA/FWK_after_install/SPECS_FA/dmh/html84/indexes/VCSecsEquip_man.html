<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Ed Hume">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (Windows NT 5.0; U) [Netscape]">
   <meta name="Description" content="User Guide and Reference Information for the Visual C++ SecsEquip Class Library used for deploying Equipment SECS/GEM interfaces.">
   <title>SecsEquip - A Visual C++ SECS Equipment Class Library</title>
</head>
<body>

<h1>
SecsEquip - A Visual C++ Class for Deploying Equipment SECS Interfaces</h1>

<p><br>Hume Integration has created a Visual C++ class for rapidly deploying
SEMI standard GEM compliant SECS equipment interfaces.&nbsp;&nbsp; Without
any customization, the class implements almost all of the Fundamental GEM
Requirements and the Additional GEM Capabilities.&nbsp; Method calls are
provided for the developer to add his own Status Variables, Equipment Constants,
Alarm Definitions, and Event Definitions to complement the existing items
specified in the GEM standard.&nbsp; The developer registers callbacks
to receive asynchronous inputs such as Remote Command invocations, Terminal
Display invocations, or the reception of any SECS message type of his choosing.&nbsp;
Other callback mechanisms are used to provide Status Variable or Equipment
Constant values needed for satisfying Host requests and for sending dynamic
Event Reports.
<br><a NAME="features"></a>
<h2>
Feature Summary</h2>

<ul>
<li>
A high-level, working SECS/GEM interface ready for adding equipment specific
customization.</li>

<li>
Built-in handling of more than 85 standard SECS message types, all required
GEM variables, and event types.</li>

<li>
Designed for efficient and productive use of&nbsp; the Microsoft Visual
C++ programming environment running on Windows Professional platforms.</li>

<li>
Leverages the Hume SECS/GEM application software which has been in 7x24
use by major equipment providers for several years.</li>

<li>
The robust and proven SECS interface server executes as a child process
with minimal impact on your application execution.</li>

<li>
Both HSMS passive and active roles are supported.</li>

<li>
Convenient use of string data to represent all SECS data types including
SECS Variant data, also known as Localized Character Strings.</li>

<li>
Supports remote debugging using the Hume Datahub SDK applications <a href="../man1/dmh_inspect.html">Inspect</a>
and <a href="../man1/hubclient.html">hubclient</a>.</li>

<li>
Integrated into the VC++ design environment with IntelliSense coding of
class methods and parameter prompting.</li>

<li>
Fully integrated into the VC++ runtime environment with high-performance
use of threading, callback dispatching, controllable trace output, and
error handling</li>

<li>
The SecsEquip class has the desirable feature set of our .NET SecsPort
Component, while providing better performance with less resource usage.</li>
</ul>

<h3>
<a NAME="Compliance"></a>GEM Compliance Statement</h3>
The software is written to conform to SEMI Standard E30 - Generic Model
for Communications and Control of SEMI Equipment (GEM).
<p>The Equipment OEM developer will need to be mindful of the standard
when using the Hume SecsEquip Component in order to insure that compliance
is fully met.
<br>&nbsp;
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td><b>Fundamental GEM Requirement</b></td>

<td><b>Implemented</b></td>

<td><b>Gem Compliant</b></td>

<td><b>Implementation Notes</b></td>
</tr>

<tr>
<td>State Models</td>

<td>Yes</td>

<td>Yes</td>

<td>The Communication State model is implemented by the SecsEquip and controlled
by calling the <a href="#CommEnable">CommEnable</a> and <a href="#CommDisable">CommDisable</a>
methods.&nbsp; The current Communication State value is readable as the
property, <a href="#CommState">CommState</a>. Your application receives
notification of CommState and similar state changes by handling the SecsEquip
<a href="#StateChange">StateChange</a>
event.&nbsp; This event notifies you of important changes such as communication
with the Host starting or ending.
<p>Your logic and your Operator GUI affect the Control State by setting
the <a href="#ControlIntent">ControlIntent </a>and <a href="#ControlMode">ControlMode</a>
properties.&nbsp;
<p>Comments on the Process State model follows in the next row.&nbsp; Other
equipment models such as Spooling are described below in this table.</td>
</tr>

<tr>
<td>Equipment Processing States</td>

<td>Yes</td>

<td>Yes</td>

<td>The example application fully implements a Process State model that
you can copy and modify.&nbsp; Follow the example as far as posting standard
GEM events for Process State changes and related events such as selecting
a different Process Program.&nbsp; You also need to update Status Variables
to keep track of the previous and current process states, just as the example
application demonstrates.</td>
</tr>

<tr>
<td>Host Initiated S1F13/F14 Scenario</td>

<td>Yes</td>

<td>Yes</td>

<td>This behavior is fully provided by the SecsEquip class.</td>
</tr>

<tr>
<td>Event Notification</td>

<td>Yes</td>

<td>Yes</td>

<td>Your logic needs to call the <a href="#EventPost">EventPost</a>() method
at the occurrence of standard collection events.&nbsp; You may choose to
define and report additional event types for the activities of your equipment.</td>
</tr>

<tr>
<td>On-Line Identification</td>

<td>Yes</td>

<td>Yes</td>

<td>You are obligated to set the property values <a href="#MDLN">MDLN</a>
and <a href="#SOFTREV">SOFTREV</a> to reflect the hardware and software
configuration of the equipment.&nbsp; Any change in the equipment software
should result in a new unique value of SOFTREV.</td>
</tr>

<tr>
<td>Error Messages</td>

<td>Yes</td>

<td>Yes</td>

<td>The standard requires use of Stream 9 Error reporting.&nbsp; The SecsEquip
sends specific Stream 9 messages for communication faults, conversation
timeouts, incorrect device ID, unhandled message stream or function types,
and non-standard data.&nbsp; In the custom message handling logic that
you write, use the method <a href="#SendS9">SendS9</a> to send error messages
when the received message data is not in the expected format or has improper
values.</td>
</tr>

<tr>
<td>Documentation</td>

<td>Yes</td>

<td>Yes</td>

<td>Hume Integration has example documentation which meets requirements
of the GEM and SECS standards.&nbsp; This documentation is provided to
Equipment providers with permission to create derivative works.
<p>&nbsp;The SECS Server has the ability to export HTML documents of the
configured event, alarm, and variable table data.&nbsp; You may want to
use this feature of the table window that is display by executing the <a href="#DebugTableWindow">DebugTableWindow</a>
method.</td>
</tr>

<tr>
<td>Control (Operator Initiated)</td>

<td>Yes</td>

<td>Yes</td>

<td>Use the VCSecsEquipApp application as a worked example.&nbsp; The startup
control state is settable using the property <a href="#ControlStateStartup">ControlStateStartup</a>.&nbsp;
The operator choice of ON-LINE or OFF-LINE control is settable as the property
value <a href="#ControlIntent">ControlIntent</a>.&nbsp; The desired substate
of ON-LINE control, LOCAL or REMOTE, is settable as the property <a href="#ControlMode">ControlMode</a>.&nbsp;
The actual control state value reflects interaction with the Host and is
readable as the property <a href="#ControlState">ControlState</a>.&nbsp;
Your application receives notification of ControlState and similar state
changes by handling the SecsEquip <a href="#StateChange">StateChange</a>
event.</td>
</tr>

<tr>
<td><b>ADDITIONAL CAPABILITIES</b></td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>Establish Communications</td>

<td>Yes</td>

<td>Yes</td>

<td>This behavior is fully provided by the SecsEquip class.</td>
</tr>

<tr>
<td>Dynamic Event Report Configuration&nbsp;</td>

<td>Yes</td>

<td>Yes</td>

<td>This behavior is fully provided by the SecsEquip class.
<p>With the capabilities that involve Status Variable values (SV) or Data
Variable values (DVVAL), your job is to add equipment specific variables
using the <a href="#VariableAdd">VariableAdd</a> method.&nbsp; You either
provide their values through a callback using <a href="#VariableMethodSet">VariableMethodSet</a>
or by calling <a href="#VariableSet">VariableSet</a> when their values
are changed.&nbsp;</td>
</tr>

<tr>
<td>Variable Data Collection</td>

<td>Yes</td>

<td>Yes</td>

<td>This behavior is fully provided by the SecsEquip class.&nbsp;</td>
</tr>

<tr>
<td>Trace Data Collection</td>

<td>Yes</td>

<td>Yes</td>

<td>This behavior is fully provided by the SecsEquip class.&nbsp;</td>
</tr>

<tr>
<td>Status Data Collection</td>

<td>Yes</td>

<td>Yes</td>

<td>This behavior is fully provided by the SecsEquip class.&nbsp;</td>
</tr>

<tr>
<td>Alarm Management</td>

<td>Yes</td>

<td>Yes</td>

<td>This behavior is fully provided by the SecsEquip class.&nbsp; Your
job is to add equipment specific alarm types using the <a href="#AlarmAdd">AlarmAdd</a>
method.&nbsp; You use the method <a href="#AlarmSet">AlarmSet</a> to indicate
when an alarm condition is set or cleared.&nbsp; You can optionally use
the method <a href="#AlarmEnable">AlarmEnable </a>to enable or disable
reporting of an alarm type as a Stream 5 message.&nbsp; Gem also requires
event reports for the Alarm Set and Alarm Clear events.&nbsp; These event
definitions are automatically created and managed for you by the SecsEquip
when you use the <b>AlarmAdd</b> method.</td>
</tr>

<tr>
<td>Remote Control</td>

<td>Yes&nbsp;</td>

<td>Yes</td>

<td>The example application shows how to use <a href="#MessageTypeAdd">MessageTypeAdd</a>
to receive and process Remote Commands (S2F21, S2F41, or S2F49) in your
application code.&nbsp;&nbsp; You need to implement control logic that
is mindful of the Process State model and the Control State model.&nbsp;
For example, you need to disallow Remote Commands that affect processing
when you are in the Online Local Control State.&nbsp;</td>
</tr>

<tr>
<td>Equipment Constants</td>

<td>Yes</td>

<td>Yes</td>

<td>This behavior is fully provided by the SecsEquip class.&nbsp; Your
job is to add equipment specific constants using the <a href="#ParameterAdd">ParameterAdd</a>
method.&nbsp; You call <a href="#ParameterSet">ParameterSet</a> if your
GUI logic or controller logic changes the value so that the SECS Server
can update the ECIDChangeName GEM variable, and issue the GEM "Operator
Equipment Constant Change" event.&nbsp; If the host changes an Equipment
Constant, you are notified via a <a href="#ParameterChange">ParameterChange</a>
event.</td>
</tr>

<tr>
<td>Process Program Management</td>

<td>Yes</td>

<td>Yes</td>

<td>The SecsEquip class fully implements process program management features
with upload and download capabilities.&nbsp; You can set the directory
used for process programs as the property <a href="#RecipeDirectory">RecipeDirectory</a>.&nbsp;
You can set whether process program data is transferred as binary or text
using the <a href="#RecipesAreBinary">RecipesAreBinary</a> property.&nbsp;
Your application is notified of process program change events by handling
the SecsEquip <a href="#StateChange">StateChange</a> event.&nbsp;&nbsp;
You will receive notice when recipes are downloaded from the host, uploaded
to the host, or deleted by the host.&nbsp; You can use these notifications
to trigger validation of downloaded recipes, or you can defer validation
until the time the process program is loaded for use.</td>
</tr>

<tr>
<td>Material Movement</td>

<td>Yes</td>

<td>Yes</td>

<td>The GEM standard only requires that the equipment provide Data Collection
events when material is sent from any port on the equipment, or received
by any port, whether the transfers are automated or manual.
<p>Automated Material Movement is implemented by calling the method <a href="#MessageTypeAdd">MessageTypeAdd</a>
and registering a callback for each of the primary message types that the
host sends.&nbsp; In your callback, you parse the received SECS message
data using the <a href="#ListSplit">ListSplit</a> and <a href="#ListElement">ListElement</a>
methods.&nbsp; You send reply messages using the <a href="#SendReply">SendReply</a>
method.&nbsp; You initiate your own primary messages and optionally wait
for the SECS replies using the <a href="#SendSecsMsg">SendSecsMsg</a> method.</td>
</tr>

<tr>
<td>Equipment Terminal Services</td>

<td>Yes</td>

<td>Yes</td>

<td>The example application for the SecsEquip demonstrates displaying data
received from the host, sending acknowledgment events, and sending display
data to the host.&nbsp; For your own implementation,&nbsp; use the method
<a href="#TerminalDisplayAck">TerminalDisplayAck</a>
to send acknowledgment events, and follow the example code for sending
input data to the host using <a href="#SendSecsMsg">SendSecsMsg</a>.</td>
</tr>

<tr>
<td>Clock</td>

<td>Yes</td>

<td>Yes</td>

<td>The SecsEquip component fully implements a host-settable Clock variable
value with standard data format choices.&nbsp; The implementation does
not affect the system clock, the host's setting is saved as an offset.</td>
</tr>

<tr>
<td>Limits Monitoring</td>

<td>No</td>

<td>&nbsp;</td>

<td>See the notes for Material Movement, above, to understand the general
approach that is taken to implement this capability.&nbsp;</td>
</tr>

<tr>
<td>Spooling</td>

<td>Yes</td>

<td>Yes</td>

<td>The SecsEquip component fully implements Spooling.&nbsp; We recommend
that the equipment supplier only allow spooling of Alarm messages, and
Event report messages or similar messages where there is no control logic
tied to the receiving of the reply messages.&nbsp; These are exactly the
message types that most factory CIM workers want to collect with spooling.&nbsp;
If restricting the spooled message types is not done, there are complex
issues with implementation and timing that cannot be adequately tested
and verified correct.&nbsp; The standard describes allowing the spooling
of nearly any primary message type, out of consideration that any message
may occur when the spool is being unloaded, and it should take its proper
sequence at the end of the spool.&nbsp; In practice this is a rare circumstance
because an HSMS implementation can unload thousands of messages in a few
seconds.&nbsp; The downside of allowing messages that have control implications
to be spooled is that they are queued for a variable and potentially lengthy
delay before delivery.&nbsp; The equipment provider's job is to provide
a robust control system, and we think that knowing immediately that a near
real-time message conversation cannot be initiated is the right choice.&nbsp;
<p>The Equipment provider can add to the message types allowed for spooling
using the <a href="#SpoolingAllow">SpoolingAllow</a> method.&nbsp; The
default behavior is to allow only Stream 5 (Alarms) and Stream 6 (Event
reports) to be spooled.</td>
</tr>

<tr>
<td>Control (Host-Initiated)</td>

<td>Yes</td>

<td>Yes</td>

<td>The SecsEquip class fully implements this behavior.</td>
</tr>
</table>

<hr WIDTH="100%"><a NAME="userguide"></a>
<h2>
<b>User Guide</b></h2>

<p><br>The SecsEquip VC++ component is provided as two Visual Studio projects,
<b>VCSecsEquip</b>
- the project for the SecsEquip class library, and <b>VCSecsEquipApp</b>
- an example MFC application.&nbsp; The SecsEquip class library is provided
with source code and can be used without using the Microsoft Foundation
Classes (MFC).&nbsp; In fact, the SecsEquip class is designed so it could
be readily ported to POSIX platforms such as Linux.&nbsp; The SecsEquip
class uses the Hume POSIX DMH client library, and a portable Pthreads library
to communicate with and control the SECS server process.
<p>Here is an overview of the provided files:
<p>The <b>VCSecsEquip</b> Project:
<ul>
<li>
<b>VCSecsEquip.h, strprtab.h, prtable.h, dmh_mutex.h </b>- header files
that define the SecsEquip class and introduce other classes that are used
to manage messages and made public for possible use in your application.&nbsp;
The dmh_mutex class is a thin wrapper on portable mutexes that are part
of the Pthreads libary.</li>

<li>
<b>VCSecsEquip.dll </b>- the SECS/GEM library file for runtime use.</li>

<li>
<b>VCSecsEquip.lib</b> - the SECS/GEM library file for development use.</li>

<li>
<b>VCSecsEquip.cpp</b>, <b>VCSecsEquip.dep</b>, <b>VCSecsEquip.dsp</b>,
<b>VCSecsEquip.dsw</b>,
<b>VCSecsEquip.mak,prtable.cpp</b>,
<b>StdAfx.cpp</b>,
<b>StdAfx.h</b>,
<b>strprtab.cpp</b>
- other project files including source files that can be used to rebuild,
customize, or deeply understand the SecsEquip class.&nbsp; We think you
will not need to modify this project for normal usage.&nbsp; By having
the source code, you can be more effective with understanding and debugging
the interaction between the SecsEquip class and your application.</li>
</ul>
The <b>VCSecsEquipApp</b> Project:
<ul>
<li>
<b>VCSecsEquipApp.*</b> (.clw, .cpp, .dep, .dsp, .dsw, .h, .mak, .rc)&nbsp;&nbsp;
- source and build files for the project.</li>

<li>
<b>VCSecsAppDlg.cpp</b>, <b>VCSecsAppDlg.h</b>&nbsp;&nbsp; - VC++ source
code for the main GUI dialog window.&nbsp; Most of the example usage logic
is in the <b>VCSecsAppDlg.cpp</b> file.</li>

<li>
<b>SecsTracewin.cpp, SecsTracewin.h</b> - This window class demonstrates
how to display dynamically adjustable trace information of the data being
sent and received by the SECS interface.&nbsp; It is an excellent tool
for troubleshooting and should be part of the system&nbsp; maintenance
features of your equipment.</li>

<li>
<b>ConnectionDialog.cpp</b>, <b>ConnectionDialog.h</b> - a dialog for configuring
the HSMS connection properties and the Device ID property.</li>

<li>
<b>AlarmTableDlg.cpp</b>, <b>AlarmTableDlg.h</b> - a simple example of
querying and displaying the status of alarms.</li>

<li>
<b>VCSecsEquipApp.exe</b>&nbsp;&nbsp;&nbsp; - the compiled example application.</li>

<li>
<b>recipes/*</b> - files used to demonstrate uploading and downloading
Process Programs.</li>

<li>
<b>res/* </b>- additional resource files used to build the application</li>

<li>
<b>SecsServer.tcl</b>, <b>SecsEquip.tcl</b>, <b>DMH_forward.tcl</b>, <b>eq_custom_spool.tcl</b>,
<b>tclIndex</b>,
<b>make_tclIndex.bat
</b>-
Tcl language files used internally by the SecsEquip class to integrate
tightly with the SECS interface server process.&nbsp; The SECS Equipment
developer does not need to modify these files.&nbsp; Standard GEM capabilities
are provided in the VC++ SecsEquip API.</li>
</ul>
Other library dependencies with provided files:
<ul>
<li>
<b>dmh.h</b>, <b>dmh.dll</b>, <b>dmh.lib</b>&nbsp; - the Hume POSIX DMH
message system client files</li>

<li>
<b>pthread.h</b>, <b>sched.h</b>, <b>pthreadVC.dll</b>,&nbsp; <b>pthreadVC.lib</b>
- a POSIX compliant portable threads library used by the POSIX DMH message
system client library</li>
</ul>

<p><br>The files are distributed in a .zip archive named&nbsp; <b>VCSecsEquip.zip</b>.&nbsp;
If you received the DMH software on CDROM, this archive is in the subdirectory
<b>LAN_IMAGE</b>.
<p>The distribution is designed and tested for Visual Studio 6.0 on Windows
XP Professional, or similar up-to-date Windows Professional versions such
as Windows 2000 Pro.
<p><a NAME="Installation"></a>
<h3>
Installation</h3>
Installation of the SecsEquip software consists of extracting files in
the <b>VCSecsEquip.zip </b>archive to a directory of your choice, and installing
the Hume Datahub SDK.&nbsp; If you have already installed the Hume Datahub
SDK,&nbsp; you should not add the files in the VCSecsEquip.zip archive
to any of the existing Datahub SDK GEM application directories.&nbsp; The
SecsEquip class is able to find and use the Datahub SDK GEM directories
without usage of a common directory.
<p>The stored paths in the .zip archive and the existing project settings
and makefiles assume three peer level directories and their subdirectories.&nbsp;
For example, if you unzip the archive in the directory C:\hume, you will
recreate our development directory structure as follows
<pre>&nbsp;&nbsp;&nbsp; c:\hume\VCSecsEquip&nbsp; (subdirectories Release, Debug)</pre>

<pre>&nbsp;&nbsp;&nbsp; c:\hume\VCSecsEquipApp (subdirectories Release, Debug, res, recipes)</pre>

<pre>&nbsp;&nbsp;&nbsp; c:\hume\posix_dmh (subdirectories pthreads, pthreads/vc6proj/Release)</pre>
&nbsp; The .zip archive does not have extra copies of the DLL files inside&nbsp;
- to minimize download size they are found in the VCSecsEquipApp\Release
directory.&nbsp; You will probably want to create the VCSecsEquipApp/Debug
directory and copy the pthreadVC.dll, dmh.dll, and the VCSecsEquip.dll
to the Debug directory so if you build the Debug version of the application
you can run it.&nbsp; The VCSecsEquip project has post-build steps that
copy the freshly built DLL to the VCSecsEquipApp Debug or Release directories.&nbsp;
These directories should exist before this copying is attempted.
<p>The SecsEquip VC++ software uses the SECS/GEM application files provided
in the Hume Datahub SDK product.&nbsp; A developer needs to install the
Hume Datahub SDK, and specify on the SETUP screen that the GEM/SECS applications
should be installed.&nbsp; The SecsEquip component is able to find the
Datahub SDK files using the environment variable <b>DMH_BIN</b> which is
set when the Datahub SDK is installed.
<p>The situation is simplified for a runtime deployment of your equipment
SECS interface.&nbsp; Instead of installing the Datahub SDK and copying
the above list of Tcl language files, you can simply deploy a single file
executeable, <b>SecsServer.exe</b>.&nbsp; This file is provided by Hume
Integration for the usual case of using the as-provided SDK files.&nbsp;
If you have customized the SDK files, you are able to create a custom version
of <b>SecsServer.exe</b> using a build script.&nbsp; We encourage you to
use the full SDK during development so that you have the toolset documentation,
the debugging tools, and you are able to view the SDK GEM application source
code.&nbsp; When you are ready for deployment, you can download the <b>SecsServer.zip</b>
archive from the Hume customer support website to obtain the <b>SecServer.exe</b>
program and its build script.
<h4>
Environment Variable&nbsp;<a NAME="DMH_DOTNET_TCLDIR"></a>SECS_EQUIP_TCLDIR</h4>
When a SecsEquip instance is constructed, it needs to find the <b>SecsServer.tcl</b>
file and the other associated support files in the same directory as the
<b>SecsServer.tcl</b>
file.&nbsp; The class logic looks for these files in the current working
directory, and then it tries one or two directory levels up, which is a
common development scenario when an executable is run from the subdirectory
Debug or Release.&nbsp;&nbsp; Alternately, you may set either the environment
variable, <b>SECS_EQUIP_TCLDIR</b> or <b>DMH_DOTNET_TCLDIR</b> to the directory
path containing the files.&nbsp; This gives you the ability to deploy the
executeables with whatever directory structure you desire.&nbsp; We suggest
using slash directory separators.&nbsp; Environment variables are set by
navigating from the Start menu - Start/Settings/Control Panel/System/Advanced/Environment
Variables.&nbsp; An example value is:
<pre>SECS_EQUIP_TCLDIR=C:/hume/VCSecsEquipApp</pre>
In a runtime deployment, the <b>SecsServer.exe</b> file is placed in the
same directory instead of the <b>SecsServer.tcl</b> file and the associated
support files.&nbsp; The same directory search order is used.
<br><a NAME="Development"></a>
<h3>
Development</h3>
To start using the Hume VC++ SecsEquip class with an existing project,
its probably easiest to add the entire VCSecsEquip project as a subproject
and indicate that it is a dependency for your application.
<p>The SecsEquip software uses the Hume POSIX DMH library internally to
control the SECS interface server using the Hume DMH message system.&nbsp;
You may want to explore using the DMH message for your own application
requirements such as integrating your User Interface with Controller systems,
intelligent devices, and instruments.
<p>Your primary focus as a developer is using the class <b>SecsEquip</b>.&nbsp;
This class implements public methods to send and receive SECS messages,
and manage an equipment SECS interface.
<p>Here is the general flow of using and configuring a SecsEquip instance:
<ol>
<li>
Construct a <a href="#SecsEquip">SecsEquip</a> instance.&nbsp; When the
SecsEquip instance is constructed, it spawns a SECS Server process.&nbsp;
The SECS Server uses DDE to determine what other Tcl/Tk applications are
running.&nbsp; You need to construct a SecsEquip instance under conditions
where your application will respond to DDE unless you disable the DDE usage
by setting the environment variable NO_DDE_QUERY to the value of 1.&nbsp;
We have found that MFC applications do not respond to DDE while executing
the OnInitDialog virtual function.&nbsp; The example application demonstrates
a small workaround - a timer event is initiated from the OnInitDialog method,
and then the SecsEquip construction and initialization are done in the
timer handler after the OnInitDialog method returns.</li>

<li>
Set the callback pointer for StateChange events.&nbsp; Once the next step
is taken, your callback is executed to provide you with initial values
of state data.&nbsp; In general the callbacks are executed from different
threads than the starting thread that created your window controls.&nbsp;
Its not documented very clearly, but for most of the method invocations,
window controls are not designed to be used by different threads than the
main event-dispatching thread of your application.&nbsp; The safest course
is to copy the techniques in the example application in the use of PostMessage
to notify the main thread.</li>

<li>
Use saved user configuration data to know the desired HSMS connection properties
such as the socket port and whether the active or passive role is desired.&nbsp;
Call ConnectTypeHsmsPassive() or ConnectTypeHsmsActive() to set the connection
type.&nbsp; When the connection type is set, the SECS server creates a
data array and table records for the SECS interface.&nbsp; Some of the
other configuration method calls require the table records or array being
present.&nbsp; So a ConnectType call should be made early in the initialization.&nbsp;
Its ok to call a ConnectType method with default argument values, and later
in the initialization, make another ConnectType call with other argument
values.&nbsp; The important point is to make the ConnectType call early.</li>

<li>
Now you can perform the bulk of your SECS interface configuration.&nbsp;
Do the following, in any order:</li>

<ul>
<li>
change other properties such as DEVID, timers, MODLN, SOFTREV, ...</li>

<li>
set the callback pointers for other events such as the host changing parameter
(ECV) values</li>

<li>
add equipment specific alarm types using <a href="#AlarmAdd">AlarmAdd</a></li>

<li>
add event types using <a href="#EventAdd">EventAdd</a></li>

<li>
add Equipment Constants (Parameters) using <a href="#ParameterAdd">ParameterAdd</a></li>

<li>
add Status and Data Value Variables using <a href="#VariableAdd">VariableAdd</a></li>

<li>
setup up callbacks to supply the value of selected Variables and Parameters
using the <a href="#VariableMethodSet">VariableMethodSet </a>call.</li>

<li>
register callbacks for additional SECS message types using <a href="#MessageTypeAdd">MessageTypeAdd</a></li>
</ul>

<li>
Programmatically you can set the desired Control State properties and then
call <a href="#CommEnable">CommEnable</a> to enable host communications.&nbsp;
You probably want to offer configuration dialogs and make the desired startup
configuration of the Contol State and whether communication is enabled
or disabled be user specified and persistent.</li>

<li>
Call <a href="#CommDisable">CommDisable</a> to disable host communications.&nbsp;
It is called automatically in the SecsEquip destructor method.</li>
</ol>

<h4>
<a NAME="TSN"></a>Tcl Secs Notation, TSN</h4>
SECS messages are passed into and out of the application as formatted strings.&nbsp;
The format is similar to the notation in the SEMI documents except that
the list formatting conventions of the Tcl programming language are followed.&nbsp;
The SecsEquip API provides methods to <a href="#ListSplit">split</a>,
<a href="#ListJoin">join</a>,
<a href="#ListAppend">append</a>,
and <a href="#ListElement">extract</a> list elements.&nbsp; In general,
curly braces, { }, are used to surround list elements which contain white
space.&nbsp; By using the API calls to append list elements or join strings
as list elements, you can be sure that your strings are properly formatted,
and you do not need to manually balance opening and closing curly braces.&nbsp;
Developers who have worked with both XML and TSN list notation have found
that the TSN notation is more compact, closer to the SEMI documentation,
and easier for a human to scan and validate when reviewing diagnostic output.
<p>As general guidance, when you expect a string value, you will get a
two element list, of the form "A:n {this is n chars of text}".&nbsp; If
a string value does not have imbedded white space, it may be formatted
without braces, such as "A:8 OneToken".&nbsp; When you use the <a href="#ListElement">ListElement</a>
or <a href="#ListSplit">ListSplit</a> methods to parse the text, they take
care of parsing and removing surrounding braces for you.&nbsp; If an empty
string is sent, you will see a one element list, A:0.&nbsp; SECS has the
notion of array data - 0 or more values of a given type.&nbsp; When you
expect to receive a single numeric value, you receive a two element list,
with the type code as the first element, such as "U4:1 290".&nbsp; You
can also receive an empty array "U4:0" or an array with more than one value
as in "U4:3 0 1 2".&nbsp; Binary data values are formatted using C-language
hexadecimal integer notation, for example, "B:3 0x00 0x01 0x02".&nbsp;
You can use the <a href="#BinToInt">BinToInt</a> method to convert these
values to integer values.&nbsp; With received data, the type code has a
length value appended to it after a colon.&nbsp; With data that you format
for sending, the length information is optional, the data is parsed to
determine the length.&nbsp; See the <a href="../mann/TSN.html">TSN.html</a>
document for more details.
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td><b>Semi Octal type code</b></td>

<td><b>TSN type code</b></td>

<td><b>Meaning &amp; Examples</b></td>
</tr>

<tr>
<td>00</td>

<td>L</td>

<td>List,&nbsp; L, L:0,&nbsp;&nbsp; "L {A {atc 100}} {A 1.0.0}", "L:2 {L:2
{U4 200} {U4 210}} {B 0}"</td>
</tr>

<tr>
<td>10</td>

<td>B</td>

<td>binary - unsigned 8 bit data, "B 0", "B 1 2 3"</td>
</tr>

<tr>
<td>11</td>

<td>TF&nbsp;</td>

<td>boolean data, TSN type codes BL or BOOLEAN are also accepted as input,
"TF 1"</td>
</tr>

<tr>
<td>20</td>

<td>A</td>

<td>Character string data.&nbsp; Traditionally this has meant printable
ASCII characters but some implementations are sending any 8 bit characters
including nulls using this type.
<br>"A {hello world}", "A hello"</td>
</tr>

<tr>
<td>21</td>

<td>J</td>

<td>Japan International Standard (JIS-8) encoded text.&nbsp; This format
is not commonly used or supported because in the past the SEMI standards
have failed to identify specific reference documents.</td>
</tr>

<tr>
<td>22</td>

<td>V1..VE</td>

<td>Variant data, also known as Localized Character Strings.&nbsp; Your
VC++ unicode text is automatically converted into the chosen encoding.&nbsp;
V1 is for Unicode 2.0, V2 is for UTF-8 encoding.&nbsp; See the <a href="../mann/TSN.html">TSN.html</a>
document for more details. "V1 {sent as Unicode}"</td>
</tr>

<tr>
<td>30</td>

<td>I8</td>

<td>8-byte signed integer, use hex notation for the value, "I8 0x123456789abcdf01"</td>
</tr>

<tr>
<td>31</td>

<td>I1</td>

<td>1-byte signed integer, "I1 -3"</td>
</tr>

<tr>
<td>32</td>

<td>I2</td>

<td>2-byte signed integer, "I2 99",&nbsp; "I2 15 -7 99"</td>
</tr>

<tr>
<td>34</td>

<td>I4</td>

<td>4-byte integer signed, "I4 -5"</td>
</tr>

<tr>
<td>40</td>

<td>F8</td>

<td>8-byte floating point, "F8 6.02e23", "F8 0.1"</td>
</tr>

<tr>
<td>44</td>

<td>F4</td>

<td>4-byte floating point, "F4 1.0"</td>
</tr>

<tr>
<td>50</td>

<td>U8</td>

<td>8-byte unsigned integer, use hex notation for the value, "U8 0x7fffffffffffffff"</td>
</tr>

<tr>
<td>51</td>

<td>U1</td>

<td>1-byte unsigned integer, "U1 0"</td>
</tr>

<tr>
<td>52</td>

<td>U2</td>

<td>2-byte unsigned integer, "U2 512"</td>
</tr>

<tr>
<td>54</td>

<td>U4</td>

<td>4-byte unsigned integer, "U2 979"</td>
</tr>
</table>

<br>&nbsp;
<h3>
<a NAME="BuiltinSecs"></a>Built-in SECS Data, Message Handling, Events</h3>
The SecsEquip class has built-in logic to handle more than 85 of the standard
SECS message types.&nbsp; You do not have to code or provide for complex
GEM capabilities such as dynamic event reports, or the communication and
state models.&nbsp; See the table at the end of this document for more
detail on the <a href="#BuiltInMessages">built-in message types</a>.
<p>Similarly, the variables required for GEM compliance are already defined,
and are listed in a <a href="#BuiltInVariables">table</a> near the end
of this document.&nbsp; In some cases, such as the PPExecName variable,
your custom application logic has to provide current data values.&nbsp;
The example application demonstrates using the <a href="#VariableSet">VariableSet</a>
method or the <a href="#VariableMethodSet">VariableMethodSet</a> method
as techniques to supply variable values.&nbsp; If a data item's value is
changed infrequently, its more efficient to use VariableSet which provides
the current value to the SECS server process.&nbsp; The VariableMethodSet
method is the right choice for data items whose value changes more often,
or are easier to manage as VC++ application data items.
<p>The SecsEquip software uses type U4 numeric identifiers for the numeric
IDs called out by GEM such as ALID, CEID, ECID, and SVID.&nbsp; These identifiers
are passed as unsigned, 4 byte integers - SEMI Octal code 54.
<p>&nbsp;There also some standard event report types specified by GEM and
pre-defined for you as listed in the <a href="#BuiltInEvents">table</a>
near the end of this document.&nbsp; Your application logic needs to call
<a href="#EventPost">EventPost</a>
as these events and your own defined events occur during processing.
<br>&nbsp;
<h3>
<a NAME="CustomSecs"></a>Custom SECS Message Handling</h3>
Use the method <a href="#MessageTypeAdd">MessageTypeAdd</a> to have SECS
messages routed to your callback code for custom handling.&nbsp; Your callback
executes in a different thread than your main Windows event dispatching
thread so use thread safe techniques for accessing application data or
GUI controls.&nbsp; The positive side of using a different thread is that
your handling logic can be coded to use simple synchronous wait-for-reply
SECS conversations without locking up your GUI.&nbsp; For example, your
callback can use <a href="#SendReply">SendReply</a> to respond to the inbound
message, and then initiate a synchronous conversation using <a href="#SendSecsMsg">SendSecsMsg</a>
and specifying that the logic should wait for the reply message.&nbsp;
While your handling code is progressing through the synchronous conversation,
other software in your application can be making method calls to report
events, or alarms.&nbsp; Because of the internal design of the SecsEquip,
these other method calls are not blocked or delayed because your handler
is busy with a conversation.
<p>Logic in your application can send SECS messages or initiate conversations
using the SendSecsMsg method.&nbsp; For HSMS communication,&nbsp; if you
are sending a message and not waiting for the reply, SendSecsMsg can be
used from your GUI code without fear of making your GUI unresponsive.&nbsp;
In some cases you need to wait for a SECS reply message.&nbsp; If you are
using HSMS, under most circumstances, the host's reply or failure to reply
will be resolved within a few seconds.&nbsp;&nbsp; The unusual circumstance
is that you still have a TCP/IP connection to the host so your send is
successful, but then the host does not reply, and you wait the full T3
period.&nbsp; You can code your logic so that if the host does not respond
to any message, you transition to offline control so subsequent message
sends fail right away because they are not appropriate in an offline control
state.&nbsp; So with this change, you risk making the GUI unresponsive
for a single T3 period in some unusual circumstances.&nbsp; If this risk
is not acceptable, you can create a new thread, and use the new thread
to perform the SECS conversation where you need to wait for the reply message.
<p><a NAME="Miscellaneous"></a>
<h4>
Miscellaneous Notes</h4>
Your design will typically use one instance of a SecsEquip component to
provide a single SECS interface.&nbsp; You can use multiple instances of
the class to provide more than one SECS interface.&nbsp; Each interface
can have its own custom handling of message types.&nbsp; The Equipment
OEM can also provide more than one SECS equipment interface to support
multiple factory host applications if provision is made for coordinating
control.&nbsp; The latter can be as simple as telling every interface exception
one that the equipment is under local control.&nbsp; This provides the
benefits of the newer EDA standards without the complexity of implementing
additional protocols.
<p>
<hr WIDTH="100%"><a NAME="Reference"></a>
<h2>
SecsEquip Class Reference</h2>

<p><br><a NAME="Properties"></a>
<table BORDER WIDTH="100%" >
<caption>&nbsp;<b>SecsEquip Properties</b></caption>

<tr>
<td><b>Property Access</b></td>

<td><a NAME="dmh"></a><b>Description</b></td>
</tr>

<tr>
<td>static DMHClient <b>dmh</b></td>

<td>SecsEquip instances use a shared connection to the DMH message system
in order to communicate with the SECS server process.&nbsp; The connection
instance, dmh, is public in case you want to access it in your application.&nbsp;
Since it is shared (static) the access is SecsEquip::dmh.<a NAME="CommState"></a></td>
</tr>

<tr>
<td>const char *get<b>CommState</b>(void)<a NAME="ControlIntent"></a></td>

<td>Read-only value of your GEM Communication State.&nbsp; Possible values
are <b>DISABLED</b>, <b>ENABLED {NOT COMMUNICATING}</b>, and <b>COMMUNICATING</b>.&nbsp;&nbsp;
The <a href="#StateChange">StateChange</a> event is used to obtain asynchronous
notification of this property value change.</td>
</tr>

<tr>
<td>const char *get<b>ControlIntent</b>(void)
<br>void setControlIntentOnline(void)
<br>void setControlIntentOffline(void)</td>

<td>Your intended GEM Control State behavior, whether your equipment is
in the <b>OFF-LINE</b> or <b>ON-LINE</b> control state.&nbsp; The default
setting is <b>OFF-LINE</b>.<a NAME="ControlMode"></a></td>
</tr>

<tr>
<td>const char *get<b>ControlMode</b>(void)
<br>void setControlModeRemote(void)
<br>void setControlModeLocal(void)</td>

<td>When in ON-LINE control, your intended substate of <b>LOCAL</b> or
<b>REMOTE</b>
control.&nbsp; Defaults to <b>LOCAL</b>.<a NAME="ControlState"></a></td>
</tr>

<tr>
<td>const char *get<b>ControlState</b>(void)</td>

<td>Read-only, your actual GEM Control State which reflects your <b>ControlMode</b>,
<b>ControlIntent</b>
and host dynamics.&nbsp; Possible values are <b>ON-LINE LOCAL</b>,
<b>ON-LINE
REMOTE</b>, <b>OFF-LINE Equipment</b>, <b>OFF-LINE Host</b>, and <b>OFF-LINE
SeekOnline</b>.&nbsp; These string values are enumerated in the SecsEquip::<b>ControlStateText
</b>string
array, in the same order as <b>ControlStateEnum</b> values.&nbsp; The <a href="#StateChange">StateChange</a>
event is used to obtain asynchronous notification of this property value
change.&nbsp;<a NAME="ControlStateStartup"></a></td>
</tr>

<tr>
<td>ControlStateEnum get<b>ControlStateStartup</b>(void)
<br>void setControlStateStartup(ControlStateEnum e)
<p>// control state values
<br>&nbsp;enum ControlStateEnum { OfflineEquipment=0,&nbsp;&nbsp; OfflineAttemptOnline=1,
OfflineHost=2, OnlineLocal=3, OnlineRemote=4};</td>

<td>Your software is able to specify the initial state for the GEM Control
State model.&nbsp; The choices are:&nbsp; <b>OfflineEquipment</b>, <b>OfflineAttemptOnline</b>,
<b>OfflineHost</b>,
<b>OnlineLocal</b>,
or <b>OnlineRemote</b>.&nbsp; This setting defaults to <b>OfflineEquipment</b>,
but is overruled to be consistent with your
<b>ControlIntent</b> and <b>ControlMode</b>
values.&nbsp; If your <b>ControlIntent</b> is <b>OFF-LINE</b>, and your
startup is an Online state, the startup state is changed to <b>OfflineEquipment</b>.&nbsp;
If your <b>ControlIntent</b> is <b>ON-LINE</b> and your startup state is
<b>OfflineEquipment</b>,
your startup state is changed to <b>OfflineAttemptOnline</b>.&nbsp; Similarly
the setting of <b>ControlMode</b> can overrule an online startup state
corresponding to the opposite <b>LOCAL</b> or <b>REMOTE</b> online substate
choice.&nbsp; This logic is applied when <a href="#CommEnable">CommEnable</a>
is called.<a NAME="DEVID"></a></td>
</tr>

<tr>
<td>int get<b>DEVID</b>(void)&nbsp;
<br>void setDEVID(int DEVID);</td>

<td>The SECS Device ID.&nbsp; An identifier imbedded in SECS header data
usually left at the default of 0.&nbsp; You can change it anytime but you
are better off setting it before enabling communication.&nbsp; Per the
standard, the SecsEquip rejects messages from the host that are not for
the equipment's Device ID.&nbsp; Settable range is 0..32767.<a NAME="DMHGroupName"></a></td>
</tr>

<tr>
<td>static char * SecsEquip::<b>DMHGroupName</b></td>

<td>The DMH message system groupname used by the SECS server.&nbsp; The
same groupname should be specified to the constructor of every SecsEquip
instance in the application in order to share the same SECS server process.<a NAME="HSMS_Host"></a></td>
</tr>

<tr>
<td>const char *get<b>HSMS_Host</b>(void)&nbsp;
<br>void setHSMS_Host(const char *h);</td>

<td>For an active HSMS connection, specifies the TCP/IP hostname or IP
address of the Host computer.<a NAME="HSMS_Passive"></a></td>
</tr>

<tr>
<td>bool get<b>HSMS_Passive</b>()&nbsp;
<br>void setHSMSPassive(bool p)</td>

<td>For an HSMS connection, whether the SecsEquip plays the passive, TCP/IP
server role.&nbsp; The default value is true which is the usual role of
equipment.&nbsp;<a NAME="HSMS_Port"></a></td>
</tr>

<tr>
<td>int get<b>HSMS_Port</b>()&nbsp;
<br>void setHSMS_Port(int p)</td>

<td>For an HSMS connection, the TCP/IP socket port number.&nbsp; Defaults
to 5555.<a NAME="MDLN"></a></td>
</tr>

<tr>
<td>const char *get<b>MDLN</b>()&nbsp;
<br>&nbsp;void setMDLN(const char *mdln)</td>

<td>The SECS Equipment Model Type - limited to no more than 6 characters
by the E5 standard.<a NAME="Name"></a></td>
</tr>

<tr>
<td>const char *get<b>Name</b>()</td>

<td>The SecsEquip name passed to the constructor and used in the SECS server
process as a Tcl command name, a global array name, and an identifier in
SQL table records.<a NAME="RecipesAreBinary"></a></td>
</tr>

<tr>
<td>bool get<b>RecipesAreBinary</b>()
<br>void setRecipesAreBinary(bool RecipesAreBinary)</td>

<td>A boolean flag to indicate whether Process Program files should be
transferred as type <b>B</b> (binary) data, or type <b>A</b> (ASCII) data.&nbsp;
The default is true, meaning binary transfer.&nbsp; If Process Program
files are printable text, the type <b>A</b> transfer is easier for the
factory personnel to work with.&nbsp; The software is able to transfer
binary data as type <b>A</b> but not all host software can accommodate
this.<a NAME="RecipeDirectory"></a></td>
</tr>

<tr>
<td>const char *get<b>RecipeDirectory</b>()&nbsp;
<br>void setRecipeDirectory(const char *RecipeDirectory)</td>

<td>A pathname to the file system directory where Process Program files
are located.&nbsp; The default is "./recipes" - a subdirectory of the current
working directory.<a NAME="ReportsAreSaved"></a></td>
</tr>

<tr>
<td>bool get<b>ReportsAreSaved</b>()
<br>void setReportsAreSaved(bool ReportsAreSaved)</td>

<td>This property controls whether the state of event reporting is saved
at the program exit and restored during the next session.&nbsp; Saving
the state of dynamic reporting is standard GEM behavior so the default
value is true.&nbsp; If the value is true, the saved event reporting configuration
is restored the first time that <a href="#CommEnable">CommEnable</a> is
called, unless it has been already restored by calling the method <a href="#ReportsRestore">ReportsRestore</a>.&nbsp;
In other words, you can use the method ReportsRestore to force loading
of the saved reporting configuration before CommEnable is called.&nbsp;&nbsp;
The report configuration data is saved as a file of SQL statements in the
subdirectory <b>spooldata</b>.&nbsp; The filename used is "reportdata_"
+ Name + ".sql".<a NAME="SOFTREV"></a></td>
</tr>

<tr>
<td>const char *get<b>SOFTREV</b>()&nbsp;
<br>void setSOFTREV(const char *softrev)</td>

<td>The SECS Software revision - limited to no more than 6 characters.&nbsp;
Default value is "1.0.0".&nbsp; You may wish to consider a pattern of <i>major</i>.<i>minor</i>.<i>patchlevel</i>.<a NAME="SpoolingAllow"></a></td>
</tr>

<tr>
<td>const char *get<b>SpoolingAllow</b>()&nbsp;
<br>void setSpoolingAllow(const char *SpoolingAllow)</td>

<td>This property is set to specify the streams which the host is allowed
to specify for spooling in message type S2F43.&nbsp; It is formatted as
a space separated list of "S&lt;s>" tokens where the &lt;s> value is stream
number.&nbsp; The standard does not allow Stream 1 to be spooled.&nbsp;
The default value is "S5 S6" which allows for spooling alarm messages and
event reports.&nbsp; An empty string value disallows any spooling.&nbsp;
The value only affects the handling of S2F43 messages from the host.&nbsp;
Your software is able to change at any time which message types are being
spooled using the method, <a href="#SpoolStreamFns">SpoolStreamFns</a>.<a NAME="State"></a></td>
</tr>

<tr>
<td>const char *get<b>State</b>()</td>

<td>A read-only value of the low-level connection state.&nbsp; Possible
values include OFFLINE, LISTENING, and COMMUNICATING.&nbsp; You will see
the OFFLINE state if the connection to the host is broken.&nbsp; The <a href="#StateChange">StateChange</a>
event is used to obtain asynchronous notification of this property value
change.<a NAME="T3"></a></td>
</tr>

<tr>
<td>int get<b>T3</b>(void)
<br>void setT3(int millisecs)</td>

<td>SECS Reply Timeout in milliseconds, range 1000..120000, default 45000<a NAME="T5"></a></td>
</tr>

<tr>
<td>int get<b>T5</b>(void)
<br>void setT5(int millisecs)</td>

<td>HSMS Connect Separation Timeout - the delay between re-connection attempts
in milliseconds, range 1000..240000, default 10000<a NAME="T6"></a></td>
</tr>

<tr>
<td>int get<b>T6</b>(void)
<br>void setT6(int millisecs)</td>

<td>HSMS Control Transaction Timeout in milliseconds, range 1000..240000,
default 5000<a NAME="T7"></a></td>
</tr>

<tr>
<td>int get<b>T7</b>(void)
<br>void setT7(int millisecs)</td>

<td>HSMS Not Selected Timeout in milliseconds, range 1000..240000, default
10000<a NAME="T8"></a></td>
</tr>

<tr>
<td>// int get<b>T8</b>(void)
<br>// void setT8(int millisecs)</td>

<td>HSMS Network Intercharacter Timeout, default value 5000.&nbsp; This
value is not used.<a NAME="TRACE"></a></td>
</tr>

<tr>
<td>int get<b>TRACE</b>(void)&nbsp;
<br>void setTRACE(int trace)</td>

<td>Used as a bitfield to control diagnostic trace information for SECS
port activity which is passed to the application in the SecsTrace event.&nbsp;
By setting specific bits, the corresponding output is turned on.&nbsp;
<p>General Tracing: (TraceType = trace)&nbsp;
<br>Bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Output Description&nbsp;
<br>0x0001&nbsp;&nbsp;&nbsp;&nbsp; Read and write calls
<br>0x0002&nbsp;&nbsp;&nbsp;&nbsp; state changes including connection attempts&nbsp;
<p>Receive Tracing: (TraceType = rtrace)&nbsp;
<br>Bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description for Received
Messages&nbsp;
<br>0x0100&nbsp;&nbsp;&nbsp;&nbsp; Header binary dump&nbsp;
<br>0x0200&nbsp;&nbsp;&nbsp;&nbsp; Header interpretation&nbsp;
<br>0x0400&nbsp;&nbsp;&nbsp;&nbsp; Stream and Function description
<br>0x0800&nbsp;&nbsp;&nbsp;&nbsp; Message data binary dump&nbsp;
<br>0x0004&nbsp;&nbsp;&nbsp;&nbsp; The Message as TSN&nbsp;
<p>Send Tracing: (TraceType = strace)&nbsp;
<br>Bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description for Sent
Messages&nbsp;
<br>0x1000&nbsp;&nbsp;&nbsp;&nbsp; Header binary dump
<br>0x2000&nbsp;&nbsp;&nbsp;&nbsp; Header interpretation
<br>0x4000&nbsp;&nbsp;&nbsp;&nbsp; Stream and Function description
<br>0x8000&nbsp;&nbsp;&nbsp;&nbsp; Message data binary dump
<br>0x0008&nbsp;&nbsp;&nbsp;&nbsp; The Message as TSN&nbsp;</td>
</tr>
</table>

<p><a NAME="ControlEvents"></a>
<br>&nbsp;
<table BORDER WIDTH="100%" >
<caption><b>SecsEquip Events</b></caption>

<tr>
<td><b>Event Handler and Argument Data&nbsp;</b></td>

<td><b>Description</b></td>
</tr>

<tr>
<td></td>

<td></td>
</tr>

<tr>
<td>All event handlers - NOTES
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>&nbsp;</td>

<td>With the VC++ SecsEquip class library, callback pointers are used to
pass event invocations into your application.&nbsp; The callback functions
need to be static functions, and you need to use ClientData arguments or
pointers to class instances if you want to execute method calls of objects.&nbsp;
The example application demonstrates these techniques.&nbsp; As noted earlier,
the thread that executes your callback is not your main GUI thread, and
you need to use threadsafe programming techniques.<a NAME="ParameterChange"></a></td>
</tr>

<tr>
<td>typedef void (SecsParameterChangeProc)(SecsEquip *, const char *varname,
const char *newvalue);
<p>&nbsp;// just set your own function address to receive the events
<br>&nbsp;SecsParameterChangeProc *<b>ParameterChange</b>Callback;
<br>&nbsp;</td>

<td>This event notifies you of host initiated Equipment Constant Variable
(ECV) changes.&nbsp; The new value is within the limits you have configured.</td>
</tr>

<tr>
<td>typedef void (<b>SecsMessageReceive</b>Proc)(SecsEquip *, int stream,
int function, bool send_reply,&nbsp;
<br>&nbsp; int transactionID, const char *TSN_data, const char *header,
void *clientData);</td>

<td>See the <a href="#MessageTypeAdd">MessageTypeAdd</a> method described
in the next section to see how to receive SECS messages in your application.&nbsp;
This mechanism is demonstrated for Remote Commands and for Terminal Services
in the example application.<a NAME="ServerError"></a></td>
</tr>

<tr>
<td>typedef void (<b>SecsServerError</b>Proc)(const char *errorInfo);
<p>static SecsServerErrorProc *SecsServerErrorCallback;</td>

<td>The SecsEquip class reports Tcl programming errors that are trapped
in the SECS Server process as SecsServerError events.&nbsp; An example
would be trying to send an improperly formatted SECS message.&nbsp; These
error events will happen during development but should be rare once the
code is debugged.<a NAME="SecsTrace"></a></td>
</tr>

<tr>
<td>typedef void (<b>SecsTrace</b>Proc)(SecsEquip *, const char *traceType,
const char *text);
<p>// just set your own function address to receive the events
<br>&nbsp;SecsTraceProc *SecsTraceCallback;</td>

<td>This event provides you with the detailed information of SECS message
traffic that is viewed in the SECS Trace window.&nbsp; The information
is controlled by setting the TRACE property<a NAME="SpoolingAlert"></a>.</td>
</tr>

<tr>
<td>typedef void (Secs<b>SpoolingAlert</b>Proc)(SecsEquip *, const char
*msgid);
<p>SecsSpoolingAlertProc *SpoolingAlertCallback;</td>

<td>The GEM standard describes Spooling events that are to be brought to
the attention of the equipment operator.&nbsp; The msgid values include
<b>SPOOLING_ACTIVATED</b>,
<b>SPOOLING_FULL</b>,
<b>SPOOLING_TERMINATED</b>,
<b>SPOOLING_NOT_PERSISTENT</b>,
and <b>SPOOLING_DATA_DISCARDED</b>.&nbsp; See example explanation messages
in the application.&nbsp; The latter two values are not seen in normal
circumstances.<a NAME="StateChange"></a></td>
</tr>

<tr>
<td>typedef void (Secs<b>StateChange</b>Proc)(SecsEquip *, const char *varname,
const char *newvalue);
<p>SecsStateChangeProc *StateChangeCallback;</td>

<td>This event notifies your application of state value changes. Possible
<i>varname</i>
values include&nbsp;
<ul>
<li>
<b>state</b> - the State property value changed</li>

<li>
<b>clock_offset</b> - this value is the number of seconds added to the
system clock to provide CLOCK variable values for the host.&nbsp; If the
value differs from 0, the host has used S2F31 to set the clock.&nbsp; Your
logic can work with host specified time values by adjusting the system
time using this offset value, or by reading the CLOCK variable using <b>VariableGet</b>().&nbsp;
We recommend that you avoid this complexity by instructing your customers
to use NTP time synchronization and that you disable S2F31 using <b>MessageTypeRemove</b>().</li>

<li>
<b>comm_state</b> - the CommState property value changed</li>

<li>
<b>control_state</b> - the ControlState property value changed</li>

<li>
<b>recipe_delete</b> - the name of a recipe that is being deleted by the
host, or being replaced with a downloaded version.</li>

<li>
<b>recipe_download</b> - the name of a recipe that has just been received
from the host.</li>

<li>
<b>recipe_upload</b> - the name of a recipe that has just been uploaded
to the host.</li>

<li>
<b>spooling_state</b> - the SecsEquip spooling state, ACTIVE or INACTIVE</li>

<li>
<b>SpoolCountActual</b> - the number of SECS messages currently spooled</li>

<li>
<b>SpoolCountTotal</b> - the total number of messages spooled and/or discarded</li>

<li>
<b>SpoolMax</b> - the configured maximum number of spooled messages</li>

<li>
<b>SpoolStreamFns</b> - the list of S&lt;s>, S&lt;s>F&lt;f> message types
that configured for spooling</li>
</ul>
Your application gets notified of the initial values of these items when
the SecsEquip connection type is initialized.</td>
</tr>
</table>

<p><a NAME="Methods"></a>
<table BORDER WIDTH="100%" >
<caption><b>SecsEquip Methods</b></caption>

<tr>
<td><b>METHOD</b></td>

<td><b>DESCRIPTION</b></td>
</tr>

<tr>
<td>General Comments
<br>&nbsp;
<br>&nbsp;
<p>&nbsp;</td>

<td>The List manipulation methods are actually implemented by the POSIX
dmh.dll, and exposed for your convenience by the SecsEquip class.<a NAME="AlarmAdd"></a></td>
</tr>

<tr>
<td>void <b>AlarmAdd</b>(int ALID, const char *ALTX)</td>

<td>Add an alarm type definition.&nbsp; Choose even numbers for the ALID
between 1000 and 2998.&nbsp; Newly created alarms are enabled.&nbsp; Per
GEM, two enabled events are created for each alarm, an alarm set event
with CEID == ALID, and an alarm clear event with CEID == ALID+1.&nbsp;
The ALTX argument is a description of the alarm and it has a length limit
of 40 ASCII characters.&nbsp; The ALTX should not contain single quote
characters.<a NAME="AlarmEnable"></a></td>
</tr>

<tr>
<td>void <b>AlarmEnable</b>(int ALID, bool is_enabled)</td>

<td>Enable or disable reporting of an Alarm type (S5F1).<a NAME="AlarmIsEnabled"></a></td>
</tr>

<tr>
<td>bool <b>AlarmIsEnabled</b>(int ALID)</td>

<td>Test if the reporting of an alarm type is enabled&nbsp;<a NAME="AlarmIsSet"></a></td>
</tr>

<tr>
<td>bool <b>AlarmIsSet</b>(int ALID)</td>

<td>Test if the alarmed state is currently set<a NAME="AlarmSet"></a></td>
</tr>

<tr>
<td>void <b>AlarmSet</b>(int ALID, bool is_set)</td>

<td>Set or Clear the alarmed state of an alarm.<a NAME="BinToInt"></a></td>
</tr>

<tr>
<td>int <b>BinToInt</b>(const char *binValue)
<p>&nbsp;</td>

<td>Converts a SECS B (Binary&nbsp; - Semi "10") data value usually formatted
as a hexadecimal string to an integer value.<a NAME="CommDisable"></a></td>
</tr>

<tr>
<td>void <b>CommDisable</b>(void)</td>

<td>Disable SECS communication.&nbsp; The SecsEquip is initialized without
communication enabled so using this method only makes sense after CommEnable
has been called.<a NAME="CommEnable"></a></td>
</tr>

<tr>
<td>void <b>CommEnable</b>(void)</td>

<td>Enables SECS communication.&nbsp; The <a href="#CommState">CommState</a>
property value will change and <a href="#StateChange">StateChange</a> events
will be received.&nbsp; These changes are the asynchronous indications
for success or failure to establish communication.&nbsp; When your equipment
is configured for the Active HSMS role, field personnel will want to display
the <a href="#Tracewin">trace window</a> with the 0x0002 <a href="#TRACE">TRACE</a>
property bit set in order to see detailed information on the status of
communication attempts.&nbsp;
<br><a NAME="ConnectTypeHsmsActive"></a></td>
</tr>

<tr>
<td>int <b>ConnectTypeHsmsActive</b>(const char *host_or_ip, int port)</td>

<td>This method is an alternative to setting the underlying property values
to specify an active HSMS connection type, and calling ConnectTypeSet().<a NAME="ConnectTypeHsmsPassive"></a></td>
</tr>

<tr>
<td>int <b>ConnectTypeHsmsPassive</b>(int port)</td>

<td>This method is an alternative to setting the underlying property values
to specify a passive HSMS connection type, and calling ConnectTypeSet().<a NAME="ConnectTypeSerial"></a></td>
</tr>

<tr>
<td>int <b>ConnectTypeSerial</b>(const char * comDevice, int baudrate)</td>

<td>This method is an alternative to setting the underlying property values
to specify a SECS-I connection type, and calling ConnectTypeSet().<a NAME="ConnectTypeSet"></a></td>
</tr>

<tr>
<td>int <b>ConnectTypeSet</b>(void)</td>

<td>This method is called to use the current property values and initialize
a SECS interface for the indicated connection type.&nbsp; It is called
by the ConnectType&lt;Type> methods.&nbsp; If you are setting connection
property data directly, call this method after your property values are
set.&nbsp; The method returns the value 0 to indicate success.<a NAME="DebugDMHStatus"></a></td>
</tr>

<tr>
<td>void <b>DebugDMHStatus</b>(bool show)</td>

<td>This method causes the DMH message system status window to either be
shown or dismissed.<a NAME="DebugInspect"></a></td>
</tr>

<tr>
<td>void <b>DebugInspect</b>()</td>

<td>This method can be used to exec the Inspect introspection debugger.<a NAME="DebugTableWindow"></a></td>
</tr>

<tr>
<td>void <b>DebugTableWindow</b>(bool show)</td>

<td>This method causes the Datahub table management GUI to be shown or
dismissed.&nbsp;<a NAME="DebugTclConsole"></a></td>
</tr>

<tr>
<td>void <b>DebugTclConsole</b>(bool show)</td>

<td>This method causes a console window for the SECS Server to be shown
or dismissed.<a NAME="DebugTraceWindow"></a></td>
</tr>

<tr>
<td>void <b>DebugTraceWindow</b>(bool show)</td>

<td>This method is used to display a window which updates to show SECS
message traffic and state information for the SecsEquip.&nbsp;&nbsp; There
are menu options to control the data displayed, and menu actions to save
the displayed data to the file system.&nbsp; This method invokes the Tcl
version of the Trace window which is created by the SECS Server process.&nbsp;
The example application features the <b>SecsTracewin</b> class and instantiates
a native VC++ window with similar function.&nbsp; Including the VC++ window
in the administration area of your equipment GUI is desirable to help field
personnel diagnose communication problems.&nbsp;<a NAME="EventAdd"></a></td>
</tr>

<tr>
<td>void <b>EventAdd</b>(int CEID, bool is_reported, const char * description)</td>

<td>This method is used to create an Event type.&nbsp; We suggest you use
CEID values between 5000 and 9999.<a NAME="EventEnable"></a></td>
</tr>

<tr>
<td>void <b>EventEnable</b>(int CEID, bool is_enabled)</td>

<td>Event reports are enabled for an event type when first created.&nbsp;
You can use this method to control whether an event report is enabled.<a NAME="EventIsEnabled"></a></td>
</tr>

<tr>
<td>bool <b>EventIsEnabled</b>(int CEID)</td>

<td>Test if reporting of an event type is currently enabled.<a NAME="EventPost"></a></td>
</tr>

<tr>
<td>void <b>EventPost</b>(int CEID)</td>

<td>You call this method to announce when an event has occurred.&nbsp;
In general, make sure that the data items that the host might want in an
event report are set to their proper values before EventPost is called.&nbsp;
You should make this call without testing to see if reporting of the event
is enabled and without other testing of the communication or control states.<a NAME="Free"></a></td>
</tr>

<tr>
<td>void <b>Free</b>(void *data)</td>

<td>This method must be called to free allocated memory that is passed
to the application as the result of calling
<ul>
<li>
ListElement</li>

<li>
ListJoin</li>

<li>
ListSplit</li>

<li>
ParameterGet</li>

<li>
ProcessProgramDownload</li>

<li>
ProcssProgramUpload</li>

<li>
QuoteDouble</li>

<li>
SendSecsMsg</li>

<li>
SendSecsMsgRcResult</li>

<li>
ServerSQLReply</li>

<li>
ServerTclReply</li>

<li>
TclReply</li>

<li>
TclReplyRcResult</li>

<li>
VariableGet</li>
</ul>
</td>
</tr>

<tr>
<td>char *<b>ListAppend</b>(const char *tclList, const char *e1, const
char *e2 = NULL,&nbsp; const char *e3 = NULL, const char *e4=NULL, const
char *e5=NULL, const char *e6=NULL);</td>

<td><a NAME="ListAppend"></a>This method is used to add one to six list
elements to text that is formatted as a Tcl list.&nbsp; It is a good programming
practice to use ListAppend or ListJoin to build a Tcl list, in order to
make sure that imbedded white space or other special characters are properly
delimited with curly braces or escaped with backslashes.&nbsp; An empty
string may be passed as any of the element argument values, in order to
represent an empty list or empty element.&nbsp; The first NULL argument
indicates the previous argument is the end of the list.
<p>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.&nbsp;<a NAME="ListElement"></a></td>
</tr>

<tr>
<td>char *<b>ListElement</b>(const char *tclList, int index1, int index2=-1,
int index3=-1);<a NAME="ListJoin"></a></td>

<td>This function is similar to the lindex function of Tcl.&nbsp; It will
parse text formatted as a Tcl list and return the specified element.&nbsp;
Indexing starts from 0.&nbsp; Arguments index2 and index3 may be used to
indicate that parsing of the TclList should continue up to two additional
levels as a nested list structure. If a specified index is out of bounds,
an empty string is returned.&nbsp; Not all strings are valid Tcl lists.&nbsp;
If an invalid list is parsed, NULL is returned.&nbsp;
<p>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.</td>
</tr>

<tr>
<td>char * <b>ListJoin</b>(const char * [] argv);<a NAME="ListSplit"></a></td>

<td>Joins together strings as Tcl list elements forming a result string
that is a Tcl list.&nbsp; Braces are added as needed to delimit empty elements,
or to delimit special Tcl character sequences involving backslashes , square
brackets, etc.&nbsp;
<p>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.</td>
</tr>

<tr>
<td>int <b>ListSplit</b>(const char *TclList, int *argc, char **argv[])</td>

<td>ListSplit( ) parses a string formatted as a Tcl list into an array
of string elements.&nbsp; The function understands the Tcl usage of quotes,
braces and backslash sequences.&nbsp; Not all strings are valid Tcl lists.
The return value is 0 on success. Failure occurs when there are unmatched
braces, unmatched quotes, or non-whitespace following braces or quotes.
<p>Memory is allocated from the heap for the resulting argv[] stack and
the elements that the stack points to. The argv result must be passed to
dmh_free() to reclaim the allocated memory when the caller is done with
it.<a NAME="MessageTypeAdd"></a></td>
</tr>

<tr>
<td>void <b>MessageTypeAdd</b>(int stream, int function, SecsMessageReceiveProc
*callback,&nbsp;&nbsp; void *clientData = NULL);)
<p>typedef void (SecsMessageReceiveProc)(SecsEquip *, int stream, int function,
bool send_reply,&nbsp;
<br>&nbsp; int transactionID, const char *TSN_data, const char *header,
void *clientData);</td>

<td>Call this method to have SECS messages processed by your custom handler
methods when the SecsEquip is in online control, and the message is received
from the host.&nbsp; You can provide for new SECS message types, or you
can replace the existing SecsEquip handling of particular messages.&nbsp;
Use the SendReply, SendS9, and SendAbort methods to send reply messages.
You can use the clientData argument to pass a pointer to an application
object or data structure into the receiving handler.<a NAME="MessageTypeRemove"></a></td>
</tr>

<tr>
<td>void <b>MessageTypeRemove</b>(int stream, int function)</td>

<td>This method is used to cancel SECS message handlers that you have setup
using MessageTypeAdd or to cancel the handling of particular messages during
the online control state by the built-in SecsEquip logic.&nbsp; For example,
you may wish to turn of Process Program management message types for a
tool that does not use Process Programs.&nbsp; If you have called MessageTypeAdd
for the specified message type, the Add is cancelled.&nbsp; If you have
not called MessageTypeAdd, the SECS server is told not to handle the message.
Unhandled messages are replied to with an abort reply.&nbsp; If the unhandled
message does not ask for a reply, an S9F5 message is sent to indicate an
unknown function.<a NAME="ParameterAdd"></a></td>
</tr>

<tr>
<td>void <b>ParameterAdd</b>(int varID, const char *varname, const char
*description, const char *value_TSN, const char *initialValue, const char
*minValue, const char *maxValue, const char *defaultValue, const char *units)</td>

<td>This method is used to add Equipment Constant Variable definitions
(ECVs).&nbsp; As with Variables, use varID values that are between 1000
to 1999 or between 9000 to 9999.&nbsp; Use a unique value for each parameter
or variable.&nbsp; The value_TSN argument is the Tcl SECS notation type
code for the ECV value such as A for ASCII string, or F4 for floating point.&nbsp;
Call <b>ParameterSet</b> when the ECV value is changed by your GUI or controller
logic so that the SECS Server can manage the appropriate GEM event.&nbsp;<a NAME="ParameterGet"></a></td>
</tr>

<tr>
<td>char *<b>ParameterGet</b>(int varID)</td>

<td>This method is used to get the current value of an ECV.&nbsp; It uses
the same access logic that host requests use so it can test your custom
value logic.&nbsp; The return value is NULL if there is an error.
<p>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.<a NAME="ParameterSet"></a></td>
</tr>

<tr>
<td>int <b>ParameterSet</b>(int varID, const char *newvalue)</td>

<td>This method is used to update the value of an ECV whose current value
is represented in the ei_variable table.<a NAME="QuoteDouble"></a></td>
</tr>

<tr>
<td>char *<b>QuoteDouble</b>(const char *text);</td>

<td>This method returns a result string where instances of single quotes
in the input string are doubled.&nbsp; This is the escaping method used
by SQL.
<p>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.<a NAME="ProcessProgramDownload"></a></td>
</tr>

<tr>
<td>RcResult <b>ProcessProgramDownload</b>(const char *ppid)&nbsp;
<p>typedef struct _RcResult {
<br>&nbsp;int rc;&nbsp; // return code
<br>&nbsp;char *result;
<br>} *<b>RcResult</b>;</td>

<td>Used by the equipment to initiate the download of a process program
from the host using S7F5.&nbsp; The ppid argument value is both the process
program identifier and the file name that is used by the equipment for
the process program file.&nbsp; There is no standard SECS command for the
equipment to know what process programs are available from the host for
downloading.&nbsp; The return value is a pointer to an allocated structure
containing an integer return code and a result string.&nbsp; If the return
code value is 0 which indicates success, the result string is the full
pathname to the process program file.&nbsp; Negative return code values
indicate error.&nbsp; Possible errors include those described with SendSecsMsg().&nbsp;
In addition the following error codes are also possible:&nbsp; -10 file
system error, -11 improper data received, -12 request denied by the host.
In the case of error, the result string is a diagnostic message.
<p>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.<a NAME="ProcessProgramUpload"></a></td>
</tr>

<tr>
<td>RcResult <b>ProcessProgramUpload</b>(const char *ppid)&nbsp;
<p>typedef struct _RcResult {
<br>&nbsp;int rc;&nbsp; // return code
<br>&nbsp;char *result;
<br>} *<b>RcResult</b>;</td>

<td>Used by the equipment to initiate transferring a process program to
the host using S7F3.&nbsp; The ppid argument value is identically the file
name of the process program and the identifier for the process program.&nbsp;
The return value is a pointer to an allocated structure containing an integer
return code and a result string. The return code value is 0 for complete
success.&nbsp; Negative return code values indicate an error.&nbsp; Possible
error values include those possible with ProcessProgramDownload().&nbsp;
In addition, the return code value of -13 is used to indicate "upload disabled
during spooling".&nbsp; A positive return code value is the SECS standard
ACKC7 code value sent by the host.&nbsp; Diagnostic text is provided in
the result string for all return code values.&nbsp;
<br><b>Important:&nbsp; Do not assume that the host saves process program
files with the same file names or in the same format that the equipment
does.&nbsp; The only proper way to use an uploaded process program file
is to download it using the same host software that uploaded it.</b>
<br>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.<a NAME="ReportsClear"></a></td>
</tr>

<tr>
<td>void <b>ReportsClear</b>()</td>

<td>This method erases any existing event report definitions, unlinks the
event reports from event types, and disables the event reports that were
linked to the deleted reports.&nbsp; The call also deletes any saved event
report data, so it can be used to prevent or nullify the restoring of event
reports from the previous saved session.&nbsp; The method is not usually
called since saving and restoring the dynamic event report configuration
is standard GEM behavior.<a NAME="ReportsRestore"></a></td>
</tr>

<tr>
<td>void <b>ReportsRestore</b>()</td>

<td>ReportsRestore gets called automatically when you first enable communication
if property ReportsAreSaved is true, and ReportsRestore has not already
been called.&nbsp; The call restores the state of event reporting from
the last session, and it initializes saving for the current session.&nbsp;
Restoring overwrites the existing event report definitions.&nbsp; There
is logic so that restoring only occurs once.&nbsp; A connection type should
be set and the variables and event types should be defined before calling
this method.<a NAME="SecsEquip"></a></td>
</tr>

<tr>
<td>void <b>SecsEquip</b>()&nbsp;
<p>void <b>SecsEquip</b>(const char *spname, const char *dmhGroup)</td>

<td>The class constructor.&nbsp; The <i>spname</i> argument becomes the
name of a global data item and a Tcl command in the SECS Server process.&nbsp;
It needs to be unique for each SecsEquip instance, and not coincide with
a keyword in the Tcl programming language.&nbsp; The default value of <i>spname</i>
is similar to <b>SecsEquip0</b>.&nbsp; The example application uses the
<i>spname</i>
value, <b>gemsim</b>.&nbsp; The name should be a single alphanumeric token.&nbsp;
<p>The <i>dmhGroup</i> argument becomes the DMH message system group name
used by the SecsEquip and SECS Server process.&nbsp; If you are instantiating
more than one SecsEquip instance in your process, construct each instance
using the same <i>dmhGroup</i> name argument so that the SECS Server process
is shared.&nbsp; The groupname chosen needs to be unique among other DMH
server instances on the computer where the SecsEquip is executing.&nbsp;
The default value is <b>GEM</b>.&nbsp; This value does not conflict with
the default value for Hume Datahub instances which is <b>mbx</b>.&nbsp;
The name should be a single alphanumeric token.&nbsp;
<p>The SecsEquip SECS Server process can be debugged remotely by connecting
to the DMH mailbox SERVER_RPC@<i>hostname</i>:<i>dmhGroup</i> using the
<a href="../man1/dmh_inspect.html">Inspect
application</a> or using the DMH mailbox SERVER_SQL@hostname:dmhGroup by
the <a href="../man1/hubclient.html">hubclient application</a>.<a NAME="SendAbort"></a></td>
</tr>

<tr>
<td>void <b>SendAbort</b>(int stream, int primaryFunction)</td>

<td>This method is used to send an F0 abort message in lieu of a proper
reply.&nbsp; It is used to indicate that the received message is not appropriate
in the current context.&nbsp;&nbsp; For example, when the control state
is ON-LINE LOCAL, the abort reply should be sent to a host message that
would affect processing.<a NAME="SendReply"></a></td>
</tr>

<tr>
<td>void <b>SendReply</b>(int stream, int function, int transactionID,
const char * TSN_data = "")</td>

<td>This method is used by your custom SECS message handling logic to send
reply messages either with or without data.&nbsp; The reply data is formatted
as <a href="../mann/TSN.html">Tcl Secs Notation </a>text.<a NAME="SendS9"></a></td>
</tr>

<tr>
<td>void <b>SendS9</b>(int function, const char *header)</td>

<td>This method is used to indicate an error condition response to a received
message - it is sent in lieu of a normal reply.&nbsp; The SecsEquip software
takes care of many of the possible error conditions automatically, including,
1- bad Device ID, 3 - bad stream, 5 - bad function, and 9 - T3 timeout.&nbsp;
You will not receive a message type, unless you register for it.&nbsp;
Therefore, you will mostly send the function value 7 to indicate improper
data.
<br><a NAME="SendSecsMsg"></a><a NAME="SendSecsMsgRcResult"></a></td>
</tr>

<tr>
<td>char *<b>SendSecsMsg</b>(int stream, int function, bool reply_wanted,
const char *TSN_data, bool wait4reply)
<br>&nbsp;
<p>RcResult <b>SendSecsMsg</b>(int stream, int function, bool reply_wanted,
const char *TSN_data, bool wait4reply)
<p>typedef struct _RcResult {
<br>&nbsp;int rc;&nbsp; // return code
<br>&nbsp;char *result;
<br>} *<b>RcResult</b>;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>&nbsp;</td>

<td>These methods are used to send a primary SECS message, optionally indicating
a reply is wanted, and optionally indicating that the call should wait
for a reply.&nbsp; The methods differ in how the return value data is presented.&nbsp;
The <b>SendSecsMsg</b>() return value is a string which is structured as
a two element list consisting of an integer return code and a string result.&nbsp;
The string result is typically parsed with the <b>ListElement</b>(), or
<b>ListSplit</b>().&nbsp;
The <b>SendSecsMsgRcResult</b>() returns a pointer to the same data already
parsed into a structure that has an integer return code and a result string.&nbsp;
In both cases, the return value must be deallocated using a single call
to the <b>Free</b>() method.&nbsp;&nbsp; The possible return values are:
<dl>
<dt>
-1</dt>

<dd>
<i>errorMessage</i>&nbsp; - the error message starts with "ERROR" and describes
the fault</dd>

<dt>
-2</dt>

<dd>
DISABLED&nbsp;&nbsp; - communication is disabled so the message could not
be sent</dd>

<dt>
-3&nbsp;</dt>

<dd>
OFF-LINE&nbsp;&nbsp; - the control state is OFF-LINE and per GEM only S1F1,
S1F13, and S9FX are sendable.</dd>

<dt>
-4&nbsp;</dt>

<dd>
DISCARDED&nbsp;&nbsp; - spooling is active and this message type is not
spooled.&nbsp; Usually the connection is down.&nbsp; But this result can
also occur for a newly established connection before the host has purged
or finished unloading the spool.</dd>

<dt>
-5&nbsp;</dt>

<dd>
BUSY&nbsp;&nbsp; - an eq_send call is currently active.&nbsp; You should
not see this error, since by design send commands are serialized using
DMH messages to the connection's command mailbox.</dd>

<dt>
1&nbsp;</dt>

<dd>
SPOOLED&nbsp;&nbsp;&nbsp; Your message has been spooled for later sending.&nbsp;
Even if you specify waiting for the reply result you receive this instead
of the reply data if the message is spooled.&nbsp; We recommend you not
allowing spooling of message types where you care about the reply.</dd>

<dt>
0&nbsp;</dt>

<dd>
SENT_NO_REPLY&nbsp; - sent successfully no reply requested</dd>

<dt>
0&nbsp;</dt>

<dd>
SENT_NO_REPLY_WAIT&nbsp; - sent successfully, a reply was indicated, not
waiting for the reply was indicated.&nbsp; The reply will be ignored when
it arrives.</dd>

<dt>
0&nbsp;</dt>

<dd>
<i>ReplyTsnData</i>&nbsp;&nbsp; -sent ok, reply requested and received.</dd>

<dt>
-6&nbsp;</dt>

<dd>
TIMEOUT&nbsp; - sent ok, reply requested, no reply, T3 timeout.&nbsp;</dd>

<dt>
-7&nbsp;</dt>

<dd>
ABORTED&nbsp; - sent ok, F0 abort reply received.</dd>

<dt>
-8&nbsp;</dt>

<dd>
REJECTED&nbsp; - sent ok, Stream 9 error message "reply".</dd>

<br>&nbsp;
<p>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>Remember to call Free() with the reply result when you are done using
it.&nbsp; You are able to Free() the RcResult in a single call because
the data pointed to by the result pointer is contained in the same memory
allocation as the _RcResult structure.<a NAME="ServerSQLCmd"></a></dl>
</td>
</tr>

<tr>
<td>static void <b>ServerSQLCmd</b>(const char *sql)</td>

<td>Send an SQL command to the SECS Server process without waiting for
a reply.&nbsp; This method is used by the SecsEquip software and made public
in case of custom requirements.<a NAME="ServerSQLReply"></a></td>
</tr>

<tr>
<td>static char *<b>ServerSQLReply</b>(const char *sql)</td>

<td>Send an SQL command to the SECS Server process and wait for the reply.&nbsp;
This method is used by the SecsEquip software and made public in case of
custom requirements.
<p>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.<a NAME="ServerTclCmd"></a></td>
</tr>

<tr>
<td>static void <b>ServerTclCmd</b>(const char * tclCommand);</td>

<td>Send a Tcl command to the SECS Server process without waiting for a
reply.&nbsp; This method is used by the SecsEquip software and made public
in case of custom requirements.&nbsp; After a SecsEquip instance has been
constructed and the connection type set, the TclCmd( ) method should be
used instead of this method for commands that are directed to a particular
interface instance.&nbsp; Why?&nbsp; Doing so serializes the commands for
a particular interface, and provides re-entrant execution protection.<a NAME="ServerTclReply"></a></td>
</tr>

<tr>
<td>static char *<b>ServerTclReply</b>(const char *tclCommand);</td>

<td>Send a Tcl command to the SECS Server process and wait for the reply
message.&nbsp; This call is used by the SecsEquip software and made public
in case of custom requirements.&nbsp; After a SecsEquip instance has been
constructed and the connection type set, the TclReply( ) method should
be used instead of this method for commands that are directed to a particular
interface instance.
<p>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.<a NAME="SpoolPurge"></a></td>
</tr>

<tr>
<td>void <b>SpoolPurge</b>(void)</td>

<td>This method discards any spooled messages that are queued for the host.<a NAME="SpoolStop"></a></td>
</tr>

<tr>
<td>void <b>SpoolStop</b>(void)</td>

<td>This method sets the messages types that are enabled for spooling to
an empty string, thus, further spooling is stopped.<a NAME="SpoolStreamFns"></a></td>
</tr>

<tr>
<td>void <b>SpoolStreamFns</b>(const char *StreamFns = NULL)</td>

<td>The method is used to set the spooled message types.&nbsp; If called
with no arguments, the streams that are allowed for the host to enable
(property <a href="#SpoolingAllow">SpoolingAllow</a>) are enabled.&nbsp;
If called with an argument, the call bypasses the SpoolingAllow property
and enables spooling for the S&lt;s> and S&lt;s>F&lt;f> message types that
are specified in the input string.<a NAME="TclCmd"></a></td>
</tr>

<tr>
<td>void <b>TclCmd</b>(const char *tcl)</td>

<td>This method is used to send Tcl code to the SECS server command mailbox
for the connection.&nbsp; It is used by the SecsEquip software and made
public to support custom requirements.<a NAME="TclReply"></a><a NAME="TclReplyRcResult"></a></td>
</tr>

<tr>
<td>char *<b>TclReply</b>(const char *tcl)
<p>RcResult <b>TclReplyRcResult</b>(const char *tcl)
<p>typedef struct _RcResult {
<br>&nbsp;int rc;&nbsp; // return code
<br>&nbsp;char *result;
<br>} *<b>RcResult</b>;</td>

<td>These methods are used to send Tcl code to the SECS server command
mailbox for the connection and wait for the evaluation result.&nbsp; They
are used by the SecsEquip software and made public to support custom requirements.&nbsp;
With <b>TclReply</b>() the string return value is structured as a list
and may be parsed using <a href="#ListSplit">ListSplit </a>or <a href="#ListElement">ListElement</a>.&nbsp;
The first element is a return code for the evaluation with 0 meaning success.&nbsp;
The second element is the return value from the executed Tcl code, or an
error message if the return code is not 0.&nbsp; With <b>TclReplyRcResult</b>(
) the same data has been parsed and is returned as separate fields in an
allocated data structure.
<p>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.<a NAME="TerminalDisplayAck"></a></td>
</tr>

<tr>
<td>void <b>TerminalDisplayAck</b>()</td>

<td>Calling this method posts GEM event 4100 which is used by the equipment
to indicate acknowledgment of a host Terminal Display.<a NAME="TsnTypeIsOk"></a></td>
</tr>

<tr>
<td>bool <b>TsnTypeIsOk</b>(const char *value_TSN)</td>

<td>This method is used to check value_TSN argument values that you pass
to the various Add methods.<a NAME="VariableAdd"></a></td>
</tr>

<tr>
<td>void <b>VariableAdd</b>(int varID, const char *varname, const char
*description, const char *varClass, const char *value_TSN, const char *varmethod,
const char *initialValue, const char *units)</td>

<td>Use this method to add a Status Value variable (varClass == "SV") or
a Data Value variable (varClass == "DVVAL").&nbsp; Both classes of variables
are available for the host to configure in event reports.&nbsp; A DVVAL
does not need to have a valid value, for example the alarm ID of the latest
alarm when there have been no alarms.&nbsp; Use varID values between 1000
and 1999 to have your variables sort before the built-in variables, or
use varID values between 9000 and 9999 to have them sort after the built-in
variables.&nbsp; Leave the varmethod argument as NULL or an empty string
if the variable value will be represented in the ei_variable table, or
you will subsequently call <b>VariableMethodSet</b> to specify an evaluation
callback.&nbsp;<a NAME="VariableGet"></a></td>
</tr>

<tr>
<td>char * <b>VariableGet</b>(int varID)</td>

<td>This method is used to get the current value of a variable.&nbsp; It
uses the same access logic that host requests use so it can test your custom
value logic.&nbsp; The return value is NULL if there is an error.
<p>Memory is allocated from the heap for the result, and it must be freed
by calling Free() when the caller is done with it.<a NAME="VariableSet"></a></td>
</tr>

<tr>
<td>void <b>VariableSet</b>(int varID)</td>

<td>This method is used to update the value of a Status Value or Data Value
variable whose current value is represented in the ei_variable table.<a NAME="VariableMethodSet"></a></td>
</tr>

<tr>
<td>void <b>VariableMethodSet</b>(int varID, SecsVarValueProc *callback)
<p>typedef const char *(SecsVarValueProc)(SecsEquip *, int varID);</td>

<td>You use this method to register a callback that is executed by the
SecsEquip software when the value of a Status or Data Value variable is
needed.&nbsp; The callback is executed by a different thread than your
main GUI thread, so be sure to use threadsafe programming techniques such
as mutexes.&nbsp; See the application example.</td>
</tr>
</table>

<h2>
SecsEquip Built-in SECS Features</h2>
This section of the document has information on the built-in features of
the SecsEquip software in regards to the SEMI E5 and GEM standards.
<p>There are no built-in alarm types.&nbsp; The example application creates
example alarm definitions to show how it is done.&nbsp; The Equipment developer
is expected to provide definitions suitable for his own equipment.
<br>&nbsp;
<h3>
<a NAME="BuiltInVariables"></a>Built-In SECS Variables</h3>
These variable definitions are specified by the SEMI standards, and are
created by the SecsEquip when the connection type is set.&nbsp; Once the
definitions exist, you are able to customize the values, or value methods.&nbsp;
Even if a definition is not appropriate for your equipment, you should
not delete it, since its existence is called out by the standards.
<h3>
Built-In SecsEquip Variables</h3>

<table BORDER id="BuiltInVariables" >
<tr>
<th>varID</th>

<th>varname</th>

<th>description</th>

<th>varclass</th>

<th>value_TSN</th>
</tr>

<tr>
<td>200</td>

<td>AlarmsEnabled</td>

<td>the list of alarm ALIDs enabled for reporting via S5</td>

<td>SV</td>

<td>L</td>
</tr>

<tr>
<td>201</td>

<td>AlarmID</td>

<td>the current alarm identifier ALID at the setting or clearing of an
alarm irrespective of reporting</td>

<td>DVVAL</td>

<td>U4</td>
</tr>

<tr>
<td>202</td>

<td>AlarmsSet</td>

<td>the list of alarm ALIDs in the set state, irrespective of reporting</td>

<td>SV</td>

<td>L</td>
</tr>

<tr>
<td>220</td>

<td>AnnotateEventReports</td>

<td>send annotated event reports as S6F13 instead of S6F11</td>

<td>ECV</td>

<td>TF</td>
</tr>

<tr>
<td>250</td>

<td>Clock</td>

<td>the value of the equipment's clock</td>

<td>SV</td>

<td>A:16</td>
</tr>

<tr>
<td>300</td>

<td>ControlMode</td>

<td>0=Local, 1=Remote (aka E5-95 ControlState 2nd definition)</td>

<td>SV</td>

<td>U1</td>
</tr>

<tr>
<td>301</td>

<td>ControlState</td>

<td>1=off-line/eq off-line 2=off/seek on 3=off/host off 4=on/local 5=on/remote</td>

<td>SV</td>

<td>B</td>
</tr>

<tr>
<td>330</td>

<td>DvvalList</td>

<td>A list of the DVVAL variables, their IDs and names (L [L:2 &lt;VID>
&lt;DVNAME>]+).&nbsp; This variable is standard for Hume implementations,
but is not specified by SEMI standards.&nbsp; The variable fills a gap
in SECS functionality - there is no standard means for the host to ask
about DVVAL variables.</td>

<td>SV</td>

<td>L</td>
</tr>

<tr>
<td>350</td>

<td>ECIDChangeName</td>

<td>The equipment constant, ECID, last updated independent of the host</td>

<td>DVVAL</td>

<td>U4</td>
</tr>

<tr>
<td>375</td>

<td>EstablishCommunicationsTimeout</td>

<td>the length of time in seconds between S1F13 attempts when initializing
communications</td>

<td>ECV</td>

<td>U4</td>
</tr>

<tr>
<td>400</td>

<td>EventsEnabled</td>

<td>the list of event CEIDs enabled for reporting via S6</td>

<td>SV</td>

<td>L</td>
</tr>

<tr>
<td>410</td>

<td>EventDescriptions</td>

<td>A list of all event CEIDs and their descriptions.&nbsp; This variable
is standard for Hume implementations, but is not specified by SEMI standards.&nbsp;
The variable fills a gap in SECS functionality - there is no standard means
for the host to ask about event types.</td>

<td>SV</td>

<td>L</td>
</tr>

<tr>
<td>500</td>

<td>LimitVariable</td>

<td>contains the VID for the variable whose value changed monitoring zones</td>

<td>DVVAL</td>

<td>U4</td>
</tr>

<tr>
<td>501</td>

<td>EventLimit</td>

<td>contains LIMITID(s) of the limit reached by LimitVariable(s)</td>

<td>DVVAL</td>

<td>L</td>
</tr>

<tr>
<td>502</td>

<td>TransitionType</td>

<td>the direction of limits zone transition 0=low2hi, 1=hi2low</td>

<td>DVVAL</td>

<td>B</td>
</tr>

<tr>
<td>600</td>

<td>MDLN</td>

<td>Equipment Model Type</td>

<td>SV</td>

<td>A:6</td>
</tr>

<tr>
<td>650</td>

<td>OperatorCommand</td>

<td>The last operator command issued during control_mode of REMOTE</td>

<td>DVVAL</td>

<td>A</td>
</tr>

<tr>
<td>700</td>

<td>PPChangeName</td>

<td>The Process Program ID, PPID, affected by the creation, edit, or delete
local to the equipment</td>

<td>DVVAL</td>

<td>A</td>
</tr>

<tr>
<td>710</td>

<td>PPChangeStatus</td>

<td>The action taken on PPChangeName, 1=create, 2=edit, 3=deleted</td>

<td>DVVAL</td>

<td>U1</td>
</tr>

<tr>
<td>715</td>

<td>PPError</td>

<td>Contains information about a failure to verify a process program</td>

<td>DVVAL</td>

<td>A</td>
</tr>

<tr>
<td>720</td>

<td>PPExecName</td>

<td>the PPID(s) of the selected Process Program(s)</td>

<td>SV</td>

<td>A</td>
</tr>

<tr>
<td>725</td>

<td>PPFormat</td>

<td>Indicates the type or types of process programs and recipes supported,
1 = unformatted PPs</td>

<td>SV</td>

<td>U1</td>
</tr>

<tr>
<td>800</td>

<td>PreviousProcessState</td>

<td>the previous processing state</td>

<td>SV</td>

<td>U1</td>
</tr>

<tr>
<td>810</td>

<td>ProcessState</td>

<td>the current processing state</td>

<td>SV</td>

<td>U1</td>
</tr>

<tr>
<td>820</td>

<td>RcpChangeName</td>

<td>The identifier of the Stream 15 recipe affected by creation, editing,
or deletion</td>

<td>DVVAL</td>

<td>A</td>
</tr>

<tr>
<td>825</td>

<td>RcpChangeStatus</td>

<td>the type of change for RcpChangeName</td>

<td>DVVAL</td>

<td>U1</td>
</tr>

<tr>
<td>830</td>

<td>RcpExecName</td>

<td>the identifier of the currently selected Stream 15 recipe</td>

<td>SV</td>

<td>A</td>
</tr>

<tr>
<td>850</td>

<td>SOFTREV</td>

<td>Equipment Software Revision ID</td>

<td>SV</td>

<td>A:6</td>
</tr>

<tr>
<td>870</td>

<td>SpoolCountActual</td>

<td>the actual # of msgs queued</td>

<td>SV</td>

<td>U4</td>
</tr>

<tr>
<td>871</td>

<td>SpoolCountTotal</td>

<td>the total # of msgs spooled and/or discarded</td>

<td>SV</td>

<td>U4</td>
</tr>

<tr>
<td>872</td>

<td>SpoolFullTime</td>

<td>the Clock from the time the spool last became full</td>

<td>SV</td>

<td>A:16</td>
</tr>

<tr>
<td>873</td>

<td>SpoolStartTime</td>

<td>the Clock from the time spooling last became active</td>

<td>SV</td>

<td>A:16</td>
</tr>

<tr>
<td>874</td>

<td>MaxSpoolTransmit</td>

<td>max. # of spooled msgs per S6F23 reply, 0=no limit</td>

<td>ECV</td>

<td>U4</td>
</tr>

<tr>
<td>875</td>

<td>SpoolMax</td>

<td>max number of messages spooled</td>

<td>ECV</td>

<td>U4</td>
</tr>

<tr>
<td>876</td>

<td>OverWriteSpool</td>

<td>true=circular spool buffering, false=stop spooling when buffer full</td>

<td>ECV</td>

<td>TF</td>
</tr>

<tr>
<td>877</td>

<td>SpoolStreamFns</td>

<td>the list of SnFm message types that are spooled, set by S2F43</td>

<td>SV</td>

<td>A</td>
</tr>

<tr>
<td>900</td>

<td>TimeFormat</td>

<td>0==YYMMDDHHMMSScc 1==YYYYMMDDHHMMSScc in S2F18, S2F31, S6F1</td>

<td>ECV</td>

<td>U4</td>
</tr>

<tr>
<td>920</td>

<td>UseMultiBlockInquire</td>

<td>If true, S6F5 is used before sending multiblock event reports.&nbsp;
The default value is true for SECS-I and false for HSMS.</td>

<td>ECV</td>

<td>TF</td>
</tr>
</table>

<h3>
<a NAME="BuiltInMessages"></a></h3>

<h3>
Built-in Handling of SECS Message Types</h3>
The E5 standard identifies data items used in message items with all uppercase
letters such as CEID.&nbsp; Typically, the standard allows for different
data types to be used for a particular message item.&nbsp; If we show a
message data item in lowercase, we are showing the preferred data type
of our implementation, and using the lowercase term to indicate a value
of the indicated data type.&nbsp; For example, we use type U4 to pass CEID
values.&nbsp; So our shorthand way of specifying this is to write "{U4
&lt;ceid>}" instead of &lt;CEID>.&nbsp; Historically, the host software
has been required to know and use the specific data types that the equipment
implements when the standard allows for different data types.&nbsp; This
has never been the case with Hume SECS/GEM implementations.&nbsp; For most
message types, the software accepts any data type for a message data item
as long as the value is equivalent.&nbsp; For example, the S1F3R message
data to obtain the value of the Clock variable, SVID = 250, is usually
sent by the host as "L {U4 250}" since our implementation uses type U4
to send SVID values.&nbsp; But the host could use type A, type U2, type
U1, type I4, or type I2 for the data type of the SVID value to make this
same request.&nbsp; The value passed by the host only needs to be equal
when compared as a string.&nbsp; If the standard identifies a single data
type for an item, only the specified type should be used.&nbsp; For example,
for control of spooling, S2F43, only type U1 should be used to indicate
streams and functions.
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td><b>Type</b></td>

<td><b>Sender</b></td>

<td><b>Data Format</b></td>

<td><b>Comments</b></td>
</tr>

<tr>
<td>S1F1R</td>

<td>H, E</td>

<td>&nbsp;</td>

<td>"Are You There?"</td>
</tr>

<tr>
<td>S1F2</td>

<td>E</td>

<td>L:2 &lt;MODLN> &lt;SOFTREV>
<br>&lt;MODLN> := {A &lt;mdln>}
<br>&lt;SOFTREV> := {A &lt;softrev>}</td>

<td>"On Line Data"
<br>MODLN and SOFTREV data are property values.</td>
</tr>

<tr>
<td>S1F3R</td>

<td>H</td>

<td>L [&lt;SVID>]*
<br>&lt;SVID>&nbsp; := {U4 &lt;varID>}</td>

<td>"Selected Equipment Status Request"&nbsp;
<br>If the host sends a 0 length list, the host gets all possible values,
but he doesn't know what they represent!&nbsp; So there is an unwritten
rule that the ordering of the L:0 reply matches the ordering of the S1F12
reply.</td>
</tr>

<tr>
<td>S1F4</td>

<td>E</td>

<td>L [&lt;SV>]*</td>

<td>"Selected Equipment Status Data"
<br>The data type of the SV value depends on the variable.</td>
</tr>

<tr>
<td>S1F11R</td>

<td>H</td>

<td>L [&lt;SVID>]*</td>

<td>&nbsp;"Status Variable Namelist Request"</td>
</tr>

<tr>
<td>S1F12</td>

<td>E</td>

<td>L [{L:3 &lt;SVID> &lt;SVNAME> &lt;UNITS>}]+</td>

<td>&nbsp;"Status Variable Namelist Reply"</td>
</tr>

<tr>
<td>S1F13R</td>

<td>H,E</td>

<td>L:2 &lt;MODLN> &lt;SOFTREV></td>

<td>&nbsp;"Establish Communications Request"</td>
</tr>

<tr>
<td>S1F14</td>

<td>E</td>

<td>L:2 &lt;COMMACK> {L:2 &lt;MODLN> &lt;SOFTREV>}
<br>&lt;COMMACK> := {B 0}</td>

<td>&nbsp;"Establish Communications Request Acknowledge"</td>
</tr>

<tr>
<td>S1F15R</td>

<td>H</td>

<td>&nbsp;</td>

<td>"Request OFF-LINE"</td>
</tr>

<tr>
<td>S1F16</td>

<td>E</td>

<td>B 0</td>

<td>"OFF-LINE Acknowledge"
<br>causes transition to OFF-LINE Host control state</td>
</tr>

<tr>
<td>S1F17R</td>

<td>H</td>

<td>&nbsp;</td>

<td>"Request ON-LINE"</td>
</tr>

<tr>
<td>S1F18</td>

<td>E</td>

<td>&lt;ONLACK> := {B &lt;onlack>}</td>

<td>"ON-LINE Acknowledge"
<br>{B 1} is sent if we have an offline control intent,
<br>{B 2} is sent if we are already online
<br>If we have an online control intent, {B 1} is sent in the unlikely
case we are in the OFF-LINE Seekonline state, since the GEM standard does
not show an online transition for this state because of S1F17R.&nbsp; The
usual case if we have an online control intent is to send {B 0}and transition
to online control</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>S2F13</td>

<td>H</td>

<td>L [&lt;ECID>]*</td>

<td>"Equipment Constant Request"</td>
</tr>

<tr>
<td>S2F14</td>

<td>E</td>

<td>L [&lt;ECV>]*</td>

<td>"Equipment Constant Data"
<br>if L:0 is input, the reply order matches S2F30.</td>
</tr>

<tr>
<td>S2F15R</td>

<td>H</td>

<td>L [{L:2 &lt;ECID> &lt;ECV>}]*</td>

<td>"New Equipment Constant Send"</td>
</tr>

<tr>
<td>S2F16</td>

<td>E</td>

<td>B &lt;rc></td>

<td>"New Equipment Constant Ack"</td>
</tr>

<tr>
<td>S2F17R</td>

<td>H</td>

<td>&nbsp;</td>

<td>"Date and Time Request"</td>
</tr>

<tr>
<td>S2F18</td>

<td>E</td>

<td>A:16 YYYYMMDDHHMMSScc&nbsp;
<br>A:12 YYMMDDHHMMSS</td>

<td>"Date and Time Data"
<br>TimeFormat ECV, varID 900, sets the reply format, 1 is the default
<br>0==YYMMDDHHMMSS 1==YYYYMMDDHHMMSScc in S2F18, S2F31, S6F1</td>
</tr>

<tr>
<td>S2F23R</td>

<td>H</td>

<td>L:5 &lt;TRID> &lt;DSPER> &lt;TOTSMP> &lt;REPGSZ> {L [&lt;SVID>]+}</td>

<td>&nbsp;"Trace Initialize Send"</td>
</tr>

<tr>
<td>S2F24</td>

<td>E</td>

<td>B &lt;rc></td>

<td>"Trace Initialize Acknowledge"
<br>The SecsEquip handles trace reports.</td>
</tr>

<tr>
<td>S2F25R</td>

<td>H,E</td>

<td>B [&lt;b>]*</td>

<td>"Loopback Diagnostic Request"</td>
</tr>

<tr>
<td>S2F26</td>

<td>E</td>

<td>B [&lt;b>]*</td>

<td>&nbsp;"Loopback Diagnostic Data"</td>
</tr>

<tr>
<td>S2F29R</td>

<td>H</td>

<td>L [&lt;ECID>]*</td>

<td>"Equipment Constant Namelist Request"</td>
</tr>

<tr>
<td>S2F30</td>

<td>E</td>

<td>L [L:6 &lt;ECID> &lt;ECNAME> &lt;ECMIN> &lt;ECMAX> &lt;ECDEF> &lt;UNITS>]+</td>

<td>&nbsp;"Equipment Constant Namelist"</td>
</tr>

<tr>
<td>S2F31R</td>

<td>H</td>

<td>A:16 YYYYMMDDHHMMSScc&nbsp;
<br>A:12 YYMMDDHHMMSS</td>

<td>"Date and Time Set Request"</td>
</tr>

<tr>
<td>S2F32</td>

<td>E</td>

<td>B &lt;rc></td>

<td>"Date and Time Set Acknowledge"
<br>The SecsEquip calculates and uses a clock offset value.</td>
</tr>

<tr>
<td>S2F33R</td>

<td>H</td>

<td>L:2 &lt;DATAID> {L [{L:2 &lt;RPTID> {L [&lt;VID>]*}]*}</td>

<td>"Define Report"</td>
</tr>

<tr>
<td>S2F34</td>

<td>E</td>

<td>B &lt;rc></td>

<td>"Define Report Acknowledge"</td>
</tr>

<tr>
<td>S2F35R</td>

<td>H</td>

<td>L:2 &lt;DATAID> {L [&lt;CEID> {L [&lt;RPTID>]*}]*}</td>

<td>"Link Event Report"</td>
</tr>

<tr>
<td>S2F36</td>

<td>E</td>

<td>B &lt;rc></td>

<td>"Link Event Report Acknowledge"</td>
</tr>

<tr>
<td>S2F37R</td>

<td>H</td>

<td>L:2 &lt;CEED> {L [&lt;CEID>]*}</td>

<td>"Enable/Disable Event Report"</td>
</tr>

<tr>
<td>S2F38</td>

<td>&nbsp;</td>

<td>B &lt;rc></td>

<td>"Enable/Disable Event Report Acknowledge"</td>
</tr>

<tr>
<td>S2F39R</td>

<td>H</td>

<td>L:2 &lt;DATAID> &lt;DATALENGTH></td>

<td>"Multi-block Inquire"
<br>The implementation does not care what type or value the &lt;DATAID>
is.</td>
</tr>

<tr>
<td>S2F40</td>

<td>E</td>

<td>B 0</td>

<td>"Multi-block Grant"</td>
</tr>

<tr>
<td>S2F41R</td>

<td>H</td>

<td>L:2 &lt;RCMD> {L [{L:2 &lt;CPNAME> &lt;CPVAL>]*}</td>

<td>"Host Command Send"</td>
</tr>

<tr>
<td>S2F42</td>

<td>E</td>

<td>L:2 &lt;HCACK> {L [{L:2 &lt;CPNAME> &lt;CPACK>]*}</td>

<td>"Host Command Acknowledge"
<br>sent by your handling logic in the application -see example</td>
</tr>

<tr>
<td>S2F43R</td>

<td>H</td>

<td>L [{L:2 {U1 &lt;strid>} {L [{U1 &lt;fcnid>}]*}]*&nbsp;</td>

<td>"Configure Spooling"</td>
</tr>

<tr>
<td>S2F44</td>

<td>E</td>

<td>L:2 {B &lt;rsack>} {L [{L:3 {U1 &lt;strid>} {B &lt;strack>} {L [{U1
&lt;fcnid>}]*}}]*}</td>

<td>"Configure Spooling Acknowledge"
<br>property <a href="#SpoolingAllow">SpoolingAllow</a> is consulted</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>S5F1</td>

<td>E</td>

<td>L:3 {B &lt;alcd>} {U4 &lt;alid>} {A &lt;altx>}</td>

<td>"Alarm Report Send"
<br>the SecPort does not request a reply</td>
</tr>

<tr>
<td>S5F3R</td>

<td>H</td>

<td>L:2 {B &lt;aled>} {U4 &lt;alid>}</td>

<td>"Enable/Disable Alarm Send"</td>
</tr>

<tr>
<td>S5F4</td>

<td>E</td>

<td>B &lt;rc></td>

<td>"Enable/Disable Alarm Ack"</td>
</tr>

<tr>
<td>S5F5R</td>

<td>H</td>

<td>&lt;ALID vector></td>

<td>"List Alarms Request"</td>
</tr>

<tr>
<td>S5F6</td>

<td>E</td>

<td>L [{L:3 {B &lt;alcd>} {U4 &lt;alid>} {A &lt;altx>}}]*</td>

<td>"List Alarm Data"</td>
</tr>

<tr>
<td>S5F7R</td>

<td>H</td>

<td>&nbsp;</td>

<td>"List Enabled Alarm Request"</td>
</tr>

<tr>
<td>S5F8</td>

<td>E</td>

<td>L [{L:3 {B &lt;alcd>} {U4 &lt;alid>} {A &lt;altx>}}]*</td>

<td>"List Enabled Alarm Data"</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>S6F1</td>

<td>E</td>

<td>L:4 &lt;TRID> {U4 &lt;smpln>} &lt;STIME> {L [&lt;SV>]+}</td>

<td>"Trace Data Send"
<br>The SecsEquip does not ask for replies.&nbsp; &lt;STIME> is formatted
per the TimeFormat ECV setting.&nbsp; &lt;TRID> is whatever type and value
the host sends in S2F23R.</td>
</tr>

<tr>
<td>S6F5R</td>

<td>E</td>

<td>L:2 &lt;DATAID> &lt;DATALENGTH></td>

<td>"Multi-block Data Send Inquire"</td>
</tr>

<tr>
<td>S6F6</td>

<td>H</td>

<td>&lt;GRANT6></td>

<td>"Multi-block Grant"</td>
</tr>

<tr>
<td>S6F11R</td>

<td>E</td>

<td>L:3 {U4 &lt;dataid>} {U4 &lt;ceid>} {L [{L:2 {U4 &lt;rptid>} {L [&lt;V>]+}}]+}</td>

<td>"Event Report Send"
<br>ECV AnnotateEventReports, varID 220, controls whether S6F11R is sent
or S6F13R is sent.&nbsp; S6F13R is the default.</td>
</tr>

<tr>
<td>S6F12</td>

<td>H</td>

<td>&lt;ACKC6></td>

<td>"Event Report Ack"</td>
</tr>

<tr>
<td>S6F13R</td>

<td>E</td>

<td>L:3 {U4 &lt;dataid>} {U4 &lt;ceid>} {L [{L:2 {U4 &lt;rptid>} {L [{L:2
{U4 &lt;vid>} &lt;V>}]+}}]+}</td>

<td>"Annotated Event Report Send"</td>
</tr>

<tr>
<td>S6F14</td>

<td>H</td>

<td>&lt;ACKC6></td>

<td>"Annotated Event Report Ack"</td>
</tr>

<tr>
<td>S6F15R</td>

<td>H</td>

<td>&lt;CEID></td>

<td>"Event Report Request"</td>
</tr>

<tr>
<td>S6F16</td>

<td>E</td>

<td>S6F11 data</td>

<td>"Event Report Data"</td>
</tr>

<tr>
<td>S6F17R</td>

<td>H</td>

<td>&lt;CEID></td>

<td>"Annotated Event Report Request"</td>
</tr>

<tr>
<td>S6F18</td>

<td>E</td>

<td>S6F13 data</td>

<td>"Annotated Event Report Data"</td>
</tr>

<tr>
<td>S6F19R</td>

<td>H</td>

<td>&lt;RPTID></td>

<td>"Individual Report Request"</td>
</tr>

<tr>
<td>S6F20</td>

<td>E</td>

<td>L [&lt;V>]*</td>

<td>"Individual Report Data"</td>
</tr>

<tr>
<td>S6F21R</td>

<td>H</td>

<td>&lt;RPTID></td>

<td>"Annotated Individual Report Request"</td>
</tr>

<tr>
<td>S6F22</td>

<td>E</td>

<td>L [{L:2 {U4 &lt;varID>} &lt;V>}]*</td>

<td>"Annotated Individual Report Data"</td>
</tr>

<tr>
<td>S6F23R</td>

<td>H</td>

<td>&lt;RSDC></td>

<td>"Request or Purge Spooled Data"</td>
</tr>

<tr>
<td>S6F24</td>

<td>E</td>

<td>&lt;RSDA></td>

<td>"Request or Purge Spooled Data Ack"</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>S7F1R</td>

<td>H, E</td>

<td>L:2 &lt;PPID> &lt;LENGTH></td>

<td>"Process Program Load Inquire"</td>
</tr>

<tr>
<td>S7F2</td>

<td>E, H</td>

<td>&lt;PPGNT></td>

<td>"Process Program Load Grant" - the SecsEquip always sends B 0.</td>
</tr>

<tr>
<td>S7F3R</td>

<td>H, E</td>

<td>L:2 {A &lt;ppid>} &lt;PPBODY></td>

<td>"Process Program Download"
<br>property <a href="#RecipesAreBinary">RecipesAreBinary</a> configures
whether PPBODY is type B or A</td>
</tr>

<tr>
<td>S7F4</td>

<td>E, H</td>

<td>B &lt;rc></td>

<td>"Process Program Download Acknowledge"</td>
</tr>

<tr>
<td>S7F5R</td>

<td>H, H</td>

<td>A &lt;ppid></td>

<td>"Process Program Upload Request"</td>
</tr>

<tr>
<td>S7F6</td>

<td>E, H</td>

<td>L:2 {A &lt;ppid>} &lt;PPBODY></td>

<td>"Process Program Upload Data"
<br>property <a href="#RecipesAreBinary">RecipesAreBinary</a> configures
whether PPBODY is type B or A</td>
</tr>

<tr>
<td>S7F17R</td>

<td>H</td>

<td>L [{A &lt;ppid>}]*</td>

<td>"Delete Process Program Send"</td>
</tr>

<tr>
<td>S7F18</td>

<td>E</td>

<td>B &lt;rc></td>

<td>"Delete Process Program Acknowledge"</td>
</tr>

<tr>
<td>S7F19R</td>

<td>H</td>

<td>&nbsp;</td>

<td>"Current Process Program Dir Request"</td>
</tr>

<tr>
<td>S7F20</td>

<td>E</td>

<td>L [{A &lt;ppid>}]*</td>

<td>"Current Process Program Data"</td>
</tr>

<tr>
<td>S*F0</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>abort replies are handled as a special case of reply</td>
</tr>

<tr>
<td>S9F1</td>

<td>E</td>

<td>&lt;MHEAD></td>

<td>"Unknown Device ID"
<br>sent automatically per the standard</td>
</tr>

<tr>
<td>S9F3</td>

<td>E,H</td>

<td>&lt;MHEAD></td>

<td>"Unknown Stream"</td>
</tr>

<tr>
<td>S9F5</td>

<td>E,H</td>

<td>&lt;MHEAD></td>

<td>"Unknown Function"</td>
</tr>

<tr>
<td>S9F7</td>

<td>E,H</td>

<td>&lt;MHEAD></td>

<td>"Illegal Data"</td>
</tr>

<tr>
<td>S9F9</td>

<td>E,H</td>

<td>&lt;MHEAD></td>

<td>"Transaction Timeout"
<br>T3 timeout</td>
</tr>

<tr>
<td>S9F11</td>

<td>E</td>

<td>&lt;MHEAD></td>

<td>"Data Too Long" - your application can send this</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>S10F1</td>

<td>E</td>

<td>L:2 {B 0} {A &lt;text>}</td>

<td>"Terminal Request"
<br>the example application sends this</td>
</tr>

<tr>
<td>S10F3R</td>

<td>H</td>

<td>L:2 &lt;TID> {A &lt;text>}</td>

<td>"Terminal Display, Single"</td>
</tr>

<tr>
<td>S10F4</td>

<td>E</td>

<td>B &lt;rc></td>

<td>"Terminal Display, Single Acknowledge"
<br>&lt;rc> is set by your application callback</td>
</tr>

<tr>
<td>S10F5R</td>

<td>H</td>

<td>L:n &lt;TID> {L [{A &lt;text>}]*}</td>

<td>&nbsp;"Terminal Display, Multi-Block"</td>
</tr>

<tr>
<td>S10F6</td>

<td>E</td>

<td>B &lt;rc></td>

<td>"Terminal Display, Multi-Block Acknowledge"
<br>&lt;rc> is set by your application callback</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>
</table>

<h3>
Built-In&nbsp;<a NAME="BuiltInEvents"></a>Event Report Definitions</h3>
&nbsp;
<table BORDER id="ei_event" >
<tr>
<th>CEID</th>

<th>Description</th>
</tr>

<tr>
<td>1000-2999</td>

<td>Alarm Set == ALID,&nbsp; Alarm Clear == ALID+1</td>
</tr>

<tr>
<td>4000</td>

<td>Control State OFF-LINE</td>
</tr>

<tr>
<td>4001</td>

<td>Control State LOCAL</td>
</tr>

<tr>
<td>4002</td>

<td>Control State REMOTE</td>
</tr>

<tr>
<td>4005</td>

<td>Material Received</td>
</tr>

<tr>
<td>4006</td>

<td>Material Removed</td>
</tr>

<tr>
<td>4015</td>

<td>Operator Command Issued</td>
</tr>

<tr>
<td>4020</td>

<td>Operator Equipment Constant Change</td>
</tr>

<tr>
<td>4030</td>

<td>Process Program Change</td>
</tr>

<tr>
<td>4035</td>

<td>Process Program Invalid</td>
</tr>

<tr>
<td>4040</td>

<td>Process Program Selected</td>
</tr>

<tr>
<td>4047</td>

<td>Processing Started</td>
</tr>

<tr>
<td>4048</td>

<td>Processing Completed</td>
</tr>

<tr>
<td>4049</td>

<td>Processing Stopped</td>
</tr>

<tr>
<td>4050</td>

<td>Process State Update</td>
</tr>

<tr>
<td>4080</td>

<td>Spooling Activated</td>
</tr>

<tr>
<td>4081</td>

<td>Spooling Deactivated</td>
</tr>

<tr>
<td>4083</td>

<td>Spool Transmit Failure</td>
</tr>

<tr>
<td>4091</td>

<td>Stream 15 Execution Recipe - New</td>
</tr>

<tr>
<td>4093</td>

<td>Stream 15 Execution Recipe - Change</td>
</tr>

<tr>
<td>4100</td>

<td>Terminal Services Operator Display Acknowledge</td>
</tr>
</table>

<p>
<hr WIDTH="100%"><a NAME="LicenseTerms"></a>
<h2>
License Terms</h2>
Subject to Change Without Notice
<p>The Hume VC++ SecsEquip software is licensed for development and runtime
use at no additional charge for computers that are licensed for development
use of the Hume Integration Datahub SDK.
<p>Hume Integration is also pleased to offer separate runtime licenses
for using the SecsEquip software on systems that are not licensed as development
systems.&nbsp; Contact Hume Integration for information on the Resale Licensing
program.
<p>
<hr WIDTH="100%">
<h2>
<a NAME="DocVersion"></a>Document Version</h2>
Date of last revision: $Date: 2005/04/06 13:55:53 $
</body>
</html>
