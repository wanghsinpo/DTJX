<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Ed Hume">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (Windows NT 5.0; U) [Netscape]">
   <meta name="Description" content="User Guide and Reference Information for the Java SecsHost  SECS Host Library">
   <title>SecsHost   - A Java SECS Host Class</title>
</head>
<body>

<h1>
SecsHost - A Java Library for Host SECS Interfaces</h1>

<p><br>The SecsHost class library is designed to provide a high-level starting
point when deploying Host SECS Interface software using the Java 2 Platform.
Without any code development, the software is able to communicate with
GEM standard equipment, manage dynamic Event Reports, upload and download
process programs, and manage automatic online initialization.&nbsp; The
library also imbeds extensive fallback logic that accommodates working
with non-standard and non-GEM compliant equipment.&nbsp; A supervisory
application is provided with source code that enables you to interactively
configure and manage multiple Host interfaces.&nbsp; Application source
code is also provided for a Host Graphical User Interface (GUI), and related
dialogs such as property editing, and a window to display detail on the
data that is being exchanged over the SECS interface.&nbsp; The SecsHost
software operates with or without these windows being present - it is a
component that can be imbedded and deployed in an application of your own
design.&nbsp; An application developer registers callback interfaces to
receive asynchronous inputs such as Event Reports, Alarm Reports, or specified
SECS message types.&nbsp; The example application code demonstrates using
these techniques without undo complexity.&nbsp; You can readily understand
how to use the software and get on with building your own application,
or you can customize the application we provide to meet your own requirements.
<p><a NAME="features"></a>
<h2>
Feature Summary</h2>

<ul>
<li>
A high-level, working host SECS interface ready for immediate use - leverage
your talents as a developer by focusing on integrating equipment into your
factory system, and not being bogged down with developing and maintaining
a library of low-level code.</li>

<li>
Comes complete with Java source code for the SecsHost class library and
Supervisor application.</li>

<li>
Incorporates practical solutions, workarounds, and best practices to address
the deficiencies, inherent contradictions, under-documented areas, and
non-standard uses of SECS and GEM.</li>

<li>
Built-in management of communication and control state models with automatic
initialization of dynamic Event Reports.</li>

<li>
Configurable Virtual Reporting - Event Reports and Status Variables can
be renamed to provide commonality across equipment.</li>

<li>
Developed using standard Java (Sun's Java 2 Platform, JDK 5.0) for portability
across many hardware and operating system platforms.</li>

<li>
Leverages the Hume SECS/GEM application software which has been in 7x24
use by major equipment providers and manufacturers for several years.</li>

<li>
Supported connection types: Standard HSMS,&nbsp; SECS-I on RS-232, and
SECS-I terminal server connections.</li>

<li>
Transparent conversion of Java Unicode String data to SECS data types including
SECS Variant data, also known as Localized Character Strings.</li>

<li>
Supports remote debugging using the Hume Datahub SDK applications <a href="../man1/dmh_inspect.html">Inspect</a>
and <a href="../man1/hubclient.html">hubclient</a>.</li>

<li>
Compatible with all Java development environments that are compatible with
Sun's standard Java.</li>
</ul>

<hr WIDTH="100%"><a NAME="userguide"></a>
<h2>
<b>User Guide</b></h2>
The SecsHost Java software is provided as the following files:
<ul>
<li>
<b>com/hume/SECS/SecsHost.java, SecsConn.java </b>- the Java source code
for the core logic of SecsHost.&nbsp; The SecsHost class extends the SecsConn
class.&nbsp; The SecsConn class has base logic that is useable for both
host and equipment SECS connections.&nbsp; The SecsHost class has logic
that is specific for host side SECS connections.&nbsp; The core logic manages
and controls a SECS server process which is used for one or more SECS host
connections.&nbsp; We think you will not need to modify the SecsHost source
code for normal usage.&nbsp; By having the source code, you can be more
effective with understanding and debugging the interaction between the
SecsHost software and your application.</li>

<li>
<b>com/hume/SECS/AlarmReportItf.java</b>, <b>EventReportItf.java</b>, <b>SecsMessageReceiveItf.java</b>,
<b>SecsTraceItf.java</b>,
<b>SecsErrorItf.java</b>,
<b>ValueChangeItf.java</b>
- Java source code to define the callback interfaces used by the software
to notify your application of various events such as the receiving of Alarm
and Event reports.</li>

<li>
<b>com/hume/SECS/RcResult.java</b> - defines a simple structure consisting
of an integer return code and a String return value.&nbsp; This data structure
is used for the return value of some methods.</li>

<li>
<b>com/hume/SECS/HubTableModel.java</b> - code that can create an extended
AbstractTableModel for any of the in-memory SQL tables used internally
by the SECS software.&nbsp; This class is used by methods that provide
the Alarm or Variable data as tables.</li>

<li>
<b>com/hume/SECS/Tracewin.java</b> - code that supports showing a Trace
window of the data being exchanged over the SECS interface.&nbsp; A Trace
window is displayed or dismissed using the <a href="#Tracewin">Tracewin(boolean
show)</a> method.</li>

<li>
<b>com/hume/SECS/*.class</b> - compiled java files ready for execution.</li>

<li>
<b>com/hume/DMH/*</b>&nbsp;&nbsp;&nbsp; - files to use the Hume DMH message
system.&nbsp; This software is used by the SecsHost to control a SECS interface
server process.</li>

<li>
<b>com/hume/DMH/TclList.java</b>, <b>TclList.class</b> - the TclList class
provides methods to parse or construct text Strings that are formatted
as lists using white space and braces to delimit list elements..</li>

<li>
<b>JavaHostApp/SuperGUI.java </b>- The main window for the Host Supervisor
application.&nbsp; Class JavaHostApp.SuperGui has a static main method
which is the starting point for our demonstration host application.</li>

<li>
<b>JavaHostApp/HostGui.java, ListDialog.java, ReportEdit.java, ReportModel.java,
SecsHostEditor.java, ServerDebug.java, TableDisplay.java</b>&nbsp;&nbsp;
- Source code for the supervisor application and an example Host GUI which
features dynamic Event Report management, Process Program Upload and Download,
and Alarm and Event Report logging.</li>

<li>
<b>JavaHostApp/*.class</b>&nbsp; - the compiled Supervisor application.</li>

<li>
<b>JavaHostApp/make.bat, run.bat</b>&nbsp;&nbsp;&nbsp; - Batch files to
compile and run the Supervisor application on Windows.</li>

<li>
<b>SecsServer.tcl</b>, <b>SecsHost.tcl</b>, <b>DMH_forward.tcl</b>, <b>merged_schema.tcl</b>,
<b>tclIndex</b>,
<b>make_tclIndex.bat
</b>-
Tcl language files used internally by the SecsHost component to integrate
with the SECS interface server process.&nbsp; A Java developer does not
need to modify these files.&nbsp; Standard SECS and GEM capabilities are
provided in the Java API.</li>

<li>
<b>SecsServer.exe</b> - This single large executable can be separately
downloaded from the Hume website for a simplified runtime deployment.&nbsp;
This file replaces installing the Datahub SDK and the above Tcl files (SecsServer.tcl
etc.).&nbsp;&nbsp; Executables for non-windows platforms can also be made
available.</li>
</ul>
The files are distributed in a .zip archive named <b>JavaHostApp.zip</b>.&nbsp;
If you received the Datahub SDK software on CDROM, this archive is in the
subdirectory
<b>LAN_IMAGE</b>.
<p>In order to run the application, you need to have either the Java 2
SDK software installed, or the Java 2 runtime installed.&nbsp; If you are
not using a development environment provided by a third party, you can
download the Sun J2SE JDK 5.0 software from <a href="http://java.sun.com/">java.sun.com</a>.
<p>Our distribution was developed and tested on up-to-date Windows Professional
versions such as Windows XP Pro or 2000 Pro.&nbsp; The software is designed
for portability to other platforms.&nbsp; Customer who intend on using
other platforms should contact Hume Integration so that their compatibility
and testing requirements are known.
<p><a NAME="Installation"></a>
<h3>
Installation</h3>
Installation consists of extracting files in the <b>JavaHostApp.zip </b>archive
to a directory of your choice.&nbsp; This directory becomes the base of
your CLASSPATH when executing the provided application.. If you have already
installed the Hume Datahub SDK, you should not add the files in the DotNetHostApp.zip
archive to any of the existing Datahub SDK GEM application directories.&nbsp;
The SecsHost software is able to find and use the Datahub SDK GEM directories
without usage of a common directory.
<p>The SecsHost Java software uses the SECS/GEM application files provided
in the Hume Datahub SDK product.&nbsp; The developer needs to install the
Hume Datahub SDK, and specify on the SETUP screen that the GEM/SECS applications
should be installed.&nbsp; The SecsHost software is able to find the Datahub
SDK files using the environment variable <b>DMH_BIN</b> which is set when
the Datahub SDK is installed.
<p>The situation is simpler for a runtime deployment of your host applications.&nbsp;
Instead of installing the Datahub SDK and copying the above list of Tcl
language files, you can simply deploy a single file executable, <b>SecsServer.exe</b>.&nbsp;
This file is provided by Hume Integration for the usual case of using the
as-provided SDK files.&nbsp; If you have customized the SDK files, you
are able to create a custom version of <b>SecsServer.exe</b> using a build
script.&nbsp; We encourage you to use the full SDK during development so
that you have the toolset documentation, the debugging tools, and you are
able to view the SDK GEM application source code.&nbsp; When you are ready
for deployment, you can download the <b>SecsServer.zip</b> archive from
the Hume customer support website to obtain the <b>SecsServer.exe</b> program
and its build script.
<h4>
Environment Variable&nbsp;<a NAME="DMH_DOTNET_TCLDIR"></a>DMH_JAVA_TCLDIR</h4>
When the SecsHost software is initialized, it needs to find the <b>SecsServer.tcl</b>
file and the other associated support files in the same directory as the
<b>SecsServer.tcl</b>
file.&nbsp; The logic looks for these files in the directory pointed to
by the environment variable, <b>DMH_JAVA_TCLDIR</b>.&nbsp; If this environment
variable is not found, the software tries to use the environment variable
<b>DMH_DOTNET_TCLDIR</b>,
and, failing that, the present working directory is checked.&nbsp; You
should set the environment variable <b>DMH_JAVA_TCLDIR</b> to the directory
path containing the files.&nbsp; We suggest using slash directory separators.&nbsp;
Environment variables are set by navigating from the Start menu - Start/Settings/Control
Panel/System/Advanced/Environment Variables.&nbsp; An example value is:
<pre>DMH_JAVA_TCLDIR=C:/hume/JavaHostApp</pre>
In a runtime deployment, the <b>SecsServer.exe</b> file is placed in the
same directory instead of the <b>SecsServer.tcl</b> file and the associated
support files.&nbsp; The same directory search order is used.
<br><a NAME="Development"></a>
<h3>
Development</h3>
To start using the SecsHost class with an existing project, you place the
<b>com/hume/SECS/*</b>
files and the <b>com/hume/DMH/*</b> in your CLASSPATH base directory or
modify your CLASSPATH to include the location of the
<b>com</b> directory.
<p>Coding is easier if you add the statement <b>import com.hume.SECS.*;</b>
to the import statements of your application source code.&nbsp; By doing
this, the package name, <b>com.hume.SECS</b>, can be omitted from name
references.&nbsp; You will typically want to add the statement&nbsp; <b>import
com.hume.DMH.TclList;</b> to make it convenient to use the TclList class.
<p>Your primary focus as a developer is using the class <b>SecsHost</b>.&nbsp;
This class implements public methods to send and receive SECS messages,
and manage a host SECS interface.
<p>Here is the general flow of using and configuring the SecsHost:
<ol>
<li>
Run the supervisor application and take a look at the SecsHostEditor dialog
in action.&nbsp; You probably want to have this dialog in your application
to let your users easily configure Host interfaces.&nbsp; Run the application
against real equipment, explore the example GUI,&nbsp; and develop confidence
that the core logic will work well in your custom application.</li>

<li>
Make a decision as to whether you will modify the provided files for your
own requirements, or create your own application, and include selected
features of the Hume application by adding selected files to your project.&nbsp;
If you move a Java class file to your own directory, you typically edit
the <b>package JavaHostApp; </b>statement near the top of the file to indicate
your own directory/package name.</li>

<li>
You can use the SecsHost class with or without user interface windows being
present.&nbsp; You can code setting the event callbacks to your application
object(s) late in your constructor code, and remove these event handlers
in a finalize method.</li>

<li>
Construct a <a href="#SecsHost">SecsHost</a> instance.&nbsp;&nbsp; At runtime,
constructing the instance causes the child SECS server process to be started.&nbsp;
The Supervisor application uses a constructor that passes many of the configurable
property values as String array arguments.&nbsp; There are also simpler
constructors where you create your instance, and subsequently use property
assignment statements to configure the instance.</li>

<li>
Code your callbacks.&nbsp; The reception of Event Reports and Alarm Reports
are dispatched into your application using callbacks.&nbsp; In general
the callbacks come into your application from different threads than the
thread that created your window controls.&nbsp; In general, the window
controls are not designed to be used by different threads than the main
GUI thread of your application.&nbsp; It is proper and documented that
the JComponent.setText() and JTextArea.append() methods are callable by
different threads.&nbsp; For other methods that affect the GUI, use the
SwingUtilities.InvokeLater() method as the example application does to
pass work to the main GUI thread.&nbsp; Use threadsafe techniques such
as the synchronized statement to lock data structures before reading or
writing to them from different threads.&nbsp; Here is an example statement
to execute the GuiXXXUpdate() method in the main GUI thread:</li>

<pre>SwingUtilities.invokeLater(new Runnable() {public void run() { GuiXXXUpdate(); }})</pre>

<li>
Use the <a href="#MessageTypeAdd">MessageTypeAdd</a> method to register
callbacks for SECS message types that you desire to handle in your application.&nbsp;
Getting communication established and capturing alarms and event reports
is already provided for.</li>

<li>
Change property values to your liking.</li>

<li>
Call <a href="#CommEnable">CommEnable</a> after you have the proper configuration
in place to enable communication with the equipment.</li>

<li>
If you update any of the connection properties after communication is enabled,
call <a href="#ConnectTypeSet">ConnectTypeSet</a> or one of the ConnectType&lt;Type>
methods.&nbsp; The method call will disable communication so you will need
to call CommEnable again.&nbsp; Connection properties include the ConnectionType,
BAUD, HSMS_Host, HSMS_Passive, HSMS_Port, and Serial_Port.</li>

<li>
Non-connection properties such as the Device ID, timer values, data types,
etc. can be updated at any time without disrupting communication.&nbsp;
The Hume software does feature adaptive logic to automatically correct
the Device ID, and to learn the data types used by the equipment.&nbsp;
Your configuration effort is substantially reduced compared to other products.</li>

<li>
Automatic initialization occurs by default whenever the equipment transitions
to an online control state.&nbsp; The default behavior is to attempt to
discover the equipment's alarms, variables, and events, and setup the configured
event reports, managed alarms, managed equipment constants, and synchronize
the clock.&nbsp; This behavior is controlled by setting the appropriate
property values and/or configuring the managed reports, alarms, or constants.</li>

<li>
Call <a href="#CommDisable">CommDisable</a> to disable host communications.&nbsp;
It is called automatically by the SecsHost <a href="#delete">delete</a>
and <b>finalize</b> methods.</li>
</ol>

<h4>
<a NAME="TSN"></a>Tcl Secs Notation, TSN</h4>
SECS messages are passed into and out of the application as formatted strings.&nbsp;
The format is similar to the notation in the SEMI documents except that
the list formatting conventions of the Tcl programming language are followed.&nbsp;
The TclList class provides methods to parse and construct lists.&nbsp;
In general, curly braces, { }, are used to surround list elements which
contain white space.&nbsp; By using the API calls to append list elements
or join strings as list elements, you can be sure that your strings are
properly formatted, and you do not need to manually balance opening and
closing curly braces.&nbsp; Developers who have worked with both XML and
TSN list notation have found that the TSN notation is more compact, closer
to the SEMI documentation, and easier for a human to scan and validate
when reviewing diagnostic output.
<p>As general guidance, when you expect a string value, you will get a
two element list, of the form "A:n {this is n chars of text}".&nbsp; If
a string value does not have imbedded white space, it may be formatted
without braces, such as "A:8 OneToken".&nbsp; When you use the <a href="HISjava.html#TclListRef">TclList.ListElement</a>
or split methods to parse the text, they take care of parsing and removing
surrounding braces for you.&nbsp; If an empty string is sent, you will
see a one element list, A:0.&nbsp; SECS has the notion of array data -
0 or more values of a given type.&nbsp; When you expect to receive a single
numeric value, you receive a two element list, with the type code as the
first element, such as "U4:1 290".&nbsp; You can also receive an empty
array "U4:0" or an array with more than one value as in "U4:3 0 1 2".&nbsp;
Binary data values are formatted using C-language hexadecimal integer notation,
for example, "B:3 0x00 0x01 0x02".&nbsp; You can use the <a href="#BinToInt">BinToInt</a>
method to convert these values to integer values.&nbsp; With received data,
the type code has a length value appended to it after a colon.&nbsp; With
data that you format for sending, the length information is optional, the
data is parsed to determine the length.&nbsp; See the <a href="../mann/TSN.html">TSN.html</a>
document for more details.
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td><b>Semi Octal type code</b></td>

<td><b>TSN type code</b></td>

<td><b>Meaning &amp; Examples</b></td>
</tr>

<tr>
<td>00</td>

<td>L</td>

<td>List,&nbsp; L, L:0,&nbsp;&nbsp; "L {A {atc 100}} {A 1.0.0}", "L:2 {L:2
{U4 200} {U4 210}} {B 0}"</td>
</tr>

<tr>
<td>10</td>

<td>B</td>

<td>binary - unsigned 8 bit data, "B 0", "B 1 2 3"</td>
</tr>

<tr>
<td>11</td>

<td>TF&nbsp;</td>

<td>boolean data, TSN type codes BL or BOOLEAN are also accepted as input,
"TF 1"</td>
</tr>

<tr>
<td>20</td>

<td>A</td>

<td>Character string data.&nbsp; Traditionally this has meant printable
ASCII characters but some implementations are sending any 8 bit characters
including nulls using this type.
<br>"A {hello world}", "A hello"</td>
</tr>

<tr>
<td>21</td>

<td>J</td>

<td>Japan International Standard (JIS-8) encoded text.&nbsp; This format
is not commonly used or supported because in the past the SEMI standards
have failed to identify specific reference documents.</td>
</tr>

<tr>
<td>22</td>

<td>V1..VE</td>

<td>Variant data, also known as Localized Character Strings.&nbsp; Your
.NET unicode text is automatically converted into the chosen encoding.&nbsp;
V1 is for Unicode 2.0, V2 is for UTF-8 encoding.&nbsp; See the <a href="../mann/TSN.html">TSN.html</a>
document for more details. "V1 {sent as Unicode}"</td>
</tr>

<tr>
<td>30</td>

<td>I8</td>

<td>8-byte signed integer, use hex notation for the value, "I8 0x123456789abcdf01"</td>
</tr>

<tr>
<td>31</td>

<td>I1</td>

<td>1-byte signed integer, "I1 -3"</td>
</tr>

<tr>
<td>32</td>

<td>I2</td>

<td>2-byte signed integer, "I2 99",&nbsp; "I2 15 -7 99"</td>
</tr>

<tr>
<td>34</td>

<td>I4</td>

<td>4-byte integer signed, "I4 -5"</td>
</tr>

<tr>
<td>40</td>

<td>F8</td>

<td>8-byte floating point, "F8 6.02e23", "F8 0.1"</td>
</tr>

<tr>
<td>44</td>

<td>F4</td>

<td>4-byte floating point, "F4 1.0"</td>
</tr>

<tr>
<td>50</td>

<td>U8</td>

<td>8-byte unsigned integer, use hex notation for the value, "U8 0x7fffffffffffffff"</td>
</tr>

<tr>
<td>51</td>

<td>U1</td>

<td>1-byte unsigned integer, "U1 0"</td>
</tr>

<tr>
<td>52</td>

<td>U2</td>

<td>2-byte unsigned integer, "U2 512"</td>
</tr>

<tr>
<td>54</td>

<td>U4</td>

<td>4-byte unsigned integer, "U2 979"</td>
</tr>
</table>

<br>&nbsp;
<h3>
<a NAME="BuiltinSecs"></a>Built-in SECS Data, Message Handling, Events</h3>
The SecsHost class has built-in logic to handle many of the standard SECS
message types.&nbsp; You do not have to code or provide for complex GEM
capabilities such as configuring and receiving dynamic event reports, or
managing the equipment communication and state models. See the table at
the end of this document for more detail on the <a href="#BuiltInMessages">built-in
message types</a>.&nbsp; If you are not familiar with the Hume host SECS
software, you may wonder if the API is missing methods, for example to
add variable definitions or event definitions.&nbsp; In most cases, the
software automatically determines the Status Variables and Equipment Constants
by querying the equipment.&nbsp; The SECS standards lack support for directly
determining types of events.&nbsp; The software listens to the events reported
by the equipment, and adds them to its table of known event types.&nbsp;
If new Status Variables are seen in an Event Report, the software automatically
saves configuration records for the newly discovered variables.&nbsp; So
instead of laboriously configuring event and variables from some inaccurate
manual, you simply deploy the software, and run the equipment to accumulate
configuration information.&nbsp; Discrete Variable Event Reports (S6F3)
and Discrete Variables are another area where the standards are deficient,
and do not provide for programmatic introspection.&nbsp; The built-in logic
saves configuration information on the format of Discrete Event Reports
and their included variables as they are encountered.&nbsp; The Supervisor
application has the ability to copy the accumulated configuration information
determined from an equipment interface to new names.&nbsp; This provides
the ability to clone working interfaces for use with multiple instances
of similar equipment in your factory.&nbsp; In the rare circumstances where
you want to manually make configuration changes, you can use the
<a href="#DebugTableWindow">DebugTableWindow</a>
method to bring up a GUI that enables you to interactively examine, edit,
and save the SECS Server configuration tables.
<br>&nbsp;
<h3>
<a NAME="CustomSecs"></a>Custom SECS Message Handling</h3>
Use the method <a href="#MessageTypeAdd">MessageTypeAdd</a> to have SECS
messages routed to your callback code for custom handling.&nbsp; You can
use this method to provide handling logic for new message types, and you
can also use this method to replace the built-in handling of selected message
types.&nbsp; Your callback executes in a different thread than your main
Windows event dispatching thread so use thread safe techniques for accessing
application data or GUI controls.&nbsp; The positive side of using a different
thread is that your handling logic can be coded to use simple synchronous
wait-for-reply SECS conversations without locking up your GUI.&nbsp; For
example, your callback can use <a href="#SendReply">SendReply</a> to respond
to the inbound message, and then initiate a synchronous conversation using
<a href="#SendSecsMsg">SendSecsMsg</a>
and specifying that the logic should wait for the reply message.&nbsp;
While your handling code is progressing through the synchronous conversation,
other software in your application can be handling event reports, or alarms
or managing other interfaces.&nbsp; Because of the internal design of the
SecsHost, these other method calls are not blocked or delayed because your
handler is busy with a conversation.
<p>Logic in your application can send SECS messages or initiate conversations
using the <a href="#SendSecsMsg">SendSecsMsg</a> method.&nbsp; For HSMS
communication,&nbsp; if you are sending a message and not waiting for the
reply, SendSecsMsg can be used from your GUI code without fear of making
your GUI unresponsive.&nbsp; In some cases you need to wait for a SECS
reply message.&nbsp; If you are using HSMS, under most circumstances, the
reply or failure to reply will be resolved within a few seconds.&nbsp;&nbsp;
The unusual circumstance is that you still have a TCP/IP connection so
your send is successful, but then there is no reply, and you wait the full
T3 period.&nbsp; If the risk of this delay is not acceptable, you can create
a new thread, and use the new thread to perform the SECS conversation where
you need to wait for the reply message.
<p>For SECS-I serial communication, timing is somewhat different.&nbsp;
With SECS-I there is no underlying TCP/IP connection that can signal the
application when it is broken.&nbsp; So there is a higher risk of your
sending thread being in an unresponsive wait to determine if a send is
successful, and then in a longer wait to obtain the reply.&nbsp; So you
may want to use a separate thread than your GUI thread to send SECS messages
or conduct send-and-reply conversations.
<p><a NAME="Miscellaneous"></a>
<h4>
Miscellaneous Notes</h4>
You can use multiple instances of the SecsHost class to provide more than
one SECS interface.&nbsp; Each interface can have its own custom handling
of message types.
<p>
<hr WIDTH="100%"><a NAME="Reference"></a>
<h2>
SecsHost API Reference</h2>

<p><br><a NAME="Properties"></a>
<table BORDER WIDTH="100%" >
<caption>&nbsp;<b>SecsHost Properties</b></caption>

<tr>
<td><b>Property Access</b></td>

<td><b>Description</b><a NAME="autoInit"></a></td>
</tr>

<tr>
<td>boolean get<b>AutoInit</b>()
<br>void set<b>AutoInit</b>(boolean autoInit)</td>

<td>Configures whether the interface should execute initialization logic
automatically when an online control state is established or re-established.&nbsp;
Since the actions performed during initialization are configurable using
other properties, most application will configure the individual actions,
and leave this overall flag at its default value of true.<a NAME="autoStart"></a></td>
</tr>

<tr>
<td>boolean get<b>AutoStart</b>()
<br>void set<b>AutoStart</b>(boolean autoStart)</td>

<td>Configures whether the interface should be started automatically with
communication enabled.&nbsp; This property is used if the interface is
created using the constructor method that accepts the property values as
string array arguments.&nbsp; The default value is false.<a NAME="BAUD"></a></td>
</tr>

<tr>
<td>int get<b>BAUD</b>()
<br>void set<b>BAUD</b>(int baudrate)</td>

<td>If you are using the SECS-I, RS-232 connection type, this property
sets the baudrate of the serial port.&nbsp; The default value is 9600.&nbsp;
If communication is already enabled, you have to make a ConnectTypeSerial()
or ConnectTypeSet() call to use a changed value.<a NAME="CEID_OFFLINE"></a></td>
</tr>

<tr>
<td>String get<b>CEID_OFFLINE</b>()&nbsp;
<br>void set<b>CEID_OFFLINE</b>(String ceid)</td>

<td>The event report identifier (CEID) that signifies that the equipment
is transitioning to an off-line control state.&nbsp; This value is used
by the logic that tracks the equipment control state.&nbsp; The default
value is "4000".<a NAME="clientData"></a></td>
</tr>

<tr>
<td>public Object <b>clientData</b></td>

<td>The SecsHost class has a public clientData value that the example HostGui
class uses.&nbsp; If you replace the HostGui class, you can use this as
a pointer to your own application object.&nbsp;<a NAME="CommState"></a></td>
</tr>

<tr>
<td>String get<b>CommState</b>()</td>

<td>Read-only value of your GEM Communication State.&nbsp; Possible values
are <b>DISABLED</b>, <b>ENABLED {NOT COMMUNICATING}</b>, and <b>COMMUNICATING</b>.&nbsp;&nbsp;
The <a href="#StateChange">StateChange</a> event is used to obtain asynchronous
notification of this property value change.<a NAME="ConnectionType"></a></td>
</tr>

<tr>
<td>int get<b>ConnectionType</b>()&nbsp;
<br>void set<b>ConnectionType</b>(int v) throws Exception</td>

<td>Configures the basic choice of connection type.&nbsp;&nbsp; The value
0 means SECS-I RS-232, 1 means SECS-I terminal server, 1993 is for non-standard
Draft HSMS, 1995 is for standard HSMS.&nbsp; The default is 1995.&nbsp;
Java does not support enum data types.&nbsp; An exception is thrown if
an inappropriate value is set.<a NAME="ControlState"></a></td>
</tr>

<tr>
<td>String get<b>ControlState</b>()</td>

<td>A read-only value of the GEM Control State.&nbsp; Possible values are
<b>OFF-LINE</b>
and <b>ON-LINE</b>.<a NAME="DEVID"></a></td>
</tr>

<tr>
<td>int get<b>DEVID</b>()
<br>void set<b>DEVID</b>(int DEVID) throws Exception</td>

<td>The SECS Device ID.&nbsp; An identifier imbedded in SECS header data
usually left at the default of 0.&nbsp; The SecsHost software has adaptive
logic to correct an improper value.&nbsp; Settable range is 0..32767.<a NAME="dmh"></a></td>
</tr>

<tr>
<td>static DMHClient SecsConn.<b>dmh</b></td>

<td>SecsHost instances use a shared connection to the DMH message system
in order to communicate with the SECS server process.&nbsp; The connection
instance, dmh, is public in case you want to access it in your application.<a NAME="DMHGroupName"></a></td>
</tr>

<tr>
<td>static String SecsConn.<b>DmhGroupName</b></td>

<td>The DMH message system groupname used by the SECS server.&nbsp; The
same groupname should be specified to the constructor of every SecsHost
instance in the application in order to share the same SECS server process.<a NAME="HSMS_Host"></a></td>
</tr>

<tr>
<td>String get<b>HSMS_Host</b>()&nbsp;
<br>void set<b>HSMS_Host</b>(String host_or_ip_addr)</td>

<td>For an active HSMS connection, specifies the TCP/IP hostname or IP
address of the Host computer.&nbsp; The default value is "localhost".<a NAME="HSMS_Passive"></a></td>
</tr>

<tr>
<td>boolean get<b>HSMS_Passive</b>()&nbsp;
<br>void set<b>HSMS_Passive</b>(boolean passive)</td>

<td>For an HSMS connection, whether the SecsHost plays the passive, TCP/IP
server role.&nbsp; The default value is false since the usual role for
the host is non-passive.&nbsp;<a NAME="HSMS_Port"></a></td>
</tr>

<tr>
<td>int get<b>HSMS_Port</b>()&nbsp;
<br>void set<b>HSMS_Port</b>(int p)</td>

<td>For an HSMS connection, the TCP/IP socket port number.&nbsp; Defaults
to 5555.<a NAME="Instances"></a></td>
</tr>

<tr>
<td>public static java.util.Hashtable&lt;String,SecsHost> <b>instances</b></td>

<td>There is a hashtable <b>SecsHost.instances</b> which is used to keep
track of the existing SecsHost instances.&nbsp; The key values are the
Name properties.<a NAME="MULT"></a></td>
</tr>

<tr>
<td>boolean <b>getMULT</b>()&nbsp;
<br>void <b>setMULT</b>(boolean MULT)</td>

<td>A flag used only for SECS-I to specify whether the equipment can handle
owing more than one reply at a time.&nbsp; The default value is true.<a NAME="Name"></a></td>
</tr>

<tr>
<td>String get<b>Name</b>()</td>

<td>The SecsHost name passed to the constructor and used in the SECS server
process as a Tcl command name, a global array name, and an identifier in
SQL table records.<a NAME="RecipeDirectory"></a></td>
</tr>

<tr>
<td>String get<b>ProcessProgramDir</b>()
<br>void set<b>ProcessProgramDir</b>(String path)</td>

<td>A pathname to the file system directory where Process Program files
are located.&nbsp; The default value is the relative subdirectory&nbsp;
"&lt;Name>_recipes" of the directory where the SECS server is executing.&nbsp;
Note that by default, each interface has its own directory for Process
Program files.&nbsp; Reading this property returns the absolute directory
path to the process program directory.&nbsp; The value can be set using
a relative or absolute pathname.<a NAME="RTY"></a></td>
</tr>

<tr>
<td>int get<b>RTY</b>()
<br>void set<b>RTY</b>(int v) throws Exception</td>

<td>SECS-I maximum send retry, range 0..31, default 3<a NAME="SerialPort"></a></td>
</tr>

<tr>
<td>String get<b>SerialPort</b>()&nbsp;
<br>void set<b>SerialPort</b>(String SerialPort)</td>

<td>For a SECS-I connection, the serial port device such as "COM1".&nbsp;
The default value is "COM1" on all platforms.&nbsp; POSIX platforms typically
need a device name such as "/dev/ttyS0".&nbsp;<a NAME="SpoolInit"></a></td>
</tr>

<tr>
<td>String get<b>SpoolInit</b>()
<br>void set<b>SpoolInit</b>(String v) throws Exception</td>

<td>Controls initialization of the equipment spooling of messages.&nbsp;
The allowed values are <b>PURGE</b>, <b>UNLOAD</b>, or <b>IGNORE</b>.&nbsp;
The default value is <b>UNLOAD</b>.<a NAME="State"></a></td>
</tr>

<tr>
<td>String get<b>State</b>()</td>

<td>A read-only value of the low-level connection state.&nbsp; Possible
values include OFFLINE, LISTENING, and COMMUNICATING.&nbsp; You will see
the OFFLINE state if the connection to the host is broken, or in the case
of SECS-I implicitly broken by a conversation timeout.&nbsp; The <a href="#StateChange">StateChange</a>
event is used to obtain asynchronous notification of this property value
change.<a NAME="T1"></a></td>
</tr>

<tr>
<td>int get<b>T1</b>()
<br>void set<b>T1</b>(int v) throws Exception</td>

<td>SECS-I Inter-Character Timeout in milliseconds, range 100..10000, default
500<a NAME="T2"></a></td>
</tr>

<tr>
<td>int get<b>T2</b>()
<br>void set<b>T2</b>(int v) throws Exception</td>

<td>SECS-I Protocol Timeout in milliseconds, range 200..25000, default
10000<a NAME="T3"></a></td>
</tr>

<tr>
<td>int get<b>T3</b>()
<br>void set<b>T3</b>(int v) throws Exception</td>

<td>SECS Reply Timeout in milliseconds, range 1000..120000, default 45000<a NAME="T4"></a></td>
</tr>

<tr>
<td>int get<b>T4</b>()
<br>void set<b>T4</b>(int v) throws Exception</td>

<td>SECS-I Inter-Block Timeout in milliseconds, range 1000..120000, default
45000<a NAME="T5"></a></td>
</tr>

<tr>
<td>int get<b>T5</b>()
<br>void set<b>T5</b>(int v) throws Exception</td>

<td>HSMS Connect Separation Timeout - the delay between re-connection attempts
in milliseconds, range 1000..240000, default 10000<a NAME="T6"></a></td>
</tr>

<tr>
<td>int get<b>T6</b>()
<br>void set<b>T6</b>(int v) throws Exception</td>

<td>HSMS Control Transaction Timeout in milliseconds, range 1000..240000,
default 5000<a NAME="T7"></a></td>
</tr>

<tr>
<td>int get<b>T7</b>()
<br>void set<b>T7</b>(int v) throws Exception</td>

<td>HSMS Not Selected Timeout in milliseconds, range 1000..24000, default
10000<a NAME="T8"></a></td>
</tr>

<tr>
<td>int get<b>T8</b>()
<br>void set<b>T8</b>(int v)</td>

<td>HSMS Network Intercharacter Timeout, default value 5000.&nbsp; This
value is not used.<a NAME="TRACE"></a></td>
</tr>

<tr>
<td>&nbsp;int get<b>TRACE</b>()&nbsp;
<br>void set<b>TRACE</b>(int TRACE)</td>

<td>Used as a bitfield to control diagnostic trace information for SECS
port activity which is passed to the application in the SecsTrace event.&nbsp;
By setting specific bits, the corresponding output is turned on.&nbsp;
<p>General Tracing: (TraceType = trace)&nbsp;
<br>Bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Output Description&nbsp;
<br>0x0001&nbsp;&nbsp;&nbsp;&nbsp; Read and write calls
<br>0x0002&nbsp;&nbsp;&nbsp;&nbsp; state changes including connection attempts&nbsp;
<p>Receive Tracing: (TraceType = rtrace)&nbsp;
<br>Bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description for Received
Messages&nbsp;
<br>0x0100&nbsp;&nbsp;&nbsp;&nbsp; Header binary dump&nbsp;
<br>0x0200&nbsp;&nbsp;&nbsp;&nbsp; Header interpretation&nbsp;
<br>0x0400&nbsp;&nbsp;&nbsp;&nbsp; Stream and Function description
<br>0x0800&nbsp;&nbsp;&nbsp;&nbsp; Message data binary dump&nbsp;
<br>0x0004&nbsp;&nbsp;&nbsp;&nbsp; The Message as TSN&nbsp;
<p>Send Tracing: (TraceType = strace)&nbsp;
<br>Bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description for Sent
Messages&nbsp;
<br>0x1000&nbsp;&nbsp;&nbsp;&nbsp; Header binary dump
<br>0x2000&nbsp;&nbsp;&nbsp;&nbsp; Header interpretation
<br>0x4000&nbsp;&nbsp;&nbsp;&nbsp; Stream and Function description
<br>0x8000&nbsp;&nbsp;&nbsp;&nbsp; Message data binary dump
<br>0x0008&nbsp;&nbsp;&nbsp;&nbsp; The Message as TSN&nbsp;<a NAME="tDATAID"></a></td>
</tr>

<tr>
<td>String get<b>tDATAID</b>()&nbsp;
<br>void set<b>tDATAID</b>(String tsntype) throws Exception</td>

<td>The SECS TSN type code for DATAID items.&nbsp; Defaults to U4.<a NAME="tDATALENGTH"></a></td>
</tr>

<tr>
<td>String get<b>tDATALENGTH</b>()
<br>void set<b>tDATALENGTH</b>(String t) throws Exception</td>

<td>The SECS TSN type code for DATALENGTH items.&nbsp; Defaults to U4.<a NAME="tLENGTH"></a></td>
</tr>

<tr>
<td>String get<b>tLENGTH</b>()&nbsp;
<br>void set<b>tLENGTH</b>(String tsntype) throws Exception</td>

<td>The SECS TSN type code for LENGTH items.&nbsp; Defaults to U4.<a NAME="tPPID"></a></td>
</tr>

<tr>
<td>String get<b>tPPID</b>()&nbsp;
<br>void set<b>tPPID</b>(String tsntype) throws Exception&nbsp;</td>

<td>The SECS TSN type code for PPID items.&nbsp; Defaults to A.<a NAME="tREPGSZ"></a></td>
</tr>

<tr>
<td>String get<b>tREPGSZ</b>()&nbsp;
<br>void set<b>tREPGSZ</b>(String tsntype) throws Exception</td>

<td>The SECS TSN type code for REPGSZ items.&nbsp; Defaults to U4.<a NAME="tRPTID"></a></td>
</tr>

<tr>
<td>String get<b>tRPTID</b>()&nbsp;
<br>void set<b>tRPTID</b>(String tsntype) throws Exception</td>

<td>The SECS TSN type code for RPTID items.&nbsp; Defaults to U4.<a NAME="tTOTSMP"></a></td>
</tr>

<tr>
<td>String get<b>tTOTSMP</b>()&nbsp;
<br>void set<b>tTOTSMP</b>(String tsntype) throws Exception</td>

<td>The SECS TSN type code for TOTSMP items.&nbsp; Defaults to U4.<a NAME="tTRID"></a></td>
</tr>

<tr>
<td>String get<b>tTRID</b>()&nbsp;
<br>void set<b>tTRID</b>(String tsntype) throws Exception</td>

<td>The SECS TSN type code for TRID items.&nbsp; Defaults to A.<a NAME="useS1F3"></a></td>
</tr>

<tr>
<td>boolean get<b>useS1F3</b>()&nbsp;
<br>void set<b>useS1F3</b>(boolean b)</td>

<td>Whether to use S1F3 during initialization to query Status Variable
values. After initialization, subsequent value changes are ordinarily known
to the host by being received in event reports. The default value is true.<a NAME="useS1F11"></a></td>
</tr>

<tr>
<td>boolean get<b>useS1F11</b>()&nbsp;
<br>void set<b>useS1F11</b>(boolean b)</td>

<td>Whether to use S1F11 during initialization to determine Status Variables.&nbsp;
Since the set of variables does not ordinarily change, and can be loaded
from saved data, the initialization query can be disabled if it is time
consuming.&nbsp; The default value is true.<a NAME="useS1F13"></a></td>
</tr>

<tr>
<td>boolean get<b>useS1F13</b>()&nbsp;
<br>void set<b>useS1F13</b>(boolean b)</td>

<td>Whether to use S1F13 during initialization to establish communications.&nbsp;
The default value is true, and is almost always appropriate since the logic
will use S1F1 if S1F13 is rejected. However, there is some defective equipment
in use that gets confused if it receives S1F13.<a NAME="useS1F17"></a></td>
</tr>

<tr>
<td>boolean get<b>useS1F17</b>()&nbsp;
<br>void set<b>useS1F17</b>(boolean b)</td>

<td>Whether to use S1F17 during initialization to request the Online Control
State.&nbsp; The default value is true.<a NAME="useS2F13"></a></td>
</tr>

<tr>
<td>boolean get<b>useS2F13</b>()&nbsp;
<br>void set<b>useS2F13</b>(boolean b)</td>

<td>Whether to use S2F13 during initialization to query Equipment Constant
values.&nbsp; The default value is true.<a NAME="useS2F29"></a></td>
</tr>

<tr>
<td>boolean get<b>useS2F29</b>()&nbsp;
<br>void set<b>useS2F29</b>(boolean b)</td>

<td>Whether to use S2F29 during initialization to determine Equipment Constants.&nbsp;
The default value is true.&nbsp; Since the set of constants does not ordinarily
change, and can be loaded from saved data, the initialization query can
be disabled if it is time consuming.<a NAME="useS2F31"></a></td>
</tr>

<tr>
<td>boolean get<b>useS2F31</b>()
<br>void set<b>useS2F31</b>(boolean b)</td>

<td>Whether to use S2F31 during initialization to synchronize the equipment
clock.&nbsp; The default value is true.<a NAME="useS5F5"></a></td>
</tr>

<tr>
<td>boolean get<b>useS5F5</b>()&nbsp;
<br>void set<b>useS5F5</b>(boolean b)</td>

<td>Whether to use S5F5 during initialization to determine Alarm types.&nbsp;
The default value is true.&nbsp; This query is not used during every initialization.
It is only used if the logic sees an enabled alarm type that it does not
already know about.<a NAME="useS5F7"></a></td>
</tr>

<tr>
<td>boolean get<b>useS5F7</b>()&nbsp;
<br>void set<b>useS5F7</b>(boolean b)</td>

<td>Whether to use S5F7 during initialization to determine enabled Alarms.&nbsp;
The default value is true.</td>
</tr>
</table>

<p><a NAME="ControlEvents"></a>
<br>&nbsp;
<table BORDER WIDTH="100%" >
<caption><b>SecsHost Events</b></caption>

<tr>
<td><b>Event Handler and Argument Data&nbsp;</b></td>

<td><b>Description</b></td>
</tr>

<tr>
<td></td>

<td></td>
</tr>

<tr>
<td>All event handlers - NOTES
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>&nbsp;</td>

<td>Java supports callback functions through the use of <b>interface</b>
declarations.&nbsp; You declare a class as implementing a particular interface
type.&nbsp; Then you are able to pass references to instances as arguments
to indicate the object which should be notified by the callback.&nbsp;
If this is new to you, take a close look at our example application code.
<p>The Interfaces we use are declared in separate java files, each named
for the Interface type name, in the com.hume.SECS directory.&nbsp; We have
adopted the convention of appending <b>Itf </b>to interface type names
to make it easy to identify which files contain interface declarations.&nbsp;
<p>Unless noted otherwise, you should assume that the callback method is
executed by a different thread than the main GUI thread of your application.&nbsp;
See the notes on threading in the Development section above.&nbsp;
<p>When the event happens, your callback interface method is called.&nbsp;<a NAME="AlarmReport"></a></td>
</tr>

<tr>
<td>
<br>public interface <b>AlarmReportItf </b>{
<br>&nbsp;&nbsp; public void <b>AlarmReport</b>(SecsHost sh, String alid,
boolean is_set, String altx, String clock);
<br>&nbsp;&nbsp; }
<p>public AlarmReportItf <b>AlarmReportHandler</b>;
<p>&nbsp;</td>

<td>Set the <b>AlarmReportHandler</b> variable value to your application
object to receive Alarm Reports.
<p>This event is raised upon receiving an S5F1 alarm report message.&nbsp;
Modern GEM equipment posts events for alarm set and alarm clear conditions
so the idea of alarms as distinct from events is becoming obsolete.<a NAME="EventReport"></a></td>
</tr>

<tr>
<td>public interface <b>EventReportItf </b>{
<br>&nbsp;&nbsp; public void <b>EventReport</b>(SecsHost sh, String CEID,
String EventID, java.util.Hashtable&lt;String,String> dataItems);
<br>&nbsp;&nbsp; }
<p>public EventReportItf <b>EventReportHandler</b>=null;</td>

<td>Set the <b>EventReportHandler</b> variable value to your application
object to receive Event Reports based on SECS messages S6F11, S6F13, Trace
Reports (S6F1), and various events synthesized by the software such as
COM_DISABLE.
<p>Event reports that are received by the SecsHost software do not become
events in your application unless you configure the corresponding event
report using the <a href="#EventReportDefine">EventReportDefine</a> method.&nbsp;
Events can be given meaningful names and descriptions using the <a href="#EventUpdate">EventUpdate</a>
method.&nbsp; In the event report data, you receive both the underlying
event identifier sent by the equipment, the CEID value, and the identifier
for the event you have optionally customized, the EventID.&nbsp;&nbsp;
The data of the event report is passed as a Hashtable instance which contains
variable name and value pairs.&nbsp; The variable names are from the VFEIname
column of the SECS server ei_variable table.&nbsp; You are able to create
your own variable names using the <a href="#VariableUpdate">VariableUpdate</a>
method.&nbsp; Using a host given name for variables allows the logic to
ensure that each name is unique, and provides for uniform naming across
equipment instances.&nbsp; The ability to rename events and variables is
referred to as Virtual Reporting.</td>
</tr>

<tr>
<td>public interface <b>SecsMessageReceiveItf </b>{
<br>&nbsp;&nbsp; public void <b>SecsMessageReceive</b>(SecsConn sp,&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp; int stream, int func, boolean sendReply, int
transactionID,&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp; String data, String header);
<br>&nbsp;&nbsp; }</td>

<td>See the <a href="#MessageTypeAdd">MessageTypeAdd</a> method described
in the next section to see how to receive SECS messages in your application.<a NAME="SecsTrace"></a></td>
</tr>

<tr>
<td>public interface <b>SecsTraceItf</b> {
<br>&nbsp;&nbsp; public void <b>SecsTrace</b>(SecsConn sp, String traceType,
String text);
<br>&nbsp;&nbsp; }
<p>SecsTraceItf <b>OnSecsTrace</b>(SecsTraceItf handler)</td>

<td>This event provides you with the detailed information of SECS message
traffic that is viewed in the SECS Trace window - see the <a href="#Tracewin">Tracewin</a>
method.&nbsp; The flow of&nbsp; information is controlled by setting the
TRACE property.&nbsp; You can cast the SecsConn argument to a SecsHost
if you want to use a method that is defined by the SecsHost class and not
the SecsConn base class.
<p>Use the <b>OnSecsTrace</b>() method to set your own handler.&nbsp; The
return value is the previous handler which you are replacing.<a NAME="ServerError"></a></td>
</tr>

<tr>
<td>public interface <b>ServerErrorItf </b>{
<br>&nbsp;&nbsp; public void <b>ServerError</b>(String message);
<br>&nbsp;&nbsp; }
<p>ServerErrorItf <b>OnServerError</b>(ServerErrorItf handler)</td>

<td>The SecsConn class reports Tcl programming errors that are trapped
in the SECS Server process as ServerError events.&nbsp; An example would
be trying to send an improperly formatted SECS message.&nbsp; These error
events will happen during development but should be rare once the code
is debugged.
<p>Use the <b>OnServerError</b>() method to set your own handler.&nbsp;
The return value is the previous handler which you are replacing.<a NAME="StateChange"></a></td>
</tr>

<tr>
<td>public interface <b>ValueChangeItf </b>{
<br>&nbsp;&nbsp; public void <b>ValueChange</b>(SecsConn sp, String name,
String newvalue);
<br>&nbsp;&nbsp; }
<p>ValueChangeItf <b>OnStateChange</b>(ValueChangeItf handler)</td>

<td>This event notifies your application of state value changes. Possible
<i>varname</i>
values include&nbsp;
<ul>
<li>
<b>state</b> - the State property value changed</li>

<li>
<b>comm_state</b> - the CommState property value changed</li>

<li>
<b>control_state</b> - the ControlState property value changed</li>

<li>
<b>recipe_delete</b> - a process program was replaced with an uploaded
version</li>

<li>
<b>recipe_download</b> - a process program was downloaded to the equipment</li>

<li>
<b>recipe_upload</b> - a process program was received from the equipment.</li>
</ul>
Your application gets notified of the initial values of these items when
the SecsHost connection type is initialized.&nbsp; With the <b>recipe_*</b>
events, the <i>newvalue</i> string is the process program identifier (ppid).
<p>Use the <b>OnStateChange</b>() method to set your own handler.&nbsp;
The return value is the previous handler which you are replacing.</td>
</tr>
</table>

<p><a NAME="Methods"></a>
<table BORDER WIDTH="97%" >
<caption><b>SecsHost Methods</b></caption>

<tr>
<td><b>METHOD</b></td>

<td><b>DESCRIPTION</b></td>
</tr>

<tr>
<td>General Comments
<br>&nbsp;
<br>&nbsp;
<p>&nbsp;</td>

<td>The SecsHost class extends the SecsConn class.&nbsp; Public methods
of both classes are shown here for convenience.&nbsp;
<p>The <a href="HISjava.html#TclListRef">TclList</a> class is documented
with the Hume Java classes for DMH communication.<a NAME="AlarmEnable"></a></td>
</tr>

<tr>
<td>void <b>AlarmEnable</b>(String ALID, boolean is_enabled)</td>

<td>Enable or disable reporting of an Alarm type (S5F1).<a NAME="AlarmIsEnabled"></a></td>
</tr>

<tr>
<td>boolean <b>AlarmIsEnabled</b>(String ALID)</td>

<td>Test if the reporting of an alarm type is enabled&nbsp;<a NAME="AlarmIsSet"></a></td>
</tr>

<tr>
<td>boolean <b>AlarmIsSet</b>(String ALID)</td>

<td>Test if the alarmed state is currently set<a NAME="AlarmTable"></a></td>
</tr>

<tr>
<td>HubTableModel <b>AlarmTable</b>()</td>

<td>This method returns current data from the SECS Server ei_alarm table
for the SecsHost instance.&nbsp; The columns of the table include: spname,
ALID, is_enabled, is_set, ALTX, host_managed, and host_wants_enabled.&nbsp;
The HubTableModel extends the Java swing AbstractTableModel and includes
a refresh() method.&nbsp; It can easily be displayed in a JTable.<a NAME="BinToInt"></a></td>
</tr>

<tr>
<td>int <b>BinToInt</b>(String binValue)
<p>&nbsp;</td>

<td>Converts a SECS B (Binary&nbsp; - Semi "10") data value usually formatted
as a hexadecimal string to an integer value.<a NAME="CommDisable"></a></td>
</tr>

<tr>
<td>void <b>CommDisable</b>()</td>

<td>Disable SECS communication.&nbsp; The SecsHost is initialized without
communication enabled so using this method only makes sense after CommEnable
has been called.<a NAME="CommEnable"></a></td>
</tr>

<tr>
<td>RcResult <b>CommEnable</b>()
<p>public class RcResult {
<br>&nbsp;&nbsp; int rc;&nbsp;&nbsp; // return code
<br>&nbsp;&nbsp; String result;
<br>&nbsp;&nbsp; }</td>

<td>Enables SECS communication.&nbsp; The <a href="#CommState">CommState</a>
property value will change and <a href="#StateChange">StateChange</a> events
will be received.&nbsp; These changes are the asynchronous indications
for success or failure to establish communication.&nbsp; You may want to
display the <a href="#Tracewin">trace window</a>&nbsp; in order to see
detailed information on the status of communication attempts.&nbsp; If
there is an error setting up the connection, the return code value will
be non-zero, and the result field will be an error message.
<br><a NAME="ConnectTypeHsmsActive"></a></td>
</tr>

<tr>
<td>RcResult <b>ConnectTypeHsmsActive</b>(String host_or_ip, int port)</td>

<td>This method is an alternative to setting the underlying property values
to specify an active HSMS connection type, and calling ConnectTypeSet().<a NAME="ConnectTypeHsmsPassive"></a></td>
</tr>

<tr>
<td>RcResult <b>ConnectTypeHsmsPassive</b>(int port)</td>

<td>This method is an alternative to setting the underlying property values
to specify a passive HSMS connection type, and calling ConnectTypeSet().<a NAME="ConnectTypeSerial"></a></td>
</tr>

<tr>
<td>RcResult <b>ConnectTypeSerial</b>(String comDevice, int baudrate)</td>

<td>This method is an alternative to setting the underlying property values
to specify a SECS-I connection type, and calling ConnectTypeSet().<a NAME="ConnectTypeSet"></a></td>
</tr>

<tr>
<td>RcResult <b>ConnectTypeSet</b>()
<p>public class RcResult {
<br>&nbsp;&nbsp; int rc;&nbsp;&nbsp; // return code
<br>&nbsp;&nbsp; String result;
<br>&nbsp;&nbsp; }</td>

<td>This method is called to use the current property values and initialize
a SECS interface for the indicated connection type.&nbsp; It is called
by the ConnectType&lt;Type> methods.&nbsp; If you are setting connection
property data directly, call this method after your property values are
set.&nbsp; The method returns the value 0 to indicate success.&nbsp; If
communication is enabled when this method is called, it becomes disabled
as a result of setting up the new connection.&nbsp; If the return code
value is not 0, then an error message is provided in the result field.<a NAME="ConnectTypeTerminalServer"></a></td>
</tr>

<tr>
<td>RcResult <b>ConnectTypeTerminalServer</b>(String host_or_ip, int port)</td>

<td>This method is an alternative to setting the underlying property values
to specify a SECS-I connection type over a TCP/IP terminal server connection
and calling ConnectTypeSet().<a NAME="ControlStateOffline"></a></td>
</tr>

<tr>
<td>void <b>ControlStateOffline</b>()</td>

<td>This method sends a S1F15R message to request the offline control state.&nbsp;<a NAME="ControlStateOnline"></a></td>
</tr>

<tr>
<td>int <b>ControlStateOnline</b>()</td>

<td>This method sends a S1F17R message to request the online control state.&nbsp;
If the return value is 0 or 2 the online state is indicated.<a NAME="Copy"></a></td>
</tr>

<tr>
<td>void <b>Copy</b>(SecsHost dest)</td>

<td>This method copies the configurable SecsHost property values to another
instance.<a NAME="CopyAll"></a></td>
</tr>

<tr>
<td>String <b>CopyAll</b>(SecsHost dest)</td>

<td>This method calls Copy to copy the current property values to another
instance, and it also copies table records of events, event reports, alarms,
variables, etc in the SECS Server to the destination instance.&nbsp; The
return value is a String formatted as a list of two integers - the total
number of table rows found, and the number of rows copied.&nbsp; In normal
circumstances, the two values are equal.<a NAME="DebugDMHStatus"></a></td>
</tr>

<tr>
<td>void <b>DebugDMHStatus</b>(boolean show)</td>

<td>This method causes the DMH message system status window to either be
shown or dismissed.<a NAME="DebugInspect"></a></td>
</tr>

<tr>
<td>void <b>DebugInspect</b>()</td>

<td>This method can be used to exec the Inspect introspection debugger
if the Datahub SDK has been installed..<a NAME="DebugTableWindow"></a></td>
</tr>

<tr>
<td>void <b>DebugTableWindow</b>(boolean show)</td>

<td>This method causes the Datahub table management GUI to be shown or
dismissed.<a NAME="DebugTclConsole"></a></td>
</tr>

<tr>
<td>void <b>DebugTclConsole</b>(boolean show)</td>

<td>This method causes a console window for the SECS Server to be shown
or dismissed.<a NAME="DebugTraceWindow"></a></td>
</tr>

<tr>
<td>void <b>DebugTraceWindow</b>(boolean show)</td>

<td>This method is used to display a window which updates to show SECS
message traffic and state information for the SecsPort.&nbsp;&nbsp; There
are menu options to control the data displayed, and menu actions to save
the displayed data to the file system.&nbsp; This method invokes the Tcl
version of the Trace window which is created by the SECS Server process.&nbsp;
See the <a href="#Tracewin">Tracewin</a> method to instantiate a native
Java window with similar function.&nbsp; Making the Java version available
in your application is desirable to help diagnose communication problems.&nbsp;<a NAME="delete"></a></td>
</tr>

<tr>
<td>void <b>delete</b>()</td>

<td>Java will not delete and finalize a SecsHost instance automatically
because a reference to each instance is kept in the static instances hashtable.&nbsp;
So we have provided a delete method that should be called when an instance
is no longer needed.&nbsp; The delete method disables communication as
well as deleting data structures and resources used by the instance.<a NAME="EventChoice"></a></td>
</tr>

<tr>
<td>String [] <b>EventChoice</b>()</td>

<td>This method returns an array of {CEID EventName Description) String
values of event types that do not currently have an associated event report.&nbsp;
The method is used to help implement the GUI feature of new report creation.<a NAME="EventDiscovery"></a></td>
</tr>

<tr>
<td>Equipment Constant Update see <a href="#ParameterUpdate">ParameterUpdate</a></td>

<td>Equipment Constant is a misnomer.</td>
</tr>

<tr>
<td>int <b>EventDiscovery</b>()</td>

<td>The SECS-II standard does not provide a way to discover equipment events.&nbsp;
This method is called to attempt event discovery by enabling all events
and asking the equipment which events are enabled.&nbsp; This technique
requires that the equipment support the underlying message types and implements
an EventsEnabled variable that has the expected name.&nbsp; A positive
return value indicates the number of new event types discovered.&nbsp;
Negative return values indicate various failure modes.<a NAME="EventsEnable"></a></td>
</tr>

<tr>
<td>int <b>EventsEnable</b>()
<br>int <b>EventsEnable</b>(String CEIDlist, boolean is_enabled)</td>

<td>Called with no arguments, EventsEnable requests that the equipment
enable all event reports.&nbsp; By providing arguments, you can request
the enabling or disabling of selected events.&nbsp; The SecsHost automatically
enables the reporting of events for which you have configured event reports
during online initialization.&nbsp; You only receive EventReport callbacks
for the event types that have configured report definitions.&nbsp; A negative
return value indicates an unexpected internal error.&nbsp; The value 0
means success, and 1 means at least one of the events does not exist.<a NAME="EventIsHostEnabled"></a></td>
</tr>

<tr>
<td>boolean <b>EventIsHostEnabled</b>(String CEID)</td>

<td>Test if reporting of an event type has been configured in the SecsHost
software to be enabled during the initialization logic.<a NAME="EventIsReported"></a></td>
</tr>

<tr>
<td>boolean <b>EventIsReported</b>(String CEID)</td>

<td>Test if the reporting of an event is currently established with the
equipment.<a NAME="EventReportDefine"></a></td>
</tr>

<tr>
<td>int <b>EventReportDefine</b>(String eventName, String [] varNames)</td>

<td>Create or update an event report configuration.&nbsp; The eventName
argument is the virtual name of the event which can be configured to be
different than the CEID value by using the EventUpdate method.<a NAME="EventReportConfig"></a></td>
</tr>

<tr>
<td>String [] <b>EventReportConfig</b>(String virtualName)</td>

<td>This method returns a four element String array for the configuration
of an event report.&nbsp; The elements are CEID, virtualName, Description,
and Variables.&nbsp; Use TclList.split() to split the Variables element
into a String array of the individual virtual variable names.&nbsp; A null
is returned in case of error.&nbsp;
<p>Use the ReportModel class of the example application for a table of
the existing EventReport configurations.&nbsp;<a NAME="EventReportDelete"></a></td>
</tr>

<tr>
<td>void <b>EventReportDelete</b>(String eventName)</td>

<td>Delete an event report configuration.<a NAME="EventUpdate"></a></td>
</tr>

<tr>
<td>String <b>EventUpdate</b>(String CEID, String eventName, String description)</td>

<td>Assign or update the virtual event name and description for an event
type.&nbsp; Per the SECS-II standard, events use integer values for identifiers.&nbsp;
There is no standardization of values.&nbsp; You are able to provide meaningful
names and descriptions for events.&nbsp; You can use this feature to great
advantage and create virtual equipment drivers with standard event and
variable names.&nbsp; If the description value is passed as null, the current
value for the event is not changed.<a NAME="Initialize"></a></td>
</tr>

<tr>
<td>int <b>Initialize</b>()</td>

<td>Performs online initialization which enables communication and sets
up event reports.&nbsp; Initialization is controlled by your settings of
property values, and configured items.&nbsp; It optionally includes:
<ul>
<li>
establishing communications if not already established</li>

<li>
requesting the equipment go online if the online control state is not already
established</li>

<li>
querying the status of alarms and variables if being online is new</li>

<li>
synching the equipment clock</li>

<li>
setting equipment constant values for the ones that you have configured
persistent values</li>

<li>
setting up event reports per your configuration</li>

<li>
enabling all events if you do not have any configured equipment based event
reports so you can capture the event definitions needed for event reports</li>

<li>
unloading, purging, or ignoring the spool</li>
</ul>
By default this initialization is attempted automatically whenever an online
control state is established.&nbsp; The <a href="#autoInit">AutoInit</a>
property is used to disable automatic initialization.
<p>The return value is 0 for success.&nbsp; Error return values include:&nbsp;
-1 TIMEOUT, 1 communication failed, 2 not online, 3 clock set, 4 setting
of Eq. Constants, 5 disabling of events &amp; reports, 6 event &amp; report
enabling, 7 alarm management, 8 Spool init, or ei_custom_init error.
<br><a NAME="MessageTypeAdd"></a></td>
</tr>

<tr>
<td>void <b>MessageTypeAdd</b>(int stream, int function, SecsMessageReceiveItf
callback)
<p>public interface <b>SecsMessageReceiveItf </b>{
<br>&nbsp;&nbsp; public void <b>SecsMessageReceive</b>(SecsConn sp,&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp; int stream, int function, boolean sendReply,
int transactionID,&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp; String data, String header);
<br>&nbsp;&nbsp; }</td>

<td>Call <b>MessageTypeAdd</b>() to have SECS messages processed by your
custom handler methods when the SecsHost has established communication
with the equipment.&nbsp; The <i>callback</i> argument specifies your application
object that implements the <b>SecsMessageReceiveItf </b>interface.&nbsp;
You can provide for new SECS message types, or you can replace the built-in
handling of particular messages.&nbsp; For example, you could take over
the handling of S6F3 discrete data reports for equipment that uses non-standard
formats.&nbsp; Use the <a href="#SendReply">SendReply</a>, <a href="#SendS9">SendS9</a>,
and <a href="#SendAbort">SendAbort</a> methods to send reply messages.
<p>The arguments passed to your <b>SecsMessageReceive</b> method are:
<br><i>sp</i> a reference to the SecsConn instance.&nbsp; You can cast
this to a SecsHost since SecsHost extends the SecsConn class.&nbsp; <i>stream</i>
and <i>function</i> - these are the message type identifiers of SECS, <i>sendReply</i>
- a boolean flag which is true if you are supposed to send a reply message.&nbsp;
<i>transactionID</i> - an integer value which identifies the specific message
instance and is needed to send a matching reply message.&nbsp; <i>data</i>
- the message data formatted as a <a href="#TSN">TSN</a> string.&nbsp;
Use the <a href="HISjava.html#TclListRef">TclList.split</a> or similar
methods to parse it.&nbsp; <i>header</i> - a TSN representation of the
message header bytes which is only used to send a Stream 9 error message
using the <a href="#SendS9">SendS9</a> method.<a NAME="MessageTypeRemove"></a></td>
</tr>

<tr>
<td>void <b>MessageTypeRemove</b>(int stream, int function)</td>

<td>This method is used to cancel SECS message handlers that you have setup
using MessageTypeAdd or to cancel the handling of particular messages by
the built-in SecsHost logic.&nbsp; If you have called MessageTypeAdd for
the specified message type, the Add is cancelled.&nbsp; If you have not
called MessageTypeAdd, the SECS server is told not to handle the message.
Unhandled primary messages are replied to with an abort reply.<a NAME="ParameterUpdate"></a></td>
</tr>

<tr>
<td>RcResult <b>ParameterUpdate</b>(String varID, String newValue)
<p>public class RcResult {
<br>&nbsp;&nbsp; int rc;&nbsp;&nbsp; // return code
<br>&nbsp;&nbsp; String result;
<br>&nbsp;&nbsp; }</td>

<td>Use this method to set the value of an Equipment Constant.&nbsp; The
return value is 0 for success, -1 and an error message if improper data
is used, 1 if the variable does not exist, 2 if the equipment refuses to
change the value at present, and 3 if the equipment rejects the new value.&nbsp;<a NAME="ProcessProgramList"></a></td>
</tr>

<tr>
<td>String [] <b>ProcessProgramList</b>()</td>

<td>Obtain the current list of process programs using S7F19R.&nbsp; The
return value is null in case of error such as the equipment not being online
or not supporting S7F19.<a NAME="ProcessProgramDownload"></a></td>
</tr>

<tr>
<td>RcResult <b>ProcessProgramDownload</b>(String pathname)
<p>public class RcResult {
<br>&nbsp;&nbsp; int rc;&nbsp;&nbsp; // return code
<br>&nbsp;&nbsp; String result;
<br>&nbsp;&nbsp; }</td>

<td>Download a process program to the equipment.&nbsp; The return value
is a two element structure, a return code and text.&nbsp; The return code
is 0 for success, in which case the text will be the PPID (the process
program name).&nbsp; Possible error codes include:
<br>-1 unexpected transaction error
<br>-2 file not found
<br>-3 file open error
<br>-4 file read error
<br>-5 invalid file data
<br>-6 SECS transaction error<a NAME="ProcessProgramUpload"></a></td>
</tr>

<tr>
<td>RcResult <b>ProcessProgramUpload</b>(String ppid)
<p>public class RcResult {
<br>&nbsp;&nbsp; int rc;&nbsp;&nbsp; // return code
<br>&nbsp;&nbsp; String result;
<br>&nbsp;&nbsp; }</td>

<td>Upload a process program from the equipment to our file system.&nbsp;
The return value is a two element structure, a return code and text. The
return code is 0 for success, in which case the text will be the pathname
of the saved program..&nbsp; Possible error codes include
<br>-1 unexpected transaction error
<br>-2 upload refused or failed
<br>-3 file system error<a NAME="SecsHost"></a></td>
</tr>

<tr>
<td>public static SecsHost <b>newSecsHost</b>()&nbsp;
<p>void <b>SecsHost</b>(String Name, String dmhGroup)
<p>void <b>SecsHost</b>(String spname, String [] cols, String [] row)&nbsp;
<br>&nbsp;</td>

<td>The constructor.&nbsp; The <i>Name</i> argument becomes the name of
a global data item and a Tcl command in the SECS Server process.&nbsp;
It needs to be unique for each SecsHost instance, and not coincide with
a keyword in the Tcl programming language.&nbsp; The default value of <i>Name</i>
is similar to <b>host0</b>. The name should be a single alphanumeric token.&nbsp;
<p>One of the constructor forms accepts property values as String arrays.&nbsp;
This form is used by our example Supervisor application.&nbsp; Take a look
at the source code for the SecsHost to understand the names used for the
property values.&nbsp; Essentially there is a direct mapping of properties
to column names in an SQL table, ei_startup, which is used to manage interface
startup information.
<p>The <i>dmhGroup</i> argument becomes the DMH message system group name
used by the SecsHost and SECS Server process.&nbsp; If you are instantiating
more than one SecsHost&nbsp; instance in your process, construct each instance
using the same <i>dmhGroup</i> name argument so that the SECS Server process
is shared.&nbsp;&nbsp; The groupname chosen needs to be unique among other
DMH server instances on the computer where the SecsPort is executing.&nbsp;
The default value is <b>GEMHOST</b>.&nbsp; This value does not conflict
with the default value for Hume Datahub instances which is <b>mbx</b>,
or the default value for the GemEqApp which is <b>GEM</b>.&nbsp; The name
should be a single alphanumeric token.&nbsp;
<p>The&nbsp; SECS Server process can be debugged remotely by connecting
to the DMH mailbox SERVER_RPC@<i>hostname</i>:<i>dmhGroup</i> using the
<a href="../man1/dmh_inspect.html">Inspect
application</a> or using the DMH mailbox SERVER_SQL@hostname:dmhGroup by
the <a href="../man1/hubclient.html">hubclient application</a>.<a NAME="SendAbort"></a></td>
</tr>

<tr>
<td>void <b>SendAbort</b>(int stream, int primaryFunction)</td>

<td>This method is used to send an F0 abort message in lieu of a proper
reply.&nbsp; It is used to indicate that the received message is not appropriate
in the current context.<a NAME="SendReply"></a></td>
</tr>

<tr>
<td>void <b>SendReply</b>(int stream, int function, int transactionID)
<p>void <b>SendReply</b>(int stream, int function, int transactionID, String
TSN_data)</td>

<td>This method is used by your custom SECS message handling logic to send
reply messages either with or without data.&nbsp; The reply data is formatted
as <a href="#TSN">Tcl Secs Notation </a>text.<a NAME="SendS9"></a></td>
</tr>

<tr>
<td>void <b>SendS9</b>(int function, String header)</td>

<td>This method is used to indicate an error condition response to a received
message - it is sent in lieu of a normal reply.&nbsp; You will not receive
a message type, unless you register for it.&nbsp; In general, host software
has less of a need to send Stream 9 messages than equipment software.
<br><a NAME="SendSecsMsg"></a></td>
</tr>

<tr>
<td>RcResult <b>SendSecsMsg</b>(int stream, int function, boolean reply_wanted,
String TSN_data, boolean wait4reply)
<p>public class RcResult {
<br>&nbsp;&nbsp; int rc;&nbsp;&nbsp; // return code
<br>&nbsp;&nbsp; String result;
<br>&nbsp;&nbsp; }
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>&nbsp;</td>

<td>These methods are used to send a primary SECS message, optionally indicating
a reply is wanted, and optionally indicating that the call should wait
for a reply.&nbsp; A null or empty String value may be used for the <i>TSN_data
</i>argument
when a header only message is to be sent.&nbsp; If a multiblock enquire/grant
transaction is required for the message type, the SecsHost software does
it automatically.&nbsp; The reply value for the <b>SendSecsMsg</b>() method&nbsp;
is a a two element data structure.&nbsp; The first element is an integer
code, and the second element is reply or diagnostic data.&nbsp; The possible
return values are:
<dl>
<dt>
-1</dt>

<dd>
<i>errorMessage</i>&nbsp; - the error message starts with "ERROR" and describes
the fault</dd>

<dt>
-2</dt>

<dd>
DISABLED&nbsp;&nbsp; - communication is disabled so the message could not
be sent</dd>

<dt>
-4&nbsp;</dt>

<dd>
SENDFAILURE&nbsp;&nbsp; - the send attempt failed.</dd>

<dt>
-5&nbsp;</dt>

<dd>
BUSY&nbsp;&nbsp; - an eq_send call is currently active.&nbsp; You should
not see this error, since by design send commands are serialized using
DMH messages to the connection's command mailbox.</dd>

<dt>
-8</dt>

<dd>
MULTIBLOCK_REFUSED - You are sending a message type that requires multiblock
enquire/grant and the equipment failed to send the code 0 GRANT reply.&nbsp;
(Possible with message types S2F33, S2F35, S2F45, S4F19, &amp; S7F3).</dd>

<dt>
0&nbsp;</dt>

<dd>
SENT_NO_REPLY&nbsp; - sent successfully no reply requested</dd>

<dt>
0&nbsp;</dt>

<dd>
SENT_NO_REPLY_WAIT&nbsp; - sent successfully, a reply was indicated, not
waiting for the reply was indicated.&nbsp; The reply will be ignored when
it arrives.</dd>

<dt>
0&nbsp;</dt>

<dd>
<i>ReplyTsnData</i>&nbsp;&nbsp; -sent ok, reply requested and received.</dd>

<dt>
-6&nbsp;</dt>

<dd>
TIMEOUT&nbsp; - sent ok, reply requested, no reply, T3 timeout.&nbsp;</dd>

<dt>
-7&nbsp;</dt>

<dd>
ABORTED&nbsp; - sent ok, F0 abort reply received.</dd>

<dt>
-8&nbsp;</dt>

<dd>
REJECTED&nbsp; - sent ok, Stream 9 error message "reply".<a NAME="ServerSQLCmd"></a></dd>
</dl>
</td>
</tr>

<tr>
<td>static void SecsConn.<b>ServerSQLCmd</b>(String sql)</td>

<td>Send an SQL command to the SECS Server process without waiting for
a reply.&nbsp; This method is used by the SecsPort software and made public
in case of custom requirements.<a NAME="ServerSQLReply"></a></td>
</tr>

<tr>
<td>static String SecsConn.<b>ServerSQLReply</b>(String sql)</td>

<td>Send an SQL command to the SECS Server process and wait for the reply.&nbsp;
This method is used by the SecsPort software and made public in case of
custom requirements.<a NAME="ServerTclCmd"></a></td>
</tr>

<tr>
<td>static void SecsConn.<b>ServerTclCmd</b>(String tclCommand);</td>

<td>Send a Tcl command to the SECS Server process without waiting for a
reply.&nbsp; This method is used by the software and made public in case
of custom requirements.&nbsp; After a SecsPort instance has been constructed
and the connection type set, the TclCmd( ) method should be used instead
of this method for commands that are directed to a particular interface
instance.&nbsp; Why?&nbsp; Doing so serializes the commands for a particular
interface, and provides re-entrant execution protection.<a NAME="ServerTclReply"></a></td>
</tr>

<tr>
<td>static String SecsConn.<b>ServerTclReply</b>(String tclCommand);</td>

<td>Send a Tcl command to the SECS Server process and wait for the reply
message.&nbsp; This call is used by the SecsPort software and made public
in case of custom requirements.&nbsp; After a SecsPort instance has been
constructed and the connection type set, the TclReply( ) method should
be used instead of this method for commands that are directed to a particular
interface instance.<a NAME="SuperSave"></a></td>
</tr>

<tr>
<td>static int SecsHost.<b>SuperSave</b>()</td>

<td>Save the SECS server table data including interface startup configurations.&nbsp;
You can write your own applications with your own persistence mechanisms.&nbsp;
Our example Supervisor application uses this method to save the state of
the configured interfaces for the next session.<a NAME="SupervisorStart"></a></td>
</tr>

<tr>
<td>static void SecsHost.<b>SupervisorStart </b>(String DmhGroup)</td>

<td>This method is the startup call for our Supervisor application example.&nbsp;
It restores data from the last SuperSave call, and instantiates all of
the configured interfaces.&nbsp; The interfaces that are configured with
<a href="#autoStart">autoStart</a>
true, are enabled for communication.<a NAME="TclCmd"></a></td>
</tr>

<tr>
<td>void <b>TclCmd</b>(String tcl)</td>

<td>This method is used to send Tcl code to the SECS server command mailbox
for the connection.&nbsp; It is used by the SecsPort software and made
public to support custom requirements.<a NAME="TclReply"></a><a NAME="TclReplyRcResult"></a></td>
</tr>

<tr>
<td>RcResult <b>TclReply</b>(String tcl)
<p>public class RcResult {
<br>&nbsp;&nbsp; int rc;&nbsp;&nbsp; // return code
<br>&nbsp;&nbsp; String result;
<br>&nbsp;&nbsp; }</td>

<td>These methods are used to send Tcl code to the SECS server command
mailbox for the connection and wait for the evaluation result.&nbsp; They
are used by the SecsHost software and made public to support custom requirements.&nbsp;
With <b>TclReply</b>() the return value is a structure.&nbsp; The first
element is a return code for the evaluation with 0 meaning success.&nbsp;
The second element is the return value from the executed Tcl code, or an
error message if the return code is not 0.&nbsp;<a NAME="TraceSetup"></a></td>
</tr>

<tr>
<td>int <b>TraceSetup</b>(String trid, int periodSecs, int totsmp, int
repgsz, String SVIDs)</td>

<td>Control TRACE Reports - a convenience method to send the S2F23R message.&nbsp;
If totsmp is 0, the trace is disabled.&nbsp; The return values are 0 =
success, 1 = too many SVIDs, 2 = no more traces allowed, 3 = invalid period
specified, -1 = error such as not being in online communication.&nbsp;<a NAME="Tracewin"></a></td>
</tr>

<tr>
<td>void <b>Tracewin</b>(boolean show);</td>

<td>The SecsPort is able to instantiate and manage a&nbsp; window class,
Tracewin, which provides a controllable display of the data being exchanged
across the SECS interface.&nbsp; The argument is set to true to display
the window, or false to close the window.&nbsp; There are menu options
to provide hex dump formatting of the data, or higher level descriptive
formatting.&nbsp; There are also menu actions to save the displayed data
to the file system.&nbsp;<a NAME="VariableChoice"></a></td>
</tr>

<tr>
<td>String [] <b>VariableChoice</b>()</td>

<td>This method returns a list of variable names which are candidates for
use in dynamic Event Report configuration.&nbsp; The names are the virtualName
(VFEIname) values.&nbsp; A null value is returned in case of error.<a NAME="VariableTable"></a></td>
</tr>

<tr>
<td>DataTable <b>VariableTable</b>()</td>

<td>This method returns a current subset of the SECS server variable table
for the SecsHost instance.&nbsp; The included columns are varID, varname,
VFEIname, description, varclass, value_TSN, varmethod,&nbsp; varvalue,
host_setval, host_managed, and t_latest.<a NAME="VariableUpdate"></a></td>
</tr>

<tr>
<td>int <b>VariableUpdate</b>(String varID, String virtualName, String
description)</td>

<td>You are able to assign meaningful names and descriptions to the equipment
variables using this method.&nbsp; The virtualName values are used in Event
Report configurations and as the variable names in the Event Report event
data.&nbsp; If the description field is passed as a null value, the current
description is not changed.</td>
</tr>
</table>

<h2>
SecsHost Built-in Features</h2>

<p><br>This section of the document has information on the built-in features
of the SecsHost software in regards to the SEMI E5 and GEM standards.
<br>&nbsp;
<h3>
<a NAME="BuiltInVariables"></a>Built-In Variables and Events</h3>
The SecsHost software creates certain variable table records to hold configured
property values.&nbsp; These records are of little interest to the Java
developer since they are managed through property value settings.
<p>There is only one other variable record of note.&nbsp; The <b>AUTO_INIT_RESULT</b>
variable exists to save the execution result when the initialization logic
executes automatically.&nbsp; It is common to configure this variable to
be part of the event report for the <b>AUTO_VIRT_INIT</b> event.&nbsp;
This dynamic event report can be configured and received even if the underlying
equipment does not support dynamic event reports.&nbsp; The event report
is created and managed by the SecsHost software.&nbsp; There are three
other events that are synthesized in the SecsHost software and presented
to the application using the same mechanisms used to dispatch equipment
based event reports.&nbsp; Here is a list of the built-in driver events:
<dl>
<dt>
<b>AUTO_VIRT_INIT</b></dt>

<dd>
This event report occurs when the <a href="#autoInit">autoInit</a> property
is left at its default value of true, and the SecsHost attempts the initialization
logic for the virtual reporting system automatically after establishing
an online control state with the equipment.&nbsp; The value of the variable
is a two element list.&nbsp; The first element indicates whether there
was a trapped execution error during initialization.&nbsp; The first element
will ordinarily be 0 to indicate that execution proceeded without error.&nbsp;
The second element will be an error message if an execution error was trapped.&nbsp;
In the usual success case, the second element is the return code from the
ei_initialize procedure.&nbsp; The following return values are possible:
0 meaning success, 1 communication failure, 2 request online failed, 3
clock synchronization failed, 4 failed setting equipment constants, 5 failed
disabling events, 6 failed enabling events and reports, 7 failed enabling
disabling alarms, 8 spool initialization failed.&nbsp; You can and should
edit the properties of your SecsHost so the initialization does not attempt
to use message types that your equipment cannot handle.</dd>

<dt>
<b>COMM_DISABLE</b></dt>

<dd>
This event report occurs when communication with the equipment is lost.</dd>

<dt>
<b>COMM_ENABLE</b></dt>

<dd>
This event report occurs when communication with the equipment is established
(or re-established).</dd>

<dt>
<b>TRACE_REPORT</b></dt>

<dd>
The SecsHost logic maps Trace Reports into Event Reports with this event
name.&nbsp; This lets you use common software to capture trace and event
reports.</dd>
</dl>

<h3>
<a NAME="BuiltInMessages"></a></h3>

<h3>
Built-in Handling of SECS Message Types</h3>
The E5 standard identifies data items used in message items with all uppercase
letters such as CEID.&nbsp; Typically, the standard allows for different
data types to be used for a particular message item.&nbsp; Historically,
the host software has been required to know and use the specific data types
that the equipment implements when the standard allows for different data
types.&nbsp; That is why the SecsHost has configurable properties for the
data types that the built-in logic uses and that cannot be discovered automatically.&nbsp;
For most message types, the Hume SECS equipment software accepts any data
type for a message data item as long as the value is equivalent.&nbsp;
This behavior cannot be assumed for other implementations.&nbsp; The table
below lists the subset of message types where the SecsHost has built-in
handling of the message type, or sends the message type as part of its
built-in logic.&nbsp; Other message types can be easily sent by your application
using the <a href="#SendSecsMsg">SendSecsMsg</a> method or received and
handled by your application using the <a href="#MessageTypeAdd">MessageTypeAdd</a>
method.&nbsp; The Data Formats in the table below show the Host message
formats in situations where host and equipment send the same message type
with different data formats.
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td><b>Type</b></td>

<td><b>Sender</b></td>

<td><b>Data Format</b></td>

<td><b>Comments</b></td>
</tr>

<tr>
<td>S1F1R</td>

<td>H, E</td>

<td>&nbsp;</td>

<td>"Are You There?"</td>
</tr>

<tr>
<td>S1F2</td>

<td>H</td>

<td>L</td>

<td>"On Line Data"</td>
</tr>

<tr>
<td>S1F3R</td>

<td>H</td>

<td>L [&lt;SVID>]*
<br>&lt;SVID>&nbsp; := {U4 &lt;varID>}</td>

<td>"Selected Equipment Status Request"&nbsp;</td>
</tr>

<tr>
<td>S1F4</td>

<td>E</td>

<td>L [&lt;SV>]*</td>

<td>"Selected Equipment Status Data"
<br>The data type of the SV value depends on the variable.</td>
</tr>

<tr>
<td>S1F11R</td>

<td>H</td>

<td>L [&lt;SVID>]*</td>

<td>&nbsp;"Status Variable Namelist Request"</td>
</tr>

<tr>
<td>S1F12</td>

<td>E</td>

<td>L [{L:3 &lt;SVID> &lt;SVNAME> &lt;UNITS>}]+</td>

<td>&nbsp;"Status Variable Namelist Reply"</td>
</tr>

<tr>
<td>S1F13R</td>

<td>H,E</td>

<td>L</td>

<td>&nbsp;"Establish Communications Request"</td>
</tr>

<tr>
<td>S1F14</td>

<td>H</td>

<td>L:2 {B 0} L</td>

<td>&nbsp;"Establish Communications Request Acknowledge"</td>
</tr>

<tr>
<td>S1F15R</td>

<td>H</td>

<td>&nbsp;</td>

<td>"Request OFF-LINE"</td>
</tr>

<tr>
<td>S1F16</td>

<td>E</td>

<td>&lt;OFLACK></td>

<td>"OFF-LINE Acknowledge"</td>
</tr>

<tr>
<td>S1F17R</td>

<td>H</td>

<td>&nbsp;</td>

<td>"Request ON-LINE"</td>
</tr>

<tr>
<td>S1F18</td>

<td>E</td>

<td>&lt;ONLACK></td>

<td>"ON-LINE Acknowledge"</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>S2F13</td>

<td>H</td>

<td>L [&lt;ECID>]*</td>

<td>"Equipment Constant Request"</td>
</tr>

<tr>
<td>S2F14</td>

<td>E</td>

<td>L [&lt;ECV>]*</td>

<td>"Equipment Constant Data"</td>
</tr>

<tr>
<td>S2F15R</td>

<td>H</td>

<td>L [{L:2 &lt;ECID> &lt;ECV>}]*</td>

<td>"New Equipment Constant Send"</td>
</tr>

<tr>
<td>S2F16</td>

<td>E</td>

<td>&lt;EAC></td>

<td>"New Equipment Constant Ack"</td>
</tr>

<tr>
<td>S2F17R</td>

<td>H</td>

<td>&nbsp;</td>

<td>"Date and Time Request"</td>
</tr>

<tr>
<td>S2F18</td>

<td>E</td>

<td>A:16 YYYYMMDDHHMMSScc&nbsp;
<br>A:12 YYMMDDHHMMSS</td>

<td>"Date and Time Data"</td>
</tr>

<tr>
<td>S2F23R</td>

<td>H</td>

<td>L:5 &lt;TRID> &lt;DSPER> &lt;TOTSMP> &lt;REPGSZ> {L [&lt;SVID>]+}</td>

<td>&nbsp;"Trace Initialize Send"</td>
</tr>

<tr>
<td>S2F24</td>

<td>E</td>

<td>&lt;TIAACK></td>

<td>"Trace Initialize Acknowledge"</td>
</tr>

<tr>
<td>S2F25R</td>

<td>H,E</td>

<td>B [&lt;b>]*</td>

<td>"Loopback Diagnostic Request"</td>
</tr>

<tr>
<td>S2F26</td>

<td>H</td>

<td>B [&lt;b>]*</td>

<td>&nbsp;"Loopback Diagnostic Data"</td>
</tr>

<tr>
<td>S2F29R</td>

<td>H</td>

<td>L [&lt;ECID>]*</td>

<td>"Equipment Constant Namelist Request"</td>
</tr>

<tr>
<td>S2F30</td>

<td>E</td>

<td>L [L:6 &lt;ECID> &lt;ECNAME> &lt;ECMIN> &lt;ECMAX> &lt;ECDEF> &lt;UNITS>]+</td>

<td>&nbsp;"Equipment Constant Namelist"</td>
</tr>

<tr>
<td>S2F31R</td>

<td>H</td>

<td>A:16 YYYYMMDDHHMMSScc&nbsp;
<br>A:12 YYMMDDHHMMSS</td>

<td>"Date and Time Set Request"</td>
</tr>

<tr>
<td>S2F32</td>

<td>E</td>

<td>&lt;TIACK></td>

<td>"Date and Time Set Acknowledge"</td>
</tr>

<tr>
<td>S2F33R</td>

<td>H</td>

<td>L:2 &lt;DATAID> {L [{L:2 &lt;RPTID> {L [&lt;VID>]*}]*}</td>

<td>"Define Report"</td>
</tr>

<tr>
<td>S2F34</td>

<td>E</td>

<td>&lt;DRACK></td>

<td>"Define Report Acknowledge"</td>
</tr>

<tr>
<td>S2F35R</td>

<td>H</td>

<td>L:2 &lt;DATAID> {L [&lt;CEID> {L [&lt;RPTID>]*}]*}</td>

<td>"Link Event Report"</td>
</tr>

<tr>
<td>S2F36</td>

<td>E</td>

<td>&lt;LRACK></td>

<td>"Link Event Report Acknowledge"</td>
</tr>

<tr>
<td>S2F37R</td>

<td>H</td>

<td>L:2 &lt;CEED> {L [&lt;CEID>]*}</td>

<td>"Enable/Disable Event Report"</td>
</tr>

<tr>
<td>S2F38</td>

<td>E</td>

<td>&lt;ERACK></td>

<td>"Enable/Disable Event Report Acknowledge"</td>
</tr>

<tr>
<td>S2F39R</td>

<td>H</td>

<td>L:2 &lt;DATAID> &lt;DATALENGTH></td>

<td>"Multi-block Inquire"</td>
</tr>

<tr>
<td>S2F40</td>

<td>E</td>

<td>&lt;GRANT></td>

<td>"Multi-block Grant"</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>S4F25R</td>

<td>H</td>

<td>L:2 &lt;DATAID> &lt;DATALENGTH></td>

<td>"Multi-block Inquire"</td>
</tr>

<tr>
<td>S4F26</td>

<td>E</td>

<td>&lt;GRANT></td>

<td>"Multi-block Grant"</td>
</tr>

<tr>
<td></td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>S5F1R</td>

<td>E</td>

<td>L:3 &lt;ALCD> &lt;ALID> &lt;ALTX></td>

<td>"Alarm Report Send"</td>
</tr>

<tr>
<td>S5F2</td>

<td>H</td>

<td>B 0</td>

<td>"Alarm Report Ack"</td>
</tr>

<tr>
<td>S5F3R</td>

<td>H</td>

<td>L:2 &lt;ALED> &lt;ALID></td>

<td>"Enable/Disable Alarm Send"</td>
</tr>

<tr>
<td>S5F4</td>

<td>E</td>

<td>&lt;ACKC5></td>

<td>"Enable/Disable Alarm Ack"</td>
</tr>

<tr>
<td>S5F5R</td>

<td>H</td>

<td>&lt;ALID vector></td>

<td>"List Alarms Request"</td>
</tr>

<tr>
<td>S5F6</td>

<td>E</td>

<td>L [{L:3 &lt;ALCD> &lt;ALID> &lt;ALTX>}]*</td>

<td>"List Alarm Data"</td>
</tr>

<tr>
<td>S5F7R</td>

<td>H</td>

<td>&nbsp;</td>

<td>"List Enabled Alarm Request"</td>
</tr>

<tr>
<td>S5F8</td>

<td>E</td>

<td>L [{L:3 &lt;ALCD> &lt;ALID> &lt;ALTX>}]*</td>

<td>"List Enabled Alarm Data"</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>S6F1</td>

<td>E</td>

<td>L:4 &lt;TRID> &lt;SMPLN> &lt;STIME> {L [&lt;SV>]+}</td>

<td>"Trace Data Send"</td>
</tr>

<tr>
<td>S6F3[R]</td>

<td>E</td>

<td>L:3 &lt;DATAID> &lt;CEID> [{L:n {L:2 &lt;DSID1> {L:m [{L:2 &lt;DVNAME>
&lt;DVVAL>}]*}}]*</td>

<td>"Discrete Variable Data Send"</td>
</tr>

<tr>
<td>S6F4</td>

<td>H</td>

<td>B 0</td>

<td>"Discrete Variable Data Ack"</td>
</tr>

<tr>
<td>S6F5R</td>

<td>E</td>

<td>L:2 &lt;DATAID> &lt;DATALENGTH></td>

<td>"Multi-block Data Send Inquire"</td>
</tr>

<tr>
<td>S6F6</td>

<td>H</td>

<td>B 0</td>

<td>"Multi-block Grant"</td>
</tr>

<tr>
<td>S6F11R</td>

<td>E</td>

<td>L:3 &lt;DATAID> &lt;CEID> {L [{L:2 &lt;RPTID> {L [&lt;V>]+}}]+}</td>

<td>"Event Report Send"</td>
</tr>

<tr>
<td>S6F12</td>

<td>H</td>

<td>B 0</td>

<td>"Event Report Ack"</td>
</tr>

<tr>
<td>S6F13R</td>

<td>E</td>

<td>L:3 &lt;DATAID> &lt;CEID> {L [{L:2 {U4 &lt;rptid>} {L [{L:2 {U4 &lt;vid>}
&lt;V>}]+}}]+}</td>

<td>"Annotated Event Report Send"</td>
</tr>

<tr>
<td>S6F14</td>

<td>H</td>

<td>B 0</td>

<td>"Annotated Event Report Ack"</td>
</tr>

<tr>
<td>S6F23R</td>

<td>H</td>

<td>&lt;RSDC></td>

<td>"Request or Purge Spooled Data"</td>
</tr>

<tr>
<td>S6F24</td>

<td>E</td>

<td>&lt;RSDA></td>

<td>"Request or Purge Spooled Data Ack"</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>S7F1R</td>

<td>H,E</td>

<td>L:2 &lt;PPID> &lt;LENGTH></td>

<td>"Process Program Load Inquire"</td>
</tr>

<tr>
<td>S7F2</td>

<td>E,H</td>

<td>&lt;PPGNT></td>

<td>"Process Program Load Grant" - The SecsHost always sends B 0.</td>
</tr>

<tr>
<td>S7F3R</td>

<td>H,E</td>

<td>L:2 &lt;PPID> &lt;PPBODY></td>

<td>"Process Program Download"</td>
</tr>

<tr>
<td>S7F4</td>

<td>E,H</td>

<td>&lt;ACKC7></td>

<td>"Process Program Download Acknowledge"</td>
</tr>

<tr>
<td>S7F5R</td>

<td>H,E</td>

<td>&lt;PPID></td>

<td>"Process Program Upload Request"</td>
</tr>

<tr>
<td>S7F6</td>

<td>E,H</td>

<td>L:2 &lt;PPID> &lt;PPBODY></td>

<td>"Process Program Upload Data"</td>
</tr>

<tr>
<td>S7F19R</td>

<td>H</td>

<td>&nbsp;</td>

<td>"Current Process Program Dir Request"</td>
</tr>

<tr>
<td>S7F20</td>

<td>E</td>

<td>L [&lt;PPID>]*</td>

<td>"Current Process Program Data"</td>
</tr>

<tr>
<td></td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>S*F0</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>abort replies are handled as a special case of reply</td>
</tr>

<tr>
<td>S9F1</td>

<td>E</td>

<td>&lt;MHEAD></td>

<td>"Unknown Device ID"&nbsp; - The SecsHost has logic to automatically
correct this error when first establishing communication.</td>
</tr>

<tr>
<td>S9F3</td>

<td>E</td>

<td>&lt;MHEAD></td>

<td>"Unknown Stream"</td>
</tr>

<tr>
<td>S9F5</td>

<td>E</td>

<td>&lt;MHEAD></td>

<td>"Unknown Function"</td>
</tr>

<tr>
<td>S9F7</td>

<td>E,H</td>

<td>&lt;MHEAD></td>

<td>"Illegal Data"</td>
</tr>

<tr>
<td>S9F9</td>

<td>E,H</td>

<td>&lt;MHEAD></td>

<td>"Transaction Timeout"
<br>T3 timeout</td>
</tr>

<tr>
<td>S9F11</td>

<td>E</td>

<td>&lt;MHEAD></td>

<td>"Data Too Long"&nbsp;</td>
</tr>

<tr>
<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>S10F1</td>

<td>E</td>

<td>L:2 {B 0} {A &lt;text>}</td>

<td>"Terminal Request"
<br>the example application handles this message type</td>
</tr>

<tr>
<td>S10F3R</td>

<td>H</td>

<td>L:2 &lt;TID> {A &lt;text>}</td>

<td>"Terminal Display, Single"</td>
</tr>

<tr>
<td>&nbsp;S10F4</td>

<td>&nbsp;E</td>

<td>&nbsp;&lt;ACKC10></td>

<td>&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%"><a NAME="LicenseTerms"></a>
<h2>
License Terms</h2>
Subject to Change Without Notice
<p>The Hume Java SecsHost software is licensed for development and runtime
use at no additional charge for computers that are licensed for development
use of the Hume Integration Datahub SDK.
<p>Hume Integration is also pleased to offer separate runtime licenses
for using the SecsHost software on systems that are not licensed as development
systems.&nbsp; Contact Hume Integration for more information.
<p>
<hr WIDTH="100%">
<h2>
<a NAME="DocVersion"></a>Document Version</h2>
Date of last revision: $Date: 2005/06/10 13:36:50 $
</body>
</html>
