<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    
  <meta name="Author" content="Ed Hume">
    
  <meta name="GENERATOR" content="Mozilla/4.77 [en] (Windows NT 5.0; U) [Netscape]">
    
  <meta name="Description" content="A high-level application component for Finite State Machine execution or event-based logic.">
    
  <meta name="KeyWords" content="Finite State Machine, Business Rule Processing, CIM Framework, E10, Utilization, VFEI, SEMATECH">
  <title>The Hume Event Processing Component</title>
</head>
  <body>
  
<center> 
<h2> The Event Processing Component (EPC)</h2>
</center>
  
<center><b>Licensed and Supported Software</b> <br>
<b>(C) Copyright 2002 Hume Integration Software</b> <br>
<b>All Rights Reserved</b></center>
  
<h2> Introduction</h2>
The capabilities of the Hume Datahub SDK enable you to
communicate with fabrication equipment, test equipment,&nbsp; instruments, 
and other devices.&nbsp; The DMH message system enables you to tie these connected
entities into a coordinated system.&nbsp; Once tool connectivity and integration
have been achieved, higher-level applications become possible and desirable.&nbsp;
The Event Processing Component (EPC) is the second component released in
a series of high-level application building blocks designed for this integrated
domain.&nbsp; What is the EPC?&nbsp; At a basic level the EPC is a set of
relational database tables and some runtime logic.&nbsp; The EPC design is
centered on bringing events and context data up into a high-level processing
framework, where table-driven configuration dictates how the events are to
be handled, and what their meaning is as far as managing state, acquiring
performance data, and executing application logic.&nbsp; The EPC is designed
to serve as a single entity for both event-based business rule execution,
and for finite state machine execution.&nbsp; The EPC is designed to scale
well.&nbsp; It can be applied to smaller problems such as coordinating the
material flow in a workcell, and to larger problems such as tracking state-dependent
performance data for dozens and dozens of connected factory tools.&nbsp;
In addition to configurable logging and diagnostic tracing, the EPC features
a delightful new scheme for simplified high-performance access to persistent
data.&nbsp; By choosing to use the EPC on your next project,&nbsp; you take
advantage of a working design that reflects years of experience.&nbsp; The
EPC can bring a new sense of order to your applications as their complexity
is unraveled to become simpler procedures tied together by understandable
table entries. 
<h2> <a name="features"></a>
Feature Summary</h2>
  
<ul>
 <li> Consolidated processing of&nbsp; alarm messages, event messages, data
change subscription notifications, timer expirations, error conditions, or
other inputs as events.</li>
  <li> Managing and processing of arbitrary context data with events.&nbsp;
Context data is modifiable as it passes through the processing pipeline.</li>
  <li> Filtering of input events, mapping of input events to different identifiers, 
and mapping of the associated physical or state machine identifier.&nbsp;&nbsp; 
Mapping of events can also depend on context data values.</li>
  <li> Execution of application logic based upon pattern matching of input
events irrespective of state.</li>
  <li> Selective execution of application logic depending on state; table
driven execution of multiple finite state machines.</li>
  <li> Execution of application logic triggered by state transitions.</li>
  <li> Configurable logging and saving of events and state changes.</li>
  <li> Configurable diagnostic tracing of event processing with a remote
viewing application.</li>
  <li> Simplified access to SQL table data as global arrays with high performance, 
and with configurable persistence.</li>
  <li> Consistent and direct naming of states and events using dotted pathnames 
(ie., periods are used to separate substate names).&nbsp; Simple and powerful 
configuration using string matching patterns such as "*.down" matching transitions
to any down substate.</li>
  <li> Periodic timer events to support interval-based performance tracking.</li>
  <li> Cancelable one-shot timer events to support interval timing.</li>
 
</ul>
  
<h2> <a name="Installation"></a>
Installation</h2>
 The first step in installation is to have the Hume DMH software products 
installed.&nbsp; To use all of the EPC capabilities, the Itcl, Itk, and Iwidgets
optional packages should be installed.&nbsp; The Hume Component Libraries
contain packages needed by the EPC, and so they must be installed.&nbsp;&nbsp; 
The EPC server component executes in an extended Tcl/Tk process such as the
Hume Integration <a href="../man1/datahub.html">Datahub</a>
 .&nbsp; It is common for the EPC server process to also function as a DMH
message system server so that client processes can easily and efficiently
interact with the server using DMH messages.&nbsp; It is also common for
the same process that executes the EPC server logic to execute other server
component logic such as the Hume <a href="datacoll.html">Data Collection
Component</a>
 (DCC).&nbsp; When server functions reside in the same process, their interactions 
are more efficient than when interprocess communication is required.&nbsp; 
The EPC software can also run in a Tcl/Tk executable not provided by Hume 
Integration Software.&nbsp; In this situation, the command "package require 
dmh" is used to pull the necessary Hume licensed extensions into the executable. 
<p>The EPC software is usually installed in its own directory, <b>epc1.0</b>
 , as a subdirectory of the Tcl/Tk library directory.&nbsp; So the EPC files 
are typically found as /usr/local/lib/epc1.0/*.*. As a subdirectory of the
Tcl/Tk library directory, the EPC software can be found and made useable just
by executing the statement "<b>package require HumeEPC</b>". </p>
<h2> Server&nbsp;<a name="Startup"></a>
 Startup</h2>
 The usual EPC server startup is: <br>
&nbsp; 
<ol>
 <li> Your application processes start and establish DMH communication to
each other.&nbsp; The datahub Tcl application is commonly used to provide
the DMH server function.&nbsp;&nbsp; If you are running your application
as NT services, it is common just to start the DMH server process as a service, 
and then have the server start the other application processes.</li>
  <li> If you are using a persistent database, you establish a DMH mailbox
for SQL commands directed to the persistent database.&nbsp; The dmh_SQLsrv 
Tcl application is commonly used to provide this function.</li>
  <li> The EPC software is found and made useable by your application executing 
"<b>package require HumeEPC</b>".&nbsp; This command will add the EPC installation 
directory to the Tcl <b>auto_path</b> global variable in the DMH server process
so that the EPC procedures can be found.</li>
  <li> The DMH server process executes the <b>ep_hub_init</b> procedure.&nbsp; 
Optional arguments to the <b>ep_hub_init</b> procedure specify the DMH mailbox
to be used for receiving EPC events, the persistent database mailbox name,
and the type of persistent database in use, such as DB2, ORACLE, or SYBASE.&nbsp;
You may optionally specify an empty string for the EPC mailbox to indicate
that EPC should function without reading DMH messages for input.</li>
  <li> The EPC server logic will create and initialize its own persistent
database tables if they do not exist, and a functional connection to the
persistent database exists.</li>
  <li> The EPC server logic will automatically read and initialize its in-memory 
tables from the saved data in the persistent database.</li>
  <li> The EPC server logic will also load and initialize the <a href="ODC.html">
Object Data Component</a>
 (ODC) to provide simplified, high-performance access to object data.</li>
 
</ol>
 A batch file to start a datahub running as a DMH, DCC, and EPC server in 
the foreground, looks something like this: <br>
&nbsp; 
<dl>
<dd> <tt>start dmh_wish -tclargs "proc start args {} ; proc goto args {}
; source startup.bat"</tt></dd>
  <dd> <tt>goto EndOfTcl</tt></dd>
    <dd> <tt>#</tt></dd>
      <dd> <tt>set group APC</tt></dd>
        <dd> <tt>set connect "connect MYDB scott tiger"</tt></dd>
          <dd> <tt>exec datahub83 "set group=$group" "set server=HUB" eof
&amp;</tt></dd>
            <dd> <tt>exec dmh_SQLsrv "set group=$group" "set server=DB" $connect
eof "eval wm iconify ." &amp;</tt></dd>
              <dd> <tt>mbx init $group 4</tt></dd>
                <dd> <tt>mbx putr HUB TRACE {eval package require HumeDCC
; dc_hub_init DB SYBASE}</tt></dd>
                  <dd> <tt>mbx putr HUB TRACE {eval package require HumeEPC
; ep_hub_init EPC DB SYBASE}</tt></dd>
                    <dd> <tt>mbx end</tt></dd>
                      <dd> <tt>exit</tt></dd>
                        <dd> <tt>#</tt></dd>
                          <dd> <tt># \</tt></dd>
                            <dd> <tt>:EndOfTcl</tt></dd>
                              </dl>
  
                              <p><br>
The above batch file is appropriate for development.&nbsp; A production server
is usually started as a service or background process. </p>
                              <h2> EPC&nbsp;<a name="Client"></a>
 Client Integration</h2>
 Typically, the EPC server logic receives DMH messages from client software, 
and processes them.&nbsp; These messages are conceptually event inputs.&nbsp; 
The DMH mailbox name used by the EPC server to receive these messages is specified
during initialization as an argument to the <a href="#ep_hub_init">ep_hub_init</a>
 procedure; the value defaults to <b>equip_box</b>.&nbsp; The event input 
messages are not SQL or Tcl commands; they are either formatted as Tcl lists
of alternating name and value elements, or they are formatted as SEMATECH
standard VFEI text.&nbsp; See the detailed specification <a href="#epc_message_formats">
below</a>
 .&nbsp; Almost always, the EPC server logic is run in a process such as a
Datahub that receives and processes SQL messages using a different DMH mailbox
than the EPC server mailbox.&nbsp; The SQL command mailbox processing gives
you the ability to manage the in-memory tables and status of the EPC server
using the <a href="../man1/hubclient.html">hubclient</a>
 application. 
                              <p>You are not required to use the DMH message
system as the input source for the EPC.&nbsp; By initializing the EPC mailbox
value to an empty string, the EPC receives and processes input "messages"
that are added to an in-memory queue using the <a href="#ep_post_event">ep_post_event</a>
 command. </p>
                              <p>The Hume GEM Host and GEM supervisor applications
are able to send VFEI alarm and event report messages to the EPC DMH mailbox.&nbsp;
To demonstrate this capability: </p>
                              <ol>
 <li> Start the application with an additional command line argument such
as <tt>"set MB_GROUP APC" </tt>to specify the DMH message system group name.&nbsp; 
If using the supervisor, configure and start a Host interface for your equipment.</li>
  <li> Check that the varvalue of the VFEI_OUTPUT_MAILBOX record in the ei_variable 
table is the mailbox name used by the EPC server.&nbsp; The default VFEI_OUTPUT_MAILBOX 
varvalue is "equip_box".</li>
  <li> Use the Host User Interface to define some VFEI reports such as a
report whenever the process state changes.</li>
  <li> Press the Initialize button to setup the event reports.</li>
  <li> Exercise the equipment in order to have it send some event reports
or alarms.</li>
  <li> Display the contents of the ep_event_log table in the EPC server process.&nbsp; 
By default, logging of events is enabled.</li>
 
                              </ol>
 Generally, the EPC server processes event messages that are sent to it by
client processes.&nbsp; Any of the DMH message system client software libraries
can be used to send the event messages to the mailbox name that the EPC is
using to receive.&nbsp; From within the EPC process, you are able to post
event messages to the EPC server using the Tcl procedure <a href="#ep_post_event">
ep_post_event</a>
 . <br>
&nbsp; 
                              <h2> Event Processing&nbsp;<a name="Overview"></a>
 Overview</h2>
 Here is the processing flow of event messages when they are received by the
EPC server.&nbsp; The role of the EPC configuration table records is indicated
as the processing flow is described. 
                              <p>As the event message is received, the timestamp
for the event, TS_EVENT,&nbsp; is obtained by executing "<a href="../mann/localtime.html">
 localtime</a>
 16".&nbsp; If the event message format is VFEI, the message is converted 
to the alternating name and value Tcl list format by the <a href="#ep_vfei_2_namevals">
ep_vfei_2_namevals</a>
&nbsp;&nbsp; procedure.&nbsp; At this point, the TS_EVENT value and the optional
message reply mailbox, mbxreply, are added to the event name-value list. </p>
                              <p>Now that the event data is in standard format,
the matching and mapping stage of processing begins using the records in
the <a href="#ep_input">ep_input</a>
 table.&nbsp; If there is already a machine identifier, MID, associated with
the event, the class of the machine is looked up to determine which table
records to use.&nbsp; If there is no MID, or the MID class has not been configured,
the machine class of "*" is used.&nbsp; The <b>ep_input</b> table records
for the machine class are selected and tested in ascending order by rank.&nbsp;
The first record found, where the event pattern and the data criteria match
the input event, is used.&nbsp; If there is no matching record, the event
passes to the next stage of processing unchanged.&nbsp; The matching record
can optionally specify a mapping or transformation of the event_id.&nbsp;
If the event_id is mapped to an empty string, the event is discarded.&nbsp;
If the event_id is changed, the original event_id value is added to the event
data with the name event_id_raw.&nbsp; Next, the record can optionally specify
a mapping or transformation of the MID value.&nbsp; If the MID value is changed,
the original MID value is added to the event data with the name MID_raw.&nbsp;
Next, the ep_input table record can optionally specify application logic
(field rule_logic) to be executed after the event_id and MID are possibly
mapped.&nbsp; Note that this logic is executed independent of state; so the
ep_input table is the place to configure application logic that is always
executed when particular events are received. </p>
                              <p>The next stage of event processing is for
state-dependent logic and optional triggering of state transitions using
the records in the <a href="#ep_input_rules">ep_input_rules</a>
 table.&nbsp; You may have changed the MID in the previous stage so the MID
class and current state are looked up for the current MID value.&nbsp; The
MID class is found as the MID attribute, MID(<i>MID</i>.class) and the state
is found as the MID attribute, MID(<i>MID</i>.state).&nbsp; These values
are stored in the <a href="ODC.html#od_attribute">od_attribute</a>
 table and accessed as global data as explained with the <b>od_attribute</b>
 table description.&nbsp; A selection is made from the <b>ep_input_rules</b>
 table for rows that match the MID class and current state.&nbsp; The first 
row found where there is a match between the record <i>event_pattern</i> value
and the current <i>event_id</i> is used.&nbsp; The <i>rule_logic</i> field
value is executed for the matching table record.&nbsp; The return value from
executing the <i>rule_logic</i> is examined.&nbsp; If the return value is
one of the values found in the <i>next_state_list</i> field of the record,
the return value initiates a state transition to the returned state value,
even if it is the same as the current state value. </p>
                              <p>At this point, if there is any active tracing
of the EPC logic, or if the MID(<i>MID</i>.DoEventLogging) attribute value
is 1, a record is added to the <a href="#ep_event_log">ep_event_log</a>
 table.&nbsp; Tracing occurs when the value of the MID(<i>MID</i>.EventTraceBits)
attribute is non-zero.&nbsp; If you are not configuring the MID(<i>MID</i>
 .EventTraceBits) attribute value for individual machines, the default value
of MID(EventTraceBits) is used. </p>
                              <p>The following logic applies if a state transition
has been initiated.&nbsp; If the destination state is different than the
current state, and MID(MID.DoStateLogging) is non-zero, a record is added
to the <a href="#ep_state_log">ep_state_log</a>
 table.&nbsp; Next, all of the matching records from the <a href="#ep_transition_rule">
ep_transition_rule</a>
 table for the MID_class are processed, in ascending order by rank.&nbsp; 
The rule_logic values of the matching records are executed.&nbsp; At the time
of execution, the current state of the MID has already been set to the new
value. </p>
                              <p>For a non-VFEI message, if a non-blank reply
mailbox is associated with the event, the final name-value list is sent as
a reply message. </p>
                              <p>For a VFEI message that requests a reply,
the EPC logic is able to create the standard VFEI CMD_ACK or REQ_QUERY reply
message and send it.&nbsp; You can send other reply formats if needed from
the application rule_logic code. <br>
&nbsp; </p>
                              <h3> Event Processing&nbsp;<a name="errorhandling"></a>
 Error Handling</h3>
 The above paragraphs describe the flow of event processing without mentioning 
how errors are handled.&nbsp; The usual situation for an active deployment 
where development is occurring is that errors will be routinely encountered.&nbsp; 
Here is how they are handled. <br>
&nbsp; 
                              <ol>
 <li> If the EPC cannot interpret an input message as either VFEI or as a
properly composed name-value list, the message is converted to an Error Event
with the event_id of ERROR_REPORT.EPC_INPUT.</li>
  <li> If the input message seems to be VFEI but then is found to be improper, 
it is converted to an Error Event with the event_id of ERROR_REPORT.EPC_VFEI_INPUT.</li>
  <li> If an error is encountered when evaluating a data_criteria expression
from the ep_input table, an additional event with the event_id of ERROR_REPORT.EPC_DATA_CRITERIA 
is posted.</li>
  <li> If an error is encountered when evaluating an event_mapping <a href="../mann/subst.html">
subst</a>
 expression from the ep_input table, an additional event with the event_id 
of ERROR_REPORT.EPC_EVENT_MAPPING is posted.</li>
  <li> If an error is encountered when evaluating an MID_mapping <a href="../mann/subst.html">
subst</a>
 expression from the ep_input table, an additional event with the event_id 
of ERROR_REPORT.EPC_MID_MAPPING is posted.</li>
  <li> If an error is encountered when evaluating a rule_logic value from
the <a href="#ep_input">ep_input</a>
 table, an additional event with the event_id of ERROR_REPORT.EPC_INPUT_LOGIC
is posted.</li>
  <li> If an error is encountered when evaluating a rule_logic value from
the <a href="#ep_input_rules">ep_input_rules</a>
 table, an additional event with the event_id of ERROR_REPORT.EPC_RULE_LOGIC
is posted.</li>
  <li> If an error is encountered when evaluating a rule_logic value from
the <a href="#ep_transition_rule">ep_transition_rule</a>
 table, an additional event with the event_id of ERROR_REPORT.EPC_TRANSITION_RULE
is posted.</li>
 
                              </ol>
 To prevent a runaway cycle of posting errors, additional error events are 
                              <b>not</b> posted if they occur during the
processing of an error event.&nbsp; So if you have an error in your handling
of error events, you will not get additional error events, but you can review
the original error events, and their trace information in the ep_event_log.&nbsp;
When trace information is collected and displayed with the traceview application,
the presence of errors is made obvious using color highlighting of the traced
data. <br>
&nbsp; 
                              <h3> Startup and Shutdown Events</h3>
 As the EPC Server starts up, it generates the EVENT_REPORT.EPC_STARTUP event.&nbsp;
This event is always the first event processed after startup.&nbsp; You can
use this event to trigger application logic.&nbsp; When the EPC Server is
told to shutdown, the last event processed is the EVENT_REPORT.EPC_SHUTDOWN. 
                              <br>
&nbsp; 
                              <h2> <a name="ConfigurationSummary"></a>
Configuration Summary</h2>
  
                              <h3> Data Items</h3>
  <br>
                              <table border="1" width="100%">
 <caption><br>
                                </caption><tbody>
 
                                </tbody>  <tbody>
                                  <tr>
 <td><b>Data Item</b></td>
  <td><b>Default</b></td>
  <td><b>Description</b></td>
 </tr>
  <tr>
 <td>EPC input mailbox</td>
  <td>equip_box</td>
  <td>The DMH mailbox used by the EPC server to receive event messages.&nbsp; 
The value is set in the call to <a href="#ep_hub_init">ep_hub_init</a>
 which is coded on the command line or in a startup script.&nbsp; If the value
is set as an empty string, the EPC logic receives and processes "messages" 
that are posted to an in-memory queue data structure using the <a href="#ep_post_event">
ep_post_event</a>
 procedure.</td>
 </tr>
  <tr>
 <td>global EPC&nbsp; <br>
EPC(EventLogInterval)</td>
  <td>600</td>
  <td>As new entries are added to the in-memory ep_event_log table, records 
that are older than this number of seconds are deleted.&nbsp; These deletions 
do not affect optional saving of these table records in a persistent database.&nbsp; 
                                    <p>The data item value is stored in the
od_attribute table, item_type='EPC', item_id='*', attribute='EventLogInterval'.</p>
                                    </td>
 </tr>
  <tr>
 <td>global EPC&nbsp; <br>
EPC(StateLogInterval)</td>
  <td>600</td>
  <td>As new entries are added to the in-memory ep_state_log table, completed 
state transition records that are older than this number of seconds are deleted.&nbsp;
These deletions do not affect optional saving of these table records in a
persistent database.&nbsp; 
                                    <p>The data item value is stored in the
od_attribute table, item_type='EPC', item_id='*', attribute='StateLogInterval'.</p>
                                    </td>
 </tr>
  <tr>
 <td>global MID&nbsp; <br>
MID(DoEventLogging)</td>
  <td>1</td>
  <td>This item controls whether ep_event_log records are created for events 
for machines in the case of machines that do not have their own values of
this attribute.&nbsp; A separate item, SaveEventLogging, controls whether 
the persistent database saves the log entries.&nbsp; 
                                    <p>The data item value is stored in the
od_attribute table, item_type='MID', item_id='*', attribute='DoEventLogging'.</p>
                                    </td>
 </tr>
  <tr>
 <td>global MID&nbsp; <br>
MID(DoStateLogging)</td>
  <td>1</td>
  <td>This item controls whether ep_state_log records are created for state 
transitions for machines in the case of machines that do not have their own
values of this attribute.&nbsp; A separate item, SaveStateLogging, controls
whether the persistent database saves the log entries.&nbsp; 
                                    <p>The data item value is stored in the
od_attribute table, item_type='MID', item_id='*', attribute='DoStateLogging'.</p>
                                    </td>
 </tr>
  <tr>
 <td>global MID&nbsp; <br>
MID(EventTraceBits)</td>
  <td>0</td>
  <td>Trace data collection can be controlled per machine instance by setting 
the value of MID(mid.EventTraceBits).&nbsp; Similar to other attributes, the
value of MID(EventTraceBits) is read and used if a value has not been specifically
configured for the machine.&nbsp; As the name suggests, the configured value
is intended to support the bitwise choice of traced data content.&nbsp; However,
for the current software, options are minimal and we suggest you configure
the value 15 when tracing is desired, and 0 when it is not.&nbsp; The traceview
application script (traceview.bat) is used to connect to the EPC server and
display trace data.&nbsp;</td>
 </tr>
  <tr>
 <td>global MID&nbsp; <br>
MID(SaveEventLogging)</td>
  <td>0</td>
  <td>This item controls whether ep_event_log records are created in a manner 
such that the persistent database will save them.&nbsp; Similar to other attributes,
the value of MID(SaveEventLogging) is read and used if a value has not been
specifically configured for a machine.&nbsp; 
                                    <p>The data item value is stored in the
od_attribute table, item_type='MID', item_id='*', attribute='SaveEventLogging'.</p>
                                    </td>
 </tr>
  <tr>
 <td>global MID&nbsp; <br>
MID(SaveStateLogging)</td>
  <td>1</td>
  <td>This item controls whether ep_state_log records are created in a manner 
such that the persistent database will save them.&nbsp; Similar to other attributes,
the value of MID(SaveStateLogging) is read and used if a value has not been
specifically configured for a machine.&nbsp; 
                                    <p>The data item value is stored in the
od_attribute table, item_type='MID', item_id='*', attribute='SaveStateLogging'.</p>
                                    </td>
 </tr>
  <tr>
 <td>global MID&nbsp; <br>
MID(class)</td>
  <td>*</td>
  <td>This value is the machine class for un-configured machines.&nbsp; 
                                    <p>The data item value is stored in the
od_attribute table, item_type='MID', item_id='*', attribute='class'.</p>
                                    </td>
 </tr>
  <tr>
 <td>global MID&nbsp; <br>
MID(state)</td>
  <td>Unknown</td>
  <td>This value is the current state for machines that do not have a state 
attribute.&nbsp; 
                                    <p>The data item value is stored in the
od_attribute table, item_type='MID', item_id='*', attribute='state'.</p>
                                    </td>
 </tr>
 
                                </tbody>
                              </table>
  
                              <h3> Table Entries</h3>
  <br>
                              <table border="1" width="100%">
 <caption><br>
                                </caption><tbody>
 
                                </tbody>  <tbody>
                                  <tr>
 <td><b>Table</b></td>
  <td><b>Description</b></td>
 </tr>
  <tr>
 <td><a href="ODC.html#od_assoc">od_assoc</a>
                                    </td>
  <td>Associations among items.&nbsp; Definitions of the types of table items 
that are supported for simplified access as global data.&nbsp; Read the table
reference information, and take advantage of the simplified access as global
data.</td>
 </tr>
  <tr>
 <td><a href="ODC.html#od_attribute">od_attribute</a>
                                    </td>
  <td>Attributes of user defined entities such as machines and lots.&nbsp; 
Read the table reference information, and take advantage of the simplified 
access as global data.</td>
 </tr>
  <tr>
 <td><a href="#ep_input">ep_input</a>
                                    </td>
  <td>Filtering and mapping of events.&nbsp; Application logic which is executed 
independent of state.&nbsp;</td>
 </tr>
  <tr>
 <td><a href="#ep_input_rules">ep_input_rules</a>
                                    </td>
  <td>State dependent logic.&nbsp; The triggering of state transitions.</td>
 </tr>
  <tr>
 <td><a href="#ep_transition_rule">ep_transition_rule</a>
                                    </td>
  <td>Application logic that is to be executed as a consequence of state transitions.</td>
 </tr>
  <tr>
 <td><a href="#ep_subscription">ep_subscription</a>
                                    </td>
  <td>A list of Datahub table subscriptions to open in order to capture data 
change events.</td>
 </tr>
 
                                </tbody>
                              </table>
  
                              <h3> Custom Tcl Code</h3>
 Without any custom code you can log events and state transitions.&nbsp; However,
the real power of the EPC component is to serve as a productive tool for
executing your custom logic.&nbsp; You are able to add custom Tcl code to
table records in the ep_input, ep_input_rules, and ep_transition_rule tables.&nbsp;
You are able to have any Tcl code in the table records; multiple programming
statements are useable separated by semicolon characters.&nbsp; You are able
to choose to whether to call your own procedures with arguments, to directly
code programming statements, or to mix both approaches.&nbsp; Your code has
access to the data of the current event by using the array name <b>event</b>
 to access it.&nbsp; The named items in the current event data are accessible
as the elements of the <b>event( )</b> array.&nbsp; For example, a call to
your own procedure, <b>myproc</b>, with the name of the current machine,
looks like this: 
                              <blockquote><tt>myproc $event(MID)</tt></blockquote>
 Here is a summary of the execution context details for your custom logic: 
                                <ol>
 <li> <b>event( )</b> is usable as an array with the subscripts being the
names of the data items in the current event data.&nbsp; So $event(MID) refers 
to the machine name.</li>
  <li> MID is already declared a global array.&nbsp; So&nbsp; $MID($event(MID).state) 
refers to the current value of the machine's attribute, state.</li>
  <li> Use "upvar event event" to access the event( ) array from within a
called procedure.</li>
  <li> Use $event(name_value_list) to access the complete set of name value
items for the event.</li>
  <li> If you write to <b>event(<i>name</i>) <i>value</i></b>, you change
the data seen by subsequent processing.&nbsp; You will be writing the new
name value pair <b><i>name value</i></b>.</li>
  <li> Because of the way variable tracing is implemented, there are certain
Tcl commands such as unset or incr that will not work on the event( ) array 
elements until they are read or written to.&nbsp; The act of reading the variables
is seen by the trace logic, and it is the trace logic that creates actual
array elements.&nbsp; Once the array elements actually exist, they can be
acted upon by unset, incr, or other commands that test for array element
existence before actual use.</li>
 
                                </ol>
 When you add new Tcl procedures in files, you need to rebuild the tclIndex 
file in the directory containing the changed files.&nbsp; Usually you have 
a Makefile and type "make" or "nmake" in the directory - look in the <b>epc</b>
 directory for an example. 
                                <p>The tclIndex file changes are not seen
by running processes.&nbsp; When you are actively developing new code and
working with a running process, the easiest way to make sure it is using
your new procedures and your new changes, is to use the <a href="../mann/source.html">
source</a>
 command and explicitly load the revised files into the process.&nbsp; When
the EPC is running on a different computer or in the background, you can
use the <a href="../man1/dmh_inspect.html">inspect</a>
 or <a href="../man1/hubclient.html">hubclient</a>
 applications to get a command prompt in order to enter the source command. 
                                <br>
&nbsp; </p>
                                <h2> Runtime&nbsp;<a name="Logging"></a>
 Logging &amp; Diagnostics</h2>
 During development you should have the EPC(EventTraceBits) set to a non-zero 
value such as 15, and you should be using the traceview application to monitor
your new logic for errors. <br>
&nbsp; 
                                <h2> <a name="StateModeling"></a>
State Modeling</h2>
 You assign states to a "machine" for the intervals in which actual time is
spent waiting for another event or condition.&nbsp; When we diagrammed our
example Craps application, we put in states for winning and losing.&nbsp;&nbsp; 
As we implemented the logic, we realized that winning and losing affected 
how the bet logic was calculated but the game never spent any time in a losing
or winning state. 
                                <p>We suggest that the state diagram and
flow implied by the records in the ep_input_rules should be for the "politically-correct"
state diagram that appears in documentation and standards.&nbsp; But the
reality of finite state machine logic is that you may get an event in any
state that tells you that communication is lost or the remote machine has
shutdown.&nbsp; In general, you may not want to diagram the truth; that there
are several "bad" transitions from any state.&nbsp; What you can do is to
react to the handful of "bad" events in the ep_input record, and make your
own procedure calls to force state transitions and invoke cleanup code.&nbsp;
We think this is cleaner to implement and maintain.&nbsp; It leaves the state
transition diagram implied by the ep_input_rules table understandable, and
amenable to neat diagrams and real-time animation. <br>
&nbsp; </p>
                                <h2> <a name="SampleApp"></a>
A Sample Application</h2>
 We have created an example application to demonstrate usage of the EPC.&nbsp; 
The example application is an automated Craps game with tracking of different 
players, and their betting.&nbsp; The application builds up from the use of
a pair of automated dice (pairodice.bat, Pairodice.itcl, die.itk, dice.wav).&nbsp; 
The dice have a visual and sonic representation to create an interesting demonstration.&nbsp;
The dice software does not have any knowledge of the game of Craps.&nbsp;
The rules of the game, and the state transitions representing the game are
only represented in the EPC.&nbsp; Similarly, status information such as
the wagers that have been won and lost are tracked in the EPC as attribute
data.&nbsp; By using the ep_timer class, a periodic event is created which
is used as a trigger to calculate the rates at which the dice are being rolled.&nbsp;
The application procedures used in the EPC table entries are coded in the
file CrapsDemo.tcl. 
                                <p> </p>
                                <hr width="100%"> 
                                <h2> <a name="ServerAPI"></a>
Server API</h2>
 In this section of the document, the more important procedures used by the
EPC are presented, along with procedures that you can use in your application 
logic.&nbsp; All of the API procedures are currently in the usual Tcl global 
namespace.&nbsp; The procedures can be used by a Tcl/Tk process after executing 
"package require HumeEPC". <br>
 
                                <hr width="100%"> <br>
                                <a name="ep_event_log_proc"></a>
                                <font size="+1"><b>ep_event_log</b> - add
log records to the ep_event_log table.</font> 
                                <p><b>Tcl Command Syntax</b> </p>
                                <blockquote><b>ep_event_log <i>event_id MID
TS_EVENT MID_state name_value_list</i></b></blockquote>
 <b>Return Value</b> 
                                  <blockquote><b>None</b></blockquote>
 <b>Description</b> 
                                    <blockquote>This procedure is used by
the EPC server to create <a href="#ep_event_log">ep_event_log</a>
 entries.&nbsp; It can be called from your application logic to create additional 
log entries, or it can be customized by you.&nbsp; The source is in the file
ep_event_log.tcl.&nbsp; When called by the EPC logic, the arguments are the
context data items for the event.</blockquote>
  
                                      <hr width="100%"> <br>
                                      <a name="ep_hub_init"></a>
                                      <font size="+1"><b>ep_hub_init</b>
- framework initialization for the EPC server.</font> 
                                      <p><b>Tcl Command Syntax</b> </p>
                                      <blockquote><b>ep_hub_init {<i>MB_EPC</i>
 equip_box} {<i>MB_DB</i> DB} {<i>DBtype</i> SYBASE}</b></blockquote>
 <b>Return Value</b> 
                                        <blockquote><b>"Event Processing
Component Initialized Successfully." </b>is returned for the usual successful
case. 
                                          <p>The procedure will return a
Tcl error if the system cannot be initialized.</p>
                                          </blockquote>
 <b>Description</b> 
                                          <blockquote>This is the entry procedure
to initialize the EPC server framework and then run the server engine.&nbsp;
The call initiates the following processing: 
                                            <ol>
 <li> Creating the in-memory EPC table schema</li>
  <li> Creating the persistent database table schema if needed</li>
  <li> Loading "first-time" data if a new EPC instance is being created</li>
  <li> Loading startup data from the persistent database or .tab files</li>
  <li> Initializing the simplified access to persistent attribute and association 
data.</li>
  <li> Setting up table subscriptions to keep the in-memory log tables finite 
sized</li>
  <li> Calling the ep_server_init procedure to startup the EPC processing
logic.</li>
 
                                            </ol>
 The first argument to the ep_hub_init procedure is <i>MB_EPC</i>, the DMH 
mailbox name that the EPC should use to receive event messages.&nbsp; If the
mailbox name is specified as an empty string, the EPC logic does not read
from a DMH message system mailbox for its input.&nbsp; In this case, the
EPC processes input messages that are added to a queue data structure using
the <a href="#ep_post_event">ep_post_event</a>
 command. 
                                            <p>The <i>MB_DB</i> argument
is the DMH mailbox of the persistent database interface.&nbsp; If a persistent
database is not being used, the <i>MB_DB</i> argument value should be an
empty string.&nbsp; The optional DBtype arguments specifies the type of persistent
database in use, such as DB2, ORACLE, or SYBASE.&nbsp; For the most part
the logic uses portable SQL but there are some differences between database
field types and error replies that the software must accommodate.</p>
                                            </blockquote>
  
                                            <hr width="100%"> <br>
                                            <a name="ep_namevals"></a>
                                            <font size="+1"><b>ep_namevals_del</b>
 - Delete named items from a name value list.</font> <br>
                                            <font size="+1"><b>ep_namevals_diff</b>
 - Analyze the difference between two name value lists.</font> <br>
                                            <font size="+1"><b>ep_namevals_get</b>
 - Retrieve a named item from a name value list.</font> <br>
                                            <font size="+1"><b>ep_namevals_insert</b>
 - Add an item to a name value list.</font> <br>
                                            <font size="+1"><b>ep_namevals_nev</b>
 - Convert a name value list to a name="value" string.</font> <br>
                                            <font size="+1"><b>ep_namevals_pop</b>
 - Retrieve and remove a named item from a name value list.</font> <br>
                                            <font size="+1"><b>ep_namevals_set</b>
 - Add or update a named item in a name value list.</font> <br>
                                            <font size="+1"><b>ep_namevals_update</b>
 - Change the value of a named item in a name value list.</font> <br>
&nbsp; 
                                            <p><b>Tcl Command Syntax</b> </p>
                                            <blockquote><b>ep_namevals_del
                                              <i>name_value_list</i> [<i>
 name</i>]+</b> <br>
                                              <b>ep_namevals_diff <i>name_value_list_A</i>
 <i>name_value_list_B</i></b> <br>
                                              <b>ep_namevals_get <i>name_value_list</i>
 <i>name </i>{<i>not_found</i> {}}</b> <br>
                                              <b>ep_namevals_insert <i>name_value_list</i>
 [<i>name value</i>]+</b> <br>
                                              <b>ep_namevals_nev <i>name_value_list</i>
 {<i>join_string</i> { }}</b> <br>
                                              <b>ep_namevals_pop <i>name_of_name_value_list</i>
 <i>name </i>{<i>not_found</i> {}}</b> <br>
                                              <b>ep_namevals_set <i>name_value_list</i>
 [<i>name value</i>]+</b> <br>
                                              <b>ep_namevals_update <i>name_value_list</i>
 [<i>name value</i>]+</b></blockquote>
 <b>Return Value</b> 
                                              <blockquote><b>ep_namevals_del
: <i>revised_name_value_list</i></b> <br>
                                                <b>ep_namevals_diff: <i>list_added_removed_changed</i></b>
 <br>
                                                <b>ep_namevals_get: <i>value</i></b>
 <br>
                                                <b>ep_namevals_insert : <i>
revised_name_value_list</i></b> <br>
                                                <b>ep_namevals_nev: [<i>name</i>
 ="<i>value</i>"]*</b> <br>
                                                <b>ep_namevals_pop: <i>value</i></b>
 <br>
                                                <b>ep_namevals_set: <i>revised_name_value_list</i></b>
 <br>
                                                <b>ep_namevals_update: <i>
revised_name_value_list</i></b></blockquote>
 <b>Description</b> 
                                                <blockquote>These are procedures
that facilitate working with Tcl lists containing alternating name and value
elements.&nbsp; The lists always contain an even number of elements.&nbsp;
These procedures are used on your behalf by the EPC logic to modify event
data which is passed in the alternating name and value format. 
                                                  <p>The <b>ep_namevals_set</b>
 procedure is similar to an assignment statement.&nbsp; It will add new <i>
name value</i> elements to a list, or update the values if they already exist.&nbsp;
The procedure <b>ep_namevals_insert</b> is used to add <i>name value</i>
elements to a list only if there is not already an existing value for the
named items.&nbsp; The procedure&nbsp; <b>ep_namevals_update</b> is used
to modify existing named values without adding new elements. </p>
                                                  <p>The procedure <b>ep_namevals_del</b>
 is used to delete named items from a list. </p>
                                                  <p>The procedure <b>ep_namevals_get</b>
 searches a list for a named value and returns it, or returns the value of
the argument <i>not_found</i> if the named item is not found.&nbsp; The procedure
can also be used to test if a named item exists in a name value list. </p>
                                                  <p>The procedure <b>ep_namevals_pop</b>
 is called with the name of the <i>name_value_list</i> and not its value.&nbsp;
The procedure removes the named value from the list, changing the <i>name_value_list</i>
 by reference using the Tcl upvar command.&nbsp; The return value of procedure
is the value of the named item, or the value of the argument <i>not_found</i>
 if the named item is not found. </p>
                                                  <p>The procedure <b>ep_namevals_diff</b>
 compares two <i>name_value_list</i> arguments and returns a three element
list of differences.&nbsp; The three elements of the return value are name_value_lists
for the items added, the items removed, and the items that have changed values
in going from the first input argument to the second. </p>
                                                  <p>The procedure <b>ep_namevals_nev</b>
 converts the input <i>name_value_list</i> into a string of <i>name</i>="<i>
 value</i>" terms.&nbsp; Imbedded quotes in values are escaped with backslash
characters.&nbsp; The default separation of each term in the result is a
single space character.&nbsp; You are able to specify a different separation
string as the <i>join_string</i> argument. <br>
&nbsp; <br>
&nbsp;</p>
                                                  </blockquote>
  
                                                  <hr width="100%"> <br>
                                                  <a name="ep_post_event"></a>
                                                  <font size="+1"><b>ep_post_event</b>
 - Post an event to the EPC server mailbox.</font> 
                                                  <p><b>Tcl Command Syntax</b>
 </p>
                                                  <blockquote><b>ep_post_event
                                                    <i>name_value_list </i>
{<i>mbxreplybox </i>{}}</b></blockquote>
 <b>Return Value</b> 
                                                    <blockquote><b>None</b></blockquote>
 <b>Description</b> 
                                                      <blockquote>See the
description of acceptable <a href="#epc_message_formats">EPC server message
formats</a>
 .&nbsp; Events that are posted to the EPC server are queued to the EPC server's
DMH command mailbox, or to the EPC's input queue, and they are processed
in the sequence of posting&nbsp; You should not supply the TS_EVENT timestamp
item with an event unless you have made provision to guarantee unique values. 
                                                        <p>When the EPC server's
DMH command mailbox is an empty string,&nbsp; the EPC logic does not read
from a DMH message system mailbox for its input, it uses a queue data structure.&nbsp;
In this situation you can setup your own mailbox to receive messages from
DMH clients and add them to the EPC input queue data structure.&nbsp; You
only need to combine the mbx and ep_post_event commands to do this.&nbsp;
We have created a simple procedure, <b>mbx_EPC</b>, as a "macro" to perform
this function. </p>
                                                        <blockquote>&nbsp;&nbsp;
# a "macro" to add DMH input to the EPC in-process queue input <br>
&nbsp;&nbsp; # eg.,&nbsp;&nbsp; mbx whenmsg EI_EPC mbx_EPC <br>
&nbsp;&nbsp; proc mbx_EPC { } { <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; global mbxmsg mbxreply <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbx whenmsg again <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ep_post_event $mbxmsg $mbxreply 
                                                          <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</blockquote>
 </blockquote>
  
                                                          <hr width="100%">
 <br>
                                                          <a name="ep_schema_write"></a>
                                                          <font size="+1"><b>
ep_schema_write</b> - Write SQL statements representing the database table
schema to a file.</font> 
                                                          <p><b>Tcl Command
Syntax</b> </p>
                                                          <blockquote><b>
ep_schema_write {filename dc_schema.sql} {DBtype hub}</b></blockquote>
 <b>Return Value</b> 
                                                            <blockquote><b>
None</b></blockquote>
 <b>Description</b> 
                                                              <blockquote>
This procedure calls ep_schema and writes the result to a file with each
create statement being written as a new line of text.</blockquote>
  
                                                                <hr width="100%">
 <br>
                                                                <a name="ep_server_init"></a>
                                                                <font size="+1"><b>
ep_server_init</b> - initialize EPC server logic, receive and process EPC
events.</font> 
                                                                <p><b>Tcl
Command Syntax</b> </p>
                                                                <blockquote><b>
ep_server_init</b></blockquote>
 <b>Return Value</b> 
                                                                  <blockquote><b>
None</b></blockquote>
 <b>Description</b> 
                                                                    <blockquote>
This procedure is called as the last part of the <a href="#ep_hub_init">ep_hub_init</a>
 call.&nbsp; It calls the <b>ep_server_data_init</b> procedure which you can
provide a custom version of, signals the EPC startup by processing the <b>
EVENT_REPORT.EPC_STARTUP</b> event, turns on <a href="#ep_subscription">configured 
table subscription inputs</a>
 , provides for the call to <b>ep_server_shutdown</b> at exit, and calls
                                                                      <b>
ep_server_run</b>.</blockquote>
  
                                                                      <hr width="100%">
 <br>
                                                                      <a name="ep_server_run"></a>
                                                                      <font size="+1"><b>
ep_server_run</b> - continue receiving and processing EPC events.</font> <br>
                                                                      <font size="+1"><b>
ep_server_step</b> - receive and process the next EPC event.</font> <br>
                                                                      <font size="+1"><b>
ep_server_stop</b> - stop receiving and processing EPC events.</font> <br>
                                                                      <font size="+1"><b>
ep_server_shutdown</b> - stop receiving and shutdown the EPC server.</font>
 
                                                                      <p><b>
Tcl Command Syntax</b> </p>
                                                                      <blockquote><b>
ep_server_run</b> <br>
                                                                        <b>
ep_server_step</b> <br>
                                                                        <b>
ep_server_stop</b> <br>
                                                                        <b>
ep_server_shutdown</b></blockquote>
 <b>Return Value</b> 
                                                                        <blockquote><b>
None</b></blockquote>
 <b>Description</b> 
                                                                          <blockquote>
The <b>ep_server_run</b> procedure is normally called from the <b>ep_server_init</b>
 procedure.&nbsp; It causes the EPC server to receive messages that are directed
to the $dc_hub(MB_EPC) DMH mailbox.&nbsp; The <b>ep_server_stop</b> procedure
can be used to stop the reception of input event messages.&nbsp; When reception
has been stopped, it can be done one event message at a time using the ep_server_step
call.&nbsp; Continual receiving and processing is resumed using the <b>ep_server_run</b>
 call.&nbsp; The <b>ep_server_shutdown</b> procedure is ordinarily executed
as part of processing the exit command.&nbsp; When this call is made, further
message input is not received.&nbsp; The EPC logic is then made to process
the <b>EVENT_REPORT.EPC_SHUTDOWN</b> event message.&nbsp; It does no good
to post additional events from your handling of this event since further
message input is not received.&nbsp; The <b>ep_server_shutdown</b> procedure
has some logic to wait if needed until the feed of messages to the persistent 
database has caught up, or has been diagnosed as being unresponsive.</blockquote>
  
                                                                            <hr width="100%">
 <br>
                                                                            <a name="ep_state_transition"></a>
                                                                            <b><font size="+1">
ep_state_transition</font></b><font size="+1"> - perform a state transition
and execute matching transition rules</font> <br>
                                                                            <font size="+1"><b>
ep_state_log_transition</b> - record and log a state transition.</font> 
                                                                            <p><b>
Tcl Command Syntax</b> </p>
                                                                            <blockquote><b>
ep_state_transition <i>event_id mid_class mid state next_state name_vals
TS_TRACE</i></b> <br>
                                                                              <b>
ep_state_log_transition <i>event_id mid state next_state ts_entry ts_exit</i></b></blockquote>
 <b>Return Value</b> 
                                                                              <blockquote><b>
None</b></blockquote>
 <b>Description</b> 
                                                                                <blockquote>
The <b>ep_state_transition</b> call is made by the EPC server to process
state transitions and execute matching transition rules as configured in
the ep_transition_rule table.&nbsp; The <b>ep_state_log_transition</b> call
does the core record-keeping and optionally logging of state transitions without
executing matching transition rules.&nbsp; The reality of programming state
machine logic is that the state machine model needs to be "neat" and "politically
correct", but that events such as entities going down can happen in any state.&nbsp;
So the real-world solution is to mix in a judicious amount of heavy-handed
manipulation of the state machine, without trying to accomplish every state
machine transition as part of the regular, configured flow.&nbsp; The <b>
ep_state_log_transition</b> call is the easiest one to make, and it will
set the recorded data and <a href="#ep_state_log">ep_state_log</a>
 records for the new state as if regular processing occurred.&nbsp; The <i>
ts_entry</i> and current <i>state</i> value are usually known from the MID(
) data, so calling the procedure from the rule_logic of an ep_input table
record might look like: 
                                                                                  <pre>ep_state_log_transition $event(event_id) $event(MID) $MID($event(MID).state)\</pre>
  
                                                                                  <pre>&nbsp;&nbsp;&nbsp; "Offline" $MID($event(MID).ts_entry) $event(TS_EVENT)</pre>
 </blockquote>
  
                                                                                  <hr width="100%">
 <br>
                                                                                  <a name="ep_timer"></a>
                                                                                  <font size="+1"><b>
ep_timer</b> - An [incr Tcl] class for periodic or one-shot timing.</font>
 
                                                                                  <p>
See <a href="../mann/ep_timer.html">../mann/ep_timer.html</a>
 <br>
 </p>
                                                                                  <hr width="100%">
 <br>
                                                                                  <a name="ep_trace"></a>
                                                                                  <font size="+1"><b>
ep_trace</b> - Add trace_data to an event.</font> <br>
                                                                                  <font size="+1"><b>
ep_trace_flush</b> - Discard trace_data for an event.</font> <br>
                                                                                  <font size="+1"><b>
ep_trace_final</b> - Final addition of trace_data to an event.</font> 
                                                                                  <p><b>
Tcl Command Syntax</b> </p>
                                                                                  <blockquote><b>
ep_trace <i>ts_event text&nbsp; </i>[<i>text_tag</i>]</b> <br>
                                                                                    <b>
ep_trace_flush <i>ts_event</i></b> <br>
                                                                                    <b>
ep_trace_final <i>ts_event text&nbsp; </i>[<i>text_tag</i>]</b></blockquote>
 <b>Return Value</b> 
                                                                                    <blockquote><b>
None</b></blockquote>
 <b>Description</b> 
                                                                                      <blockquote>
These procedures are used by the EPC server to collect trace data as it processes
events.&nbsp; Trace data is detailed debugging and diagnostic data showing
the flow of processing, including which table records were matched, and the
configuration data that was used such as event_mapping and rule_logic values.&nbsp;
The collection of trace data is normally off, since it greatly expands the
volume of data added to the ep_event_log table.&nbsp; When trace data is
collected, it is written into the trace_data field of the ep_event_log.&nbsp;
This column only exists in the in-memory schema.&nbsp; Trace data collection
can be controlled per machine instance by setting the value of <b>MID(<i>
 mid</i>.EventTraceBits)</b>.&nbsp; Similar to other attributes, the value
of <b>MID(EventTraceBits)</b> is read and used if a value has not been specifically
configured for the machine.&nbsp; As the name suggests, the configured value
is intended to support the bitwise choice of traced data content.&nbsp; However,
for the current software, options are minimal and we suggest you configure
the value 15 when tracing is desired, and 0 when it is not.&nbsp; The traceview
application script (<b>traceview.bat</b>) is used to connect to the EPC server
and display trace data. 
                                                                                        <p>
The <b>ep_trace</b> procedure can be called from your custom procedures to
provide trace data.&nbsp; The <i>ts_event </i>argument is the timestamp of
the current event, $event(TS_EVENT).&nbsp; The text argument is ordinary prose
which may contain tabs and/or newline characters to create a nicely formatted
display.&nbsp; The optional text_tag argument is used to pass highlighting
information to the viewing application.&nbsp; The following tags are used
to indicate the context of trapped errors: </p>
                                                                                        <blockquote>
 <dt> <b>cfg_err</b> - errors with data_criteria evaluation</dt>
  <br>
                                                                                            <b>
map_err</b> - errors with event_mapping or MID_mapping evaluation <br>
                                                                                            <b>
rule_err</b> - errors with rule_logic evaluation <br>
                                                                                            <b>
epc_err</b> - unexpected error within the EPC server code <br>
                                                                                            <b>
fmt_err</b> - improper format of input event data</blockquote>
 The EPC logic has to begin the collection of trace data for an event before 
the MID instance is known, and thus before the configuration of tracing is
known.&nbsp; The <b>ep_trace_flush</b> call is used internally to signal that
tracing of the event is not desired.&nbsp; Trace data is written if ep_flush_trace
is not called, or if your logic calls ep_trace after ep_trace_flush has been
called.&nbsp; When tracing has been configured off, the EPC framework ordinarily
follows the ep_trace_flush call with the ep_trace_final call and writing
of trace data does not occur.</blockquote>
  
                                                                                            <hr width="100%">
 <br>
                                                                                            <a name="ep_vfei_2_namevals"></a>
                                                                                            <font size="+1"><b>
ep_vfei_2_namevals</b> - translate a VFEI message to an EPC name value list.</font>
 
                                                                                            <p><b>
Tcl Command Syntax</b> </p>
                                                                                            <blockquote><b>
ep_vfei_2_namevals <i>vfei_message </i>[<i>ts_trace</i>]</b></blockquote>
 <b>Return Value</b> 
                                                                                              <blockquote><b><i>
name_value_list</i></b></blockquote>
 <b>Description</b> 
                                                                                                <blockquote>
This procedure is used by the EPC server to translate a SEMATECH VFEI 2.2
message format into the EPC alternating name and value list format.&nbsp; 
There is logic in the procedure to check for selected mandatory data items, 
and to supply selected default values.&nbsp; If the message cannot be successfully 
converted, it is converted into an error report name value list with the event_id
of <tt>ERROR_REPORT.EPC_VFEI_INPUT</tt>.&nbsp; If the optional argument <i>
ts_trace</i> is supplied, and the input format is erroneous, the procedure
calls ep_trace to add diagnostic information to the ep_trace_log table record
for the event.&nbsp; The <i>ts_trace</i> argument is passed by the EPC depending
on the value of the configuration item MID(*.EventTraceBits).</blockquote>
  
                                                                                                  <hr width="100%">
 <br>
                                                                                                  <a name="ep_vfei_reply"></a>
                                                                                                  <font size="+1"><b>
ep_vfei_reply</b> - create reply messages for VFEI commands.</font> 
                                                                                                  <p><b>
Tcl Command Syntax</b> </p>
                                                                                                  <blockquote><b>
ep_vfei_reply <i>name_value_list</i></b></blockquote>
 <b>Return Value</b> 
                                                                                                    <blockquote><b><i>
vfei_reply</i></b></blockquote>
 <b>Description</b> 
                                                                                                      <blockquote>
This procedure is used by the EPC server logic to create reply messages for
EPC events that are received in the format of VFEI command messages.&nbsp;
VFEI is a SEMATECH standard format for messages that are used for equipment
integration.&nbsp; This procedure creates the "boilerplate" acknowledgment
message, 
                                                                                                        <p><tt>
CMD/A="CMD_ACK" MID/A="&lt;MID&gt;" MTY/A="R" TID/U4="&lt;TID&gt;" ECD/U4=&lt;ECD&gt; 
ETX/A="&lt;ETX&gt;"</tt> </p>
                                                                                                        <p>
using data items found in the event <i>name_value_list</i>.&nbsp; The command
will prepare a CMD_ACK or RES_LIST reply message.&nbsp; If you are using
VFEI, and supporting the RES_REQUEST or STATUS_QUERY commands, you need to
provide your own application logic to create the more complex RES_TRANSFER,
or STATUS_LIST reply messages, and to send them, and not rely on the built-in
EPC support.&nbsp;&nbsp;&nbsp; When you send your own reply messages, you
remove the "mbxreply" data item from the event <i>name_value_list</i> using
the Tcl unset command so that the EPC logic does not attempt to send a second
reply.</p>
                                                                                                        </blockquote>
  
                                                                                                        <hr width="100%">
 <br>
                                                                                                        <a name="tsdiff"></a>
                                                                                                        <font size="+1"><b>
tsdiff</b> - Computes the time interval between high resolution timestamps.</font>
 
                                                                                                        <p>
See <a href="../mann/tsdiff.html">../mann/tsdiff.html</a>
 </p>
                                                                                                        <p>
The command is often used with the ep_state_log table records to determine 
the elapsed time spent in a state given the entry and exit timestamp values. 
                                                                                                        <br>
 </p>
                                                                                                        <hr width="100%">
 
                                                                                                        <hr width="100%">
 
                                                                                                        <h2>
 <a name="schema"></a>
SQL Table Schema</h2>
 In-memory tables are created in the Tcl/Tk process where the EPC server executes.&nbsp;
A corresponding set of tables is created in the persistent database if one
is used. <br>
 
                                                                                                        <hr width="100%">
 
                                                                                                        <h4>
 <a name="ep_event_catalog"></a>
ep_event_catalog Table - Catalog of Expected Input Events</h4>
 This table is more or less online documentation for the expected event_id 
naming patterns and expected event data attributes.&nbsp; It also shows what
some of the thinking at SEMATECH has been regarding the naming of common
equipment integration events. 
                                                                                                        <p><a name="epc_message_formats"></a>
The EPC accepts text messages sent to its DMH input mailbox which are formatted
as: </p>
                                                                                                        <ul>
 <li> SEMATECH VFEI 2.2 messages starting with the character sequences CMD/A= 
or CMD=.&nbsp; For example,&nbsp;&nbsp; {CMD/A="ALARM_REPORT" MID/A="gemsim"&nbsp; 
MTY/A="E" ECD/U4=0 ETX/A="" ALARM_ID/I4=1000 ALARM_STATE/U1=1 ALARM_TEXT/A="Software 
test alarm 1000"}.&nbsp; The SEMATECH VFEI 2.2 standard is publicly downloadable 
as Technology Transfer document #95113016ATR through <a href="http://www.sematech.org">
www.sematech.org</a>
 .</li>
  <li> A Tcl formatted list consisting of an even number of elements.&nbsp;
There are alternating names and values of event data items.&nbsp; There are
at least two elements.&nbsp; The first element is always the literal text 
                                                                                                            <b>
event_id</b>, and the second element is the value of the event_id such as
ALARM_REPORT.1000.&nbsp; Additional pairs of elements are optionally present
in no particular order.&nbsp; This format is simple to prepare or parse in
different language environments.&nbsp; For example, {event_id ALARM_REPORT.1000
MID gemsim ALARM_ID 1000 ALARM_STATE 1 ALARM_TEXT "Software test alarm 1000"}&nbsp;
Note that Tcl is able to parse text strings that are delimited with braces
or with double quotes.</li>
 
                                                                                                        </ul>
 The rows in the event catalog table show the event types and expected data 
items for the usual event inputs passed by SEMATECH compliant VFEI equipment 
drivers, and high-level software components provided by Hume Integration.&nbsp; 
Other event types can be used just by developing new software that reports 
the new events, or by using the event mapping table entries to configure new
event types.&nbsp; The deployment staff can add rows to this table documenting
new or custom message types.&nbsp; The entries in the table specify the event_id
formats after VFEI messages have been parsed and reformatted as Tcl lists.&nbsp;
Also, there are other context data items that are known and accessible from
application logic in addition to the values shown in this table, such as
the timestamp of the event. <br>
&nbsp; <br>
&nbsp; <br>
                                                                                                        <table border="1" width="100%">
 <caption><br>
                                                                                                          </caption><tbody>
 
                                                                                                          </tbody>
  <tbody>
                                                                                                            <tr>
 <td><b>Column Name</b></td>
  <td><b>Key</b></td>
  <td><b>Type</b></td>
  <td><b>Description</b></td>
 </tr>
  <tr>
 <td>event_type</td>
  <td>PK</td>
  <td>varchar(32)</td>
  <td>A specification of the event_id string used to represent instances of
the event type.&nbsp; In the specification, portions of the event_id that
are supplied by variable substitution are indicated by angle brackets.&nbsp; 
For example, ALARM_REPORT.&lt;ALID&gt;.&nbsp;</td>
 </tr>
  <tr>
 <td>name_items</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(80)</td>
  <td>Variable names that can be used to reference portions of the event_id 
during the processing of event mapping.&nbsp; For example, ALID.&nbsp; In
these contexts, the whole name of the event is accessible using the variable
name event_id.</td>
 </tr>
  <tr>
 <td>data_items</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(1000)</td>
  <td>A list of the names provided in the name value items that are expected 
to be reported with instances of the event.&nbsp; For example, 'MID ALARM_STATE 
ALARM_TEXT'.&nbsp; Names that are often expected but may not be present are
listed surrounded by square brackets; the usual notation for optional arguments.</td>
 </tr>
  <tr>
 <td>description</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(2000)</td>
  <td>A description of what the event and data items typically represent, 
where the events originate, relative standards, etc.</td>
 </tr>
 
                                                                                                          </tbody>
                                                                                                        </table>
  
                                                                                                        <hr width="100%">
 
                                                                                                        <h4>
 <a name="ep_event_log"></a>
ep_event_log Table - History of Events</h4>
 The EPC provides a built-in business rule that can be configured to insert 
records into this table for the purpose of logging event occurrences.&nbsp; 
The design of this table is a compromise which provides a general solution 
with decent performance.&nbsp; We collect the <i>name_value_list</i> data 
that is acquired with events, but it is not stored in a normalized form that
is preferred for ease of lookup and reporting.&nbsp; So we recommend that
you develop your own business rules that log the event data as you see fit.&nbsp;
You may wish to create your own normalized tables.&nbsp; We suggest you look
at the Hume Data Collection Component for collecting important data items
in a normalized format.&nbsp; Also, the DCC supports SPC analysis, charting,
and reporting capabilities. 
                                                                                                        <p>
You should be careful about enabling the saving of event data without having
functionality or procedures in place to eventually delete the acquired data
from the persistent database. </p>
                                                                                                        <p>
As a new event record is added to the table, event records that are older
than $ts_event - $EPC(EventLogInterval) are removed from the in-memory table. 
                                                                                                        <br>
&nbsp; <br>
                                                                                                        <table border="1" width="100%">
 <caption><br>
                                                                                                          </caption><tbody>
 
                                                                                                          </tbody>
  <tbody>
                                                                                                            <tr>
 <td><b>Column Name</b></td>
  <td><b>Key</b></td>
  <td><b>Type</b></td>
  <td><b>Description</b></td>
 </tr>
  <tr>
 <td>ts_event</td>
  <td>PCK</td>
  <td>timestamp</td>
  <td>The high resolution timestamp for the occurrence in the UTC timezone.</td>
 </tr>
  <tr>
 <td>MID</td>
  <td>PCK*</td>
  <td>varchar(32)</td>
  <td>A key in the persistent database where the event time can be duplicated 
in multiple EPC instances.</td>
 </tr>
  <tr>
 <td>event_id</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(32)</td>
  <td>Not part of the key.&nbsp; Because of serialized processing, no two 
events will have the same event time.&nbsp; This is the value of the event_id 
after mapping.</td>
 </tr>
  <tr>
 <td>state_name</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(32)</td>
  <td>The state of the MID at the time of the event occurrence.</td>
 </tr>
  <tr>
 <td>name_value_list</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(2000)</td>
  <td>The list of alternating name and value elements that contains context 
data acquired with the event and added to by business rule processing.&nbsp; 
The logic examines the field length at runtime and if needed removes name 
value pairs when saving to make the collected data fit without corrupting 
its list structure.&nbsp;</td>
 </tr>
  <tr>
 <td>trace_data</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(80000)</td>
  <td>This field only exists in the in-memory schema.&nbsp; It is used to 
hold optionally collected trace data.&nbsp; The column data is formatted as
a Tcl list, consisting of alternating text and tag elements.&nbsp; The tag
elements are optionally non-empty to indicate highlighted text conditions 
such as the presence of errors in the user's executed rule_logic code.&nbsp; 
The <b>traceview</b> application script renders the column data as formatted 
text with color highlights.&nbsp; See the discussion of the <a href="#ep_trace">
ep_trace</a>
 procedure.</td>
 </tr>
  <tr>
 <td>is_ignored</td>
  <td><br>
                                                                                                              </td>
  <td>int</td>
  <td>This column exists only in the in-memory tables.&nbsp; It is used to 
hide deletes from the persistent database when those deletes are performed 
for keeping the number of in-memory rows finite.&nbsp;</td>
 </tr>
 
                                                                                                          </tbody>
                                                                                                        </table>
  </p>
                                                                                                        <hr width="100%">
 
                                                                                                        <h4>
 <a name="ep_input"></a>
ep_input Table - Matching, Filtering, Mapping, and Early Processing of Input
Events</h4>
 The records in this table configure the first stages of event processing;&nbsp; 
consisting of matching inputs, optionally filtering and mapping the event_id 
and MID values, and optionally executing application logic. 
                                                                                                        <p>
The identifier for an event can be mapped to a different identifier.&nbsp; 
For example, EVENT_REPORT.COM_DISABLE can be mapped to the simpler name, COM_DISABLE.&nbsp;
Often, this mapping is used to convert integer identifiers into meaningful
character string identifiers.&nbsp; It is also desirable to convert the SECS
alarm and event identifiers reported by various machines to a common set
of values.&nbsp; For example, it is possible for different Event Reports
from different equipment which have the same meaning to be mapped to same
Event Report identifier.&nbsp;&nbsp; It is also possible for the data of
an event report to be used as part of the mapping criteria.&nbsp; For example,
alarm reports where the data indicates the alarm is set or cleared, can be
mapped to separate alarm set and alarm clear events. </p>
                                                                                                        <p>
Events can also be ignored from further processing by configuring the mapping
of their identifiers to an empty string. </p>
                                                                                                        <p>
Events are associated with machine instances for the purpose of managing state
information and context data.&nbsp; This table can supply default values
for associated machine instances for event reports that do not identify an
associated machine.&nbsp; For example, the EPC can be used to manage business
rule processing associated with production Lot processing.&nbsp; Events and
data that are related to production lots can be associated with a state machine
name such as "SFC" to create a locus for configuration and runtime context. 
                                                                                                        </p>
                                                                                                        <p>
The combination of the event_pattern, MID_class, and data_criteria, is used
to match input events.&nbsp; There can be more than one matching record in
the table.&nbsp; The matching record with the lowest rank value is used.&nbsp;
The MID_class is determined from the MID of the event data if found.&nbsp;
If the MID is not found, or the MID_class is not configured for the found
MID value, default values are used.&nbsp; For the as-shipped configuration,
the default MID value is "*", and the default MID_class value is "*". </p>
                                                                                                        <p>
When mapping of the event_id value occurs, the original event_id value is
added to the event &lt;name value list&gt; with the name "event_id_raw".&nbsp; 
The original event_id may need to be known for debugging and diagnostics, 
and it may be of use to business rules.&nbsp; Similarly if the MID value is
mapped, the original value is preserved with the name MID_raw. </p>
                                                                                                        <p>
At configuration time, the user is guided to configure sets of records for
a particular class of Machine.&nbsp;&nbsp; With the MID mapping feature, it
is possible that the configuration records for a particular MID_class may
affect different MID_classes.&nbsp; This is something to be mindful of. <br>
&nbsp; <br>
                                                                                                        <table border="1" width="100%">
 <caption><br>
                                                                                                          </caption><tbody>
 
                                                                                                          </tbody>
  <tbody>
                                                                                                            <tr>
 <td><b>Column Name</b></td>
  <td><b>Key</b></td>
  <td><b>Type</b></td>
  <td><b>Description</b></td>
 </tr>
  <tr>
 <td>MID_class</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>The class of machines for which the record pertains.</td>
 </tr>
  <tr>
 <td>rank</td>
  <td>PCK</td>
  <td>int</td>
  <td>It is possible for more than one record in this table to match an input 
event.&nbsp; Therefore, the records are examined in sorted order from the 
lowest value of this field to the highest, and the first match is used.&nbsp; 
It is proper to have repeated values in this field - it is used as a priority 
indication and not as a sequencing.&nbsp; The configuration GUI should assign
lower values to records that contain a specific event identifier than to
records containing the wildcard * character.&nbsp;&nbsp; Logically this value
is not a key column of the table and it is not a key in the persistent database.&nbsp;
This row is declared a key column in the in-memory database to take advantage
of the row ordering provided by the keys.&nbsp; Further, values are restricted
to the range from 0 to 9 so that the ordering works correctly when string
comparisons are used.</td>
 </tr>
  <tr>
 <td>event_pattern</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>A specific event name such as EVENT_REPORT.373 or a string matching 
pattern such as ALARM_REPORT.* to be used for matching the input event.</td>
 </tr>
  <tr>
 <td>data_criteria</td>
  <td>PCK*</td>
  <td>varchar(500)</td>
  <td>Events optionally have associated data attributes.&nbsp; The data items 
are accessed as elements of the event( ) array.&nbsp; A Tcl boolean expression 
such as $event(ALARM_STATE) == 1 can be entered into this field to restrict 
the matching of the input events based on the values of associated data attributes.&nbsp;&nbsp;
The expression should conform to the syntax of the Tcl <a href="../mann/expr.html">
expr</a>
 command.&nbsp; Variable names are case sensitive.&nbsp; The data_criteria
expression can also use the global array MID to access machine attributes
as in the example,&nbsp; $MID($event(MID).target) == $event(TOTAL).&nbsp;
The field is declared as part of the table key in the in-memory database
but not in the persistent database.</td>
 </tr>
  <tr>
 <td>description</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(80)</td>
  <td>A user provided comment or description that is viewable when configuring 
input business rules and state machine transition rules.&nbsp;</td>
 </tr>
  <tr>
 <td>event_mapping</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(100)</td>
  <td>The event name to assign to the matched input event for further processing.&nbsp; 
An empty string implies matched events are to be discarded.&nbsp; The value 
= means that the mapped event identifier should be the same as the input value.&nbsp;
A specific string value, such as COM_DISABLE, is typical.&nbsp; If the value
in this field starts with <b>subst </b>followed by a space, the contents
are processed by the Tcl subst command to compute the mapped identifier.&nbsp;
For example, 'subst EVENT_REPORT.[expr $event(ALID) + 1]' could be used to
map the value of an alarm report identifier, ALID, to an event report.&nbsp;</td>
 </tr>
  <tr>
 <td>MID_mapping</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(100)</td>
  <td>The machine identifier to be assigned to the event for further processing.&nbsp; 
The value <b>=</b> means that the mapped value should be the input value.&nbsp;&nbsp; 
If the value in this field starts with <b>subst </b>followed by a space, the
contents are processed by the Tcl subst command to compute the mapped identifier.&nbsp;
The MID_mapping capability is useful for providing an MID when there isn't
one.&nbsp; Another use might be to route events for a complex system to separate
machines that model simpler components of the complex system.</td>
 </tr>
  <tr>
 <td>rule_logic</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(2000)</td>
  <td>Optionally Tcl code that is executed after matching and mapping of the
input event.&nbsp; The code can read or change the event data by reading or
writing values to the array event( ).&nbsp; An example of calling a procedure
with arguments is:&nbsp; 
                                                                                                              <p>
&nbsp; MyEventXInputLogic $event(MID) $event(event_id)&nbsp; </p>
                                                                                                              <p>
From within a called procedure, access to the event( ) array is obtained by
executing "upvar event event".&nbsp; You can also have inline Tcl statements 
such as:&nbsp; </p>
                                                                                                              <p>
&nbsp;&nbsp; set MID($event(MID).state) Unknown&nbsp; </p>
                                                                                                              <p>
The complete set of name value items for the event is accessible through the
array element event(name_value_list).</p>
                                                                                                              </td>
 </tr>
 
                                                                                                          </tbody>
                                                                                                        </table>
  </p>
                                                                                                        <hr width="100%">
 
                                                                                                        <h4>
 <a name="ep_input_rules"></a>
ep_input_rules Table - Logic to execute upon receiving an event in a specific
state</h4>
 This is configuration of the second stage of event processing, where the 
state-dependent logic rules are executed, and state machine transitions are
initiated. <br>
&nbsp; <br>
                                                                                                        <table border="1" width="100%">
 <caption><br>
                                                                                                          </caption><tbody>
 
                                                                                                          </tbody>
  <tbody>
                                                                                                            <tr>
 <td><b>Column Name</b></td>
  <td><b>Key</b></td>
  <td><b>Type</b></td>
  <td><b>Description</b></td>
 </tr>
  <tr>
 <td>MID_class</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>The class of machines for which the record pertains.</td>
 </tr>
  <tr>
 <td>state_name</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>The name of the finite state machine (FSM) state for which the record 
pertains.</td>
 </tr>
  <tr>
 <td>event_pattern</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>A specific event name such as EVENT_REPORT.373 or a string matching 
pattern such as ALARM_REPORT.* to be used for matching the input event.</td>
 </tr>
  <tr>
 <td>description</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(80)</td>
  <td>A user supplied description for the record to support configuration 
and development.</td>
 </tr>
  <tr>
 <td>rule_logic</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(2000)</td>
  <td>Tcl code to execute when an input event is found to match the <i>event_pattern</i>
 and the current machine state is the <i>state_name</i> value.&nbsp; The rule_logic
has read/write access to the event data using the event( ) array as described
with ep_input table rule_logic field.&nbsp; If the return value of the rule_logic
execution is one of the FSM state_names listed in the <i>next_state_list</i>
 field, then a state transition to the specified value is initiated.&nbsp; 
                                                                                                              <p>
It is possible to signal a "transition" to the current state by returning 
its value as the return value of the rule_logic execution.&nbsp; The EPC will
not log a state transition since the next state is the same as the current
state.&nbsp; However, the EPC will execute the rule_logic code of any ep_transition_rule
table records matching the "transition".&nbsp; To prevent unintended execution
of matching transition rules, your rule logic can return an empty result.&nbsp; 
                                                                                                              </p>
                                                                                                              <p>
The recommended format for specifying a state transition without any other
logic, is to use the return command:&nbsp; </p>
                                                                                                              <p>
&nbsp;&nbsp;&nbsp; return "E10.prod.idle"</p>
                                                                                                              </td>
 </tr>
  <tr>
 <td>next_state_list</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(1000)</td>
  <td>A space delimited list of FSM state_names which are the possible next 
states for transitions from the current state_name value.&nbsp; The list is
used to validate the return values of the rule_logic execution, and for state
machine depiction.</td>
 </tr>
 
                                                                                                          </tbody>
                                                                                                        </table>
  
                                                                                                        <hr width="100%">
 
                                                                                                        <h4>
 <a name="ep_state_def"></a>
ep_state_def&nbsp; Table - Definition of Finite State Machine States</h4>
 This table is used to supply descriptive information to configuration and 
runtime animation user interfaces.&nbsp; The runtime logic does not check 
that state_name values used elsewhere in the system have proper records in
this table. <br>
&nbsp; <br>
                                                                                                        <table border="1" width="100%">
 <caption><br>
                                                                                                          </caption><tbody>
 
                                                                                                          </tbody>
  <tbody>
                                                                                                            <tr>
 <td><b>Column Name</b></td>
  <td><b>Key</b></td>
  <td><b>Type</b></td>
  <td><b>Description</b></td>
 </tr>
  <tr>
 <td>MID_class</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>The class of machines for which the record pertains.&nbsp;</td>
 </tr>
  <tr>
 <td>state_name</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>A user provided name for the state.&nbsp; You should use the period 
as a separator for substates.&nbsp; There is provision in the logic to indicate
relative state transitions using "*.&lt;substate&gt;" notation.&nbsp; Also,
there is reliance on matching state names using "&lt;parent_state&gt;.*" or
"*.&lt;substate&gt;" notation.</td>
 </tr>
  <tr>
 <td>sequence</td>
  <td><br>
                                                                                                              </td>
  <td>integer</td>
  <td>Values that are in the range 100 to 999 specifying the order in which 
the user would like to have the state_names displayed for configuration.&nbsp; 
It is typical to give the power-up state the value 100 which specifies it
as the first (column).</td>
 </tr>
  <tr>
 <td>description</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(80)</td>
  <td>A user provided description for the state.</td>
 </tr>
  <tr>
 <td>rgb_color</td>
  <td><br>
                                                                                                              </td>
  <td>varchar(20)</td>
  <td>A color name or rgb code value compatible with Tk widget options.&nbsp; 
Hume Integration has a utility program, tk_colornames, which displays the 
various Tk colors and their names.</td>
 </tr>
 
                                                                                                          </tbody>
                                                                                                        </table>
  
                                                                                                        <hr width="100%">
 
                                                                                                        <h4>
 <a name="ep_state_log"></a>
ep_state_log Table - History of State Changes</h4>
 The rows in this table show the current and past values of finite state machine
states.&nbsp; In the in-memory table, only the latest records are shown.&nbsp;
The displayed interval is configurable as described below. 
                                                                                                        <p>
There is an attribute of state machine classes that determines whether the
transitions of their machine instances are copied to the persistent database.&nbsp;
It is a good idea to disable persistent saving of state changes unless the
saved records are used and there is provision for eventual deletion from
the persistent database. </p>
                                                                                                        <p>
The combination of MID and ts_entry is used as a key for the in-memory and
persistent database.&nbsp; Therefore you cannot share a persistent database
across different MID instances of the same name.&nbsp; The alternative is
to also include the EPC instance name as a key in the table, and we do not
think that it is worth the added storage consumption. </p>
                                                                                                        <p>
It is easy to determine the MID_class for an MID using the od_attribute table.&nbsp;
Therefore the MID_class is not copied into each record. </p>
                                                                                                        <p>
As new records are added to the table, completed rows that are older than
$EPC(StateLogInterval) in seconds are deleted.&nbsp; This is done to keep
the amount of data that is resident in memory finite. <br>
&nbsp; <br>
                                                                                                        <table border="1" width="100%">
 <caption><br>
                                                                                                          </caption><tbody>
 
                                                                                                          </tbody>
  <tbody>
                                                                                                            <tr>
 <td><b>Column Name</b></td>
  <td><b>Key</b></td>
  <td><b>Type</b></td>
  <td><b>Description</b></td>
 </tr>
  <tr>
 <td>MID</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>The machine instance for which the record pertains.&nbsp;</td>
 </tr>
  <tr>
 <td>ts_entry</td>
  <td>PCK</td>
  <td>timestamp</td>
  <td>A high resolution timestamp in the UTC timezone for the instant in which
the state was entered.&nbsp; It is also the same value entered as the ts_exit
of the previous record for the machine.</td>
 </tr>
  <tr>
 <td>ts_exit</td>
  <td><br>
                                                                                                              </td>
  <td>timestamp</td>
  <td>A high resolution timestamp in the UTC timezone for the instant in which
the state was exited.&nbsp; 
                                                                                                              <p>
Because some persistent databases do not accept empty strings as NULL timestamp
values, the ts_exit value is set to the ts_entry value when the record is
first inserted.&nbsp; When the state is exited, the ts_exit value is updated
with the actual value which is the same as the ts_entry of the next state.&nbsp; 
                                                                                                              </p>
                                                                                                              <p>
The time spent in the state, measured in seconds as a floating point value,
is easily calculated in Tcl logic by:&nbsp; </p>
                                                                                                              <blockquote>
 
                                                                                                                <pre>tsdiff $ts_entry $ts_exit</pre>
 </blockquote>
 Because both the ts_entry and ts_exit are provided in each record, it is 
easy to find the state value at a moment in time by selecting with a comparison 
expression involving both.&nbsp; Also, it is easy to traverse the rows for
a machine using the ts_entry and ts_exit values.&nbsp; 
                                                                                                                <p>
The timestamp of an event that causes a state transition is equal to the
ts_exit value of one record and the ts_entry of another.&nbsp; So you may
wish to think about how you will use the comparison operators if you are
attempting to assign the machine state of the trigger event.&nbsp; Most people
would choose (ts_entry &lt; '$ts') and ('$ts' &lt;= ts_exit).</p>
                                                                                                                </td>
 </tr>
  <tr>
 <td>state_name</td>
  <td><br>
                                                                                                                </td>
  <td>varchar(32)</td>
  <td><br>
                                                                                                                </td>
 </tr>
  <tr>
 <td>entry_event</td>
  <td><br>
                                                                                                                </td>
  <td>varchar(32)</td>
  <td>The input event_id which triggered the state change to enter into the 
recorded state.</td>
 </tr>
  <tr>
 <td>discard_flag</td>
  <td><br>
                                                                                                                </td>
  <td>int</td>
  <td>This column is used to hide deletes from the persistent database when 
those deletes are performed for keeping the number of in-memory rows finite.&nbsp;</td>
 </tr>
 
                                                                                                            </tbody>
                                                                                                          </table>
  </p>
                                                                                                          <hr width="100%">
 
                                                                                                          <h4>
 <a name="ep_subscription"></a>
ep_subscription Table - Subscriptions opened by the EPC to receive Data Events</h4>
 The EPC opens subscriptions in the configured datahub processes to receive 
the subscription notifications, map the MID, and forward the data events to
the EPC.&nbsp; When the ep_server_shutdown procedure is called, the EPC will
attempt to close the subscriptions listed in this table.&nbsp; The EPC opens
a subscription to this table to manage dynamic changes to the desired set
of subscriptions.&nbsp; So you will see subscription changes take effect
immediately, without restarting the EPC server. 
                                                                                                          <p>
For best efficiency, you will ordinarily have only one subscription per table
and datahub process.&nbsp; However, more than one subscription on a table
may be a reasonable way to configure complex mapping of the table rows to
MIDs. </p>
                                                                                                          <p>
The epc_hub field is not part of the primary composite key for the table in
the datahub, but it is part of the primary composite key in the persistent 
storage system. <br>
&nbsp; <br>
                                                                                                          <table border="1" width="87%">
 <caption><br>
                                                                                                            </caption><tbody>
 
                                                                                                            </tbody>
  <tbody>
                                                                                                              <tr>
 <td><b>Column Name</b></td>
  <td><b>Key</b></td>
  <td><b>Type</b></td>
  <td><b>Description</b></td>
 </tr>
  <tr>
 <td>epc_hub</td>
  <td>PCK*</td>
  <td>varchar(80)</td>
  <td>In order to have more than one EPC instance share a persistent database, 
they need to be distinguished.&nbsp;&nbsp; This field is a key in the persistent 
database but not the in-memory table.&nbsp; 
                                                                                                                <p>
The name of the EPC is usually <i>boxname</i>@<i>groupname</i>.&nbsp; Some
may want to have the hostname be part of the key, so they can have the same
groupname on different hosts, and still a shared persistent database.&nbsp; 
So, as with DCC, we allow for a global to be already defined as <i>boxname</i>
 @<i>hostname</i>:<i>groupname </i>per the user's desires.</p>
                                                                                                                </td>
 </tr>
  <tr>
 <td>datahub</td>
  <td>&nbsp;PCK</td>
  <td>varchar(80)</td>
  <td>The value identifies a DMH mailbox name that processes SQL commands, 
and is the target for where the subscription should be opened.&nbsp; This 
field needs to made a key so that upon delete we can identify which table 
subscription in the distributed system to close.&nbsp; Persistent databases 
can have problems with using empty strings in key fields.&nbsp; Therefore 
a mailbox name is always specified.&nbsp; The value is ordinarily a name such
as DATAHUB, but it can be groupname qualified name <i>boxname</i>@[<i>host</i>
 :]<i>groupname</i>.&nbsp; The target process is expected to have the EPC 
software accessible through the usual auto_path mechanism.&nbsp; The value 
should not be the epc_hub value because the DMH mailbox specified by the epc_hub
processes EPC events and not SQL commands.</td>
 </tr>
  <tr>
 <td>subtable</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>The tablename for the subscription.&nbsp; Made a key so upon delete 
we can identify which table subscription to close.</td>
 </tr>
  <tr>
 <td>subname</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>A unique name for the subscription suggested by the configuration software 
or by the user.&nbsp; Suggested names are of the form "EPC_${table}" or possibly
"EPC_${table}_${N}</td>
 </tr>
  <tr>
 <td>MID_expression</td>
  <td><br>
                                                                                                                </td>
  <td>varchar(200)</td>
  <td>The subscription notifications must be mappable to an MID.&nbsp; The 
                                                                                                                <i>
MID_expression</i> is a Tcl expression such as "FixedName", or such as $<i>
 colname,</i> or such as '[my_proc $<i>colA</i> $<i>colB</i>]' which the
EPC logic evaluates using the Tcl subst command in context when the table
key columns are the names of local Tcl variables.&nbsp; The evaluation result
is the MID value that the subscription notification is mapped to.&nbsp;</td>
 </tr>
  <tr>
 <td>subcolumns</td>
  <td><br>
                                                                                                                </td>
  <td>varchar(1000)</td>
  <td>Either * to indicate all columns or a list of column names.&nbsp; The 
column names and values show up as part of the name value list associated 
with the event.&nbsp;</td>
 </tr>
  <tr>
 <td>notifications</td>
  <td><br>
                                                                                                                </td>
  <td>varchar(32)</td>
  <td>Either <b>*</b> to indicate all notifications or one or more of the 
words&nbsp; <b>insert</b> <b>update</b> or <b>delete</b>.&nbsp; Warning -
with an empty string there are no subscription notifications - this is a
feature that can be used to temporarily disable a subscription input.</td>
 </tr>
  <tr>
 <td>where_clause</td>
  <td><br>
                                                                                                                </td>
  <td>varchar(1000)</td>
  <td>An optional where clause for the subscription.&nbsp; Includes the literal 
"where" keyword if provided.</td>
 </tr>
 
                                                                                                            </tbody>
                                                                                                          </table>
  </p>
                                                                                                          <hr width="100%">
 <br>
&nbsp; 
                                                                                                          <h4>
 <a name="ep_transition_rule"></a>
ep_transition_rule Table - Business Rules to Execute when Leaving or Entering
a State</h4>
 Both the leaving and entering state patterns must match to execute the rule,
so it is common to see a lot of wildcard '*' values used for the pattern
values.&nbsp; The Tcl <a href="../mann/string.html">string match</a>
 command is used for pattern comparisons and not the SQL like operator. 
                                                                                                          <p>
The rule_logic in the ep_input_rules table can optionally initiate a state
transition.&nbsp; When a transition is initiated, all matching records in
this table are processed even if the transition is for leaving and entering 
the current state. <br>
&nbsp; <br>
                                                                                                          <table border="1" width="100%">
 <caption><br>
                                                                                                            </caption><tbody>
 
                                                                                                            </tbody>
  <tbody>
                                                                                                              <tr>
 <td><b>Column Name</b></td>
  <td><b>Key</b></td>
  <td><b>Type</b></td>
  <td><b>Description</b></td>
 </tr>
  <tr>
 <td>MID_class</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>The class of machines for which the record pertains.</td>
 </tr>
  <tr>
 <td>rank</td>
  <td>PCK</td>
  <td>int</td>
  <td>A user provided value in the range of 0..9 used to set the order of 
execution.&nbsp; Records are matched and executed in ascending order by rank.</td>
 </tr>
  <tr>
 <td>leaving_state_pattern</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>A specific state name such as <tt>product.running</tt> or a string matching
pattern such as <tt>product.*</tt>, or <tt>*.running</tt> to be used for
matching the state that is being exited.&nbsp;</td>
 </tr>
  <tr>
 <td>entering_state_pattern</td>
  <td>PCK</td>
  <td>varchar(32)</td>
  <td>A specific state name such as <tt>product.running</tt> or a string matching
pattern such as <tt>product.*</tt>, or <tt>*.running</tt> to be used for
matching the state that is being entered.</td>
 </tr>
  <tr>
 <td>rule_logic</td>
  <td><br>
                                                                                                                </td>
  <td>varchar(2000)</td>
  <td>The code has read/write access to the event data items using the array 
event( ) as described earlier.&nbsp; The state being left may be referenced as
$event(state) and the state being entered may be referenced as $event(next_state).</td>
 </tr>
 
                                                                                                            </tbody>
                                                                                                          </table>
  </p>
                                                                                                          <hr width="100%">
 
                                                                                                          <h2>
 <a name="LicenseTerms"></a>
License Terms</h2>
 The Event Processing Component software is not part of the Hume Datahub 
SDK; it is available as a separate licensed product. 
Contact Hume Integration for current terms. <br>
 
                                                                                                          <hr width="100%">
 
                                                                                                          <h2>
 <a name="DocVersion"></a>
Document Version</h2>
 Date of last revision: $Date: 2004/03/02 17:04:39 $ 
                                                                                                          <p>
This document covers the Hume Integration Software developed Event Processing 
Component which is available for the Tcl 8.3/Tk 8.3 environment on the Windows
2000/NT and UNIX/POSIX platforms. </p>
                                                                                                          </body>
                                                                                                          </html>
