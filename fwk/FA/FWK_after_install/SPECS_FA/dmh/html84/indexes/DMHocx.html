<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Ed Hume">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <meta name="Description" content="User Guide and Reference Information for the DMH VB Active-X Control">
   <title>DMH Visual Basic Active-X Control</title>
</head>
<body>

<h1>
DMH.ocx - A Visual Basic DMH Active-X Control</h1>

<p><br>Hume Integration has created an Active-X control for integrating
Visual Basic (VB) programs into a distributed system using the Distributed
Message Hub (DMH) message system.&nbsp;&nbsp; The VB DMH control component
provides high-level methods for sending and receiving messages, with either
send-and-reply synchronous-style interactions, or higher performance asynchronous-style
interactions.&nbsp;&nbsp;&nbsp; Message exchanges are typically directed
to application servers such as the Hume Integration Datahub, or the dmh_SQLsrv
persistent database interface.&nbsp; The DMH message system is remarkably
easy to use with these DMH Tcl processes because the messages are typically
SQL, Tcl, or VFEI text that is directly interpreted by the receiver.&nbsp;&nbsp;
To extend this ease of use to the VB DMH client, methods are provided with
the control to convert Tcl list text strings into native VB data types,
or to create Tcl list text strings from VB data.&nbsp; Also, a method is
provided to convert SEMATECH VFEI formatted text into Dictionary entries.&nbsp;
(The Dictionary class is the native VB associative array.&nbsp; VFEI is
a self-describing, name-equals-value text format that is used for equipment
integration.)&nbsp; The VB DMH Active-X control fully supports peer-to-peer
interactions.
<p><a NAME="features"></a>
<h2>
Feature Summary</h2>

<ul>
<li>
High performance asynchronous message sending and receiving</li>

<li>
Convenient synchronous send-and-reply server or peer interaction provided
as well</li>

<li>
Fully compatible with Internationalization</li>

<li>
Transparent conversion of Unicode &lt;-> UTF-8 International capable character
sets</li>

<li>
Comprehensive support of DMH message system features such as mailbox manipulation</li>

<li>
TclSplit( ), ListElement( ), and TclJoin( ) methods provided for convenient
manipulation of Datahub SQL replies or similar Tcl list results in Visual
Basic applications</li>

<li>
Disconnected events and Error events provided for application recovery
and resume logic</li>

<li>
Usable in multiple instances for high performance access to multiple DMH
servers</li>

<li>
Fully integrated with the VB development environment with IntelliSense
specification of methods and parameters, and controllable debug output</li>

<li>
Fully integrated into the VB runtime environment with high-performance
use of threading, event dispatching, controllable trace output, and error
handling</li>

<li>
No static maximum sizes for DMH messages</li>

<li>
VFEI2Dictionary( ) method provided to parse SEMATECH VFEI formatted messages.</li>
</ul>

<hr WIDTH="100%"><a NAME="userguide"></a>
<h2>
<b>User Guide</b></h2>

<p><br>The DMH Active-X control for Visual Basic is provided as a file,
<b>DMH.ocx</b>,
for the Windows 2000 and Windows NT x86 architecture platform.&nbsp;&nbsp;
The .ocx binary file is provided with a test and demonstration application,
TestDMHProj.exe, along with the test application source code, and project
file.&nbsp; The files are distributed in a .zip archive file, <b>DMHocx.zip</b>.
The documentation files in the archive are copies of the same files that
are incorporated into the main online documentation.
<p>The control is designed to successfully interoperate with any recent
version of the Tcl/Tk DMH software running on any platform.
<br><a NAME="Installation"></a>
<h3>
Installation</h3>
If you received the DMH software on CDROM, the <b>DMHocx.zip</b> archive
is found in the subdirectory LAN_IMAGE. The <b>DMHocx.zip</b> distribution
archive needs to be unzipped into a path of your choosing; for example,
c:\usr\local. The archive includes the subdirectory DMHocx, so the complete
pathname to the DMH.ocx file becomes <i>your_path</i>\DMHocx\DMH.ocx. Only
the DMH.ocx file is needed for a runtime deployment. For runtime-only machines,
you may choose to copy just this file to the directory where your VB application
.exe files and .dll files are installed.
<p>As with any Active-X component, the ocx file needs to be registered
on a computer system before being used.&nbsp;&nbsp; Registration is a one-time
activity.&nbsp; The installation path should be chosen carefully since
you need to unregister and re-register the .ocx if you move it.&nbsp; Registration
logic is also built into programs that are built using VB6.&nbsp; For example,
if you run the test and demonstration program that comes with the control,
TESTDMHProj.exe, the DMH.ocx control gets registered using its current
file system location.&nbsp; The registration can also be performed at the
command line by executing
<p>&nbsp;&nbsp;&nbsp; regsvr32 <i>pathname</i>\DMH.ocx
<p>where <i>pathname</i> is your pathname to the file.&nbsp;&nbsp; The
VB6 Development Environment can also register a component - refer to its
documentation.
<p>At runtime, the control uses the VB6 runtime DLL,&nbsp; the Microsoft
Scripting Runtime, and the Microsoft Winsock Control 6.0 (%SystemRoot%\System32\MSWINSCK.OCX).&nbsp;
These DLLs/controls may need to be copied&nbsp; from a development machine
to any runtime machine where VB6 has not been installed.&nbsp; If they
are copied, they also need to be registered.
<br><a NAME="Development"></a>
<h3>
Development</h3>
The control is used from Visual Basic Version 6 as follows.&nbsp; Use the
menu item Project/Components... to bring up a list of available components.&nbsp;
Check the "Hume Integration DMH VB Active-X Control" checkbox to make the
control available to your project.&nbsp; Press the Ok button.
<p>Now when you visually edit your main form, you should see the "DMH"
control as a selectable component on your toolbar.
<p>Add one instance of the DMH control to your form by double-clicking
on the "DMH" component icon.&nbsp; VB gives your instance the name DMH1
but you may wish to assign a name of your choosing.&nbsp; We will use the
name "dmh" for example.&nbsp; You only need one instance of the control
- it should be shared among all your forms, as discussed later in this
section.&nbsp; The control will be invisible at runtime.&nbsp; Place it
on your form as you see fit.
<p>As a developer, per the licensing terms, you are required to have the
Tcl/Tk DMH software installed on your development system.&nbsp;&nbsp; One
reason for this requirement is to insure that you have the <a href="../index.html" target="_blank">online
documentation</a> for the DMH system.&nbsp; A second major reason is so
that you can run your own DMH server process to test and debug against
without affecting a factory production system.
<p>If you are not familar with the DMH message system, you may want to
read the mbx document which is usually installed at <a href="../mann/mbx.html">\usr\local\htm83\mann\mbx.html</a>.&nbsp;
Your VB application acts a DMH message system client, and attaches to a
running DMH server.&nbsp; Once you are connected to the DMH system, you
can exchange messages with other attached processes.
<p>To get started, you only need to know the hostname where the DMH server
is running, and the DMH Groupname that has been assigned to the server.&nbsp;&nbsp;
If you click on the "Programs"/"Tcl 8.3 - Tk 8.3 - DMH"/"Datahub" program
item, you will start a DMH server running on your host, with the default
DMH groupname of "mbx".
<p>The usual application design, and the one that provides the best performance,&nbsp;
is to connect to the DMH server during initialization, and to use this
connection during the life of the application.&nbsp; The <a href="#Init">Init(
) method</a> is used to connect to the server.&nbsp; The server's hostname
and groupname can be provided as arguments to the Init( ) method, or set
as property values during development or runtime.&nbsp; One idea is to
set the production system hostname and groupname at development time as
property values, and then at runtime check to see if environment variables
of your choice are pointing to an alternate DMH server.&nbsp; You can call
the Init( ) method from your Form_Load subroutine.
<br><a NAME="Errors"></a>
<h4>
Error Handling</h4>
A long running program such as a user interface or automation application
needs to handle intermittant errors with network outages or server shutdowns.&nbsp;
There are two styles of handling errors; you can mix both styles in your
application as you see fit.
<p>The first style of error handling is to avoid them by disabling buttons
and window controls that make use of DMH features when there is not a server
connection.&nbsp; You write the statements that enable your buttons in
the control "Connected" event handler, and you write statements that disable
the buttons in your "Disconnected" event handler.&nbsp; During initialization,
before you have a connection, call the Disconnected event handler yourself
to disable the buttons.&nbsp; Also during initialization, call the Init(
) method.&nbsp; When the Init( ) succeeds, a "Connected" event occurs and
your buttons become enabled.&nbsp; This technique requires less coding
than the method described next.&nbsp; Your code may look something like
this:
<p><tt>Private Sub dmh_Connected()</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TraceAppend ("Connected Event")</tt>
<br><tt>&nbsp;&nbsp;&nbsp; butInit.Caption = "Disconnect"</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'enable buttons that require a connection</tt>
<br><tt>&nbsp;&nbsp;&nbsp; butDoXact.Enabled = True</tt>
<br><tt>&nbsp;&nbsp;&nbsp; butSend.Enabled = True</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'etcetera</tt>
<br><tt>End Sub</tt>
<p><tt>Private Sub dmh_Disconnected()</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TraceAppend ("Disconnected Event")</tt>
<br><tt>&nbsp;&nbsp;&nbsp; butInit.Caption = "Initialize"</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'disable buttons that need dmh to avoid errors</tt>
<br><tt>&nbsp;&nbsp;&nbsp; butDoXact.Enabled = False</tt>
<br><tt>&nbsp;&nbsp;&nbsp; butSend.Enabled = False</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'etcetera</tt>
<br><tt>End Sub</tt>
<p><tt>Private Sub Form_Load()</tt>
<br><tt>&nbsp;&nbsp;&nbsp; butInit.Caption = "Initialize"</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' could disable all buttons that need a connection</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' for example have that code in the disconnected
event and call it here</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Call dmh_Disconnected</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' and then enable buttons in the Connect() event</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' connect using property values</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Call dmh.Init( )</tt>
<br><tt>End Sub</tt>
<br>&nbsp;
<p>The second style of error handling is to add explicit error trapping
to your procedures.&nbsp; This is the safest style since an untrapped error
will end your program.&nbsp;&nbsp; An example procedure with error trapping
follows:
<p><tt>Private Sub butClose_Click()</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'this button stays enabled when there is no
connection so it</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' needs error trapping</tt>
<br><tt>&nbsp;&nbsp;&nbsp; On Error GoTo butClose_Err</tt>
<br><tt>&nbsp;&nbsp;&nbsp; dmh.CloseMailbox txtreplybox.Text</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Exit Sub</tt>
<br><tt>butClose_Err:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; MsgBox "Trapped Error " &amp; Err.Number &amp;
vbCrLf &amp; Err.Description</tt>
<br><tt>End Sub</tt>
<p>If your application does asynchronous receiving, you should probably
avoid using the MsgBox call.&nbsp; During our testing we found that receiving
did not work if a MsgBox dialog was being shown.&nbsp; The good news is
that receiving works fine if a VB modal form is being displayed.
<p>Here is a summary of the kinds of errors that the DMH control will raise.&nbsp;
When you make a method call that requires a DMH server connection, and
you do not have one, the method call will exit with error 40006 being raised.&nbsp;
If you use an improper mailbox name such as one with whitespace in it,
the method call will exit with error 380 being raised.&nbsp; These are
the two main errors when initiating a method call.&nbsp; These errors are
raised using the Err.Raise( ) facility of Visual Basic.&nbsp; Most of the
DMH control method calls are then processed asynchronously.&nbsp; In other
words, your method call returns, and the message communication you initiated
happens as events are processed.&nbsp; An error that occurs during event
processing results in the DMH control Error( ) event occuring.&nbsp; A
DMH Error( ) event is different than an error raised by Err.Raise( ).&nbsp;
You do not need to write an Error( ) event handler, and these events do
not end your application.&nbsp; In contrast,&nbsp; an error created by
Err.Raise( ) will terminate your program unless it is trapped with an On
Error statement.&nbsp; You probably should write a handler for the DMH
Error( ) event to communicate to the users of your program errors that
occur.&nbsp; When the Error( ) event occurs, the Disconnected( ) event
will also occur.&nbsp; You can place logic in your Disconnected( ) event
handler to initiate recovery and resume logic, exit the program, etc.
<br><a NAME="ChildForms"></a>
<h4>
Child Forms</h4>
Here is the recommended technique to use a single DMH control with all
of the form code of your application.&nbsp; If you have a child form (window)
with the name subtest, include a variable for use in referencing the parent
form DMH control.&nbsp; So in the child form declarations, you include:
<p>'<tt> Child Form declaration</tt>
<br><tt>Public dmh As DMH</tt>
<br><tt>'Child Form code</tt>
<br><tt>Private Sub butChild_Click()</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Dim reply as String</tt>
<br><tt>&nbsp;&nbsp;&nbsp; reply = dmh.DoXact("DATAHUB", "eval localtime
16");</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' etc</tt>
<br><tt>End Sub</tt>
<p>And the logic in your main form will look something like this:
<p><tt>' Parent form declaration</tt>
<br><tt>' a child window -&nbsp; how to access the dmh control</tt>
<br><tt>' that exists on the parent</tt>
<br><tt>Private subwin As subtest</tt>
<p><tt>Private Sub Form_Load()</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' have an example child window that can also
use our DMH connection</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' you should share a single DMH control as in
this example</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Set subwin = New subtest</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' you MUST use "Set" in the object assignment</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Set subwin.dmh = dmh</tt>
<br><tt>End Sub</tt>
<p><tt>Private Sub butSubtest_Click()</tt>
<br><tt>&nbsp;&nbsp;&nbsp; subwin.Show vbModeless</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'subwin.Show vbModal, Me</tt>
<br><tt>End Sub</tt>
<p>In the code for the child window logic, we use the variable "dmh" just
as we do when coding logic for the parent form.
<br><a NAME="basicDMH"></a>
<h4>
Sending and Receiving - Basics</h4>
The programming model of the DMH message system is that you send a plain
text message to a destination mailbox.&nbsp; When sending the message,
you can optionally specify the name of a second mailbox for the recipient
to send a reply message to.&nbsp; Usually you send a message to an application
logic server such as a Datahub.&nbsp; The message is usually SQL,&nbsp;
Tcl, or VFEI code that the recipient executes.&nbsp; If the sender has
designated a reply mailbox, the result of executing the command is sent
to the reply mailbox.
<p>Lets discuss sending without asking for replies using the <a href="#Send">Send(
) method</a>.&nbsp;&nbsp; For example,&nbsp; suppose you are integrating
a barcode reader.&nbsp; When data is read from the barcode reader device,
your code is supposed to update a record in a Datahub table.&nbsp; You
will send messages without asking for reply messages - if there is a system
shutdown or communication failure, your application will know from the
Disconnected( ) event.&nbsp; This is more efficient than asking for a reply
message at every barcode read.
<p><tt>' update latest read record in table barcode_reader at the Datahub</tt>
<br><tt>Dim message as String</tt>
<br><tt>message = "update barcode_reader set data_in='" &amp; newdata &amp;
"' where device_id='" &amp; myID &amp; "'"</tt>
<br><tt>call dmh.Send(Hub, message)</tt>
<p>When you send a message without waiting for a reply, it is referred
to as an asynchronous send.
<p>Often, you will want to send a message to obtain reply data.&nbsp; The
most convenient method to use is the <a href="#DoXact">DoXact( ) method</a>.
This method will take care of specifying and using a unique mailbox for
your reply message, and it will take care of managing a timer in case a
reply message is not forthcoming.&nbsp; Suppose you want to query a database
table, and the DB variable is assigned the mailbox name of the <a href="../man1/dmh_SQLsrv.html">dmh_SQLsrv</a>
process.&nbsp;&nbsp; The online documentation shows that the SQL standard
"select" command sends multiple reply messages, but the "telect" command
sends a single reply message with all of the requested data formatted as
a Tcl list.&nbsp; The DoXact( ) method is designed for a single reply message,
so your code looks like:
<p><tt>Dim reply as String</tt>
<br><tt>reply = dmh.DoXact(DB, "telect device_id from barcode_config where
display='" &amp; dmh.LocalHostname( ) &amp; "'")</tt>
<br><tt>if reply = "TIMEOUT" then</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Exit Sub</tt>
<br><tt>End If</tt>
<br><tt>' Parse the Tcl List</tt>
<br><tt>' element(6) = rows of data, then (0) = first row, then (0) = first
item in row</tt>
<br><tt>device_id&nbsp; = dmh.ListElement(reply, 6, 0, 0)</tt>
<p><a NAME="advancedDMH"></a>
<h4>
Sending and Receiving - Advanced</h4>
If your application needs to receive unsolicited messages from other processes,
you use the <a href="#Whenever">Whenever( ) method</a> to setup asynchronous
receiving.&nbsp; When an unsolicited message is received, your <a href="#MessageArrival">MessageArrival(
) event handler</a> is called.&nbsp; If you are receiving to multiple mailbox
names, you will need to code a Select/Case statement or some if...then...else
logic in your MessageArrival( ) event handler.&nbsp; By convention you
should use mailbox names for receiving that end in _SQL if SQL messages
are expected, _VFEI if VFEI messages are expected, and _RPC if Tcl messages
are expected.&nbsp;&nbsp; There is no limit to the number of mailboxes
that you use for receiving, but the design convention is that you use unique
names based on the server function(s) provided.&nbsp; There should be only
one receiving process per mailbox name in a DMH group.&nbsp; You may wish
to create a unique mailbox name for receiving by basing the name on your
hostname - see the DMH method <a href="#LocalHostname">LocalHostname( )</a>.
<p>The Whenever( ) method is used for ongoing receiving - your application
will continue to receive the messages that are sent to your specified mailbox.&nbsp;
The <a href="#Disarm">Disarm( ) method</a> can be used to stop asynchronous
receiving.
<p>The <a href="#Whenmsg">Whenmsg( ) method</a> is similar to Whenever(
) except that it functions to receive only one message.&nbsp; If <a href="#WhenmsgAgain">Whenmsg_Again(
)</a> is executed from the MessageArrival( ) event handler, then the control
is re-armed to receive the next message.&nbsp; So the combination of Whenmsg(
) and WhenmsgAgain( ) are equivalent to the Whenever( ) method.
<p>Lets revisit the DoXact( ) method.&nbsp; In some situations, you may
want higher performance by sending messages and collecting the replies
asynchronously, instead of waiting for each reply before sending the next
message.&nbsp; You do this by setting up one or more reply mailboxes and
arming them for receiving using the Whenmsg( ) or Whenever( ) methods.&nbsp;
Instead of using DoXact( ) use the Send( ) command and specify the reply
mailbox argument.&nbsp; Typically a high&nbsp; performance application
will create a small number of unique mailbox names for replies, and re-use
them.&nbsp; If you are creating unique mailboxes for each reply message,
use the <a href="#CloseMailbox">CloseMailbox( ) method</a> when you are
done with each one, to recover resource usage.
<br><a NAME="events"></a>
<h4>
Event Handling Notes</h4>
Your application should not "live" inside of your event handling code.&nbsp;
Be sure to return in due course.&nbsp; Avoid calling DoEvents or performing
long running computations.
<p>Be careful with the Trace( ) event.&nbsp; If you turn on character conversion
tracing and are exchanging long messages, your application will be manipulating
huge amounts of string data.
<p>Do not call MsgBox( ) or invoke similar modal windows from inside of
an event handler.&nbsp; Instead, have a list box or text field on a Form
window that you append to.
<br><a NAME="International"></a>
<h4>
International Character Sets</h4>
International characters can be part of your data messages that you exchange
with Tcl applications and store in Datahub or ODBC tables.&nbsp; The DMH
control translates the Unicode wide characters used in VB to the multibyte
UTF-8 characters used by Tcl.&nbsp; When declaring database tables to hold
international text, base the VARCHAR( ) sizes on UTF-8 byte counts, not
on the number of characters.&nbsp; In the most conservative case,&nbsp;
you need to allow 3 bytes per displayed character.
<p>Lets do a "hello world" example.&nbsp; On a US English keyboard, the
character &eacute; (e with an acute accent) is entered by holding down
the Alt key and typing 1 3 0 on the numeric keypad.&nbsp;&nbsp; Start the
Datahub by clicking on the Tcl 8.3 program item.&nbsp; Start the TestDMHProj.exe
test program.&nbsp; Click the Initialize button to connect to the Datahub.&nbsp;
In the entryfield for "Message or Input Data", type the command
<p>eval set hello h&eacute;llo
<p>Press the "DoXact(Mailbox,Message)" button to send this to the Datahub.&nbsp;
This command tells the Datahub to evaluate the Tcl statement "set hello
h&eacute;llo".&nbsp;&nbsp; You will see the text "DoXact( ) Reply:h&eacute;llo"
in the "Reply or Output Data" field.&nbsp; Bring up the Datahub console
window using the menu item "File/Tcl command..." on the Datahub application,
or just send the message "eval console show".&nbsp; On the datahub console,
type the command "set hello".&nbsp; This statement asks to display the
value of the global variable hello.&nbsp; You should see the text result
h&eacute;llo.&nbsp; If you type the command "string length $hello", the
result is the value 5.&nbsp; If you execute "string bytelength $hello"
the result is 6.&nbsp; These results tell you that the value of the hello
variable is a 5 character string that uses 6 bytes for its internal representation.&nbsp;
If you turn on String Conversion tracing on the TestDMHProj.exe program,
you will see that the &eacute; character is represented in Tcl using the
two bytes (hex C3 and hex A9).
<p>For Internationalization to succeed as well for your language(s), you
need to make sure that you have installed fonts and chosen fonts in your
application that are capable of displaying the characters you require.
<br><a NAME="Termination"></a>
<h4>
Termination</h4>
When your application is shutting down, you should call the <a href="#Disconnect">Disconnect(
) method</a> to disconnect gracefully from the DMH server.&nbsp; Practically
speaking the DMH server routinely takes care of situations where clients
leave ungracefully, but proper software manners are encouraged.
<br><a NAME="Miscellaneous"></a>
<br>&nbsp;
<h4>
Miscellaneous Notes</h4>
An actual network connection is not attempted until Init() is called.
<p>The programming model is that you will not have more than one connection
to a particular DMH server.&nbsp; It is typical to have only one DMH connection
per application process.&nbsp; Communication across DMH groups can be accomplished
by sending to mailbox@groupname.&nbsp; It is also possible to use multiple
controls, each connected to a different DMH Group.
<p>There should be only one reader per mailbox name in a given DMH group.
<p>The VB DMH control is able to use and resolve DMH groupname aliases
as described in the online Tcl documentation.&nbsp; Groupname aliases are
resolved at the DMH server and not at the client.
<p>Mailbox Naming rules:
<ul>
<li>
A mailbox name should be limited to 31 or fewer characters but there is
no firm limit.</li>

<li>
The name must start with an ANSI letter, digit, or the underscore</li>

<li>
Other characters in the name may include - or&nbsp; !.</li>

<li>
The period, colon, or @ symbol should only be used to specify optional
groupname qualification of a mailbox name as in <i>boxname</i>[<b>@</b><i>host_or_ip_address</i><b>:</b><i>groupname</i>]</li>
</ul>

<p><br>
<hr WIDTH="100%"><a NAME="Reference"></a>
<h2>
DMH.ocx Control Reference</h2>
<a NAME="Properties"></a>
<table BORDER WIDTH="100%" >
<caption>&nbsp;<b>DMH.ocx</b> <b>Control Properties</b></caption>

<tr>
<td><b>Property Name</b></td>

<td><b>Data Type</b></td>

<td><a NAME="DefaultTimeout"></a><b>Description</b></td>
</tr>

<tr>
<td><b>DefaultTimeout</b></td>

<td>Long<a NAME="RemoteGroup"></a></td>

<td>The default timeout interval for send and reply transactions, or timed
receive invocations.&nbsp;&nbsp; In seconds - the default value is 30.&nbsp;
Settable range: 1 - 86399.</td>
</tr>

<tr>
<td><b>RemoteGroup</b></td>

<td>String<a NAME="RemoteHost"></a></td>

<td>The name of the DMH server message group, such as "PIC".&nbsp; The
DMH software maps the specified groupname to a TCP/IP socket port.&nbsp;
The value may also be specified as&nbsp; numeric text which is interpreted
as directly specifying the TCP/IP port the DMH server is using.&nbsp; The
default value is "mbx" which enables connection to a Datahub program started
with default values.&nbsp; This property can be set at design or runtime,
or set when calling the Init method.</td>
</tr>

<tr>
<td><b>RemoteHost</b></td>

<td>String<a NAME="State"></a></td>

<td>The TCP/IP hostname of the DMH server.&nbsp; The default value is "localhost"
which is a standard way to specify the computer that the control is executing
on.&nbsp; The value can also specify an IP address such as "192.168.2.12".&nbsp;
This property can be set at design or runtime, or set when calling the
Init( ) method.</td>
</tr>

<tr>
<td><b>State</b></td>

<td>Enumerated
<br>Integer<a NAME="Tracebits"></a></td>

<td>The state property is a read-only value available at runtime.&nbsp;
The value can be read to determine if a healthy communication connection
exists, etc.&nbsp;&nbsp;&nbsp; Applications will ordinarily use event methods
and not poll the state property value.&nbsp; The transient and error states
may not last long, so testing for the values 0 or 7 would be the most common
scenario.
<dl>
<dl>
<pre>&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; disconnected</pre>

<pre>&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hostname is being resolved</pre>

<pre>&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection setup in progress&nbsp;</pre>

<pre>&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; healthy connection exists</pre>

<pre>&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection close in progress</pre>

<pre>&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a communication error has occured&nbsp;&nbsp;</pre>

<pre>519&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DMH protocol setup in progress (519 = &amp;H100 Or 7)</pre>
</dl>
</dl>
</td>
</tr>

<tr>
<td><b>Tracebits</b></td>

<td>Long<a NAME="mhgroup"></a></td>

<td>The Tracebits property controls output of diagnostic data to the Trace
event.&nbsp; This value is used as a bitfield with the bit values controlling
the following categories of output:
<p>01 data reads
<br>02 data writes
<br>04 message receiving
<br>08 message sending
<br>16 logic tracing
<br>32 UTF-8, BSTR character conversions</td>
</tr>

<tr>
<td><b>mhgroup</b></td>

<td>String</td>

<td>The mhgroup property is a readonly runtime value indicating the <i>hostname<b>:</b>port&nbsp;</i>
of the DMH server when connected, else as empty string.&nbsp; <i>Hostname</i>
is the server's idea of his hostname which may be different from the RemoteHost
that was specified at the client.</td>
</tr>

<tr>
<td></td>

<td></td>

<td></td>
</tr>
</table>

<p><a NAME="ControlEvents"></a>
<br>&nbsp;
<table BORDER WIDTH="100%" >
<caption><b>DMH.ocx Control Generated Events</b></caption>

<tr>
<td><a NAME="Connected"></a><b>Event Signature</b></td>

<td><b>Description</b></td>
</tr>

<tr>
<td></td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>
</tr>

<tr>
<td><b>Connected</b>( )<a NAME="Disconnected"></a></td>

<td>Happens after successfully connecting to the DMH server in the wake
of the Init method invocation.</td>
</tr>

<tr>
<td><b>Disconnected</b>( )<a NAME="ErrorEvent"></a></td>

<td>The DMH connection has been closed from any circumstance such as remote
closure, communication failure, error, or invocation of the Disconnect
method.&nbsp; This event is similar to the Tcl lostserver procedure invocation</td>
</tr>

<tr>
<td><b>Error</b>(
<br>error number as Long,&nbsp;
<br>description as String)</td>

<td>The Error event happens when the Init method fails, or there has been
communication failure.&nbsp; In most cases when the Error event happens,
the control state will transition to the disconnected state, and the Disconnected(
) event will occur shortly.
<p>Init errors include
<dl>
<dd>
<tt>10051&nbsp; the network is unreachable</tt></dd>

<dd>
<tt>10060&nbsp; Connection has timed out. This error indicates that the
remote host may not be online.</tt></dd>

<dd>
<tt>10061&nbsp; Connection attempt is refused.&nbsp;</tt></dd>

<dd>
<tt>10061&nbsp; Connection is forcefully rejected.</tt></dd>

<dd>
<tt>The remote host is online and reachable, but there is not a DMH server
at the specified group or port.&nbsp; In some cases we have improperly
seen this error when using the hostname "localhost", and have worked around
it using the actual hostname.&nbsp; This seems to be a buggy behavior that
is being investigated.</tt></dd>

<dd>
<tt>11001&nbsp; Hostname not found (DNS authoritative).&nbsp; This error
may indicate an improperly spelled hostname, or a hostname that is not
known to your name server.</tt></dd>

<dd>
<tt>11002&nbsp; Hostname not found (non-authoritative name resolution).&nbsp;
This error may indicate that your name server is down.</tt></dd>

<dd>
<tt>50003&nbsp; DMH Server refuses our client connection</tt></dd>

<dd>
<tt>This error indicates that customer modified software running in the
DMH server has rejected the connection.&nbsp; It is likely that you are
in violation of your site's security policy.</tt></dd>

<dd>
<tt>50004&nbsp; DMH Protocol error - improper setup reply.</tt></dd>

<dd>
<tt>You should never see this error.</tt></dd>

<dd>
</dd>
</dl>

<p><br>Broken connection errors include:
<dl>
<dd>
<tt>10051&nbsp; the network is unreachable</tt></dd>

<dd>
<tt>10060&nbsp; Connection has timed out</tt></dd>

<dd>
<tt>11053&nbsp; Connection is aborted due to timeout or other failure</tt></dd>

<dd>
<tt>10054&nbsp; Connection is reset by remote system</tt></dd>

<dd>
<tt>10058&nbsp; Connection has been shutdown</tt></dd>

<dd>
<tt>50001&nbsp; DMH Protocol error - missing data.&nbsp; You should never
see this error.</tt></dd>

<dd>
<tt>50002&nbsp; DMH Protocol error - improper packet.&nbsp; You should
never see this error.</tt></dd>

<dd>
</dd>
</dl>
<tt>Attempting to use a method that requires a connection when a healthy
connection does not exist results in the error:</tt>
<dl>
<dd>
<tt>40006&nbsp; Wrong connection state for the request</tt></dd>

<dd>
<a NAME="MessageArrival"></a><tt>40006&nbsp; No DMH Server Connection</tt></dd>
</dl>
</td>
</tr>

<tr>
<td><b>MessageArrival</b>(
<br>DestinationMailbox as String,&nbsp;
<br>ReplyMailbox as String,&nbsp;
<br>Data as String)<a NAME="Shutdown"></a></td>

<td>A message has arrived.&nbsp; The DestinationMailbox parameter is a
mailbox name that your application has specified when initiating receiving.&nbsp;
If the sender of the message indicated a reply mailbox, it is passed as
the second argument, ReplyMailbox.&nbsp; If no reply mailbox has been specified,
the ReplyMailbox argument is an empty string.&nbsp; The Data argument is
the text of the sent message.&nbsp; The DMH control's logic protects you
from receiving another message for the DestinationMailbox, and re-entering
your MessageArrival logic until you have returned from the MessageArrival(
) call
<p>String data is represented in Tcl as multibyte UTF-8 character sequences,
and as double byte character sequences in Visual Basic.&nbsp;&nbsp; Conversion
between the two representations occurs transparently.&nbsp;</td>
</tr>

<tr>
<td><b>Shutdown</b>(ByRef StayAlive as Boolean)<a NAME="Trace"></a></td>

<td>A remote request has been received to terminate the process.&nbsp;
If you do not set the StayAlive flag true, the control will cause the application
to disconnect from the DMH message system.&nbsp; Because of implementation
constraints the control is not able to cause your application to exit.&nbsp;
If you want to exit, you need to write a Shutdown event handler that executes
"End" or "Unload me".</td>
</tr>

<tr>
<td><b>Trace</b>(Message as String)</td>

<td>This event provides diagnostic and debug information per the Tracebit
property setting.&nbsp; Your application needs to avoid creating new DMH
activity in the Trace event callback, that in return causes Trace events.&nbsp;
A cycle of positive feedback is possible which will cause a software fission
reaction.</td>
</tr>
</table>

<p><a NAME="Methods"></a>
<table BORDER WIDTH="100%" >
<caption><b>DMH.ocx&nbsp;<a NAME="Abort"></a>Control Methods</b></caption>

<tr>
<td></td>

<td></td>
</tr>

<tr>
<td><b>Abort</b>( )<a NAME="CloseMailbox"></a></td>

<td>Any in-progress send-and-reply or modal wait transactions such as the
Init( ) method or DoXact( ) calls are aborted with return values indicating
TIMEOUT.&nbsp; Invoking the Abort method does not affect asynchronous receiving
that is setup using the Whenmsg( ) or Whenever( ) methods.</td>
</tr>

<tr>
<td><b>CloseMailbox</b>(boxname )<a NAME="Count"></a></td>

<td>Stop using a mailbox - Disarm receiving if listening, Flush if not
empty,&nbsp; and remove from existence if it exists.&nbsp; The Tcl version
of this call, differs because it will not flush existing messages.
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>Count</b>(boxname) as long(3)<a NAME="Disarm"></a></td>

<td>Returns a three element array giving the total count of messages that
have been sent to the mailbox, the total count of messages that have been
consumed from the mailbox, and last, the current count of pending messages.&nbsp;
A pending message is one that exists in the queue associated with the mailbox,
and has not been consumed by reading or flushing.
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>Disarm</b>(optional boxname as String)<a NAME="Disconnect"></a></td>

<td>Un-register the listener from a specified&nbsp; mailbox.&nbsp; This
call may be used to cancel an earlier whenever( ) or whenmsg( ) call.&nbsp;
If called with no arguments, all Whenever( ) and Whenmsg( ) receiving registrations
are cancelled.&nbsp; The Abort( ) method will cancel in-progress DoXact(
) calls.
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>Disconnect</b>( )<a NAME="DoXact"></a></td>

<td>The counterpart of Init( ); disconnects from the DMH server.&nbsp;
The Abort( ) method gets called to end any in-progress transactions.&nbsp;
The Disarm( ) method gets called with no arguments to cancel all receiving.</td>
</tr>

<tr>
<td><b>DoXact</b>(DestinationMailbox as String,
<br>Message as String,&nbsp;
<br>optional TimeoutSeconds as Long,
<br>optional ReplyMailbox as String)&nbsp;
<br>As String<a NAME="Flush"></a></td>

<td>Performs a complete send and reply transaction with timeout management.&nbsp;
Creates and manages a unique reply mailbox for the send and reply transaction
if the replybox argument is defaulted.&nbsp; If the timeout is not specified,
the DefaultTimeout value is used.&nbsp; The usual reply is the text of
the reply message. The String literal TIMEOUT is returned in case of failure.&nbsp;
You can only have one instance, of DoXact( ) or TimedReceive( ) active
at a time.&nbsp; If you specify a ReplyMailbox, you need to insure that
the name you specify is only used by your application.&nbsp; It is usual
to create a unique reply mailbox name, perhaps based on the hostname, assign
it to a variable, and use it repeatedly.
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>Flush</b>(MailboxName)<a NAME="GroupnamePort"></a></td>

<td>Empty a mailbox of any pending messages.&nbsp; A pending message is
one that has been sent to the mailbox but has not been consumed.&nbsp;
In other words, a pending message is waiting in a queue associated with
the&nbsp; mailbox name.&nbsp; Messages are consumed by reading or flushing.
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>GroupnamePort</b>(Groupname as String)&nbsp;
<br>As Long<a NAME="Init"></a></td>

<td>Used to determine the TCP/IP port number that is used by the DMH server
to listen for client connections.&nbsp; The method is equivalent to the
mh_name_to_socket Tcl procedure.&nbsp; Most applications will not have
a use for this method since the server socket port is managed by the DMH
software.&nbsp;</td>
</tr>

<tr>
<td><b>Init</b>(Optional DMHGroupname as String,&nbsp;
<br>Optional RemoteHostname) As Long<a NAME="ListElement"></a></td>

<td>Performs the initial connection to the DMH message server. The connection
will be setup or an error result will be obtained before returning.
<p>If no DMHGroupname or RemoteHostname is specified, the control property
values are used.&nbsp;
<p>If the connection succeeds, the return value is 0.&nbsp; A non-zero
result is an error number indicating why the initialization failed.&nbsp;
See the Error( ) event for specific codes.
<p>When the initialization is successfully completed, the Connected( )
event is fired.&nbsp; If the Init call fails, the Error( ) event is fired.&nbsp;
<p>If the connection to the DMH server is ever lost, the Disconnected(
) event is fired.</td>
</tr>

<tr>
<td><b>ListElement</b>(TclList as String,&nbsp;
<br>index1 as Long,&nbsp;
<br>optional index2 as Long,
<br>optional index3 as Long ) As String<a NAME="LocalHostname"></a></td>

<td>This method is similar to the lindex method of Tcl.&nbsp; It will parse
text formatted as a Tcl list and return the specified element.&nbsp; Additional
indexes may be specified to parse nested lists.&nbsp; If a specified index
is out of bounds, an empty string is returned.&nbsp; Error 50008 is raised
if an invalid list is parsed.&nbsp;
<p>Dim reply as String
<br>Dim item as String
<br>reply = dmh.DoXact(Datahub, telect_query)
<br>' index 6 = rows of data, 0 = first row, 0 = first item in row
<br>item = dmh.ListElement(reply, 6, 0, 0)</td>
</tr>

<tr>
<td><b>LocalHostname</b>( ) as String<a NAME="ReceiveList"></a></td>

<td>Returns the TCP/IP hostname of the computer that the control is executing
on.&nbsp; The name is guaranteed to be stripped of domain information,
and imbedded white spaces which are not valid in hostnames are replaced
with underscores.</td>
</tr>

<tr>
<td><b>ReceiveList</b>( ) as String<a NAME="Send"></a></td>

<td>Returns a list of the mailboxes you are listening for messages on.&nbsp;
Does not show mailbox names that have in-progress MessageArrival( ) events.&nbsp;
This command may be useful for debugging, and it is not used in a typical
application.
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>Send</b>( DestinationMailbox as String,
<br>Message as String,
<br>optional ReplyMailbox as String)<a NAME="ServerStatus"></a></td>

<td>Send a message to a mailbox, optionally with a reply mailbox indicated.&nbsp;&nbsp;
By convention, when a reply mailbox is indicated for a command message
sent to a Datahub mailbox or equipment interface mailbox, the command is
processed, and a reply message is sent to the reply mailbox.&nbsp;
<p>Specifying the reply mailbox as an empty string or as the literal value
"NULL" is equivalent to not specifying a reply mailbox.
<p>Sending to the mailbox name "TRACE" sends the message to the DMH Server
Trace Facility.
<p>The Send method corresponds to the Tcl mbx put and mbx putr commands.&nbsp;
Note that "Put" is a keyword in Visual Basic and could not be used for
this method.
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>ServerStatus</b>( ) as String<a NAME="TclJoin"></a></td>

<td>Returns a Tcl list containing the information presented in the Tcl
DMH status window.&nbsp; The information can be parsed by the application
to determine&nbsp; status information on every mailbox that is currently
in use.&nbsp; This command may be useful for debugging, and is not used
by ordinary applications.
<p>The first element of the list is a list of 5 elements:
<br>{ <i>hostname</i><b>:</b><i>port messages_received messages_sent messages_queued
tcl_version </i>}
<p>Subsequent elements in the list are lists of four or five elements:
<br>{ <i>mailboxname count_in count_out count_pending </i>[<i>reader_handle</i>]
}
<p>Additional elements may exist in the list if there are DMH clients that
are not currently waiting to receive messages.&nbsp; These elements are
formatted as:
<br>{{{no whenmsg pending}} - - - <i>reader_handle</i>}
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>TclJoin</b>(elements( ) as String,
<br>optional joinstring = " ")
<br>as String<a NAME="TclJoinV"></a></td>

<td>Joins together strings as Tcl list elements forming a result string
that is a Tcl list.&nbsp; Similar to the Join( ) command of Basic except
that braces are added as needed to delimit empty elements, or to delimit
special Tcl character sequences involving backslashes , square brackets,
etc.</td>
</tr>

<tr>
<td><b>TclJoinV</b>(elements as Variant,
<br>optional joinstring = " ")
<br>as String<a NAME="TclSplit"></a></td>

<td>Same as TclJoin( ) except the list elements are passed as a Variant
array.&nbsp; The Variant array is also the output type of the array( )
function.
<p>Dim s as String
<br>s = TclJoinV(array("hello world", "arg 2", "last"))
<br>&nbsp;= "{hello world} {arg 2} last"</td>
</tr>

<tr>
<td><b>TclSplit</b>( Tcllist as String,&nbsp;
<br>ByRef elements() as String,
<br>optional ByRef ErrorInfo as String)&nbsp;
<br>as Long<a NAME="TimedReceive"></a></td>

<td>TclSplit( ) parses a string formatted as a Tcl list into an array of
string elements.&nbsp; The method is similar to the Split( ) function of
VB except that it understands the Tcl usage of quotes, braces and backslash
sequences.&nbsp; Not all strings are valid Tcl lists.&nbsp; The return
value is 0 on success.&nbsp; In case of error, the elements array is set
to an empty array, and the return value and ErrorInfo are set as follows:
<p>return value, ErrorInfo
<br>0, ""
<br>1, list element in braces followed by non-whitespace
<br>2, list element in quotes followed by non-whitespace
<br>3, unmatched open quote in list
<br>4, unmatched open brace in list
<br>&nbsp;</td>
</tr>

<tr>
<td><b>TimedReceive</b>(ReceiveMailbox as String,
<br>optional TimeoutSeconds as Long)&nbsp;
<br>As String<a NAME="Version"></a></td>

<td>Waits for a message to be received in the specified mailbox.&nbsp;
If the call succeeds,&nbsp; the return value is the message data.&nbsp;
If the call fails, the return value is the literal string "TIMEOUT".&nbsp;
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>Version</b>( ) as String<a NAME="VFEI2Dictionary"></a></td>

<td>Current software returns the string "1.1" to&nbsp; indicate compatibility
with DMH versions 1.1 and earlier.</td>
</tr>

<tr>
<td><b>VFEI2Dictionary</b>(VFEItext as String,
<br>ByRef NameValues as Dictionary) as Long
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>&nbsp;</td>

<td>The VFEI2Dictionary method parses a SEMATECH VFEI formatted text string
into (name, value) items in a Visual Basic Dictionary.&nbsp; VFEI is a
SEMATECH standard for the format of messages used for equipment integration.
This command parses a VFEI version 2.2 (or 2.1) message for the name and
value of the data items.&nbsp; The return value is the count of items that
have been added to the dictionary as a result of parsing the text.&nbsp;
This implementation succeeds in parsing VFEI messages that do not strictly
adhere to the SEMATECH description. In general, quotes are only needed
to delineate a data item that has imbedded white space. There is no problem
with additional white space between any of the lexical elements. The "/"
and format code are optional and may be omitted.
<br>&nbsp;
<p>Private Sub butVFEI_Click()
<br>&nbsp;&nbsp;&nbsp; Dim dic As New Dictionary
<br>&nbsp;&nbsp;&nbsp; Dim tsts As Variant
<br>&nbsp;&nbsp;&nbsp; Dim key As Variant
<br>&nbsp;&nbsp;&nbsp; Dim rc As Long
<br>&nbsp;&nbsp;&nbsp; Dim text As String
<br>&nbsp;&nbsp;&nbsp; Dim teststring As String
<br>&nbsp;&nbsp;&nbsp; On Error Resume Next
<br>&nbsp;&nbsp;&nbsp; tsts = Array( _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "DESC=|The VFEI parser can parse name
= value strings!| ", _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Filename=|dmh.ocx| directory=|\\server\path1\path2|
", _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Command=|you can have \|imbedded quotes\|
| ", _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CMD / A = |ALARM SETUP|&nbsp; MID/A=|STP1|
MTY/A=|C| TID/U4=2 ENABLE/U1=0 ALARM_ID/I4[3]=[ 1 |2|&nbsp; 3 ]", _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CMD/A=|INITIALIZE| MID/A=|STP1| MTY/A=|C|
TID/U4=1", _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CMD / A = |ALARM SETUP|&nbsp; MID/A=|STP1|
MTY/A=|C| TID/U4=2 ENABLE/U1=0 ALARM_ID/I4[3]=[1 2 3]", _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "xx/U1 = 0 xU2/U2=0 xI4/I4= 1234 xI8/
I8 = 2 xF4/F4 = 1.2 xBL/BL=0", _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CMD/A=|INITIALIZE| LL/L[3]=[MID/A=|STP1|
MTY/A=|C| TID/U4=1]", _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CMD=INITIALIZE MID=STP1 THING1=|hello
world| thing2=355 thing3=6.02e23", _
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CMD/A=TEST5 REPORT2/L[3]=[EVENT_ID/A=|MB_COMPLETE|
CLOCK/A=|1992| XX/L[3]=[FIRST/A=|TEXT 1st| SECOND/U2=255 THIRD/F4=0.003]]",
_
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "")
<p>&nbsp;&nbsp;&nbsp; text = ""
<br>&nbsp;&nbsp;&nbsp; For Each tst In tsts
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'replace | with quote (cannot
imbed quotes directly)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; teststring = Replace(tst,
"|", Chr(34))
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text = text &amp; teststring
&amp; vbCrLf
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = -1
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err.Number = 0
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = dmh.VFEI2Dictionary(teststring,
dic)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text = text &amp; "rc="
&amp; rc &amp; vbCrLf
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For Each key In dic
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
text = text &amp; key &amp; "=" &amp; dic.Item(key) &amp; vbCrLf
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Err.Number &lt;> 0 Then
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
text = text &amp; "trapped error: " &amp; Err.Number &amp; Err.Description
&amp; vbCrLf &amp; vbCrLf
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
text = text &amp; vbCrLf
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; txtoutput.text = text
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dic.removeall
<br>&nbsp;&nbsp;&nbsp; Next
<br><a NAME="Whenever"></a>End Sub</td>
</tr>

<tr>
<td><b>Whenever</b>(MailboxName as String)<a NAME="Whenmsg"></a></td>

<td>Registers to receive all messages directed to the specified mailbox.&nbsp;
When the MessageArrival( ) event handler returns, the control re-arms for
receiving the next message directed to the specified mailbox.&nbsp; The
Disarm( ) method is used to stop receiving.
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>Whenmsg</b>(MailboxName as String)<a NAME="WhenmsgAgain"></a></td>

<td>Register for receiving the next available message directed to the specified
mailbox.&nbsp; Calling WhenmsgAgain( ) in the MessageArrival( ) event handling
code re-arms the receive registration for the next message.
<p>You must be connected to use this call.</td>
</tr>

<tr>
<td><b>WhenmsgAgain</b>( )</td>

<td>The Whenmsg( ) method functions as a one-shot.&nbsp; In other words,
receiving is stopped after receiving one message.&nbsp; Calling the WhenmsgAgain
method from the MessageArrival handler re-registers to receive the next
message.
<p>You must be connected to use this call.</td>
</tr>
</table>

<p>
<hr WIDTH="100%"><a NAME="MethodErrors"></a>
<h2>
Err.Raise Method Errors</h2>
These are errors that may be raised as a result of a method invocation.
<p>&nbsp;&nbsp;&nbsp; 380&nbsp;&nbsp;&nbsp; mailbox name must start with
an ANSI letter, digit, or underscore
<br>&nbsp;&nbsp;&nbsp; 380&nbsp;&nbsp;&nbsp; mailbox name must contain
only ANSI letters, digits, -, _, ., !, :, or @
<br>&nbsp;&nbsp;&nbsp; 380&nbsp;&nbsp;&nbsp; The property value is invalid.
<br>40006&nbsp;&nbsp;&nbsp; No DMH Server Connection
<br>40006&nbsp;&nbsp;&nbsp; Cannot re-enter synchronous send and reply
logic
<br>40006&nbsp;&nbsp;&nbsp; Cannot initialize in current state
<br>50005&nbsp;&nbsp;&nbsp; Already processing a DoXact( ) call for this
ReplyMailbox
<br>50006&nbsp;&nbsp;&nbsp; Timeout or other error obtaining count
<br>50007&nbsp;&nbsp;&nbsp; String to byte conversion failure
<br>50008&nbsp;&nbsp;&nbsp; improper Tcl List
<br>50009&nbsp;&nbsp;&nbsp; invalid VFEI text
<br>50010&nbsp;&nbsp;&nbsp; improper use of NULL mailbox
<p>
<hr WIDTH="100%"><a NAME="LicenseTerms"></a>
<h2>
License Terms</h2>

<p><br>Subject to Change Without Notice
<p>The VB DMH Active-X control is licensed for development and runtime
use at no additional charge for computers that are licensed for development use of the
Hume Integration Datahub SDK.&nbsp; We ask that
VB developers install the Tcl executables and actively use the Tcl executables
for testing and development, instead of developing against their factory's
production servers.&nbsp; Also, we ask that VB developers install the Tcl
online documentation and use it to supplement the material presented in
this document.
<p>Hume Integration is also pleased to offer separate runtime licenses
for using the DMH control on systems that are not licensed as development systems.
Runtime usage of the DMH client 
software is licensed separately from the Datahub SDK runtime license.  
<p>
<hr WIDTH="100%"><a NAME="References"></a>
<h2>
References</h2>
The author wrote his first Basic program in 1966 using his father's Teletype
dialed in to an IBM timesharing system at 115 baud or so.&nbsp;&nbsp; The
language has changed quite a bit, and the following books were found helpful.
<ol>
<li>
<u>VB &amp; VBA In A Nutshell: The Language</u> by Paul Lomax, O'Reilly
&amp; Associates Inc. 1998.&nbsp; This book was by far the most useful.&nbsp;
It is awkward to use the online VB documentation because each topic is
a separate document and the navigation between related topics is difficult.</li>

<li>
<u>Visual Basic Controls In a Nutshell: The Controls of the Professional
and Enterprise Editions</u> by Evan S. Dictor, O'Reilly &amp; Associates
Inc. 1999.</li>

<li>
<u>Hardcode Visual Basic Second Edition</u> by Bruce McKinney, Microsoft
Press, 1997.&nbsp; I wish this book was updated for VB6, but it is based
on VB5.&nbsp; Nonetheless it covers topics that the above references do
not address.</li>
</ol>

<hr WIDTH="100%">
<h2>
<a NAME="DocVersion"></a>Document Version</h2>
Date of last revision: $Date: 2004/08/13 15:58:11 $
</body>
</html>
