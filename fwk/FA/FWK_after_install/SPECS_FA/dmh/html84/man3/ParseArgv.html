<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML><HEAD>
<A NAME="Tk_ParseArgv_Tk_"></A>
<TITLE>Tk_ParseArgv Tk Library Procedures</TITLE></HEAD>
<BODY>
<HR>
<P>
<H2>NAME</H2>
 Tk_ParseArgv - process command-line options <P>
<H2>SYNOPSIS</H2>
 
<B>#include &lt;tk.h&gt;</B>
<P>
int
<B>Tk_ParseArgv</B>(<I>interp, tkwin, argcPtr, argv, argTable, flags</I>)
<P>
<H2>ARGUMENTS</H2>

<P><DT><B>Tcl_Interp <I>*interp</I></B> (in)
<DD>Interpreter to use for returning error messages.
<P><DT><B>Tk_Window <I>tkwin</I></B> (in)
<DD>Window to use when arguments specify Tk options.  If NULL, then
no Tk options will be processed.
<P><DT><B>int <I>argcPtr</I></B> (in/out)
<DD>Pointer to number of arguments in argv;  gets modified to hold
number of unprocessed arguments that remain after the call.
<P><DT><B>CONST char <I>**argv</I></B> (in/out)
<DD>Command line arguments passed to main program.  Modified to
hold unprocessed arguments that remain after the call.
<P><DT><B>Tk_ArgvInfo <I>*argTable</I></B> (in)
<DD>Array of argument descriptors, terminated by element with
type TK_ARGV_END.
<P><DT><B>int <I>flags</I></B> (in)
<DD>If non-zero, then it specifies one or more flags that control the
parsing of arguments.  Different flags may be OR'ed together.
The flags currently defined are TK_ARGV_DONT_SKIP_FIRST_ARG,
TK_ARGV_NO_ABBREV, TK_ARGV_NO_LEFTOVERS, and TK_ARGV_NO_DEFAULTS.
<HR>
<P>
<H2>DESCRIPTION</H2>

<P>
<B>Tk_ParseArgv</B> processes an array of command-line arguments according
to a table describing the kinds of arguments that are expected.
Each of the arguments in <I>argv</I> is processed in turn:  if it matches
one of the entries in <I>argTable</I>, the argument is processed
according to that entry and discarded.  The arguments that do not
match anything in <I>argTable</I> are copied down to the beginning
of <I>argv</I> (retaining their original order) and returned to
the caller.  At the end of the call
<B>Tk_ParseArgv</B> sets <I>*argcPtr</I> to hold the number of
arguments that are left in <I>argv</I>, and <I>argv[*argcPtr]</I>
will hold the value NULL.  Normally, <B>Tk_ParseArgv</B>
assumes that <I>argv[0]</I> is a command name, so it is treated like
an argument that doesn't match <I>argTable</I> and returned to the
caller;  however, if the TK_ARGV_DONT_SKIP_FIRST_ARG bit is set in
<I>flags</I> then <I>argv[0]</I> will be processed just like the other
elements of <I>argv</I>.
<P>
<B>Tk_ParseArgv</B> normally returns the value TCL_OK.  If an error
occurs while parsing the arguments, then TCL_ERROR is returned and
<B>Tk_ParseArgv</B> will leave an error message in <I>interp-&gt;result</I>
in the standard Tcl fashion.  In
the event of an error return, <I>*argvPtr</I> will not have been
modified, but <I>argv</I> could have been partially modified.  The
possible causes of errors are explained below.
<P>
The <I>argTable</I> array specifies the kinds of arguments that are
expected;  each of its entries has the following structure:
<PRE>
typedef struct {
	char *<I>key</I>;
	int <I>type</I>;
	char *<I>src</I>;
	char *<I>dst</I>;
	char *<I>help</I>;
} Tk_ArgvInfo;
</PRE>
The <I>key</I> field is a string such as ``-display'' or ``-bg'' that is compared with the values in <I>argv</I>.  <I>Type</I> indicates how to process an argument that matches <I>key</I> (more on this below).  <I>Src</I> and <I>dst</I> are additional values used in processing the argument.  Their exact usage depends on <I>type</I>, but typically <I>src</I> indicates a value and <I>dst</I> indicates where to store the value.  The <B>char *</B> declarations for <I>src</I> and <I>dst</I> are placeholders:  the actual types may be different.  Lastly, <I>help</I> is a string giving a brief description of this option;  this string is printed when users ask for help about command-line options. <P>
When processing an argument in <I>argv</I>, <B>Tk_ParseArgv</B> compares the argument to each of the <I>key</I>'s in <I>argTable</I>. <B>Tk_ParseArgv</B> selects the first specifier whose <I>key</I> matches the argument exactly, if such a specifier exists.  Otherwise <B>Tk_ParseArgv</B> selects a specifier for which the argument is a unique abbreviation.  If the argument is a unique abbreviation for more than one specifier, then an error is returned.  If there is no matching entry in <I>argTable</I>, then the argument is skipped and returned to the caller. <P>
Once a matching argument specifier is found, <B>Tk_ParseArgv</B> processes the argument according to the <I>type</I> field of the specifier.  The argument that matched <I>key</I> is called ``the matching argument'' in the descriptions below.  As part of the processing, <B>Tk_ParseArgv</B> may also use the next argument in <I>argv</I> after the matching argument, which is called ``the following argument''.  The legal values for <I>type</I>, and the processing that they cause, are as follows: 
<DT><B>TK_ARGV_END</B>
<DD>Marks the end of the table.  The last entry in <I>argTable</I> must have this type;  all of its other fields are ignored and it will never match any arguments. 
<DT><B>TK_ARGV_CONSTANT</B>
<DD><I>Src</I> is treated as an integer and <I>dst</I> is treated as a pointer to an integer.  <I>Src</I> is stored at <I>*dst</I>. The matching argument is discarded. 
<DT><B>TK_ARGV_INT</B>
<DD>The following argument must contain an integer string in the format accepted by <B>strtol</B> (e.g. ``0'' and ``0x'' prefixes may be used to specify octal or hexadecimal numbers, respectively).  <I>Dst</I> is treated as a pointer to an integer;  the following argument is converted to an integer value and stored at <I>*dst</I>.  <I>Src</I> is ignored.  The matching and following arguments are discarded from <I>argv</I>. 
<DT><B>TK_ARGV_FLOAT</B>
<DD>The following argument must contain a floating-point number in the format accepted by <B>strtol</B>. <I>Dst</I> is treated as the address of an double-precision floating point value;  the following argument is converted to a double-precision value and stored at <I>*dst</I>.  The matching and following arguments are discarded from <I>argv</I>. 
<DT><B>TK_ARGV_STRING</B>
<DD>In this form, <I>dst</I> is treated as a pointer to a (char *); <B>Tk_ParseArgv</B> stores at <I>*dst</I> a pointer to the following argument, and discards the matching and following arguments from <I>argv</I>.  <I>Src</I> is ignored. 
<DT><B>TK_ARGV_UID</B>
<DD>This form is similar to TK_ARGV_STRING, except that the argument is turned into a Tk_Uid by calling <B>Tk_GetUid</B>. <I>Dst</I> is treated as a pointer to a Tk_Uid; <B>Tk_ParseArgv</B> stores at <I>*dst</I> the Tk_Uid corresponding to the following argument, and discards the matching and following arguments from <I>argv</I>.  <I>Src</I> is ignored. 
<DT><B>TK_ARGV_CONST_OPTION</B>
<DD>This form causes a Tk option to be set (as if the <B>option</B> command had been invoked).  The <I>src</I> field is treated as a pointer to a string giving the value of an option, and <I>dst</I> is treated as a pointer to the name of the option.  The matching argument is discarded.  If <I>tkwin</I> is NULL, then argument specifiers of this type are ignored (as if they did not exist). 
<DT><B>TK_ARGV_OPTION_VALUE</B>
<DD>This form is similar to TK_ARGV_CONST_OPTION, except that the value of the option is taken from the following argument instead of from <I>src</I>.  <I>Dst</I> is used as the name of the option. <I>Src</I> is ignored.  The matching and following arguments are discarded.  If <I>tkwin</I> is NULL, then argument specifiers of this type are ignored (as if they did not exist). 
<DT><B>TK_ARGV_OPTION_NAME_VALUE</B>
<DD>In this case the following argument is taken as the name of a Tk option and the argument after that is taken as the value for that option.  Both <I>src</I> and <I>dst</I> are ignored.  All three arguments are discarded from <I>argv</I>.  If <I>tkwin</I> is NULL, then argument specifiers of this type are ignored (as if they did not exist). 
<DT><B>TK_ARGV_HELP</B>
<DD>When this kind of option is encountered, <B>Tk_ParseArgv</B> uses the <I>help</I> fields of <I>argTable</I> to format a message describing all the valid arguments.  The message is placed in <I>interp-&gt;result</I> and <B>Tk_ParseArgv</B> returns TCL_ERROR.  When this happens, the caller normally prints the help message and aborts.  If the <I>key</I> field of a TK_ARGV_HELP specifier is NULL, then the specifier will never match any arguments;  in this case the specifier simply provides extra documentation, which will be included when some other TK_ARGV_HELP entry causes help information to be returned. 
<DT><B>TK_ARGV_REST</B>
<DD>This option is used by programs or commands that allow the last several of their options to be the name and/or options for some other program.  If a <B>TK_ARGV_REST</B> argument is found, then <B>Tk_ParseArgv</B> doesn't process any of the remaining arguments;  it returns them all at the beginning of <I>argv</I> (along with any other unprocessed arguments). In addition, <B>Tk_ParseArgv</B> treats <I>dst</I> as the address of an integer value, and stores at <I>*dst</I> the index of the first of the <B>TK_ARGV_REST</B> options in the returned <I>argv</I>.  This allows the program to distinguish the <B>TK_ARGV_REST</B> options from other unprocessed options that preceded the <B>TK_ARGV_REST</B>. 
<DT><B>TK_ARGV_FUNC</B>
<DD>For this kind of argument, <I>src</I> is treated as the address of a procedure, which is invoked to process the following argument. The procedure should have the following structure: <DL>
<PRE>
int
<I>func</I>(<I>dst</I>, <I>key</I>, <I>nextArg</I>)
	char *<I>dst</I>;
	char *<I>key</I>;
	char *<I>nextArg</I>;
{
}
</PRE>
The <I>dst</I> and <I>key</I> parameters will contain the corresponding fields from the <I>argTable</I> entry, and <I>nextArg</I> will point to the following argument from <I>argv</I> (or NULL if there aren't any more arguments left in <I>argv</I>). If <I>func</I> uses <I>nextArg</I> (so that <B>Tk_ParseArgv</B> should discard it), then it should return 1.  Otherwise it should return 0 and <B>TkParseArgv</B> will process the following argument in the normal fashion.  In either event the matching argument is discarded. </DL>

<DT><B>TK_ARGV_GENFUNC</B>
<DD>This form provides a more general procedural escape.  It treats <I>src</I> as the address of a procedure, and passes that procedure all of the remaining arguments.  The procedure should have the following form: <DL>
<PRE>
int
<I>genfunc</I>(dst, interp, key, argc, argv)
	char *<I>dst</I>;
	Tcl_Interp *<I>interp</I>;
	char *<I>key</I>;
	int <I>argc</I>;
	char **<I>argv</I>;
{
}
</PRE>
The <I>dst</I> and <I>key</I> parameters will contain the corresponding fields from the <I>argTable</I> entry.  <I>Interp</I> will be the same as the <I>interp</I> argument to <B>Tcl_ParseArgv</B>. <I>Argc</I> and <I>argv</I> refer to all of the options after the matching one.  <I>Genfunc</I> should behave in a fashion similar to <B>Tk_ParseArgv</B>:  parse as many of the remaining arguments as it can, then return any that are left by compacting them to the beginning of <I>argv</I> (starting at <I>argv</I>[0]).  <I>Genfunc</I> should return a count of how many arguments are left in <I>argv</I>; <B>Tk_ParseArgv</B> will process them.  If <I>genfunc</I> encounters an error then it should leave an error message in <I>interp-&gt;result</I>, in the usual Tcl fashion, and return -1;  when this happens <B>Tk_ParseArgv</B> will abort its processing and return TCL_ERROR. </DL>
<P>
<P>
<H2>FLAGS</H2>
 
<DT><B>TK_ARGV_DONT_SKIP_FIRST_ARG</B>
<DD><B>Tk_ParseArgv</B> normally treats <I>argv[0]</I> as a program or command name, and returns it to the caller just as if it hadn't matched <I>argTable</I>.  If this flag is given, then <I>argv[0]</I> is not given special treatment. 
<DT><B>TK_ARGV_NO_ABBREV</B>
<DD>Normally, <B>Tk_ParseArgv</B> accepts unique abbreviations for <I>key</I> values in <I>argTable</I>.  If this flag is given then only exact matches will be acceptable. 
<DT><B>TK_ARGV_NO_LEFTOVERS</B>
<DD>Normally, <B>Tk_ParseArgv</B> returns unrecognized arguments to the caller.  If this bit is set in <I>flags</I> then <B>Tk_ParseArgv</B> will return an error if it encounters any argument that doesn't match <I>argTable</I>.  The only exception to this rule is <I>argv[0]</I>, which will be returned to the caller with no errors as long as TK_ARGV_DONT_SKIP_FIRST_ARG isn't specified. 
<DT><B>TK_ARGV_NO_DEFAULTS</B>
<DD>Normally, <B>Tk_ParseArgv</B> searches an internal table of standard argument specifiers in addition to <I>argTable</I>.  If this bit is set in <I>flags</I>, then <B>Tk_ParseArgv</B> will use only <I>argTable</I> and not its default table. <P>
<P>
<H2>EXAMPLE</H2>
 <P>
Here is an example definition of an <I>argTable</I> and some sample command lines that use the options.  Note the effect on <I>argc</I> and <I>argv</I>;  arguments processed by <B>Tk_ParseArgv</B> are eliminated from <I>argv</I>, and <I>argc</I> is updated to reflect reduced number of arguments. <PRE>
/*
 * Define and set default values for globals.
 */
int debugFlag = 0;
int numReps = 100;
char defaultFileName[] = "out";
char *fileName = defaultFileName;
Boolean exec = FALSE;
<P>
/*
 * Define option descriptions.
 */
Tk_ArgvInfo argTable[] = {
	{"-X", TK_ARGV_CONSTANT, (char *) 1, (char *) &amp;debugFlag,
		"Turn on debugging printfs"},
	{"-N", TK_ARGV_INT, (char *) NULL, (char *) &amp;numReps,
		"Number of repetitions"},
	{"-of", TK_ARGV_STRING, (char *) NULL, (char *) &amp;fileName,
		"Name of file for output"},
	{"x", TK_ARGV_REST, (char *) NULL, (char *) &amp;exec,
		"File to exec, followed by any arguments (must be last argument)."},
	{(char *) NULL, TK_ARGV_END, (char *) NULL, (char *) NULL,
	    (char *) NULL}
};
<P>
main(argc, argv)
	int argc;
	char *argv[];
{
	...
<P>
	if (Tk_ParseArgv(interp, tkwin, &amp;argc, argv, argTable, 0) != TCL_OK) {
		fprintf(stderr, "%s\n", interp-&gt;result);
		exit(1);
	}
<P>
	/*
	 * Remainder of the program.
	 */
}
</PRE>
<P>
Note that default values can be assigned to variables named in <I>argTable</I>:  the variables will only be overwritten if the particular arguments are present in <I>argv</I>. Here are some example command lines and their effects. <PRE>
prog -N 200 infile		# just sets the numReps variable to 200
prog -of out200 infile 	# sets fileName to reference "out200"
prog -XN 10 infile		# sets the debug flag, also sets numReps
</PRE>
In all of the above examples, <I>argc</I> will be set by <B>Tk_ParseArgv</B> to 2, <I>argv</I>[0] will be ``prog'', <I>argv</I>[1] will be ``infile'', and <I>argv</I>[2] will be NULL. <P>
<P>
<H2>KEYWORDS</H2>
 arguments, command line, options 
</BODY>
</HTML>
