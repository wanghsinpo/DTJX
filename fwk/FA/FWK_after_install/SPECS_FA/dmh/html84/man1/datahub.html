<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>The Hume Integration Datahub</TITLE>
</HEAD>
<BODY>
<P><A NAME="datahub"></A></P>
<HR>
<H1>The Hume Integration Datahub</H1>
<HR>
<H2>Table of Contents</H2>

<P><A HREF="#Abstract">Abstract</A></P>

<P><A HREF="#Usage">Usage Concepts</A></P>
<DIR>
<P><A href="#DB_Management">Database Management</A>
</P><P>
<A href="#SQL_Syntax">SQL Syntax</A>
</P><P>
<A href="#Key_Columns">Using Key Columns</A>
</P><P>
<A href="#WHERE">The Where Clause</A>
</P><P>
<A href="#Subscriptions">Subscriptions</A>
</P><P>
<A href="#DMH">DMH Message System Integration</A>
</P><P>
<A href="#CommandLine">Command Line Usage</A>
</DIR>

<A NAME="Cmds_index">&nbsp;</A>
<P><A HREF="#Tcl_commands">Datahub Tcl Commands</A></P>

<DIR>
<TABLE BORDER=0 CELLPADDING=4 ><TR><TD>
<A HREF="#SQL">SQL</A>
</TD><TD>
<A HREF="#execute">execute</A> 
</TD><TD>
<A HREF="#gs_execute">gs_execute</A>
</TD><TD>
<A HREF="#hub_fieldtype">hub_fieldtype</A>
</TR><TR><TD>
<A HREF="#hub_html_save">hub_html_save</A>
</TD><TD>
<A HREF="#hub_schema_html_data">hub_schema_html_data</A>
</TD><TD>
<A HREF="#hub_schema_select">hub_schema_select</A>
</TD><TD>
<A HREF="#hub_select_html_data">hub_select_html_data</A>
</TR><TR><TD>
<A HREF="#hub_select_to_csv">hub_select_to_csv</A>
</TD><TD>
<A HREF="#hub_select_to_html">hub_select_to_html</A>
</TD><TD>
<A HREF="#hub_select_to_xml">hub_select_to_xml</A>
</TD><TD>
<A HREF="#hub_subs_close_all">hub_subs_close_all</A>
</TR><TR><TD>
<A HREF="#hub_table_csv">hub_table_csv</A>
</TD><TD>
<A HREF="#hub_table_exists">hub_table_exists</A>
</TD><TD>
<A HREF="#hub_table_list">hub_table_list</A>
</TD><TD>
<A HREF="#hub_table_refresh">hub_table_refresh</A>
</TR><TR><TD>
<A HREF="#hub_table_schema_list">hub_table_schema_list</A>
</TD><TD>
<A HREF="#hub_table_sub_list">hub_table_sub_list</A>
</TD><TD>
<A HREF="#hub_tables">hub_tables</A>
</TD><TD>
<A HREF="#hub_tables_load_all">hub_tables_load_all</A>
</TR><TR><TD>
<A HREF="#hub_tables_save_all">hub_tables_save_all</A>
</TD><TD>
<A HREF="#hub_templates">hub_templates</A>
</TD><TD>
<A HREF="#hub_xml_sanitize">hub_xml_sanitize</A>
</TD></TR></TABLE>
</DIR>

<P><A HREF="#SQL_commands">SQL Command Reference</A></P>

<DIR>
<TABLE BORDER=0 CELLPADDING=4 ><TR><TD>
<A HREF="#LB">#</A> 
</TD><TD>
<A HREF="#CLOSE">CLOSE</A> 
</TD><TD>
<A HREF="#CREATE">CREATE</A>
</TD><TD>
<A HREF="#DELETE">DELETE</A> 
</TD><TD>
<A HREF="#DROP">DROP</A> 
</TD><TD>
<A HREF="#DUMP">DUMP</A>
</TR><TR><TD>
<A HREF="#ECHO">ECHO</A> 
</TD><TD>
<A HREF="#EOF">EOF</A> 
</TD><TD>
<A HREF="#EVAL">EVAL</A>
</TD><TD>
<A HREF="#EXIT">EXIT</A>
</TD><TD>
<A HREF="#HELP">HELP</A> 
</TD><TD>
<A HREF="#INCLUDE">INCLUDE</A> 
</TR><TR><TD>
<A HREF="#INSERT">INSERT</A>
</TD><TD>
<A HREF="#OPEN">OPEN</A> 
</TD><TD>
<A HREF="#PING">PING</A> 
</TD><TD>
<A HREF="#QUERY">QUERY</A>
</TD><TD>
<A HREF="#READ">READ</A> 
</TD><TD>
<A HREF="#REM">REM</A>
</TR><TR><TD>
<A HREF="#SELECT">SELECT</A> 
</TD><TD>
<A HREF="#SET">SET</A> 
</TD><TD>
<A HREF="#SOURCE">SOURCE</A> 
</TD><TD>
<A HREF="#TELECT">TELECT</A> 
</TD><TD>
<A HREF="#UPDATE">UPDATE</A>
</TD><TD>
<A HREF="#WRITE">WRITE</A>
</TR></TABLE>
</DIR>

<P><A HREF="#TclReplyFormat">Tcl Reply Format</A></P>

<P><A HREF="#Notation">Notation</A></P>

<P><A HREF="#Compatibility">Compatibility Notes</A></P>

<P><A HREF="#version">Document Version</A></P>

<HR>
<PRE>(C)Copyright 1996, 2004 Hume Integration Software
All Rights Reserved
</PRE>
<I>This document may not be reproduced or redistributed without prior
written permission of Hume Integration Software.  Licensed users
of HIS provided software have permission to reproduce or electronically
distribute this document to support their usage of the HIS 
software.</I>
<HR><HR><A NAME="Abstract"></A></P>

<H2>Abstract</H2>

<P>The Hume Datahub is an in-memory, low-latency database, a subscription
server, a configurable Tcl/Tk interpreter, and a Distributed Message Hub
(DMH) server. The synergistic combination of these capabilities is the
cornerstone of a new architecture for distributed applications.</P>

<P>As a database server, the Hub provides the familiar programming model
of relational database tables using a subset of Structured Query Language
(SQL). A graphical user interface is available to display and manipulate
table data either remotely as a client, or as part of the Hub process when
it is not running in the background.</P>

<P>As a subscription server, the Hume Datahub provides asynchronous
notification to Client processes whenever data that meets their selection
criteria is inserted, updated, or deleted. These notifications can be standard
SQL messages which are useful for data replication to other Hume Datahubs,
or for data replication to commercially available persistent databases,
such as Oracle or DB2. Other subscription options enable the developer
to execute user defined Tcl procedures within the Hub process, or to obtain
notification messages in a format that is designed for use by Tcl list
manipulation commands.</P>

<P>When used as a DMH message server, a Hume Datahub becomes the hub
of an efficient, event-driven, distributed application. The Tcl interpreter
provides a high-level, dynamically customizable programming environment
with comprehensive features. Client processes can easily exchange peer
messages, can easily share common data in relational tables, and can subscribe
and respond in realtime to changes in the application data. Shared application
logic can be executed within the Hume Datahub process, sharing the
same address space with application data tables and SQL command processing
logic. The requirement for interprocess communication and the substantial
overhead that it entails is reduced drastically compared to other approaches.
<HR><A NAME="Usage"></A></P>

<H2>Usage Concepts</H2>

<P>The capabilities of the Hume Datahub are built into a general purpose
Tcl/Tk interpreter, where they are accessed along with the multitude of
other Tcl/Tk commands. From within Tcl code, a developer uses the <B>SQL</B>
Tcl command with an SQL statement as
a single argument to access the data management functionality.</P>
<P>
The Tcl programming language has features such as the 
<a href="../mann/namespace.html">namespace</a> command to support combining
new commands like the Hume provided <B>SQL</B> command with commands from other 
packages.  When you use the Hume Datahub features, typically
the command <b><a href="../mann/package.html">package require dmh</a></b> and the
command <b><a href="../mann/dmh_import.html">dmh_import</a></b> have been executed
during initialization to make the <b>dmh</b> package commands such as SQL
available in the global namespace of the interpreter.  If the <b>dmh</b>
package commands have not been imported into the global namespace, then
the command names must be invoked using the namespace prefix, for example,
<b>::dmh::SQL</b> would be used instead of <b>SQL</b>.  </P>

<P>In normal use, a Datahub is also participating in a DMH messaging group.
In this usage, the Datahub receives DMH messages sent to its command mailbox,
and executes the messages as SQL statements. Usually these command messages
are standard SQL statements such as the SQL <A HREF="#INSERT">insert</A>
statement or the SQL <A HREF="#SELECT">select</A> statement. For convenience
to its message system clients, the Datahub accepts and processes certain
statements that are not standard SQL, which allow the clients to access
the Tcl commands and features of the Datahub. For example, a client can
use <A HREF="#EVAL">eval</A> to execute Tcl code such as procedure evaluations.</P>

<P>The Graphical User Interface (GUI) of the Datahub provides features
to display and manipulate table data. Also, the GUI provides windows for
the input of Tcl commands or SQL commands. The GUI is written in Tcl code,
and dynamically loaded into the Tcl/Tk interpreter using the same techniques
that you use to create your own applications.</P>

<A NAME="DB_Management">&nbsp;</A>
<H3>Database Management</H3>

<P>The Datahub uses a subset of ANSI standard SQL for database management.
The basic SQL commands are supported for operations on one table per SQL
statement. Table joining, grant and revoke, commit and rollback, creation
of views, or data integrity constraints are not directly supported by the
SQL command. However, because the SQL functionality is imbedded in a Tcl/Tk
interpreter, it is possible to provide equivalent functionality to many
of these advanced SQL features by writing Tcl procedures.</P>

<A NAME="SQL_Syntax">&nbsp;</A>
<h4>SQL Syntax</H4>

<P>Table names and column names can have 1 to 31 alphanumeric or underscore
characters. They should start with a leading alphabetic character or underscore.
You are able to use either alphabetic case for table and column names or
for SQL keywords in your SQL statements. The Datahub retains the original
alphabetic case of table and column names from the table create statement,
and uses this for query replies.</P>

<P>SQL character strings must be delimited with single quotes, even when
they are a single character. To imbed single quotes in a character string,
double them, as in the example: 'Here''s Johnny'.</P>

<P>The new Datahub is able to convert data types in SQL statements and
expressions, between the basic integer, floating point, or character types.
For example, the string constant '43' is acceptable as the value of an
integer or as the floating point value, 43.0. Similarly, the numeric value,
3.14, if used in context where a character value is expected, will be treated as
the character string '3.14'.</P>

<P>There is sufficent information in the reference section of this document
to understand the syntax of SQL statements that are accepted by the Data
Hub. If you are new to relational databases, you may wish to obtain additional
information on table design and data normalization.</P>

<P>Database tables are created using the SQL <A HREF="#CREATE">create</A>
command, and destroyed using the SQL <A HREF="#DROP">drop</A> command.
Each column of a table is a specific data type such as INTEGER. The supported
data types are described with the <A HREF="#CREATE">create</A> command.</P>

<A NAME="Key_Columns">&nbsp;</A>
<h4>Using Key Columns</h4>

<P>When a table is created, one or more columns can be specified as primary
key columns. When key columns are used, insertion of duplicate rows is
not allowed. Said another way, you cannot insert a row into a table if
a row already exists in the table with the same values of the key columns.
In addition to preventing duplicate rows, keys are used to speed the lookup
of rows, when processing the SQL <A HREF="#INSERT">insert</A>, <A HREF="#UPDATE">update</A>,
<A HREF="#DELETE">delete</A>, or <A HREF="#SELECT">select</A> commands.
If all of the values of the key columns are specified, the specific row
is located directly.</P>

<P>Using key columns also causes the <A HREF="#SELECT">select</A> command
to return row data in sorted order. In contrast to ANSI standard SQL, the
sorted result is obtained by default, without using an ORDER BY clause
in the SQL <A HREF="#SELECT">select</A> command. If the keys are VARCHAR
data types, the sorted order will be a proper ascending sequence of the
primary key columns. If numeric data types are used as keys, the ordering
is not as useful, and you may want to use the Tcl <A HREF="../mann/lsort.html">lsort</A>
command on the selected rows to obtain a properly sorted result.</P>

<P>Data is added to a table one row at a time using the SQL <A HREF="#INSERT">insert</A>
command. The SQL <A HREF="#INSERT">select</A> command is used to query
existing data. The SQL <A HREF="#UPDATE">update</A> command is used to
modify stored data, and the SQL <A HREF="#DELETE">delete</A> command is
used to delete data rows. </P>

<A name="WHERE">&nbsp;</A>
<h4>The Where Clause</h4>

<P>When using the select, update, and delete commands
you optionally provide a WHERE clause which specifies selection criteria
for the affected rows. Also, a WHERE clause can be specified when using
the SQL <A HREF="#OPEN">open</A> command to establish a subscription only
for rows meeting the WHERE clause selection criteria. A WHERE clause consists
of one or more comparisons between a column value and a constant, or two
column values. All of the usual SQL comparison operators are supported:
equal (=), not equal (&lt;&gt;), less than (&lt;), less than or equal (&lt;=),
greater than (&gt;), and greater than or equal (&gt;=). Compound conditions
are expressed using the NOT, AND, and OR operators. Parentheses may be
used to group terms. All of the comparison operators have equal precedence,
and their precedence is higher than the NOT, AND, and OR operators. So,
if you write</P>

<PRE>        select * from equipment where machine='hx14' or machine='hx15'
</PRE>

<P>it is equivalent to</P>

<PRE>        select * from equipment where (machine='hx14') or (machine='hx15')
</PRE>

<P>since the OR operator binds less tightly than the comparison operator
=.</P>

<P>NOT has a higher precedence than AND which has a higher precedence than
OR. If you write</P>

<PRE>    select * from equipment where
   class='hx' and not color='green' or machine='zq2'
</PRE>

<P>it is equivalent to</P>

<PRE>    select * from equipment where
  ((class='hx') and (not (color='green'))) or (machine='zq2')
</PRE>

<P>Your WHERE clauses can also use the LIKE comparison operator to compare
a VARCHAR field to a string constant pattern. Standard SQL uses the % character
as a wild card that matches 0 or more characters, and the underscore, _,
as a wild card that matches 1 character. So if you write</P>

<PRE>    SQL &quot;select * from equipment where machine like 'hxq%'&quot;
</PRE>

<P>you will select machine values such as 'hxq14'.</P>

<P>The LIKE operator has been implemented using the <A HREF="../mann/string.html">string
match</A> functionality of Tcl. If you look at the reference for the string
match command, you will see that it has more features than the simple matching
characters of the standard SQL LIKE; for example, you can use character
classes such as [0-9] to represent any number. These powerful features
have not been disabled, and you are able to use them in your LIKE operator
patterns. However, these features are not standard SQL, and you should
consider that these features are not portable to other SQL databases. The
other implication of not disabling these features, is that if your LIKE
pattern contains the special characters *, ?, or [ and ], you need to escape
them using the backslash character to have them treated as regular characters.</P>

<A NAME="Subscriptions">&nbsp;</A>
<h4>Subscriptions</h4>

<P>Table data subscriptions are opened to have notification messages sent
any time specified table data is changed, or, to have a Tcl procedure executed
any time specified data is changed. There can be any number of subscriptions
on each table. For example, you may wish to have each user interface open
a subscription to a table that holds active alarm data so that a message
is sent to every user interface when a new row representing a new alarm
is inserted.</P>

<P>Another example use of a table data subscription is to perform realtime
analysis on new measurement data using a Tcl procedure that executes in
the Datahub. The analysis code is activated without the overhead of interprocess
communication. The logic that produces the measurement data, whether it
be an equipment interface, or user interface, is developed, tested, and
deployed independent of the analysis logic.</P>

<P>The SQL <A HREF="#OPEN">open</A> command is used to create a table data
subscription. Each use of the open command creates a subscription to one
or more columns of a specific table for all rows which match specified
selection criteria. Options to the open command indicate whether the subscription
notifications execute a Tcl procedure, or whether the notifications result
in messages being sent. There is also a SYNC option that causes notifications
to be activated for all of the existing data matching the selection criteria
at the time the subscription is opened. The SYNC feature makes it easy
for a client to synchronize with the current and future states of the application
data. The ease of meeting this application requirement stands in marked
contrast to other CIM products such as CELLWORKS dmbx, DEC Message Queue,
or TIBCO Rendezvous, which offer broadcast or subscription based message
propagation without any history.</P>


<P>The SQL <A HREF="#CLOSE">close</A> command is used to remove table data
subscriptions.</P>

<A NAME="DMH">&nbsp;</A>
<h4>DMH Message System Integration</h4>

<P>The Datahub has a small set of data items that are assigned values
using the SQL <A href="#SET">set</A> command or queried using the SQL
<A href="#QUERY">query</A> command.  These data parameters are used to
configure specific aspects of the Datahub's behavior and are described
under the <A href="#SET">set</A> command.</P>

<P>The <A href="#GROUP">GROUP</A> parameter specifies the DMH message group
name that the Datahub will use when initializing DMH message communication.
The value defaults to "mbx".  The <A href="#SERVER">SERVER</A> parameter
specifies the mailbox name that the Datahub will use to receive 
SQL message commands from the DMH messaging system.  The value of the SERVER
parameter defaults to "DATAHUB".  The SQL <A href="#EOF">EOF</A> command
is used to initialize message system communication.  Once message communication
has been initialized, the values of the SERVER and GROUP parameters cannot
be changed.  It is typical to specify these parameters, and to initialize
DMH message communication on the Datahub's command line.  A typical
startup might also use the SQL <A href="#SOURCE">source</A> command to
read and process some Tcl initialization code, such as statements to
build tables and load data.  Thus, an invocation of a Datahub
might look like:
<PRE>datahub "set server=DBM" "set group=spc2" "source hub_init.tcl" eof &
</PRE>

<A NAME="CommandLine">&nbsp;</A>
<h4>Command Line Usage</h4>
<P>
The capabilities of the Datahub are built into a general purpose Tcl/Tk
interpreter, <A href="dmh_wish.html">dmh_wish</A> which has its own document
describing its command line options.  These command line options are
available to the Datahub. </P>
<P>
Typically, the Datahub is invoked from a script file; namely <B>datahub84</B>, 
<B>hub84</B>, or <B>datahub84.bat</B>.  On your system, you may find these scripts also 
installed under the version independent name <B>datahub</B> or 
<B>datahub.bat</B>. 
The script file configures the underlying interpreter so that the command line
arguments which are not processed as interpreter options,
are processed as SQL commands as described in the 
<A href="#SQL_commands">SQL Command Reference</A> section of this document.
One of the important <A href="dmh_wish.html">dmh_wish</A>
command line options is <B>-notk</B>.  This option starts the Datahub in
background, without it communicating with the Windowing system.  This is
the way you want to run a production application, so that you can logout
without shutting down the Datahub.  Also, when running for production on Unix,
you should start the Datahub in a shell that provides protection against
the SIGHUP signal at logout such as the <B>ksh</B>, the <B>csh</B>, or the 
<B>bash</B> shells.  If you use the older Bourne shell 
you may need to use the <B>nohup</B> command.
<P>
You typically do not use the <B>-notk</B>
for development work.  In this usage, the datahub script file creates the
user interface to the Datahub which is invaluable to a developer.  </P>
<P>
Whether you run the Datahub in background or not, you can also run the 
<a href="hubclient.html">hubclient</a>  
application on any X-display or any Windows NT display in
your TCP/IP network, in order to provide the same Datahub user interface.
You are able to run as many instances of this application as you choose.</P>
The Datahub user interface is a tool for developers and not for application
users, because it makes it easy to drop tables, delete rows, terminate
client applications, or make other potentially disruptive changes.</P>
<P>
The <B>hubclient</B> can be started with an argument that specifies the
<A href="#SERVER">SERVER</A> mailbox and the DMH <A href="#GROUP">GROUP</A>
of the target Datahub.  For example, to provide a user interface to a Datahub
running on host malibu, with the SERVER mailbox of DBM, and the DMH GROUP of
sta1, enter
<PRE>hubclient DBM@malibu:sta1 &amp;
</PRE>
at the command prompt.  Windows NT users do not enter the background operator &amp;.
If you do not supply a command line argument, the
hubclient application will prompt you for one.</P>
<P>The <B>hub84</B> script configures the Datahub so that it does not
become a DMH message system server.  You use the <B>hub84</B> script when
you wish to run additional instances of Datahubs in a DMH message group,
and another process in the group is already functioning as the DMH server.
In other words, you should select a single Datahub to
be the DMH server for a given group, and invoke it with the <B>datahub</B>
script.  Subsequent Datahubs that will join the same DMH group should be
started using <B>hub84</B>.  See the 
<A href="../mann/mbx.html">mbx</A> command for more information
on message groups.</P>

<P>
<HR><HR></P>

<P><A NAME="Tcl_commands">&nbsp;</A></P>
<H2>Datahub Tcl Commands</H2>

<P>The following Tcl commands have been implemented as part of the 
Hume <b>dmh</b> package in order to provide Hume Datahub functionality.
Almost always, these commands have been imported into the global namespace
of the Tcl interpreter from the <b>::dmh</b> namespace. The importing
occurs when the user runs the <b>datahub84</b> or <b>hub84</b> application scripts.
Custom applications that do not use these scripts can have the same
convenient global access to the commands by calling 
<a href="../mann/dmh_import.html">dmh_import</a> or by directly using
the <a href="../mann/namespace.html">namespace import</a> command.
The package commands can
be accessed in their native namespace by prepending <b>::dmh::</b> to the
command name.  For example, the SQL command is always accessible as <b>
::dmh::SQL</b>.
</P>
<DIR>
<TABLE BORDER=0 CELLPADDING=4 ><TR><TD>
<A HREF="#SQL">SQL</A>
</TD><TD>
<A HREF="#execute">execute</A> 
</TD><TD>
<A HREF="#gs_execute">gs_execute</A>
</TD><TD>
<A HREF="#hub_fieldtype">hub_fieldtype</A>
</TR><TR><TD>
<A HREF="#hub_html_save">hub_html_save</A>
</TD><TD>
<A HREF="#hub_schema_html_data">hub_schema_html_data</A>
</TD><TD>
<A HREF="#hub_schema_select">hub_schema_select</A>
</TD><TD>
<A HREF="#hub_select_html_data">hub_select_html_data</A>
</TR><TR><TD>
<A HREF="#hub_select_to_html">hub_select_to_html</A>
</TD><TD>
<A HREF="#hub_select_to_xml">hub_select_to_xml</A>
</TD><TD>
<A HREF="#hub_subs_close_all">hub_subs_close_all</A>
</TD><TD>
<A HREF="#hub_table_csv">hub_table_csv</A>
</TR><TR><TD>
<A HREF="#hub_table_exists">hub_table_exists</A>
</TD><TD>
<A HREF="#hub_table_list">hub_table_list</A>
</TD><TD>
<A HREF="#hub_table_refresh">hub_table_refresh</A>
</TD><TD>
<A HREF="#hub_table_schema_list">hub_table_schema_list</A>
</TR><TR><TD>
<A HREF="#hub_table_sub_list">hub_table_sub_list</A>
</TD><TD>
<A HREF="#hub_tables">hub_tables</A>
</TD><TD>
<A HREF="#hub_tables_load_all">hub_tables_load_all</A>
</TD><TD>
<A HREF="#hub_tables_save_all">hub_tables_save_all</A>
</TR><TR><TD>
<A HREF="#hub_templates">hub_templates</A>
</TD><TD>
<A HREF="#hub_xml_sanitize">hub_xml_sanitize</A>
</TD></TR></TABLE>
</DIR>


<HR>
<A NAME="SQL">&nbsp;</A>
<H3>SQL - Execute an SQL Statement</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>SQL</B> <I>sql_command</I>
<P></P><DT><B>Description</B><DD>
The SQL command processes the <I>sql_command</I> argument as 
described in the next section <A HREF="#SQL_commands">SQL Command
Reference</A>.  This command is the workhorse Tcl command that
you use in your custom Tcl procedures in order to access
database functionality.  
</DL>

<P>
<HR>
<A NAME="execute">&nbsp;</A></P>
<H3>execute - Execute an SQL Statement</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>execute</B> <I>sql_command</I>
<P></P><DT><B>Description</B><DD>
The execute command exists for compatibility with Tcl code that was
written for earlier versions of the Datahub.  New Tcl code should use the
<A HREF="#SQL">SQL</A> command to access database functionality of the
Datahub.
<P>The Tcl execute command is nearly synonymous with the Tcl <A HREF="#SQL">SQL</A>
command. The command processes the <I>sql_command</I> argument as a <A HREF="#SQL_commands">Data
Hub SQL command</A> as described in the next section. The return value
is a Tcl list where each element of the list is a reply message that would
be obtained if the argument were sent as a message command to the Data
Hub's command mailbox. In other words, since most of the <A HREF="#SQL_commands">Data
Hub SQL commands</A> return a single reply message, most of the return
values will be formatted similar to &quot;{//c 0 COMMAND: success}&quot;.</P>

<P>The execute Tcl command differs from the <A HREF="#SQL">SQL</A> Tcl
command in the format of the reply for the <A HREF="#SELECT">select</A>
and the <A HREF="#TELECT">telect</A> SQL statements. For both these statements,
the SQL command reply uses the <A HREF="#TclReplyFormat">Tcl Reply
Format</A> so that the query data is easily manipulated using Tcl list
commands. In contrast, the execute select statement reply is a list of
&quot;SELECT: ...&quot; messages with a final &quot;//c&quot; legacy style
message. See the <A HREF="#SELECT">select</A> description for details.</P>

<P>The difference with the execute and SQL &quot;telect&quot; statement
replies is subtle. The execute command returns the <A HREF="#TclReplyFormat">Tcl
Select Reply Format</A> but it is packaged as a one element Tcl list. Therefore,
it is always true that the return value of the execute statement is a Tcl
list where each element of the list is a reply message that would be obtained
if the argument were sent as a message command to the Datahub's command
mailbox.</P>
</DL>

<hr>

<P><A NAME="gs_execute">&nbsp;</A></P>
<H3>gs_execute - Process an SQL Message</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>gs_execute</B> <I>mbxdest</I> <I>mbxmsg</I> <I>mbxreply</I>
<P></P><DT><B>Description</B><DD>
<P>This Tcl command is used internally by the Datahub software when
it receives SQL command messages from its command mailbox.  The
command causes the <I>mbxmsg</I> argument to be processed as an
SQL command, and causes reply messages to be sent to mailbox
<I>mbxreply</I> when appropriate.  When message communication
is initialized with the SQL <A HREF="#EOF">EOF</A> command,
Tcl code similar to:
<PRE>mbx whenmsg $SQL(SERVER) { mbx whenmsg again ; 
gs_execute $mbxdest $mbxmsg $mbxreply }
</PRE>
is executed to establish the basic processing of command messages.
<P>
Usually, the application developer need not be concerned about the gs_execute command.
However, there are three circumstances that we can think of where you may
want to use this command. </P>
<P>
First, you can use this command in order to 
process SQL commands that are received in a different mailbox than the main
server command mailbox.  Just execute your own "mbx whenmsg" statement
specifying the mailbox name that you wish.</P>
<P>
A second use for the gs_execute command is to modify the basic DMH command
processing loop of the Datahub.  For example, in a debugging situation,
you could print every statement being processed by executing:</P>
<PRE>mbx whenmsg $SQL(SERVER) { mbx whenmsg again ; puts $mbxmsg ;
gs_execute $mbxdest $mbxmsg $mbxreply }
</PRE>
<P>
Finally, in rare circumstances you may wish to re-arm the Datahub for
re-entrant execution of SQL message commands.  Ordinarily, you will not
receive another DMH message in your command mailbox if gs_execute has not
completed processing a prior message.  This is a desirable characteristic
of the DMH message system since it saves you from having to worry about
re-entrant execution of your application code.  However, there are
circumstances where re-entrant execution may be desired.  For example,  
a Datahub may receive a message that causes it to query another application
for some data.  In turn, the other application needs to query the Datahub
for related data before sending a reply.  
To re-arm itself for re-entrant execution, the Datahub needs to execute the
full statement
<PRE>mbx whenmsg $SQL(SERVER) { mbx whenmsg again ; puts $mbxmsg ;
gs_execute $mbxdest $mbxmsg $mbxreply }
</PRE>
while it is "busy" processing the original message.</P>
<P>
This contrived
example does require re-entrant execution, but in truth its a more
insightful example of poor design.  The application should not
require the Datahub to perform a synchronous query of another
application in order to return a synchronous reply.  The design should
be reworked so that the processes pass along enough context information
in order to process the same work asynchronously.  The example
problem can also be sidestepped by having the Datahub process message
commands received in another mailbox, and having the other application
use this alternate mailbox for its nested queries.
</DL>

<hr>
<A NAME="hub_fieldtype">&nbsp;</A>
<H3>hub_fieldtype - Return a Column Datatype</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_fieldtype</B> <I>Column</I> <I>Schema_list</I>
<P></P><DT><B>Description</B><DD>
Given a <I>Schema_list</I> returned from using <A href="#hub_table_schema_list">
hub_table_schema_list</A> and the name of a column <I>Column</I>, this Tcl
procedure returns the datatype of the column such as "varchar", "varchar(20)",
"int", "float" or "double". 
</DL>

<hr>
<A NAME="hub_html_save">&nbsp;</A>
<H3>hub_html_save - Write data or schema as HTML documents</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_html_save [<i>one_doc</i> [<i>data</i> [<i>schema</i> [<i>contents</i>
 [<i>schema_description</i> [<i>table_list</i> [<i>pathname_or_dir</i>]]]]]]]</B>
<P></P><DT><B>Description</B><DD>
This procedure writes table data or table schema information from one or
more tables to 1 or more HTML documents.  The command is used to implement
the HTML Save feature of the Datahub GUI, and it can be a useful procedure
for your applications.
The <i>one_doc</i>,
<i>data</i>, <i>schema</i>, <i>contents</i>, and <i>schema_description</i>
arguments are all used as boolean with values 1 or 0 as follows:
<DL>
<DT><i>one_doc</i>
<DD>If 1, output will be to a single file, and the <i>pathname_or_dir</i>
argument if provided, specifies the output pathname.  Defaults to 1.
<DT><i>data</i>
<DD>If 1, table data will be output. Defaults to 1.
<DT><i>schema</i>
<DD>If 1, table schema information will be output.  Defaults to 1.
<DT><i>contents</i>
<DD>If 1, a Table of Contents with hyperlink references will be
written into the output file(s). Defaults to 1.
<DT><i>schema_description</i>
<DD>If 1, the schema tables will have an additional column <b>Description</b>
which will be empty.  This option is used to help prepare documentation.
Defaults to 0.
<DT><i>table_list</i>
<DD>The default value creates output for every hub table.
<DT><i>pathname_or_dir</i>
<DD>If this argument is supplied, it is used as the output pathname if
<i>one_doc</i> is 1, otherwise it specifies the output directory.  The default filename
when <i>one_doc</i> is 1 is <b>snapshot<i>YYYYMMDD</i>_<i>HHMMSS</i>.html</b>,
where substitutions are made for the current date and time.  For output to
multiple documents, the filenames are written as <b><i>tablename</i>.html</b>.
The default directory in both cases is the current working directory.
</DL>
</DL>

<hr>
<A NAME="hub_schema_html_data">&nbsp;</A>
<H3>hub_schema_html_data - obtain schema data as HTML</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_schema_html_data <i>tablename</i> [<i>Description</i> [<i>fid</i>]]</B>
<P></P><DT><B>Description</B><DD>
This command writes an HTML table describing the schema of <i>tablename</i>.
If passed a handle to an open file as <i>fid</i>, the command writes
directly to the file; otherwise the HTML is the returned result.
The <i>Description</i> argument is used as a boolean to indicate whether
an additional column labeled <b>Description</b> should be output.  This 
option may be used to help create documentation.
</DL>
<hr>
<A NAME="hub_schema_select">&nbsp;</A>
<H3>hub_schema_select - Obtain the schema of a table as a selection result</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_schema_select <i>tablename</i> [<i>Description</i>]</B>
<P></P><DT><B>Description</B><DD>
The command provides the schema of a table as if it is a Tcl Reply Format
selection result.  The result
includes spaces and mixed case column names which you would not get
from an ordinary table selection.
Set the <i>Description</i> argument to 1 to obtain a blank Description column
which may be desired for creating HTML documention.  The provided columns are
<b>Column Name</b>, <b>Key</b>, and <b>Type</b> and then optionally <b>Description</b>.
</DL>
<hr>
<A NAME="hub_select_html_data">&nbsp;</A>
<H3>hub_select_html_data - Obtain table data as HTML</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_select_html_data <i>table</i> [<i>fid</i> [<i>columns</i> [<i>where_clause</i>]]]</B>
<P></P><DT><B>Description</B><DD>
Selects data from a table using the SQL command. 
Converts the data to HTML.  If passed the handle to an open file, writes to the file
otherwise returns the HTML data as the result.
The default value of the <i>columns</i> argument selects all the columns.
You can optionally specify a list of desired columns.
The default value of the <i>where_clause</i> argument selects all the rows.
When provided, the <i>where_clause</i> should include the <b>where</b> keyword.
</DL>

<hr>
<A NAME="hub_select_to_csv">&nbsp;</A>
<H3>hub_select_to_csv - Convert Selected Data to CSV Format</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_select_to_csv <I>selection</I> [<I>write_headers</I>]</B>
<P></P><DT><B>Description</B><DD>
This procedure is used to convert a Datahub or ODBC selection result
to the popular Comma Separated Value (CSV) format.  
The procedure return value is a list of text lines without newline delimiters.
The optional argument <I>write_headers</I> defaults to 1 which causes a
comma separated list of column names to be included as the first list
element of the return value.
</DL>

<hr>
<A NAME="hub_select_to_html">&nbsp;</A>
<H3>hub_select_to_html - Convert the Tcl Reply Format to HTML</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_select_to_html <i>selection</i> [<i>empty_string</i>]</B>
<P></P><DT><B>Description</B><DD>
Convert a Datahub or ODBC selection result to HTML.
The HTML result is also proper XML.
This format uses the table rendering tags of HTML and displays
properly in a browser.
You may want to set the <i>empty_string</i> argument to &amp;nbsp; to have
empty table cells displayed as recessed.
<p>Here is an example of the format.  The table below:</p>
<p></p>
<table id="dc_runrules" border="1"><tr> <th>name</th><th>description</th></tr>
<tr><td>3sigma</td><td>Western Electric #1 - one point outside of +/- 3 sigma</td></tr>
<tr><td>3sigmaH</td><td>One point higher than + 3 sigma</td></tr>
<tr><td>3sigmaL</td><td>One point lower than - 3 sigma</td></tr>
</table>
<p>is rendered from the HTML data:
<PRE>&lt;table id=&quot;dc_runrules&quot; border=&quot;1&quot;&gt;&lt;tr&gt; &lt;th&gt;name&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3sigma&lt;/td&gt;&lt;td&gt;Western Electric #1 - one point outside of +/- 3 sigma&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3sigmaH&lt;/td&gt;&lt;td&gt;One point higher than + 3 sigma&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3sigmaL&lt;/td&gt;&lt;td&gt;One point lower than - 3 sigma&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

</PRE
</DL>
<hr>
<A NAME="hub_select_to_xml">&nbsp;</A>
<H3>hub_select_to_xml - Convert the Tcl Reply Format to XML</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_select_to_xml <i>reply</i> [<i>header</i>]</B>
<P></P><DT><B>Description</B><DD>
Convert a Tcl Reply Format result to XML.
The input format is from a selection, or a subscription notification.
The tags make no sense to a browser, so this format is intended for
XML parsing software.  Setting the <i>header</i> argument to 0 suppresses
having the string &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; as the
first part of the result.  
<p>Here is an example of the XML format.  The table data that resulted in the 
HTML table shown in the previous procedure was also converted to the following XML data:
<PRE>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;selection&gt;
 &lt;notification&gt;select&lt;/notification&gt;
 &lt;tablename&gt;dc_runrules&lt;/tablename&gt;
 &lt;columns&gt;
   &lt;column&gt;name&lt;/column&gt;&lt;column&gt;description&lt;/column&gt;&lt;/columns&gt;
 &lt;keys&gt;
   &lt;key&gt;name&lt;/key&gt;&lt;/keys&gt;
 &lt;count&gt;3&lt;/count&gt;
 &lt;errorInfo&gt;&lt;/errorInfo&gt;
 &lt;rows&gt;
  &lt;row&gt;&lt;name&gt;3sigma&lt;/name&gt;&lt;description&gt;Western Electric #1 - one point outside of +/- 3 sigma&lt;/description&gt;&lt;/row&gt;
  &lt;row&gt;&lt;name&gt;3sigmaH&lt;/name&gt;&lt;description&gt;One point higher than + 3 sigma&lt;/description&gt;&lt;/row&gt;
  &lt;row&gt;&lt;name&gt;3sigmaL&lt;/name&gt;&lt;description&gt;One point lower than - 3 sigma&lt;/description&gt;&lt;/row&gt;
 &lt;/rows&gt;
&lt;/selection&gt;

</PRE>
</DL>

<hr>
<A NAME="hub_subs_close_all">&nbsp;</A>
<H3>hub_subs_close_all - Close All Subscriptions</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_subs_close_all</B>
<P></P><DT><B>Description</B><DD>
Calling this Tcl procedure closes all the subscriptions on all the
tables of the Datahub.
</DL>

<hr>
<A NAME="hub_table_csv">&nbsp;</A>
<H3>hub_table_csv - Write Data in CSV Format</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_table_csv <I>table</I> [<I>pathname</I> [<I>column_list</I> [<I>where_clause</I>]]]</B>
<P></P><DT><B>Description</B><DD>
This procedure is used to write selected data of a table to a file in the
popular Comma Separated Value (CSV) format.  The  procedure will overwrite without
warning an existing file of the same name.  The default <I>pathname</I> is the table
name concatenated with ".csv" in the working directory.  You may optionally
specify selected columns as the <I>column_list</I> argument.  The default is to
output all columns.  You may specify a row selection criteria as the 
optional <i>where_clause</i> argument.  The default behavior is to select all rows.
The <i>where_clause</I> argument, if used, should be a complete SQL select where
clause, including the literal <B>where</B> keyword.   
</DL>


<hr>
<A NAME="hub_table_exists">&nbsp;</A>
<H3>hub_table_exists - Check For Table Existence </H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_table_exists</B> <I>table</I>
<P></P><DT><B>Description</B><DD>
Calling this Tcl procedure returns 1 if the table named <I>table</I>
exists or 0 if it does not.  The alphabetic case of <I>table</I> 
does not matter.
</DL>

<hr>
<A NAME="hub_table_list">&nbsp;</A>
<H3>hub_table_list - List Table Statistics</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_table_list</B>
<P></P><DT><B>Description</B><DD>
Calling this Tcl procedure returns a list of 
{<I>table</I> <I>row_count</I> <I>subscription_count</I>}
records for each table.  The field <I>table</I> is the table name,
<I>row_count</I> is the current count of data rows, and <I>subscription_count</I>
is the current count of subscriptions on the table.  Use the
<A href="#hub_tables">hub_tables</A> procedure to obtain a plain list
of table names.
</DL>

<hr>
<A NAME="hub_table_refresh">&nbsp;</A>
<H3>hub_table_refresh - Refresh the Datahub GUI Main Window</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_table_refresh</B>
<P></P><DT><B>Description</B><DD>
Calling this Tcl procedure updates the Datahub GUI main window.
It is an error to call this procedure if the Datahub is
executing in the background without a main window.
</DL>

<hr>
<A NAME="hub_table_schema_list">&nbsp;</A>
<H3>hub_table_schema_list - Query a Table's Schema</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_table_schema_list</B> <I>table</I>
<P></P><DT><B>Description</B><DD>
Calling this Tcl procedure returns a list of 
{<I>columnname</I> <I>datatype</I> <I>key_number</I>} records for
each column in the table.  The <I>key_number</I> item is an
empty string if the column is not a key.
</DL>

<hr>
<A NAME="hub_table_sub_list">&nbsp;</A>
<H3>hub_table_sub_list - List Table Subscriptions</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_table_sub_list</B> <I>table_list</I>
<P></P><DT><B>Description</B><DD>
Given a list of 1 or more tables, this Tcl procedure returns a list
of subscription records where each record consists of
{<I>table subscription_name open_statement</I>}
</DL>

<hr>
<A NAME="hub_tables">&nbsp;</A>
<H3>hub_tables - List Existing Tables</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_tables</B>
<P></P><DT><B>Description</B><DD>
This Tcl procedure returns a list of existing tables.
</DL>

<hr>
<A NAME="hub_tables_load_all">&nbsp;</A>
<H3>hub_tables_load_all - Read Saved Table Files</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_tables_load_all</B>
<P></P><DT><B>Description</B><DD>
This Tcl procedure attempts to load all of the files in the
current directory that match the pattern *.tab using the 
<A href="#READ">read over</A> command.  The assumption is that
they store a set of tables that were saved using the <A href="#WRITE">write
</A> command or the <B>hub_tables_save_all</B> procedure.
</DL>

<hr>
<A NAME="hub_tables_save_all">&nbsp;</A>
<H3>hub_tables_save_all - Save All Tables</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_tables_save_all</B>
<P></P><DT><B>Description</B><DD>
This Tcl procedure writes all existing tables as
.tab files in the 
current working directory using the 
<A href="#WRITE">write over</A> command. 
</DL>

<hr>
<A NAME="hub_templates">&nbsp;</A>
<H3>hub_templates - Provide template SQL statements</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_templates <I>table</I> [<I>format</I>]</B>
<P></P><DT><B>Description</B><DD>
This Tcl procedure returns a list of programming statements
which are models for custom development.  The optional
<I>format</I> argument defaults to <b>tcl</b> which means
that the statements are Tcl code.  In this case, a list of
six elements is returned.  The list consists of a create
statement, an insert statement, an update statement, 
a delete statement, template selection code, and a column name 
assignment statment.
The value of <B>sql</B> is also supported for the <I>format</I> argument,
in which case the template programming statements are SQL.  In this
case the procedure return value is a list of five SQL statements;
the create, insert, update, delete, and select statements.
This procedure is used by the Datahub user interface to provide
the developer with cut-and-paste statement templates to facilitate
software development.
</DL>

<hr>
<A NAME="hub_xml_sanitize">&nbsp;</A>
<H3>hub_xml_sanitize - Replace special XML or HTML characters</H3>
<DL><DT><B>Tcl Command Syntax</B><DD>
<B>hub_xml_sanitize <i>data</i></B>
<P></P><DT><B>Description</B><DD>
This command uses regsub to substitute &amp;<i>tag</i>; entities
for occurences of &amp;, &lt;, &gt;, and &quot;.  The substitution
should be done to prepare correct XML and HTML document data.
</DL>

<HR>
<HR>
<A NAME="SQL_commands">&nbsp;</A>
<H2>SQL Command Reference</H2>

<P>In this section, the commands that are given as arguments to the Tcl
SQL command, or to the Tcl execute command are presented. These are also
the commands that are processed when sent as messages to the command mailbox
of the Datahub.</P>
<P>The new Datahub retains reply format compatibility with the SCC Data
Server program was developed by SEMATECH.
In general, a reply is formatted as "//c <I>rc</I> <I>COMMAND</I>: <I>text</I>".
In this format, a return code, <I>rc</I>, of 0 means that the command
completed successfully.  A non-zero code implies an error or warning
condition.</P>
<P> 
A blank statement is treated as comment text.  Comment commands
are exceptional in that reply messages are not sent when the 
comment commands are received through the message system.</P>
<P>
If you execute an SQL statement that is not supported, or execute
some other unrecognized statement, the reply is:
<PRE>//c 2 &lt;UNKNOWN&gt;:  Unrecognized command, enter "help" for command list.
</PRE>
</P>
<P>These commands also retain compatibility with the SEMATECH
SCC Data Server program in other ways that are not explicitly
documented for each command, because they are deprecated for future use.
See the section on <A href="#Compatibility">Compatibility</A>.  </P>
<P><A name="SQL_commandsDir">&nbsp;</A>
<DIR>
<TABLE BORDER=0 CELLPADDING=4 ><TR><TD>
<A HREF="#LB">#</A> 
</TD><TD>
<A HREF="#CLOSE">CLOSE</A> 
</TD><TD>
<A HREF="#CREATE">CREATE</A>
</TD><TD>
<A HREF="#DELETE">DELETE</A> 
</TD><TD>
<A HREF="#DROP">DROP</A> 
</TD><TD>
<A HREF="#DUMP">DUMP</A>
</TR><TR><TD>
<A HREF="#ECHO">ECHO</A> 
</TD><TD>
<A HREF="#EOF">EOF</A> 
</TD><TD>
<A HREF="#EVAL">EVAL</A>
</TD><TD>
<A HREF="#EXIT">EXIT</A>
</TD><TD>
<A HREF="#HELP">HELP</A> 
</TD><TD>
<A HREF="#INCLUDE">INCLUDE</A> 
</TR><TR><TD>
<A HREF="#INSERT">INSERT</A>
</TD><TD>
<A HREF="#OPEN">OPEN</A> 
</TD><TD>
<A HREF="#PING">PING</A> 
</TD><TD>
<A HREF="#QUERY">QUERY</A>
</TD><TD>
<A HREF="#READ">READ</A> 
</TD><TD>
<A HREF="#REM">REM</A>
</TR><TR><TD>
<A HREF="#SELECT">SELECT</A> 
</TD><TD>
<A HREF="#SET">SET</A> 
</TD><TD>
<A HREF="#SOURCE">SOURCE</A> 
</TD><TD>
<A HREF="#TELECT">TELECT</A> 
</TD><TD>
<A HREF="#UPDATE">UPDATE</A>
</TD><TD>
<A HREF="#WRITE">WRITE</A>
</TR></TABLE>
</DIR>
<HR></P>
<A NAME="LB">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 >
<TR>
<TD><B>#</B></TD>
<TD>comment</TD>
</TR>
<TR>
<TD><B>Syntax</B></TD>
<TD># <I>comment text</I></TD>
</TR>
<TR>
<TD><B>Examples</B></TD>
<TD>
<PRE># These statements build version 2 tables
# Send change requests to flipper@ocean.umiami.edu
</PRE>
</TD>
</TR>
<TR>
<TD><B>Description</B></TD>
<TD>This command lets you lets you add comments to files of SQL commands
that will be processed using the SQL <A HREF="#INCLUDE">include</A> command.
The <B>#</B> command and the <B>rem</B> command are equivalent.</TD>
</TR>
<TR>
<TD><B>Replies</B></TD>
<TD>none</TD>
</TR>
</TABLE>

<P>&nbsp;</P>

<P><A NAME="CLOSE">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>CLOSE</B></TD>
<TD>Close a subscription</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>CLOSE SUB</B> <I>subname</I> <B>TO</B> <I>table</I></TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>SQL "close sub my_sub to equipment"</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>This command removes the subscription named <I>subname</I>
from the table named <I>table</I>.   Use <A href="#DUMP">dump</A>,
or the Datahub GUI to display existing subscriptions.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 CLOSE: &nbsp;<I>subname</I> - Subscription closed to table <I>table</I>.

//c 5 CLOSE: &nbsp;<I>table</I> - table not found"
//c 5 CLOSE: &nbsp;Table <I>table</I> record is corrupt"
//c 5 CLOSE: &nbsp;<I>subname</I> - subscription not found in table <I>table</I>.
</PRE>
</TD></TR></TABLE>

<P>&nbsp;</P>

<P><A NAME="CREATE">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>CREATE</B></TD>
<TD>Create a new database table</TD>
</TR><TR><TD><B>Syntax</B></TD><TD>
<B>CREATE TABLE</B> <I>table</I> <B>(</B> <I>colname datatype</I>
[<B>,</B> <I>colname datatype</I>]* 
[<B>, PRIMARY KEY(</B><I>colname</I> [<B>,</B> <I>colname</I>]*<B>)</B>]
<B>)</B>
<P><I>datatype</I> := { <B>VARCHAR</B>[<B>(</B><I>n</I><B>)</B>] | 
<B>INT</B>[<B>TEGER</B>] |
<B>FLOAT</B> |
<B>DOUBLE</B> [<B>PRECISION</B>] }</P>
<P><I>n</I> := non-zero unsigned integer </P>

</TD></TR><TR><TD><B>Examples</B></TD><TD>
<PRE>SQL "create table spc_type (
typecode varchar, 
description varchar(80),
primary key(typecode))"
</PRE>
</TD></TR><TR><TD><B>Description</B></TD><TD>
The SQL create statement creates an empty database table.
<P>Each column of the table is a specific datatype:
<dl>
<dt>INTEGER | INT</dt>
<dd>Corresponds to a C language integer, typically
a 32-bit signed integer, with the range of -2147483648 to 2147483647.</dd>
<P></P>
<dt>VARCHAR(<I>n</I>) | VARCHAR
<dd>Character strings are stored as arrays of 8-bit values.  
With VARCHAR(<I>n</I>), you specify <I>n</I> as the maximum number of characters
possible for the field. The VARCHAR type declaration is used to store 
a single character.  The Datahub only uses as much memory
as is actually needed to store your data, so there is no added overhead with
specifying generous array sizes.  
<P>
You can store and retrieve
all of the usual printable ASCII characters and the extended characters
ranging from binary codes 0x80 to 0xff.  Also, you can get away with
storing and retrieving unprintable characters except for the
null byte 0x00 and its successor 0x01 which are used internally by the
Datahub software.  Although it is less compact,
you can always store text representations of binary codes such as
the literal sequence \x00.  </dd>
<P></P>
<dt>FLOAT | DOUBLE | DOUBLE PRECISION</dt>
<dd>The current Datahub stores these types using IEEE 8 byte double
precision floating point variables with a range of absolute values of
>= 2.225073858507201e-308 and <= 1.7976931348623158e+308.  Most databases
store the FLOAT type as 4 byte single precision floating point values
with a smaller range; this may be a portability issue.  See the
discussion of the <A href="#USE_TCL_PRECISION">USE_TCL_PRECISION</A>
parameter for information on how to control the number of 
digits that are displayed when values are queried.
</dl>
<P>
There is no set limit to the number of rows that are stored in a table.
If you will be querying tables that have thousands of rows,
you should design your application to use primary keys so that
performance scales well.
<P>
The Datahub itself imposes a limit that the total number of characters 
in an SQL command has to be less than 70,000 and the number of lexical
tokens in an input line has to be less than 2500.  This imposes a
generous limit on the amount of data that can be stored in a single
table row.  These figures also imply that the maximum number of columns 
is limited to some value over 1200.
</P>
<P>
This is no fixed limit on the size of a query result, other than a limit
of 70,000 on any single row of table data.  If your operating system
and TCP/IP implementation can handle it, you can successfully  
manipulate multiple megabyte queries.</P>
Use <A href="#DUMP">dump</A>,
or the Datahub GUI to display existing tables.  Use <A href="#DROP">drop</A>
to delete tables.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 CREATE: &nbsp;<I>table</I> - Table created.

//c 5 CREATE: &nbsp;<I>table</I> - table already exists
//c 5 CREATE: &nbsp;bad data type for column <I>colname</I>
//c 5 CREATE: &nbsp;incomplete statement
//c 5 CREATE: &nbsp;bad array size for column <I>colname</I>
//c 5 CREATE: &nbsp;expected ) to close array size for column <I>colname</I>
//c 5 CREATE: &nbsp;<I>table</I> - column "<I>colname</I>"  already specified.
//c 5 CREATE: &nbsp;<I>table</I> - missing KEY after PRIMARY
//c 5 CREATE: &nbsp;<I>table</I> - expected ( after KEY
//c 5 CREATE: &nbsp;<I>table</I> - expected key column name
//c 5 CREATE: &nbsp;<I>table</I> - declared key <I>colname</I> unknown
//c 5 CREATE: &nbsp;<I>table</I> - <I>colname</I> duplicate key
//c 5 CREATE: &nbsp;extra tokens after closing )
//c 5 CREATE: &nbsp;improper column name (a keyword perhaps?)
</PRE>
</TD></TR></TABLE>

<P>&nbsp;</P>

<P><A NAME="DELETE">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>DELETE</B></TD>
<TD>Delete rows from a table</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>DELETE FROM</B> <I>table</I> [<B>WHERE</B> <I>where_criteria</I>]</TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>SQL {delete from captains_log where stardate<'1996-07-05 00:00:00'}</P>
<P>delete from my_table</P>
<P>SQL "delete from my_table where my_col like 'tmp%'"</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>This command deletes rows that are selected by the <I>where_criteria</I>
from the table named <I>table</I>.   If no <B>WHERE</B> clause
is supplied, all of the rows are deleted.  
See <A href="#WHERE">The Where Clause</A>
for the grammar of the <I>where_criteria</I> argument.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 DELETE: &nbsp;<I>table</I> - 1 row deleted.
//c 0 DELETE: &nbsp;<I>table</I> - <I>N</I> rows deleted.

//c 3 DELETE: &nbsp;<I>table</I> - 0 rows deleted.

//c 5 DELETE: &nbsp;<I>table</I> - table not found"
//c 5 DELETE: &nbsp;Table <I>table</I> record is corrupt"
//c 5 DELETE: &nbsp;<I>syntax error description</I>
</PRE>
</TD></TR></TABLE>

<P>&nbsp;</P>

<P><A NAME="DROP">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>DROP</B></TD>
<TD>Destroy an entire table</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>DROP TABLE</B> <I>table</I> </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>drop table report_temp</P>
<P>SQL "drop table report_temp"</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>This command destroys the named table, freeing the memory
resources it was using.  Subscriptions on the table are closed as it is
dropped.
<P>It is more efficient to empty a table
using delete than to drop and re-create it.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 DROP: &nbsp;<I>table</I> - Table destroyed.

//c 5 DROP: &nbsp;<I>table</I> - table not found"
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="DUMP">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>DUMP</B></TD>
<TD>Obtain status information</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>DUMP</B> { <B>TABLE</B> | <B>SCHEMA</B> <I>table</I> | <B>SUB</B> <I>table</I> } </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>dump schema repair_log</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
There are three variations of the DUMP command:
<DL>
<DT>DUMP TABLE</DT>
<DD>returns a list of all the existing tables, and shows the number of
rows and columns of each.</DD>
<P></P>
<DT>DUMP SCHEMA <I>table</I></DT>
<DD>returns a list of the columns of the table named <I>table</I>.</DD>
<P></P>
<DT>DUMP SUB <I>table</I></DT>
<DD>returns a list of the subscriptions on the table named <I>table</I>.</DD>
</DL>
This command is almost never used directly since the same information
is presented using the Datahub GUI or the hubclient GUI.  For new Tcl
code, we highly recommend that you use the hub_* Tcl procedures to
obtain the same information in forms that are better suited for program
use.  See for example, <a href="#hub_tables">hub_tables</a>, 
<a href="#hub_table_list">hub_table_list</a>,
<a href="#hub_table_exists">hub_table_exists</a>,
<a href="#hub_table_schema_list">hub_table_schema_list</a>, or <a href="#hub_fieldtype">hub_fieldtype</a>.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE><I>multiple replies of status information</I> followed by
//c 0 DUMP: Complete

//c 5 DUMP: &nbsp;<I>table</I> - table not found"
</PRE>
</TD></TR></TABLE>

<P>&nbsp;</P>

<P><A NAME="ECHO">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>ECHO</B></TD>
<TD>send the argument as a reply</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>ECHO</B> <I>echo_text</I>  </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>echo hello world</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This command exists for compatibility with the older versions.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE><I>echo_text</I>
</PRE>
</TD></TR></TABLE>

<P>&nbsp;</P>

<P><A NAME="EOF">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>EOF</B></TD>
<TD>initialize message system communication</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>EOF</B>  </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>datahub "set group=spc2" eof &</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
Executing this command causes the Datahub to initialize message
system communication, and thereafter to process messages received
in the <A href="#SERVER">server</A> mailbox as SQL commands.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 EOF:  Message system initialized, command mailbox is \
  "<I>SERVER@GROUP</I>"
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="EVAL">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>EVAL</B></TD>
<TD>evaluate Tcl code</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>EVAL</B> <I>tclcode</I> </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>eval user_login jsmith rx7fan</P>
<P>eval exec xterm -display atlas:0.0 &</P>
<P>eval SQL "update checking set balance=12 where acct='smith'" ; 
SQL "update savings set balance=24 where acct='smith'</P>
<P>eval proc hello {a} {puts $a}
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This command provides a means for message system clients to
access the Tcl functionality of the Datahub.  As the examples
show, it can be used to execute Tcl procedures, or even to
execute more than 1 SQL command in a single message.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
If you are accessing the eval command with the DMH message system
the reply message is exactly the result you would see if the same
<I>tclcode</I> were executed at a Tcl/Tk shell prompt.  <P>
When you access the eval command in Tcl code using the
SQL command, the result is always returned as a single list
element, which means that braces are added if the result contains
internal white space.  Here are two examples to demonstrate the 
difference, which can be subtle.
<DL>
<DT>"eval set x hello"
<DD>Reply message is <b>hello</b>
<DD>SQL "eval set x hello" result is <b>hello</b>.
<DT>"eval set x {hello world}"
<DD>Reply message is <b>hello world</b>.
<DD>SQL "eval set x {hello world}" result is <b>{hello world}</b>
</DL>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="EXIT">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>EXIT</B></TD>
<TD>shutdown the Datahub</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>EXIT</B> </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>exit</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This command causes the Datahub to exit.
In contrast to older versions of the Datahub, delete and
drop messages are not sent to subscribers during the
processing of the exit.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 EXIT:  orderly shutdown initiated
</PRE>
</TD></TR></TABLE>

<P>&nbsp;</P>


<P><A NAME="HELP">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>HELP</B></TD>
<TD>display command usage </TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>HELP</B> [<I>command_name</I>]</TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>help</P>
<P>help create</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This command returns the syntax of an SQL command or of all the 
SQL commands.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE><I>command synopsis</I>
//c 0 HELP:  Complete, '*' indicates disabled.
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="INCLUDE">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>INCLUDE</B></TD>
<TD>process a file of SQL commands</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>INCLUDE</B> <I>pathname</I></TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>include c:/users/tonka/xtc.sql</P>
<P>include ../lib/report1.sql</P>
<P>SQL "include ../lib/report1.sql"</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This reads and processes a file of SQL commands.  
The logic reads each text line in the file as
a new SQL command except if the ending newline occurs 
inside of an SQL string constant or inside of an unfinished
sequence of Tcl code.  In the latter cases, additional lines
are read until the SQL command is complete.
<P>Relative pathnames are with respect to the current working directory
of the Datahub process.  The current working directory of the Datahub can be changed
using the Tcl <A href="../mann/cd.html">cd</A> command, or
by setting the <A href="#CWD">CWD</A> parameter.</P>
<P>Even on Windows NT platforms, the pathname is specified using
Unix style slashes.</P>
<P>The INCLUDE command may be nested inside of included files
to arbitrary depths.</P>
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE><I>a reply for each included command</I>  
possibly intercalated with:
[Error at line <I>N</I> in file "<I>pathname</I>".]
followed by:
//c 0 INCLUDE:  Completed file "<I>pathname</I>" <I>N</I> errors encountered.
//c 0 INCLUDE:  Completed file "<I>pathname</I>" 1 error encountered.

//c 1 INCLUDE:  Unable to open file "<I>pathname</I>"
//c 2 INCLUDE:  Usage - INCLUDE <filename>
</PRE>
</TD></TR></TABLE>

<P>&nbsp;</P>

<P><A NAME="INSERT">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>INSERT</B></TD>
<TD>add a new row to a table</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>INSERT INTO</B> <I>table</I> <B>(</B><I>colname</I> [<B>,</B> <I>colname</I>]*
<B>) VALUES (</B><I>value</I> [<B>,</B> <I>value</I>]*<B>)</B></TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>insert into spc_type (code,description) values ('X','XBar, S')</P>
<P>insert into system_constants (name, value) values ('USE_BLIVETS', '1')</P>
<P>SQL {insert into spc_type (code,description) values ('R','XBar, R')}</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This is a standard SQL syntax for adding a data row to a table.
Columns that are not specifically named are given the default values
of 0 for numeric fields and the empty string, '', for character data.  
<P>As a portability issue you should know that some persistent
databases do not allow empty strings to be inserted for character fields
that are primary key columns.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 INSERT:  <I>table</I> - Record inserted.

//c 1 INSERT:  <I>table</I> - column "<I>colname</I>" not in table
//c 3 INSERT:  Unable to insert. Unique key violation
//c 5 INSERT:  <I>table</I> - table not found.
//c 5 INSERT:  Table <I>table</I> record is corrupt
//c 7 INSERT:  bad value for column <I>colname</I>
//c 9 INSERT:  improper value supplied for column <I>colname</I>
//c 10 INSERT:  cannot convert string value to number for column \
 <I>colname</I>
//c 13 INSERT:  memory allocation failed
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="OPEN">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>OPEN</B></TD>
<TD>create a new subscription on a table</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD>
<P>For a message subscription:</P>
<P>
<B>OPEN SUB</B> <I>subname</I> <B>TO</B> <I>table</I> 
[<B>SENDTO=</B><I>mailbox</I>] [<B>REPLYTO=</B><I>mailbox</I>] [<B>TELECT</B>] 
[<B>INSERT</B>] [<B>UPDATE</B>] [<B>DELETE</B>] [<B>DROP</B>] [<B>SYNC</B>] [<B>CREATE</B>] 
{ * | <I>colname</I> [<B>,</B> <I>colname</I> ]* }
[<B>WHERE</B> <I>where_criteria</I> ]
</P>
<P>For a procedure subscription:</P>
<B>OPEN SUB</B> <I>subname</I> <B>TO</B> <I>table</I> 
{ <B>PROC=</B><I>procedure</I> | <B>SQLPROC=</B><I>procedure</I> }
[<B>INSERT</B>] [<B>UPDATE</B>] [<B>DELETE</B>] [<B>DROP</B>] [<B>SYNC</B>] [<B>CREATE</B>]
{ * | <I>colname</I> [<B>,</B> <I>colname</I> ]* }
[<B>WHERE</B> <I>where_criteria</I> ]
</P>

</TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>open sub testing to mytable sqlproc=puts *</P>
<P>open sub demo2 to mytable sqlproc=puts col1,col2,col3 where col1>20</P>
<P>open sub ENGDB to shopdata sendto=ENGBD * where engdb_wants=1 and station='test'</P>
<PRE>proc sub1 {notice_type table cols keys row_ct errtext data} {
    puts "table=$table notice_type=$notice_type"
    foreach row $data {
        vset $row $cols
        foreach col $cols { puts "\t$col=[set $col]" }
        }
    }

SQL "open sub sub1 to test_table proc=sub1 insert update\
  delete sync *"


proc sub2 {stmt} { puts "SQL statement=$stmt" }

SQL "open sub sub2 to test_table proc=sub2 *"
</PRE>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
<P>The command opens a subscription to the table named <I>table</I>.
You can only open subscriptions on tables that have one or more
columns designated as primary key columns.  </P>
<P>
There are two main variations depending on whether you want a message
sent for each subscription notification, or you want to have a Tcl procedure 
evaluated for each subscription notification.</P>
<P>
When opening a message-based subscription, you specify the mailbox to
receive the notifications using the SENDTO=<I>mailbox</I> clause.
The default value of this optional clause is the 
reply mailbox of the open command message itself.
By default, the message notifications will be SQL statements.  You may
specify the TELECT keyword in order to receive messages that are formatted
in the <A href="#TclReplyFormat">Tcl Reply Format</A> style.  Also, you
may optionally specify the REPLYTO=<I>mailbox</I> clause to indicate 
a reply mailbox for the notification messages.  The default value of the
REPLYTO mailbox is NULL, which is a special value that means no reply 
mailbox is applicable.  You could use the reply mailbox as a mechanism to indicate
which Datahub or which subscription a subscription message came from.</P>
<P>
When opening a procedure subscription,  the 
SQLPROC=<I>procedure</I> clause is used to indicate that the Tcl procedure
named <I>procedure</I> is to be called with a single argument, the SQL
notification statement.  The alternative clause, PROC=<I>procedure</I>, 
is used to specify a Tcl procedure that gets called with the 7 arguments
of the <A href="#TclReplyFormat">Tcl Reply Format</A>.</P>
<P>
You are able to choose the type of data changes you wish to receive
notifications for by optionally specifying one or more of the keywords
INSERT, UPDATE, DELETE, or DROP.  If you do not specify any of these
data change types, then you receive notifications for all of them.</P>
<P>
The SYNC option causes your subscription to be notified immediately 
with insert notifications for each row in the table selected by your
specified or implicit <I>where_criteria</I>.  This option lets you 
synchronize with the existing data, and in the same action be registered
for future changes.  The default behavior is only to notify you of future
changes.</P>
<P>
The CREATE keyword is used to receive an SQL create table statement as the
first SQL notification message or first SQLPROC procedure evaluation.  The SQL create
table statement is for the entire table, not just the columns that you
are subscribing to.  Using both the SYNC and CREATE options is a
convenient way to get all of the SQL statements needed to replicate a table.
For example, you can use the SYNC and CREATE options and specify as the SENDTO 
destination the mailbox of another datahub, to create a copy of a table
that stays in synchronization with changes to the original table.</P>
<P>
You can specify a list of specific column names for your subscription,
or use * to indicate all columns.  Whether you ask for them or not,
all of the key columns for the table are included in 
your column list, and included in all of your notifications.  This
is done so that your notifications are unambiguous.  
You specify a column name to indicate you would like
to be notified if a value in that column is updated, or you would 
like to know the new value of that column when a row is inserted.
When a row is updated, update notifications do not include the value
of every column name in the subscription's list.  Instead, the
update notifications include values for all of the key columns,
and values for the non-key columns requested by the subscription only 
if they have been changed in the update.  A value must actually
be changed to appear in an update notification.  For example,
if an update statement is processed that specifies updating a
field to its current value, no notifications are dispatched.  </P>
<P>
When opening the subscription you optionally supply a 
<A href="# ">WHERE clause</A> to
specify row selection criteria for your notifications.  The default 
is that you are notified for changes to any row.  
See <A href="#WHERE">The Where Clause</A>
for the grammar of the <I>where_criteria</I> argument.
</P>
<P>
Here is a fine point on update notifications.
The where clause is evaluated on the updated row data, not on the original row
data.  If your where clause specifies comparisons on non-key column values,
(1) you will see update notifications for rows that 
are updated to match the where criteria from a previous unmatching state, 
and (2) you will not see update notifications for rows that are updated 
such that they no longer match your where criteria.</P>
<P>
If the value of a primary key column (or columns) is (are) updated, 
the Datahub processes two notifications; a delete notification for the 
original value of all the key columns, followed by an insert notification for the
row data with new key column values.  This behavior guarantees that if
a WHERE clause is expressed only on values of key columns, the subscription
notifications synchronize perfectly with the selected subset of the
table.  If a single update notification were sent, (1) a selective subscription
would not be notified when a row is updated to no longer match the WHERE criteria, and
(2) a selective subscription would receive update notifications for rows that
it did not previously know about, as they were updated to match the WHERE criteria.  </P>
<P>
There can be any number of subscriptions on a table.</P>
<P>
The subscription name, <I>subname</I>, must be unique among all of the
subscriptions to table <I>table</I>.
Subscription names follow the same conventions as table and column names,
except that they can be as long as 80 characters in length.
You use the subscription name with the
<A href="#CLOSE">close</A> command to close a subscription.</P>
<P>
All of the subscriptions on a table are processed by the Datahub before
it replies to the original SQL command that caused the data change(s).</P>
<P>
There are certain operations that you should not do in a subscription
procedure.  
<UL>
<LI>You should not drop the table, or close the subscription that 
is being processed.  The new Datahub has internal protection to prevent
core dumping if this happens but we advise against doing it.  
If you must do either of these, do it in an <A href="../mann/after.html">after</A>
command so it is carried out after the subscription returns.
<LI>You should not perform lengthy operations, or perform blocking
operations, such as waiting for user input.  
</UL>
<P>Perhaps surprisingly, it is safe in your subscription procedure
to perform nested data manipulations, such as updating a row that
has just been updated, or deleting a row that has been inserted or
updated.  If you design a complex mess like this, you need to be mindful
that you are possibly breaking the design assumptions of the other
subscriptions on the table.  Also, the
subscription notifications may not be in the proper sequence 
for all of the subscriptions since 
the nested notifications are completed before the Datahub finishes
with the original notifications.  A design alternative to nested
data manipulations is to do the data manipulation in an 
<A href="../mann/after.html">after</A> command so it is carried 
out after the procedure returns. </P>

</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 OPEN:  <I>subname</I> - subscription opened.

//c 1 OPEN:  invalid column name
//c 1 OPEN:  <I>table</I> - column "<I>colname</I>" not in table.
//c 1 OPEN:  SENDTO missing for message subscription
//c 2 OPEN:  SENDTO is mutually exclusive with non-message\
 subscriptions
//c 3 OPEN:  REPLYTO is mutually exclusive with non-message\
 subscriptions
//c 4 OPEN:  PROC is mutually exclusive with other\
 subscription types
//c 5 OPEN:  <I>table</I> - table not found.
//c 5 OPEN:  <I>syntax error description</I>
//c 6 OPEN:  SQLPROC is mutually exclusive with other\
 subscription types
//c 7 OPEN:  TELECT is mutually exclusive with non-message\
 subscriptions
//c 8 OPEN:  <I>subname</I> -  table <I>table</I> does not contain keys.
//c 9 OPEN:  Insufficient options to determine subscription type
//c 10 OPEN:  CREATE option requires SQL notification format
//c 11 OPEN:  <I>subname</I> - duplicate subscription name for table <I>table</I>.
//c 13 OPEN:  Table <I>table</I> record is corrupt
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="PING">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>PING</B></TD>
<TD>verify online responsiveness</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>PING</B>  </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>ping</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This command exists for compatibility with the older versions.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 PING:  <I>SERVER</I> <I>date</I> <I>time</I> (<I>POSIX_seconds</I>) <I>Id</I>

//c 0 PING:  datahub 08/09/96 17:52:00 (839620320) datahub
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="QUERY">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>QUERY</B></TD>
<TD>display the value of configuration parameters</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>QUERY</B> [<I>parameter</I>] </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>query group</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
The Datahub has a handful of configurable data parameters.  Each is
described under the <A href="#SET">SET</A> command.
This command lets you obtain the current value(s).  With no argument,
all of the values are returned, otherwise the value of <I>parameter</I>
is returned.  For compatibility with SEMATECH style servers, 
the <I>parameter</I> = <I>value</I> reply is spaced differently 
depending on whether you requested a specific <I>parameter</I>
or not.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>one or more:
<I>parameter</I> = <I>value</I>
followed by
//c 0 QUERY:  Complete, '*' indicates disabled.

//c 1 QUERY:  Variable "<I>name</I>" not found.
//c 2 QUERY:  QUERY [variable]
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="READ">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>READ</B></TD>
<TD>create a populated table from a saved file</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>READ</B> [<B>OVER</B>] <I>table</I> </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>read over lotdata</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This command restores a table schema and its data from a 
previously saved image.  The saved image is created using the
<A href="#WRITE">write</A> command.  The <B>OVER</B> option
is used in order to replace an existing table using the <B>read</B>
command.  </P>
<P>The <B>read</B> command expects to find a file of
the name <I>table</I>.tab in its current working directory in order
to process table <I>table</I>.  The current working directory can
be changed using the <A href="#CWD">CWD</A> parameter or the Tcl
<A href="../mann/cd.html">cd</A> command.</P>
<P>Subscription information is not saved and restored using <B>read</B>
and <A href="#WRITE">write</A>.  When you use the <B>OVER</B> option
and replace a table, existing subscriptions are all closed.

</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 READ:  <I>table</I> - Table read from file "<I>table</I>.tab"

//c 3 READ:  <I>table</I> - Error reading file "<I>table</I>.tab".
//c 7 READ:  <I>table</I> - table exists and overwrite option not set.
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="REM">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 >
<TR>
<TD><B>REM</B></TD>
<TD>comment</TD>
</TR>
<TR>
<TD><B>Syntax</B></TD>
<TD>REM <I>comment text</I></TD>
</TR>
<TR>
<TD><B>Examples</B></TD>
<TD>
<PRE>rem uncomment the following statements for option B 
</PRE>
</TD>
</TR>
<TR>
<TD><B>Description</B></TD>
<TD>This command lets you lets you add comments to files of SQL commands
that will be processed using the SQL <A HREF="#INCLUDE">include</A> command.
The <B>#</B> command and the <B>rem</B> command are equivalent.</TD>
</TR>
<TR>
<TD><B>Replies</B></TD>
<TD>none</TD>
</TR>
</TABLE>


<P>&nbsp;</P>

<P><A NAME="SELECT">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>SELECT</B></TD>
<TD>query table data</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>SELECT</B> { <B>*</B> | <I>column</I> [<B>,</B> <I>column</I>]* } 
<B>FROM</B> <I>table</I> [ <B>WHERE</B> <I>where_criteria</I> ]   </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>select help_text from help_config where lot_id='any lot' and step='etch'</P>

<P>select * from capt_log where sdate<='1996-01-01'</P>
<PRE>SELECT: capt_log event='Klingons near chimney' sdate='1992-12-25'
SELECT: capt_log event='read Dr. Spock''s book' sdate='1994-04-21'
//c 0 SELECT: 2 rows selected
</PRE>
<P>SQL "select * from spc_datatype"</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
<B>select</B> is used routinely to lookup stored table data.  You can
use the symbol <B>*</B> to specify that you would like all of
the column values in your query, or you can explicitly list the columns
of interest.  
If you do not provide a WHERE clause, you obtain all rows
of the table.  See <A href="#WHERE">The Where Clause</A>
for the grammar of the <I>where_criteria</I> argument.

</TD></TR><TR><TD><B>Replies</B></TD><TD>
<P>
If <B>select</B> is executed in Tcl code from the <A href="#SQL">SQL</A> command,
you obtain the <A href="#TclReplyFormat">Tcl Reply Format</A> which
is described in its own section.  The format described below is obtained when
the <B>select</B> statement is sent to a Datahub as a message command, or
executed in Tcl code from the <A href="#execute">execute</A> command.</P>
<PRE><I>One or more messages for each row, formatted as</I>
SELECT: <I>table</I> [<I>column</I>=<I>value</I>]+
<I>where value is enclosed in single quotes for character data,
and then a final message,</I>
//c 0 SELECT:  <I>table</I> - <I>N</I> row[s] selected

//c 3 SELECT:  <I>table</I> - 0 rows selected

//c 1 SELECT:  <I>table</I> - column "<I>column</I>" not in table
//c 5 SELECT:  <I>table</I> - table not found
//c 5 SELECT:  Table <I>table</I> record is corrupt
//c 5 SELECT:  <I>syntax error description</I>

</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="SET">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>SET</B></TD>
<TD>configure a Datahub data parameter</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>SET</B> <I>parameter</I>=<I>value</I> </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>set server=DBM</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
The Datahub has a small set of configurable data parameters that
can be assigned values using this command.  
<DL>
<DT><A NAME="CWD">CWD</A></DT>
<DD>current working directory.  New code should use the Tcl 
<A href="../mann/cd.html">cd</A> command.</DD>
<DT><A NAME="GROUP">GROUP</A></DT>
<DD>DMH message group.  Once the message system interface has
been initialized using <A href="#EOF">eof</A> this parameter cannot
be changed.  See the <A href="../mann/mbx.html">mbx</A> document
for a discussion of message groups.
The value of this parameter defaults to mbx.</DD>
<DT><A NAME="SERVER">SERVER</A></DT>
<DD>the command mailbox.  Once the message system interface has
been initialized using <A href="#EOF">eof</A>, the Datahub reads
messages from this mailbox and processes them as SQL commands.
The value of this parameter defaults to DATAHUB.</DD>
<DT><A NAME="TRACE">TRACE</A></DT>
<DD>the mailbox to send TRACE messages.  This parameter is
provided for compatibility with SEMATECH style servers.  There are
no TRACE features built into the Datahub software.
<DT><A NAME="USE_TCL_PRECISION">USE_TCL_PRECISION</A></DT>
<DD>floating point format control.  When this value is 1, floating point
values are formatted using the conventions of the Tcl interpreter
which is controlled by the global Tcl variable
<A href="../mann/tclvars.html">tcl_precision</A>. When this parameter is
set to 0, floating point values are printed using the C language
sprintf "%g" convention which can cause loss of precision.  The latter
behavior is provided to be compatible with the SEMATECH SCC Data Server.
The default value of this parameter is set to 1 in the C source code,
but it is set to 0 in certain datahub Tcl/Tk scripts for compatibility.
If you care, set it to your choice.</DD>

</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 SET:  Variable "<I>parameter</I>" set to "<I>value</I>".

//c 1 SET:  Variable "<I>parameter</I>" not found.
//c 3 SET:  Unable to set variable "<I>parameter</I>", <I>error message</I>
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="SOURCE">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>SOURCE</B></TD>
<TD>source a file of Tcl code</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>SOURCE</B> <I>pathname</I> </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>source c:/users/doe/zapp.tcl</P>
<P>source ../library/util.tcl</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This command is used to explicitly load Tcl code such as procedure
definitions into the Datahub.  The functionality is equivalent to the Tcl
command <A href="../mann/source.html">source</A>.
<P>You use this command repeatedly during development to reload a file
of source code that you are editing.  However, for production, many
applications will take advantage of the interpreter's 
<A href="../mann/library.html">auto_path</A> mechanism that loads 
unknown Tcl code only if it is actually executed.  To use this
mechanism, the developer uses the 
<A href="../mann/library.html">auto_mkindex</A> command to build a
tclIndex file, and adds the directories where the source code files are
found to the <A href="../mann/library.html">auto_path</A> list.</P>
</TD></TR><TR><TD><B>Replies</B></TD><TD>
The reply is an empty string or a single error message.
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="TELECT">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>TELECT</B></TD>
<TD>an alias for the select command</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><I>see <A href="#SELECT">select</A></I> </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>telect * from menu_data</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This command exists to provide the <A href="#TclReplyFormat">Tcl Reply Format</A>
for message system clients.  In the name of compatibility, the reply to
select statements received through the command mailbox is the older, one
message per row style.  Tcl applications can use "telect" instead of "select" to
obtain the new format which is designed for ease of parsing in Tcl code.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE><A href="#TclReplyFormat">The Tcl Reply Format</A>
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="UPDATE">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>UPDATE</B></TD>
<TD>change existing rows in a table</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>UPDATE</B> <I>table</I> <B>SET</B> 
<I>column</I><B>=</B><I>value</I> [ <B>,</B> <I>column</I><B>=</B><I>value</I> ]*
[ <B>WHERE</B> <I>where_criteria</I> ]
</TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>update fast_food set pace='slow', rate=4.5 where vendor='TurtleJoe'</P>
<P>SQL "update lot_data set is_removed=1 where lot_id='9803021A'"
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
This is the ANSI standard SQL statement for modifying the data of
a single table.
If you do not provide a WHERE clause, you update all rows
of the table.  See <A href="#WHERE">The Where Clause</A>
for the grammar of the <I>where_criteria</I> argument.
</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 UPDATE:&nbsp;  <I>table</I> - <I>N</I> row[s] updated.

//c 1 UPDATE:&nbsp;  <I>table</I> - column "<I>column</I>" not in table.
//c 3 UPDATE:&nbsp;  <I>table</I> - 0 rows updated.
//c 5 UPDATE:&nbsp;  <I>table</I> - table not found
//c 5 UPDATE:&nbsp; Table <I>table</I> record is corrupt
//c 5 UPDATE:&nbsp;  <I>syntax error description</I>
//c 13 UPDATE:&nbsp; unique key violation
</PRE>
</TD></TR></TABLE>


<P>&nbsp;</P>

<P><A NAME="WRITE">&nbsp;</A>
<TABLE BORDER=1 CELLPADDING=4 ><TR>
<TD><B>WRITE</B></TD>
<TD>save a table to a file</TD>
</TR><TR><TD><B>Syntax</B></TD>
<TD><B>WRITE</B> [<B>OVER</B>] <I>table</I> [<I>pathname</I>] </TD>
</TR><TR><TD><B>Examples</B></TD><TD>
<P>write over variable_data</P>
<P>write over variable_data /tmp/myfile.sql</P>
</TD></TR><TR><TD><B>Description</B></TD>
<TD>
<P>This command writes a create statement and insert statements representing
a table to a file.  The file can be read and the table restored using the
<A href="#READ">read</A> command or the <A href="#INCLUDE">include</A>
command.</P>
<P>
If <I>pathname</I> is specified, it is used as the path and file specification
for the table information.  Otherwise, the command creates a file by the
name of <I>table</I>.tab in the current working directory.</P>

</TD></TR><TR><TD><B>Replies</B></TD><TD>
<PRE>//c 0 WRITE:&nbsp;  <I>table</I> - Table written to file "<I>file</I>" - <I>N</I> of <I>N</I> rows

//c 3 WRITE:&nbsp;  <I>table</I> - Table written to file "<I>file</I>" - <I>N</I> of <I>M</I> rows

//c 3 WRITE:&nbsp;  <I>table</I> - Unable to open file "<I>file</I>".
//c 5 WRITE:&nbsp;  <I>table</I> - table not found
//c 5 WRITE:&nbsp; Table <I>table</I> record is corrupt
//c 7 WRITE:&nbsp;  <I>table</I> - file "<I>file</I>" exists and overwrite option not set.
</PRE>
</TD></TR></TABLE>

<P>&nbsp;</P>

<P>
<HR><A NAME="TclReplyFormat">&nbsp;</A></P>
<H2>Tcl Reply Format</H2>
The format described in this section is used for 
<UL>
<LI>the return value of an SQL select statement
<LI>the reply message of a telect statement received as a message command
<LI>the return value of an execute telect statement
<LI>the TELECT format of message subscription notifications
<LI>the argument list of "PROC=" subscription Tcl procedures
</UL>
Similar formats are also used by other Tcl database 
software such as the <A href="../mann/odbc.html">odbc</A> command.  

<P>The format is a seven element Tcl list.  
Each element is now described. </P>

<TABLE BORDER=1 CELLPADDING=4 ><TR><TD>
<B>Element</B></TD><TD><B>Index</B></TD><TD><B>Description</B></TD></TR>
<TR><TD><I>notification</I></TD><TD>0</TD><TD>
This element will be the literal string <B>select</B> for the return
value of a select or telect query.  For a subsciption notification, it
will be the literal text <B>insert</B>, <B>update</B>, <B>delete</B>, or <B>drop</B>.
</TD></TR>
<TR><TD><I>tablename</I></TD><TD>1</TD><TD>
This item with be the name of the database table.  The name will be
formatted exactly as it was in the table's <A href="#CREATE">create</A> statement.
</TD></TR>
<TR><TD><I>columns</I></TD><TD>2</TD><TD>
This element will be a list of the column names in the same sequence 
as the data items in the <I>data_list</I> element.  For a select
statement, the columns are in the order of your request, or in the
table create statement order if you queried for <B>*</B>.
For a subscription notification, the list will always
include the primary keys of the table.
</TD></TR>
<TR><TD><I>key_columns</I></TD><TD>3</TD><TD>
This element will be a list of the column names of the primary key columns.
</TD></TR>
<TR><TD><I>row_count</I></TD><TD>4</TD><TD>
This element returns a count of the data rows in the 
<I>data_list</I> element.   For the usual <B>insert</B>, <B>update</B>, 
or <B>delete</B> subscription notification, the value will be
1 because a separate notification is issued for each row.
</TD></TR>
<TR><TD><I>error_info</I></TD><TD>5</TD><TD>
If your query has an error such as referring to a column or table 
that does not exist, or a syntax error, this element is a string
containing a non-zero numeric return code, followed by a diagnostic
message.  The return code is the number that you see in the old style 
"//c <I>number</I>" reply documentation.
If you have a valid query that does not find any data rows,  
it is not an error, and the <I>error_info</I> element is an empty string. 
</TD></TR>
<TR><TD><I>data_list</I></TD><TD>6</TD><TD>
This element is a list of data rows.  
Each data row has the elements named in the <I>columns</I> element, in the same order.  
Character strings that have imbedded white space are delimited in 
Tcl fashion using braces instead of single quotes.  
There are as many rows as specified by the <I>row_count</I> element. 
</TD></TR>
</TABLE>
<P>
Here is example code displaying this format:</P>
<PRE>&nbsp; # create a table with some data
&nbsp; SQL "create table a (i int, str varchar(20), d double)"
&nbsp; SQL "insert into a (i,str,d) values (1,'hello world', 1.1)"
&nbsp; SQL "insert into a (i,str,d) values (2, 'two', 2.2)"

&nbsp; puts [SQL "select * from a"]
select a {i str d} {} 2 {} {{1 {hello world} 1.1} {2 two 2.2}}
&nbsp;
&nbsp; set reply [SQL "select str from a where i=1"]
select a {str} {} 1 {} {{{hello world}}}
&nbsp; # Here is a methodical way to parse the reply for a single value
&nbsp; set datarows [lindex $reply 6]
&nbsp; set firstrow [lindex $datarows 0]
&nbsp; set firstvalue [lindex $firstrow 0]
&nbsp; puts "str=$firstvalue"
str=hello world
&nbsp; # 
&nbsp; # As of Tcl 8.4, lindex can take several indicies at once
&nbsp; #   so this is the preferred method to isolate a value.
&nbsp; # 
&nbsp; set firstvalue [lindex $reply 6 0 0]
&nbsp; puts "str=$firstvalue"
str=hello world
&nbsp; # this example is compact and backwards compatible:
&nbsp; set str [lindex [lindex [lindex $reply 6] 0] 0]
&nbsp; # The rset command is even more compact
&nbsp; # but is not more efficient unless you are using several values
&nbsp; # such as the row count, the errtext, and the data value
&nbsp; rset $reply "tag table cols keys ct errtext {{{str}}}"
&nbsp; if { $ct == 1 } { puts "str=$str" }\
&nbsp; elseif { $errtext != "" } { puts "Error: errtext=$errtext" }

&nbsp; puts [SQL "select bad syntax from a"]
select {a} {} {} 0 {1 a - column "bad" not in table} {}

&nbsp; puts [SQL "select * from a where i=200"]
select a {i str d} {} 0 {} {}
</PRE>
  
You may find the <A href="../mann/vset.html">vset</A> Tcl command extremely
useful to assign the data of a row to the column names, as in the example:
<PRE>set reply [SQL "select * from lotdata where lot='x'"]
set cols [lindex $reply 2]
foreach row [lindex $reply 6] {
&nbsp;&nbsp;&nbsp; vset $row $cols
&nbsp;&nbsp;&nbsp; puts lot=$lot
&nbsp;&nbsp;&nbsp; }
</PRE>
</P>

<HR>
<A NAME="Notation">&nbsp;</A>
<H2>Notation</H2>
<P><B>BOLD</B> is used to indicate commands, keywords, or punctuation 
that needs to be entered as written.  With the SQL commands, the
keywords are written in uppercase for emphasis, but you can enter them
in lowercase too.  Tcl commands such as <B>SQL</B> 
and <B>hub_tables</B> are case sensitive and are entered exactly as
written.</P>
<P><I>Italics</I> are used to indicate names or other items where you 
supply your own instance value.  For example, where we have written
<I>table</I> you are expected to supply the name of a table.</P>
<P>We use square brackets to enclose items that are optionally specified.
For example [<B>WHERE</B> <I>where_criteria</I>] indicates this clause
may be omitted.  The square brackets themselves are not entered.</P>
<P>When you see the * character following a phrase, it means the
phrase is optionally repeated 0 or more times.  For example,
<I>column</I> [<B>,</B> <I>column</I>]* indicates that one <I>column</I>
name must be supplied, followed by zero or more <B>,</B> <I>column</I>
phrases.</P>
Finally, the braces are used to show sets of alternate choices, with the
choices separated by the | character.  For example, 
{ <B>PROC=</B><I>procname</I> | <B>SQLPROC=</B><I>procname</I> }.
The braces and the | character are part of the notation and are not
entered when the command is used.</P>

<HR>
<A NAME="Compatibility">&nbsp;</A>
<H2>Compatibility Notes</H2>
<P>
The new Datahub provided by Hume Integration Software, has been written
from "scratch" as a set of C code extensions to the Tcl/Tk interpreter.
While the software retains command syntax and reply format compatibility
with the SEMATECH SCC Data Server and the extended version developed
at Motorola, it does not use any of the source code from these applications,
such as the SEMATECH Generic Server.  Therefore, there are a
substantial number of changes that you may need to be aware of in
running your existing applications.</P>
<P>
First of all, the new Datahub returns the same reply formats for the
ordinary, successful usage of commands, but the error replies are
for the most part different.  The basic
error replies that might be used to test for table existence, such
as the "table not found" reply are preserved.  
However, in most cases, you will find that
the error replies of the new Datahub are more
detailed and specific, and will help you develop your applications
faster.  For example, if you try to insert a duplicate row in a
keyed table, the old data server replied:
<PRE>//c 3 INSERT:&nbsp; Unable to insert.
</PRE>
The new Datahub replies:
<PRE>//c 3 INSERT:&nbsp; Unable to insert.&nbsp; Unique key violation
</PRE>
<P>
With the new Datahub, a table that has primary key columns does not
allow duplicate rows.  This is a change - the old versions allowed
duplicate rows unless the keyword NODUPROWS was supplied in the table
create statement.  For compatibility, the new Datahub accepts and
ignores the keyword NODUPROWS.  With the new Datahub, if you want
a table that allows duplicate rows, you need to declare it 
without key columns.</P>
<P>
The new Datahub allows you to update the values of any columns in an
update statement.  The old versions would not let you update the
values of key columns; you had to delete the row and
insert the updated row instead.  As explained 
with the <A href="#OPEN">open</A> command, the new Datahub
processes subscription notifications of key value updates as
both a delete and an insert notification,
and therefore preserves interoperable compatibilty with the old
versions and existing applications.</P>
<P>
There are other changes with the subscription features.  The
default REPLYTO for a message subscription was changed from the
data server's command mailbox to NULL.  This makes it safe to
feed a message subscription to another Datahub without having
the subscription replies coming into the command mailbox if
a developer forgets to set REPLYTO.</P>
Also, there is a new message subscription option, <B>TELECT</B>.
When this option is indicated for a message subscription, the
format used is the <A href="#TclReplyFormat">Tcl Reply Format</A>
instead of SQL statements.</P>
<P>
Another change was made to the subscription functionality in order
to make it more consistent and easier to explain.  The old versions
always include key column values on delete and update notifications 
even when they are not requested.  However, insert notifications only
provide the columns that are explicitly requested.  The new Datahub
always includes the key column values, on all of the data change
notifications, whether they are explicitly requested or not.</P>
<P>
Another improvement is that the new Datahub is able to properly
handle newlines when they are imbedded in the data of SQL statements
that are read from files using the <A href="#READ">read</A> or
<A href="#INCLUDE">include</A> commands.  The old versions use
the Generic Server INCLUDE code which reads each
line in a file as a separate command.  With the older versions,
you cannot properly <A href="#READ">read</A> the data of a table, 
if a row has an imbedded newline in its data.</P>
<P>
The older versions use the <A href="#EOF">eof</A> command to signify
both the end of command line or console input, as well as a
command to initialize message system communication.  The new 
Datahub uses the <A href="#EOF">eof</A> command only as a
command to initialize message system communication.  The
new Datahub uses the command line, file input, and or console
input consistently with other Tcl/Tk interpreter applications.</P>
<P>
The new Datahub does not support the old <B>sleep</B> command.
You can accomplish the same functionality using the 
<A href="../mann/after.html">after</A> Tcl command.</P>
<P>
The new Datahub is compatible with the old versions in allowing
trailing semicolons on SQL commands.  This is not ANSI SQL and is
deprecated for new applications.</P>
<P>
The new Datahub overcomes a very nasty problem with the old versions.
When the old versions are shutdown, subscribers are sent delete
notifications as all of the application data is deleted.  Many
applications feed subscription notifications to a persistent
database, and risk losing all of their data if the Data Server
is shutdown without the subscriptions being closed, and the
persistent database interface is not shutdown first.  The new
Datahub exits without sending these notifications.</P>
<P>
The new Datahub also uses binary signatures to protect against
data corruption.  With the old versions, if you close a
subscription in a procedure notification of the same subscription,
or drop a table in a procedure notification on that table, the
program will almost certainly exit with a segmentation violation.
The new Datahub will take these changes in stride.</P>
<P>
There have been other improvements that should not adversely
affect existing applications.  
For example, the memory utilization of the new
Datahub is substantially improved over the old versions:
<UL>
<li>a large decrease in allocation and freeing
<li>drastically reduced paging
<li>optimized data alignment
<li>less memory consumed with heap allocation management
<li>drastically reduced heap fragmentation
</UL>
Finally overall performance has been radically improved.
The new Datahub uses real table management algorithms that
scale as log N.  The typical performance gain is 5-10X and
it gets better and better for larger tables.  
<HR>
<A NAME="version">&nbsp;</A>
<H2>Document Version</H2>
<P>
Date of last revision: $Date: 2005/03/16 21:49:17 $ </P>
<P>
This document covers the Hume Integration Software developed
Datahub that is available for the Tcl 8.4/Tk 8.4 environment
on the Windows NT and UNIX/POSIX platforms.
<HR>
<P>
Go to the <A href="#datahub">Datahub Contents</A>
<P>
Leave this document and go to the <A href="../index.html" target="_top">Tcl/Tk Resource Index</A>
</P>
</BODY>
</HTML>
