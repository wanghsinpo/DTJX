<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML><HEAD>
<A NAME="ehttp"></A>
<TITLE>ehttp HTTP client</TITLE></HEAD>
<BODY>
<HR>
<P>
<H2>NAME</H2>
 ehttp - Client-side implementation of the HTTP/1.0 and 1.1 protocols. <P>
<H2>SYNOPSIS</H2>
 <B>package require Humelib</B> <P>
<B>::ehttp::config <I>?options?</B></I> <P>
<B>::ehttp::geturl <I>url ?options?</B></I> <P>
<B>::ehttp::formatQuery</B> <I>key value</I> ?<I>key value</I> ...? <P>
<B>::ehttp::reset</B> <I>token</I> ?<I>why</I>? <P>
<B>::ehttp::wait <I>token</B></I> <P>
<B>::ehttp::status <I>token</B></I> <P>
<B>::ehttp::size <I>token</B></I> <P>
<B>::ehttp::code <I>token</B></I> <P>
<B>::ehttp::ncode <I>token</B></I> <P>
<B>::ehttp::data <I>token</B></I> <P>
<B>::ehttp::error <I>token</B></I> <P>
<B>::ehttp::cleanup <I>token</B></I> <P>
<B>::ehttp::register <I>proto port command</B></I> <P>
<B>::ehttp::unregister <I>proto</B></I> <HR>
<P>
<P>
<H2>DESCRIPTION</H2>
 <P>
The <B>ehttp</B> package provides the client side of the HTTP version 1.0 and 1.1 protocols.  The software is based on the standard Tcl http package with enhancements for using the version 1.1 HTTP protocol, and being able to trace data that is sent or received.  The package implements the GET, POST, and HEAD operations of HTTP.  It allows configuration of a proxy host to get through firewalls.  The package is compatible with the <B>Safesock</B> security policy, so it can be used by untrusted applets to do URL fetching from a restricted set of hosts. This package can be extended to support additional HTTP transport protocols, such as HTTPS, by providing a custom <B>socket</B> command, via <B>ehttp::register</B>. <P>
The <B>::ehttp::geturl</B> procedure does a HTTP transaction. Its <I>options </I> determine whether a GET, POST, or HEAD transaction is performed.   The return value of <B>::ehttp::geturl</B> is a token for the transaction. The value is also the name of an array in the ::ehttp namespace that contains state information about the transaction.  The elements of this array are described in the STATE ARRAY section. <P>
If the <B>-command</B> option is specified, then the HTTP operation is done in the background. <B>::ehttp::geturl</B> returns immediately after generating the HTTP request and the callback is invoked when the transaction completes.  For this to work, the Tcl event loop must be active.  In Tk applications this is always true.  For pure-Tcl applications, the caller can use <B>::ehttp::wait</B> after calling <B>::ehttp::geturl</B> to start the event loop. <P>
<H2>COMMANDS</H2>
 
<DT><B>::ehttp::config</B> ?<I>options</I>?
<DD>The <B>::ehttp::config</B> command is used to set and query the name of the proxy server and port, and the User-Agent name used in the HTTP requests.  If no options are specified, then the current configuration is returned.  If a single argument is specified, then it should be one of the flags described below.  In this case the current value of that setting is returned.  Otherwise, the options should be a set of flags and values that define the configuration: <DL>

<DT><B>-accept</B> <I>mimetypes</I>
<DD>The Accept header of the request.  The default is */*, which means that all types of documents are accepted.  Otherwise you can supply a  comma separated list of mime type patterns that you are willing to receive.  For example, "image/gif, image/jpeg, text/*". 
<DT><B>-proxyhost</B> <I>hostname</I>
<DD>The name of the proxy host, if any.  If this value is the empty string, the URL host is contacted directly. 
<DT><B>-proxyport</B> <I>number</I>
<DD>The proxy port number. 
<DT><B>-proxyfilter</B> <I>command</I>
<DD>The command is a callback that is made during <B>::ehttp::geturl</B> to determine if a proxy is required for a given host.  One argument, a host name, is added to <I>command</I> when it is invoked.  If a proxy is required, the callback should return a two element list containing the proxy server and proxy port.  Otherwise the filter should return an empty list.  The default filter returns the values of the <B>-proxyhost</B> and <B>-proxyport</B> settings if they are non-empty. 
<DT><B>-useragent</B> <I>string</I>
<DD>The value of the User-Agent header in the HTTP request.  The default is <B>"Hume EDA Tcl http client package 1.0."</B> </DL>

<DT><B>::ehttp::geturl</B> <I>url</I> ?<I>options</I>? 
<DD>The <B>::ehttp::geturl</B> command is the main procedure in the package. The <B>-query</B> option causes a POST operation and the <B>-validate</B> option causes a HEAD operation; otherwise, a GET operation is performed.  The <B>::ehttp::geturl</B> command returns a <I>token</I> value that can be used to get information about the transaction.  See the STATE ARRAY and ERRORS section for details.  The <B>::ehttp::geturl</B> command blocks until the operation completes, unless the <B>-command</B> option specifies a callback that is invoked when the HTTP transaction completes. <B>::ehttp::geturl</B> takes several options: <DL>

<DT><B>-binary</B> <I>boolean</I>
<DD>Specifies whether to force interpreting the url data as binary.  Normally this is auto-detected (anything not beginning with a <B>text</B> content type or whose content encoding is <B>gzip</B> or <B>compress</B> is considered binary data). 
<DT><B>-blocksize</B> <I>size</I>
<DD>The blocksize used when reading the URL. At most <I>size</I> bytes are read at once.  After each block, a call to the <B>-progress</B> callback is made (if that option is specified). 
<DT><B>-channel</B> <I>name</I>
<DD>Copy the URL contents to channel <I>name</I> instead of saving it in <B>state(body)</B>. 
<DT><B>-command</B> <I>callback</I>
<DD>Invoke <I>callback</I> after the HTTP transaction completes. This option causes <B>::ehttp::geturl</B> to return immediately. The <I>callback</I> gets an additional argument that is the <I>token</I> returned from <B>::ehttp::geturl</B>. This token is the name of an array that is described in the STATE ARRAY section.  Here is a template for the callback: <DL>
<PRE>
proc httpCallback {token} {
    upvar #0 $token state
    # Access state as a Tcl array
}
</PRE>
</DL>

<DT><B>-handler</B> <I>callback</I>
<DD>Invoke <I>callback</I> whenever HTTP data is available; if present, nothing else will be done with the HTTP data.  This procedure gets two additional arguments: the socket for the HTTP data and the <I>token</I> returned from <B>::ehttp::geturl</B>.  The token is the name of a global array that is described in the STATE ARRAY section.  The procedure is expected to return the number of bytes read from the socket.  Here is a template for the callback: <DL>
<PRE>
proc httpHandlerCallback {socket token} {
    upvar #0 $token state
    # Access socket, and state as a Tcl array
    ...
    (example: set data [read $socket 1000];set nbytes [string length $data])
    ...
    return nbytes
}
</PRE>
</DL>

<DT><B>-headers</B> <I>keyvaluelist</I>
<DD>This option is used to add extra headers to the HTTP request.  The <I>keyvaluelist</I> argument must be a list with an even number of elements that alternate between keys and values.  The keys become header field names.  Newlines are stripped from the values so the header cannot be corrupted.  For example, if <I>keyvaluelist</I> is <B>Pragma no-cache</B> then the following header is included in the HTTP request: <PRE>
Pragma: no-cache
</PRE>

<DT><B>-progress</B> <I>callback</I>
<DD>The <I>callback</I> is made after each transfer of data from the URL. The callback gets three additional arguments: the <I>token</I> from <B>::ehttp::geturl</B>, the expected total size of the contents from the <B>Content-Length</B> meta-data, and the current number of bytes transferred so far.  The expected total size may be unknown, in which case zero is passed to the callback.  Here is a template for the progress callback: <DL>
<PRE>
proc httpProgress {token total current} {
    upvar #0 $token state
}
</PRE>
</DL>

<DT><B>-query</B> <I>query</I>
<DD>This flag causes <B>::ehttp::geturl</B> to do a POST request that passes the <I>query</I> to the server. The <I>query</I> must be a x-url-encoding formatted query.  The <B>::ehttp::formatQuery</B> procedure can be used to do the formatting. 
<DT><B>-queryblocksize</B> <I>size</I>
<DD>The blocksize used when posting query data to the URL. At most  <I>size</I> bytes are written at once.  After each block, a call to the <B>-queryprogress</B> callback is made (if that option is specified). 
<DT><B>-querychannel</B> <I>channelID</I>
<DD>This flag causes <B>::ehttp::geturl</B> to do a POST request that passes the data contained in <I>channelID</I> to the server. The data contained in <I>channelID</I> must be a x-url-encoding formatted query unless the <B>-type</B> option below is used. If a Content-Length header is not specified via the <B>-headers</B> options, <B>::ehttp::geturl</B> attempts to determine the size of the post data in order to create that header.  If it is unable to determine the size, it returns an error. 
<DT><B>-queryprogress</B> <I>callback</I>
<DD>The <I>callback</I> is made after each transfer of data to the URL (i.e. POST) and acts exactly like the <B>-progress</B> option (the callback format is the same). 
<DT><B>-timeout</B> <I>milliseconds</I>
<DD>If <I>milliseconds</I> is non-zero, then <B>::ehttp::geturl</B> sets up a timeout to occur after the specified number of milliseconds. A timeout results in a call to <B>::ehttp::reset</B> and to the <B>-command</B> callback, if specified. The return value of <B>::ehttp::status</B> is <B>timeout</B> after a timeout has occurred. 
<DT><B>-TRACE</B> <I>tracebits</I>
<DD>The <B>-TRACE</B> option is used in conjunction with the <B>-tracecmd</B> option to control the information being passed to the user-defined <I>tracecmd</I>.  The <I>tracebits</I> integer value is used as a bitfield.  The table below shows the bit values as hexadecimal integers, and the corresponding information provided if the bit is set.<dl>
<DT>0x0001
<DD>status messages
<DT>0x0100
<DD>Received HTTP header data
<DT>0x0800
<DD>Received HTTP content data
<DT>0x1000
<DD>Sent HTTP header data
<DT>0x8000
<DD>Sent HTTP query data
</dl>
<DT><B>-tracecmd</B> <I>tracecmd</I>
<DD>The ehttp software is instrumented with the capability to execute user-defined code
which is passed the data being exchanged or status information.  See the <B>-TRACE</B> option above for a description of the bitfield values that control the <I>tracecmd</I> evaluation.  The <I>tracecmd</I> is concatenated with three arguments during evaluation, (1) the geturl transaction token (an array name), (2) the pertinent TRACE bit value, and (3) the data that was read or written or a status message.  If this option is used, in addition to the bit values specified by the <B>-TRACE</B> option, the <I>tracecmd</I> code is also executed with the bit value of 0 and the value of the geturl transaction token after the transaction array has been initialized.
<DT><B>-type</B> <I>mime-type</I>
<DD>Use <I>mime-type</I> as the <B>Content-Type</B> value, instead of the default value (<B>application/x-www-form-urlencoded</B>) during a POST operation. 
<DT><B>-validate</B> <I>boolean</I>
<DD>If <I>boolean</I> is non-zero, then <B>::ehttp::geturl</B> does an HTTP HEAD request.  This request returns meta information about the URL, but the contents are not returned.  The meta information is available in the <B>state(meta) </B> variable after the transaction.  See the STATE ARRAY section for details. 
<DT><B>-version</B> <I>version</I>
<DD>The <I>version</I> argument can be specified as <B>1.0</B> or <B>1.1</B> to specify the desired version of the HTTP protocol.  The default is 1.0 which uses a new socket connection for each geturl operation.  Version 1.1 re-uses socket connections and is slightly more efficient if more than one operation is being performed with the same HTTP server.  There can be problems using version 1.1 since the content length stated by the server is relied upon to know when the contents have been completely received.  With version 1.0, the end-of-file condition indicates transmission completion even if the content length is not correct.  In particular, a problem is seen when a non-binary document containing CR, LF sequences is fetched.  The character count computed by the client is less than that stated by the server when the CR, LF characters are mapped to \n during utf-8 encoding.  So the geturl operation does not complete.  To avoid this situation, the <b>-binary</b> option should be specified, or version 1.0 of the HTTP protocol should be used.
</DL>

<DT><B>::ehttp::formatQuery</B> <I>key value</I> ?<I>key value</I> ...?
<DD>This procedure does x-url-encoding of query data.  It takes an even number of arguments that are the keys and values of the query.  It encodes the keys and values, and generates one string that has the proper &amp; and = separators.  The result is suitable for the <B>-query</B> value passed to <B>::ehttp::geturl</B>. 
<DT><B>::ehttp::reset</B> <I>token</I> ?<I>why</I>?
<DD>This command resets the HTTP transaction identified by <I>token</I>, if any.  This sets the <B>state(status)</B> value to <I>why</I>, which defaults to <B>reset</B>, and then calls the registered <B>-command</B> callback. 
<DT><B>::ehttp::wait</B> <I>token</I>
<DD>This is a convenience procedure that blocks and waits for the transaction to complete.  This only works in trusted code because it uses <B>vwait</B>.  Also, it's not useful for the case where <B>::ehttp::geturl</B> is called <I>without</I> the <B>-command</B> option because in this case the <B>::ehttp::geturl</B> call doesn't return until the HTTP transaction is complete, and thus there's nothing to wait for. 
<DT><B>::ehttp::data</B> <I>token</I>
<DD>This is a convenience procedure that returns the <B>body</B> element (i.e., the URL data) of the state array. 
<DT><B>::ehttp::error</B> <I>token</I>
<DD>This is a convenience procedure that returns the <B>error</B> element of the state array. 
<DT><B>::ehttp::status</B> <I>token</I>
<DD>This is a convenience procedure that returns the <B>status</B> element of the state array. 
<DT><B>::ehttp::code</B> <I>token</I>
<DD>This is a convenience procedure that returns the <B>http</B> element of the state array. 
<DT><B>::ehttp::ncode</B> <I>token</I>
<DD>This is a convenience procedure that returns just the numeric return code (200, 404, etc.) from the <B>http</B> element of the state array. 
<DT><B>::ehttp::size</B> <I>token</I>
<DD>This is a convenience procedure that returns the <B>currentsize</B> element of the state array, which represents the number of bytes received from the URL in the <B>::ehttp::geturl</B> call. 
<DT><B>::ehttp::cleanup</B> <I>token</I>
<DD>This procedure cleans up the state associated with the connection identified by <I>token</I>.  After this call, the procedures like <B>::ehttp::data</B> cannot be used to get information about the operation.  It is <I>strongly</I> recommended that you call this function after you're done with a given HTTP request.  Not doing so will result in memory not being freed, and if your app calls <B>::ehttp::geturl</B> enough times, the memory leak could cause a performance hit...or worse. 
<DT><B>::ehttp::register</B> <I>proto port command</I>
<DD>This procedure allows one to provide custom HTTP transport types such as HTTPS, by registering a prefix, the default port, and the command to execute to create the Tcl <B>channel</B>. E.g.: <DL>
<PRE>
package require Humelib
package require tls
<P>
ehttp::register https 443 ::tls::socket
<P>
set token [ehttp::geturl https://my.secure.site/]
</PRE>
</DL>

<DT><B>::ehttp::unregister</B> <I>proto</I>
<DD>This procedure unregisters a protocol handler that was previously registered via <B>ehttp::register</B>. <P>
<P>
<H2>ERRORS</H2>
 The <B>ehttp::geturl</B> procedure will raise errors in the following cases: invalid command line options, an invalid URL, a URL on a non-existent host, or a URL at a bad port on an existing host. These errors mean that it cannot even start the network transaction. It will also raise an error if it gets an I/O error while writing out the HTTP request header. For synchronous <B>::ehttp::geturl</B> calls (where <B>-command</B> is not specified), it will raise an error if it gets an I/O error while reading the HTTP reply headers or data.  Because <B>::ehttp::geturl</B> doesn't return a token in these cases, it does all the required cleanup and there's no issue of your app having to call <B>::ehttp::cleanup</B>. <P>
For asynchronous <B>::ehttp::geturl</B> calls, all of the above error situations apply, except that if there's any error while  reading the HTTP reply headers or data, no exception is thrown.  This is because after writing the HTTP headers, <B>::ehttp::geturl</B> returns, and the rest of the HTTP transaction occurs in the background.  The command callback can check if any error occurred during the read by calling <B>::ehttp::status</B> to check the status and if its <I>error</I>, calling <B>::ehttp::error</B> to get the error message. <P>
Alternatively, if the main program flow reaches a point where it needs to know the result of the asynchronous HTTP request, it can call <B>::ehttp::wait</B> and then check status and error, just as the callback does. <P>
In any case, you must still call <B>::ehttp::cleanup</B> to delete the state array when you're done. <P>
There are other possible results of the HTTP transaction determined by examining the status from <B>ehttp::status</B>. These are described below. 
<DT>ok
<DD>If the HTTP transaction completes entirely, then status will be <B>ok</B>. However, you should still check the <B>ehttp::code</B> value to get the HTTP status.  The <B>ehttp::ncode</B> procedure provides just the numeric error (e.g., 200, 404 or 500) while the <B>ehttp::code</B> procedure returns a value like "HTTP 404 File not found". 
<DT>eof
<DD>If the server closes the socket without replying, then no error is raised, but the status of the transaction will be <B>eof</B>. 
<DT>error
<DD>The error message will also be stored in the <B>error</B> status array element, accessible via <B>::ehttp::error</B>. <P>
Another error possibility is that <B>ehttp::geturl</B> is unable to write all the post query data to the server before the server responds and closes the socket. The error message is saved in the <B>posterror</B> status array element and then  <B>ehttp::geturl</B> attempts to complete the transaction. If it can read the server's response it will end up with an <B>ok</B> status, otherwise it will have an <B>eof</B> status. <P>
<P>
<H2>STATE ARRAY</H2>
 The <B>::ehttp::geturl</B> procedure returns a <I>token</I> that can be used to get to the state of the HTTP transaction in the form of a Tcl array. Use this construct to create an easy-to-use array variable: <PRE>
upvar #0 $token state
</PRE>
Once the data associated with the url is no longer needed, the state array should be unset to free up storage. The <B>ehttp::cleanup</B> procedure is provided for that purpose. The following elements of the array are supported: <DL>

<DT><B>body</B>
<DD>The contents of the URL.  This will be empty if the <B>-channel</B> option has been specified.  This value is returned by the <B>::ehttp::data</B> command. 
<DT><B>charset</B>
<DD>The value of the charset attribute from the <B>Content-Type</B> meta-data value.  If none was specified, this defaults to the RFC standard <B>iso8859-1</B>, or the value of <B>$::ehttp::defaultCharset</B>.  Incoming text data will be automatically converted from this charset to utf-8. 
<DT><B>coding</B>
<DD>A copy of the <B>Content-Encoding</B> meta-data value. 
<DT><B>currentsize</B>
<DD>The current number of bytes fetched from the URL. This value is returned by the <B>::ehttp::size</B> command. 
<DT><B>error</B>
<DD>If defined, this is the error string seen when the HTTP transaction was aborted. 
<DT><B>http</B>
<DD>The HTTP status reply from the server.  This value is returned by the <B>::ehttp::code</B> command.  The format of this value is: <DL>
<PRE>
<I>HTTP/1.x code string</I>
</PRE>
The <I>code</I> is a three-digit number defined in the HTTP standard. A code of 200 is OK.  Codes beginning with 4 or 5 indicate errors. Codes beginning with 3 are redirection errors.  In this case the <B>Location</B> meta-data specifies a new URL that contains the requested information. </DL>

<DT><B>meta</B>
<DD>The HTTP protocol returns meta-data that describes the URL contents. The <B>meta</B> element of the state array is a list of the keys and values of the meta-data.  This is in a format useful for initializing an array that just contains the meta-data: <DL>
<PRE>
array set meta $state(meta)
</PRE>
Some of the meta-data keys are listed below, but the HTTP standard defines more, and servers are free to add their own. 
<DT><B>Content-Type</B>
<DD>The type of the URL contents.  Examples include <B>text/html</B>, <B>image/gif,</B> <B>application/postscript</B> and <B>application/x-tcl</B>. 
<DT><B>Content-Length</B>
<DD>The advertised size of the contents.  The actual size obtained by <B>::ehttp::geturl</B> is available as <B>state(size)</B>. 
<DT><B>Location</B>
<DD>An alternate URL that contains the requested data. </DL>

<DT><B>posterror</B>
<DD>The error, if any, that occurred while writing the post query data to the server. 
<DT><B>status</B>
<DD>Either <B>ok</B>, for successful completion, <B>reset</B> for user-reset, <B>timeout</B> if a timeout occurred before the transaction could complete, or <B>error</B> for an error condition.  During the transaction this value is the empty string. 
<DT><B>totalsize</B>
<DD>A copy of the <B>Content-Length</B> meta-data value. 
<DT><B>type</B>
<DD>A copy of the <B>Content-Type</B> meta-data value. 
<DT><B>url</B>
<DD>The requested URL. </DL>
<P>
<H2>EXAMPLE</H2>
 <PRE>
# Copy a URL to a file and print meta-data
proc ::ehttp::copy { url file {chunk 4096} } {
    set out [open $file w]
    set token [geturl $url -channel $out -progress ::ehttp::Progress \
	-blocksize $chunk]
    close $out
    # This ends the line started by ehttp::Progress
    puts stderr ""
    upvar #0 $token state
    set max 0
    foreach {name value} $state(meta) {
	if {[string length $name] &gt; $max} {
	    set max [string length $name]
	}
	if {[regexp -nocase ^location$ $name]} {
	    # Handle URL redirects
	    puts stderr "Location:$value"
	    return [copy [string trim $value] $file $chunk]
	}
    }
    incr max
    foreach {name value} $state(meta) {
	puts [format "%-*s %s" $max $name: $value]
    }
<P>
    return $token
}
proc ::ehttp::Progress {args} {
    puts -nonewline stderr . ; flush stderr
}
</PRE>
<P>
<P>
<H2>SEE ALSO</H2>
 <a href="../mann/safe.html">safe</a>, <a href="../mann/socket.html">socket</a> <P>
<P>
<H2>KEYWORDS</H2>
 HTTP, security policy, socket 
</BODY>
</HTML>
