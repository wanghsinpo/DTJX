#!/bin/sh
# $Header: /usr/cvsroot/gem/host/gemhost,v 1.19 2004/09/24 18:03:20 hume Exp $
#
# Restart using Tcl/Tk with the hub UI script.
# Additional command line arguments can be Tcl statements
#  Examples:
#     gemhost -notk "set MB_GROUP photobay1" \
#          "set PORT 192.168.2.4:5555" \
#          "set HSMS 1"
# 
#     gemhost "set PORT doc:5050" "set HSMS 1" \                     
#       "set gemhost(PROTOCOL) 1993" &

# Use -notk to run detached from X-windows.
# \
exec dmh_wish -tclargs "$@" -f "$0"

# load the database ui when running with Tk
global tk_version env
if { [info exists tk_version] } {
    if { [info exists env(DMH_BIN)] } {
        source [file join $env(DMH_BIN) hub[join [split $tk_version .] ""]]
        } \
    else { 
        source [file join /usr/local/bin hub[join [split $tk_version .] ""]]
        }
    }

#
# gem/VFEI host equipment interface
#   ref SEMI E30-95
#   see vfei.tcl
#
# Licensed and Supported Software
# (C)Copyright 1997 Hume Integration Software
# All Rights Reserved
#
# $Log: gemhost,v $
# Revision 1.19  2004/09/24 18:03:20  hume
# Changed default TRACE value to include state & connection attempts.
#
# Revision 1.18  2002/11/01 15:57:14  hume
# Changed lset usage to vset usage, using dmh_import, and dmh_var for Tcl 8.4
# compatibility.
#
# Revision 1.17  2002/10/17 12:45:11  hume
# tracewin_TRACE needed initialization for -notk on Unix.
#
# Revision 1.16  2002/07/31 13:12:49  hume
# Changed initialization to have trace window earlier to see 1st messages.
# Proc ei_init has new optional argument, tracewin_TRACE.  Stopped reading
# from <MachineName> DMH mailbox for VFEI commands - only <MachineName>_VFEI.
#
# Revision 1.15  2001/11/15 17:03:50  hume
# Changed Hume Integration Services to Hume Integration Software.
#
# Revision 1.14  2000/10/12 12:40:14  hume
# Needed to tweak initialization defaults to restore HSMS default.
#
# Revision 1.13  2000/10/10 21:00:09  hume
# Added PASSIVE HSMS option for supervisor and gemhost/supervisor command lines.
#
# Revision 1.12  1999/07/24 22:40:05  hume
# Added -notk logic on conditional existence of dmh(notk) (NT, Tcl 8.1)
#
# Revision 1.11  1999/01/19 19:49:26  hume
# Handling of empty return of mbx init on reconnect failure was not proper.
#
# Revision 1.10  1997/12/15 14:38:54  hume
# Typo in last edit.
#
# Revision 1.9  1997/12/15 14:24:31  hume
# Change tk_version reference so you can run in background.
#
# Revision 1.8  1997/10/28 02:39:19  hume
# Tweaking version independent start.
#
# Revision 1.7  1997/10/28 02:13:13  hume
# Fixed typo bug in variables.tcl, and make startup version independent.
#
# Revision 1.6  1997/09/30 11:59:40  hume
# You can set DEVID "Device ID" on the command line.
#
# Revision 1.5  1997/09/08 18:11:44  hume
# Fixed for rs232 by removing use of secs_xact in receive callbacks.
#
# Revision 1.4  1997/08/09 10:55:28  hume
# Added more logic to auto_path initialization and added instructions for
# setting up equipment specific directories and using the custom directory.
#
# Revision 1.3  1997/08/08 22:16:22  hume
# Added example mh_app_lostserver procedure which is commented out.
#
# Revision 1.2  1997/08/08 21:00:09  hume
# Made mods to promote ease of customization using custom directory.
#
# Revision 1.1.1.1  1997/07/01 13:39:51  hume
# New SECS/VFEI/GEM application.
#


# You may want to develop your own version of this script
# that starts several equipment interfaces in the same process.
# You can use the "custom" directory which is provided for
# this purpose, or you can create a new directory that is a
# peer to this directory.  The auto_path initialization
# below, accomodates both possibilities.

proc main {} {
    # Add this directory and others to the path that is searched for
    # unknown Tcl procedures (see mann/library.html).
    # If you need to customize any of the source code, copy the file(s)
    # to ../custom,  rebuild the tclIndex there, and your version 
    # will be found and used instead of the HIS version.
    # The file commands are used for portability.
    global auto_path
    set pwd [pwd]
    if { [lsearch -exact $auto_path $pwd] < 0 } {
        # If we are not running in the "host" directory, add the
        # current directory to the auto_path first.
        # We assume the customer has copied this file to a new
        # directory which has equipment specific code.
        set phost [file join [file dirname $pwd] host]
        if { ![file isdirectory $phost] } {
           error "Can't find \"host\" subdirectory.  The auto_path\
 initialization code assumes that the working directory is the\
 \"host\" directory, or a peer to it such as ../custom or\
 ../<your_dir>"
           }
        # we only add it to the auto_path if its properly indexed
        if { $pwd != $phost && \
                [file exists [file join $pwd tclIndex]]} {
            lappend auto_path $pwd
            }
        # Next, if the customer has installed custom code in the 
        # custom directory, add it to the auto_path, if we did not
        # already add it above.
        set pcustom [file join [file dirname $pwd] custom]
        if { [file exists [file join $pcustom tclIndex]] } {
            if { $pwd != $pcustom } {
                lappend auto_path $pcustom
                }
            }
        # Next, add the "host" and the "lib" subdirectories to the
        # auto_path so that HIS provided code is found
        lappend auto_path $phost [file join [file dirname $pwd] lib]
        }

    # compatibility with Tcl 8.4+
    dmh_import

    # if running hub script
    # the hub script is run after this one
    # change the titles etc after it runs
    after 1 "catch {
              wm title . \"EI Data Tables\"
              wm iconname . \"EI\nTables\"
              #wm iconify .
              }"

    # connect to the DMH message system (and VFEI input)
    # if the DMH group is specified on the command line 
    #  gemhost "set MB_GROUP xxx"
    global MB_GROUP MB_SERVER argv0
    if { [info exist MB_GROUP] } { 
        mbx init $MB_GROUP
        # listen to a DMH mailbox for SQL commands
        # for use by remote hubclient user inteface(s)
        global argv0
        set mailbox [file rootname [file tail $argv0]]_SQL
        if { ![info exists MB_SERVER] } { set MB_SERVER $mailbox }
        mbx whenmsg $MB_SERVER {mbx whenmsg again; \
 gs_execute $mbxdest $mbxmsg $mbxreply}
        }

    # Here we are figuring things out for 1 equipment connection
    # Your application may startup connections to N equipment
    # (See the supervisor application for plural startup)

    # our connection object name
    set spname gemhost

    # you can set HSMS, PORT, DEVID, BAUD on the commandline
    # you can set PASSIVE on the commandline (PASSIVE==hsms_passive)
    global PORT HSMS DEVID BAUD PASSIVE $spname
 
    set baud 9600
    set devid 0
    set hsms 1
    set hsms_passive 0
    set port localhost:5555
    if { [info exists BAUD] } { set baud $BAUD }
    if { [info exists DEVID] } { set devid $DEVID }
    if { [info exists PORT] } { 
        set hsms 0 ;# defining PORT changes HSMS default 
        set port $PORT 
        if { [info exists HSMS] } { 
            set hsms $HSMS
            if { [info exists PASSIVE] } {
               if { $PASSIVE != "0" } { set hsms_passive 1 } 
               }
            }
        }

    # startup a single equipment connection
    set text [ei_startup $spname $port $hsms $devid $baud $hsms_passive]\n

    return $text
    }


proc ei_startup {spname port hsms devid baud hsms_passive} {
    global $spname tk_library 

    # Do we want to show windows for this interface?
    # need Tk, and allow for -notk command line argument
    if { [info exists tk_library] } {
        set notk_var [dmh_var dmh notk]
        if { [info exists $notk_var] && [set $notk_var] } { set tracewin_TRACE 0 }\
        else { set tracewin_TRACE 0x440E }
        }\
    else { set tracewin_TRACE 0 }

    # do the basic communication initialization
    ei_init $spname $port $hsms $devid $baud $hsms_passive $tracewin_TRACE

    # lets assume the equipment can handle multiple open transactions
    set ${spname}(MULT) 1

    if { $tracewin_TRACE != 0 } {
        # refresh hub view of table counts during initialization
        foreach delay {1000 2000 3000} { after $delay hub_table_refresh }
        # put up an example UI for status and characterization
        ei_ui $spname
        }

    return "$spname started at [localtime 0]"
    }

main

# You probably want to create your own version of mh_app_lostserver
# which is called if the message system is shutdown, or if the
# connection is broken from any other cause such as a network or
# workstation failure.  You need to have your procedure already
# sourced into your interpreter before it is needed.  The logic
# calls it only if it already is defined.
#
#proc mh_app_lostserver {group fileID} {
#   global MB_GROUP 
    # maybe you just want to exit and start everything later
    # let this procedure complete and then initiate the exit
    #after 1000 exit
    #
    # maybe you want to fall into a loop where you attempt to rejoin
    # the restarted message system
    # Give it some time between each try. 
#   after 300000 "ei_try_mbx_init $MB_GROUP"
#   proc ei_try_mbx_init group { 
#       if { [catch {mbx init $group} reply] || $reply == "" } { 
#           after 300000 "ei_try_mbx_init $group"
#           return
#           }
        # we are back online with the message system
        # if you call ei_vfei_output_init for your machines, the
        # queued vfei output will be sent and then deleted
        #global gemhost
        #ei_vfei_output_init gemhost $gemhost(VFEI_MID)
#       }
#   }


