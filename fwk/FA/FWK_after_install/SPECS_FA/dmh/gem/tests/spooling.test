
#  starts both gemhost and gemsim
# uses tk send - start dmh_wish in foreground
# this test has some dependencies on the system speed - TBD fix it.
# 
if {[string compare test [info procs test]] == 1} then {source defs}

global testdir gemsim_pid gemhost_pid gemsim gemhost


test spooling-1 {start gemsim} {
    global testdir gemsim_pid gemsim
    set testdir [pwd]
    cd ../equip
    set gemsim gemsim
    set gemsim_pid [exec gemsim &]
    cd $testdir
    expr $gemsim_pid > 0 
} 1

# use send to find gemsim
test spooling-2 {send to gemsim} {
    global gemsim gemsim_pid
    wait 5000  ;# allow for init
    send $gemsim set gemsim(comm_state)
} {ENABLED {NOT COMMUNICATING}}
    

test spooling-3 {start gemhost} {
  global testdir gemhost gemhost_pid
  cd ../host
  set gemhost gemhost
  set gemhost_pid [exec gemhost &]
  cd $testdir
  expr $gemhost_pid > 0
} 1

# use send to chat with gemhost
test spooling-4 {send to gemhost} {
    global gemhost gemhost_pid
    wait 10000  ;# allow for init
    send $gemhost set gemhost(comm_state)
} {COMMUNICATING}

# gemsim should also be talking
test spooling-5 {send to gemsim} {
    global gemsim gemsim_pid
    send $gemsim set gemsim(comm_state)
} {COMMUNICATING}

# raise the main windows so any errors are visible
test spooling-6 {send to gemsim} {
    global gemsim gemhost
    send $gemsim wm deiconify .
    send $gemhost wm deiconify .
} {}

test spooling-6a  {gemhost spooling var queries} {
    global gemhost
    set cmd "ei_eqconst_set gemhost {{SpoolMax 400} {OverWriteSpool 0}} varname"
    set reply [send $gemhost $cmd]
} {0}

# purge the spool (if any) to get to a known condition
# there will be an operator alert if there was spooled data
test spooling-6b {gemsim spool purge} {
   global gemhost
   set cmd "secs_xact gemhost S6F23R {U1 1}"
   lindex [send $gemhost $cmd] 0
} {B:1}

# have gemhost tell gemsim to turn on spooling for
#  S5 and S6
test spooling-6c {S2F43 on} {
   global gemhost
   set cmd "secs_xact gemhost S2F43R {L {L {U1 5} L} {L {U1 6} L}}"
   send $gemhost $cmd
} {L:2 {B:1 0x00} {L:0}}

# this should show up as a gemsim variable
test spooling-7 {gemsim variable SpoolStreamFns} {
    global gemsim
    set cmd [list SQL {select varvalue from ei_variable where spname='gemsim' and\
 varname='SpoolStreamFns'}]
    set reply [send $gemsim $cmd]
    lindex [lindex [lindex $reply 6] 0] 0
 } {S5 S6}

# have gemhost tell gemsim to turn off spooling 
test spooling-8 {S2F43 off} {
   global gemhost
   set cmd "secs_xact gemhost S2F43R L"
   send $gemhost $cmd
} {L:2 {B:1 0x00} {L:0}}

# this should show up as a gemsim variable
test spooling-9 {gemsim variable SpoolStreamFns} {
    global gemsim
    set cmd [list SQL {select varvalue from ei_variable where spname='gemsim' and\
 varname='SpoolStreamFns'}]
    set reply [send $gemsim $cmd]
    lindex [lindex [lindex $reply 6] 0] 0
 } {}

# since this is a change, it shows up in the persistence file
test spooling-10 {gemsim spooling persistence} {
    set text [exec tail -n 1 ../equip/spooldata/spooldata.sql]
} {update ei_variable set varvalue='' where spname='gemsim' and varID='877' }

# cannot spool S1
test spooling-11 {S2F43 improper} {
   global gemhost
   set cmd "secs_xact gemhost S2F43R {L {L {U1 5} L} {L {U1 1} L}}"
   send $gemhost $cmd
} {L:2 {B:1 0x01} {L:1 {L:3 {U1:1 1} {B:1 0x01} {L:0}}}}

# cannot spool S6F8 (any) secondary
test spooling-12 {S2F43 improper} {
   global gemhost
   set cmd "secs_xact gemhost S2F43R {L {L {U1 5} L} {L {U1 6} {L {U1 11} {U1 8}}}}"
   send $gemhost $cmd
} {L:2 {B:1 0x01} {L:1 {L:3 {U1:1 6} {B:1 0x04} {L:1 {U1:1 8}}}}}

# have gemhost tell gemsim to turn on spooling for S6 and S7F23
test spooling-13 {S2F43 on} {
   global gemhost
   set cmd "secs_xact gemhost S2F43R {L {L {U1 7} {L {U1 23}}} {L {U1 6} L}}"
   send $gemhost $cmd
} {L:2 {B:1 0x00} {L:0}}

# check gemsim variable
test spooling-14 {gemsim variable SpoolStreamFns} {
    global gemsim
    set cmd [list SQL {select varvalue from ei_variable where spname='gemsim' and\
 varname='SpoolStreamFns'}]
    set reply [send $gemsim $cmd]
    lindex [lindex [lindex $reply 6] 0] 0
 } {S7F23 S6}

# kill gemhost - spooling on 
#                comm_disable event causes spooling start
test spooling-15 {spooling starts} {
    global gemhost
    send $gemhost "after 1 exit"
    set pik [tk_dialog .popup "Spooling Test" \
 "Is there an Operator Alert warning that spooling started?" question 0 Yes No]
    set pik
} 0

# create an event so there will be spooled data
test spooling-16 {gemsim spool data} {
    global gemsim
    set cmd [list SQL {update ei_alarm set is_set=1 where ALID='1002' and spname='gemsim'}]
    set reply [send $gemsim $cmd]
 } {{//c 0 UPDATE:  ei_alarm - 1 row updated.}}


test spooling-17 {gemsim spool data} {
    global gemsim
    set cmd [list SQL {select sfr from ei_spool_data where spname='gemsim'}]
    set reply [send $gemsim $cmd]
    lindex $reply 6
 } {S6F13R}

# create more events so there will be spooled data
test spooling-18 {gemsim spool data} {
    global gemsim
    set cmd [list SQL {update ei_alarm set is_set=0 where ALID='1002' and spname='gemsim'}]
    set reply [send $gemsim $cmd]
    set cmd [list SQL {update ei_alarm set is_set=1 where ALID='1000' and spname='gemsim'}]
    set reply [send $gemsim $cmd]
    set cmd [list SQL {update ei_alarm set is_set=0 where ALID='1000' and spname='gemsim'}]
    set reply [send $gemsim $cmd]
 } {{//c 0 UPDATE:  ei_alarm - 1 row updated.}}

# kill gemsim and bring it back - test persistence
test spooling-19 {gemsim dies} {
    global gemsim
    send $gemsim "after 1 exit"
    wait 100
    expr 1
    } 1

test spooling-20 {start gemsim} {
    global testdir gemsim_pid gemsim
    cd ../equip
    set gemsim_pid [exec gemsim &]
    cd $testdir
    expr $gemsim_pid > 0 
} 1

wait 5000

# raise the main windows so any errors are visible
test spooling-21 {send to gemsim} {
    global gemsim gemhost
    send $gemsim wm deiconify .
    #send $gemhost wm deiconify .
} {}

# check gemsim variable
test spooling-21 {gemsim variable SpoolStreamFns} {
    global gemsim
    set cmd [list SQL {select varvalue from ei_variable where spname='gemsim' and\
 varname='SpoolStreamFns'}]
    set reply [send $gemsim $cmd]
    lindex [lindex [lindex $reply 6] 0] 0
 } {S7F23 S6}

test spooling-21 {gemsim spool recovery} {
    global gemsim
    set cmd [list SQL {select sequence from ei_spool_data where spname='gemsim'}]
    set reply [send $gemsim $cmd]
    lindex $reply 6
 } {1 2 3 4}
    
# start the gemhost
test spooling-22 {start gemhost} {
  global testdir gemhost gemhost_pid
  cd ../host
  set gemhost_pid [exec gemhost &]
  cd $testdir
  expr $gemhost_pid > 0
} 1

wait 10000

# use send to chat with gemhost
test spooling-23 {send to gemhost} {
    global gemhost
    send $gemhost set gemhost(comm_state)
} {COMMUNICATING}

# we pick up two control state remote events
test spooling-24 {gemhost spooling var queries} {
    global gemhost 
    set cmd "ei_var_query gemhost SpoolCountActual varname"
    set reply [send $gemhost $cmd]
} {{U4 6}}


# set MaxSpoolTransmit to 2
test spooling-25 {gemhost spooling var queries} {
    global gemhost
    set cmd "ei_eqconst_set gemhost {{MaxSpoolTransmit 2}} varname"
    set reply [send $gemhost $cmd]
} {0}


# request spool unload
test spooling-26 {gemhost spooling var queries} {
    global gemhost
    set cmd "secs_xact gemhost S6F23R {U1 0}"
    set reply [send $gemhost $cmd]
} {B:1 0x00}

wait 1000

test spooling-27 {partial unload} {
    global gemsim
    set cmd [list SQL {select sequence from ei_spool_data where spname='gemsim'}]
    set reply [send $gemsim $cmd]
    lindex $reply 6
 } {3 4 5 6}

test spooling-28 {spool more data} {
    global gemsim
    set cmd [list SQL {update ei_alarm set is_set=1 where ALID='1000' and spname='gemsim'}]
    set reply [send $gemsim $cmd]
    set cmd [list SQL {select sequence from ei_spool_data where spname='gemsim'}]
    set reply [send $gemsim $cmd]
    lindex $reply 6
 } {3 4 5 6 7}

# request spool unload (leaving 3)
test spooling-29 {gemhost spooling var queries} {
    global gemhost
    set cmd "secs_xact gemhost S6F23R {U1 0}"
    set reply [send $gemhost $cmd]
} {B:1 0x00}

wait 1000

test spooling-30 {spool more data} {
    global gemsim
    set cmd [list SQL {update ei_alarm set is_set=0 where ALID='1000' and spname='gemsim'}]
    set reply [send $gemsim $cmd]
    set cmd [list SQL {select sequence from ei_spool_data where spname='gemsim'}]
    set reply [send $gemsim $cmd]
    lindex $reply 6
 } {5 6 7 8}

# request spool unload (leaving 2)
test spooling-29 {gemhost spooling var queries} {
    global gemhost
    set cmd "secs_xact gemhost S6F23R {U1 0}"
    set reply [send $gemhost $cmd]
} {B:1 0x00}

wait 1000

# request spool unload (leaving 0)
test spooling-29 {gemhost spooling unload} {
    global gemhost
    set cmd "secs_xact gemhost S6F23R {U1 0}"
    set reply [send $gemhost $cmd]
} {B:1 0x00}

wait 1000

test spooling-31 {spooling done} {
    set pik [tk_dialog .popup "Spooling Test" \
 "Is there an Operator Alert that spooling ended?" question 0 Yes No]
    set pik
} 0


# request spool unload with none spooled
test spooling-30 {gemhost spooling unloaded} {
    global gemhost
    set cmd "secs_xact gemhost S6F23R {U1 0}"
    set reply [send $gemhost $cmd]
} {B:1 0x02}

# spool max testing
# small max spool and overwrite false 
test spooling-31  {gemhost spooling var queries} {
    global gemhost
    set cmd "ei_eqconst_set gemhost {{SpoolMax 4} {OverWriteSpool 0}} varname"
    set reply [send $gemhost $cmd]
} {0}

# kill host and create spool data
test spooling-32 {spooling starts} {
    global gemhost
    send $gemhost "after 1 exit"
    set pik [tk_dialog .popup "Spooling Test" \
 "Is there an Operator Alert warning that spooling started?" question 0 Yes No]
    set pik
} 0

# create more events than max spool
test spooling-33 {gemsim spool data} {
    global gemsim time33
    set time33 [send $gemsim "secs_CLOCK $gemsim"]
    for {set i 0} {$i < 4} {incr i} {
    set cmd [list SQL {update ei_alarm set is_set=1,is_enabled=1 where ALID='1000' and spname='gemsim'}]
    set reply [send $gemsim $cmd]
    set cmd [list SQL {update ei_alarm set is_set=0 where ALID='1000' and spname='gemsim'}]
    set reply [send $gemsim $cmd]
    }
    set reply
 } {{//c 0 UPDATE:  ei_alarm - 1 row updated.}}

test spooling-34 {spool full} {
    set pik [tk_dialog .popup "Spooling Test" \
 "Is there an Operator Alert warning that the spool filled?" question 0 Yes No]
    set pik
} 0

# only oldest max msgs stored
test spooling-35 {gemsim spool max} {
    global gemsim
    set cmd [list SQL {select sequence from ei_spool_data where spname='gemsim'}]
    set reply [send $gemsim $cmd]
    lindex $reply 6
 } {1 2 3 4}

# time full
test spooling-35 {gemsim spool max} {
    global gemsim time33
    set cmd [list SQL {select varvalue from ei_variable where spname='gemsim' and varname='SpoolFullTime'}]
    set reply [send $gemsim $cmd]
    set tfull [lindex [lindex [lindex $reply 6] 0] 0]
    string compare $time33 $tfull
 } -1

# Counts 
test spooling-36 {gemsim spool max} {
    global gemsim 
    set cmd [list SQL {select varvalue from ei_variable where spname='gemsim' and (varname='SpoolCountActual' or varname='SpoolCountTotal')}]
    set reply [send $gemsim $cmd]
    lindex $reply 6
 } {4 8}


# purge
test spooling-37 {gemsim spool max} {
    global gemsim
    set cmd "eq_spool_purge $gemsim"
    set reply [send $gemsim $cmd]
 } {0}

# Counts
test spooling-38 {gemsim spool max} {
    global gemsim
    set cmd [list SQL {select varvalue from ei_variable where spname='gemsim' and (varname='SpoolCountActual' or varname='SpoolCountTotal')}]
    set reply [send $gemsim $cmd]
    lindex $reply 6
 } {0 8}

test spooling-39 {post purge} {
    set pik [tk_dialog .popup "Spooling Test" \
 "Is there an Operator Alert that the spooling terminated (empty spool)?" question 0 Yes No]
    set pik
} 0

test spooling-40  {set overwrite true} {
    global gemsim
    set cmd "SQL {update ei_variable set varvalue='1' where spname='$gemsim' and varname='OverWriteSpool'}"
    set reply [send $gemsim $cmd]
} {{//c 0 UPDATE:  ei_variable - 1 row updated.}}


# create more events 
test spooling-41 {gemsim spool data} {
    global gemsim 
    for {set i 0} {$i < 4} {incr i} {
    set cmd [list SQL {update ei_alarm set is_set=1,is_enabled=1 where ALID='1000' and spname='gemsim'}]
    set reply [send $gemsim $cmd]
    set cmd [list SQL {update ei_alarm set is_set=0 where ALID='1000' and spname='gemsim'}]
    set reply [send $gemsim $cmd]
    }
    set reply
 } {{//c 0 UPDATE:  ei_alarm - 1 row updated.}}

# only newest max msgs stored
test spooling-42 {gemsim spool max} {
    global gemsim
    set cmd [list SQL {select sequence from ei_spool_data where spname='gemsim'}]
    set reply [send $gemsim $cmd]
    lindex $reply 6
 } {5 6 7 8}

# restart host
test spooling-43 {start gemhost} {
  global testdir gemhost gemhost_pid
  cd ../host
  set gemhost_pid [exec gemhost &]
  cd $testdir
  expr $gemhost_pid > 0
} 1

wait 15000

# use send to chat with gemhost
test spooling-44 {send to gemhost} {
    global gemhost
    send $gemhost set gemhost(comm_state)
} {COMMUNICATING}

test spooling-45 {gemhost spooling var queries} {
    global gemhost
    set cmd "ei_var_query gemhost SpoolCountActual varname"
    set reply [send $gemhost $cmd]
} {{U4 4}}


# change SpoolMax MaxSpoolTransmit
test spooling-46  {gemhost spooling var queries} {
    global gemhost
    set cmd "ei_eqconst_set gemhost {{SpoolMax 1000} {MaxSpoolTransmit 0}} varname"
    set reply [send $gemhost $cmd]
} {0}

#  spool unload 
test spooling-47 {gemhost spooling unloaded} {
    global gemhost
    set cmd "secs_xact gemhost S6F23R {U1 0}"
    set reply [send $gemhost $cmd]
} {B:1 0x00}

wait 5000

# Counts
test spooling-48 {gemsim spool max} {
    global gemsim
    set cmd [list SQL {select varvalue from ei_variable where spname='gemsim' and (varname='SpoolCountActual' or varname='SpoolCountTotal')}]
    set reply [send $gemsim $cmd]
    lindex $reply 6
 } {0 10}

test spooling-49 {post purge} {
    set pik [tk_dialog .popup "Spooling Test" \
 "Is there an Operator Alert that the spooling terminated (empty spool)?" question 0 Yes No]
    set pik
} 0


# gemsim should have made the spooling state persistent
# a subscription writes to a file


#################################################
# final shutdown
test spooling-end {kill processes} {
    global gemsim gemhost
    send $gemsim "after 1 exit"
    send $gemhost "after 1 exit"
    expr 1
    } 1

