#
# "sendout" gateway used by the Distributed Message Hub
#
# (C) Copyright Hume Integration Software 1994, 1995, 2002
# All Rights Reserved
# Licensed Materials - Property of Hume Integration Software
#
# $Log: dmh_gateway,v $
# Revision 1.2  2002/10/28 17:22:42  hume
# Working through namespace version changes.
#
# Revision 1.1.1.1  2002/10/06 17:21:35  hume
# From previous version with changes for new ::dmh namespace and lset -> vset
#
#
# design assumptions
#  started by server 
#  runs on host of server
#  forwards all outbound mail of server to other servers
#
# typical startup:
#  exec dmh84 -f dmh_gateway -notk $group DBM@factory &
#
# we subsequently process messages like
#  "mh_link DBM@factory factory"
#
package require dmh 1.2

namespace eval dmh {

proc main {argv} {
    set group [lindex $argv 0]
    if { $group == "" } {
        global argv0
        error "$argv0 called without message groupname argument"
        exit
        }
    for { set i 0 } { 1 } { incr i} {
        set text [mbx init $group] 
        if { $text != "" } break
        }
    # when our parent server is gone
    # and we have completed deliveries to remote clients
    # we exit.  If we get killed, a maximum of 1 message per
    # remote box may be lost on connections that we are trying to
    # recover.
    # if the remote connections are healthy, no messages are lost.
    variable mh_group
    variable mh_server
    dp_atclose $mh_server($mh_group) append {after idle exit}
    set commandbox __mh_gateway_RPC
    mbx whenmsg $commandbox {::dmh::mbx_RPC $mbxmsg $mbxreply}
    # tell our server about us
    dp_RDO $mh_server($mh_group) ::dmh::mhs_gateway_callback [pid] $commandbox
    # you can have a link box and an alias on the command line after the groupname
    set box_at_group [lindex $argv 1] 
    set agroup [lindex $argv 2]
    if { $box_at_group != "" } {
        mh_link $box_at_group $agroup
        }
    }


# link a mailbox so that messages written to it
# are forwarded to another group
# the fullname of the mailbox tells you where it should go
# The source group defaults to the first group we were a client of.
# This connection is usually made at startup to the parent server
# that launched us.
#
#             BILL@SFC   spc2      groupX 
proc mh_link {fullboxname group_alias {srcgroup ""}} {
    variable mh_alias 
    variable mh_status
    if { $srcgroup == "" } { set srcgroup $mh_alias() }
    set i [string last @ $fullboxname]
    if { $i <= 0 } { error "Cannot link $fullboxname - no destination group" }
    set box [string range $fullboxname 0 [expr $i-1]]
    set destgroup [string range $fullboxname [expr $i+1] end] 
    if { $group_alias != "" } {
        set destgroup $group_alias
        }\
    else { set group_alias $destgroup }
    set destbox ${box}@${destgroup}
    if { [mh_needclientconn $destgroup] == "" } {
        # try again later
        set mh_status "in retry delay on link to $destgroup"
        after 300000 "::dmh::mh_link $fullboxname $group_alias $srcgroup"
        return ""
        }
    set srcbox $fullboxname@$srcgroup
    mbx whenmsg $srcbox "::dmh::mh_forward_msg $destbox \$mbxreply \$mbxmsg $srcbox"
    return $fullboxname
    }

# forward a message
# The destbox is assumed to be @group qualified and the usual putr code
# will pick the correct server.
# The replybox may not be groupname qualified.
# If it is not, the global mh_group tells us the group it was
# received from. 
# we are assumed to already have a client connection to the destination group.
proc mh_forward_msg {destbox replybox msg srcbox} {
    variable mh_group
    if { $replybox != "" } {
        set i [string last @ $replybox]
        if { $i <= 0 } {
            append replybox @$mh_group
            }
        }
    # check to see that we still have our connection
    # if it closed, we may need to recover it
    set i [string last @ $destbox]
    set destgroup [string range $destbox [expr $i+1] end]
    set txt [mh_needclientconn $destgroup]
    if { $txt == "" } {
        # We failed to recover the client connection
        # We still service the connections that are working while
        # we attempt to recover this one
        after 300000 [list ::dmh::mh_forward_msg $destbox $replybox $msg $srcbox]
        return
        # This message has been dequeued but not delivered.
        # If this program is terminated, the message can be lost.
        }
    if { [catch {mbx putr $destbox $replybox $msg} ] } {
        # retry later
        after 300000 [list ::dmh::mh_forward_msg $destbox $replybox $msg $srcbox]
        return
        }
    # now we are ready for the next message from the original server
    # we do not use whenmsg again to rearm because if we executed 
    # from the "after" recovery clause, the original dispatch context 
    # is long gone.  
    # We do it in an after clause to let the event stack unwind
    set cmd "::dmh::mh_forward_msg $destbox \$mbxreply \$mbxmsg $srcbox"
    after 0 [list ::dmh::mbx whenmsg $srcbox $cmd]
    }
    
#
# called to ensure that a client connection exists
# this call will try once to create the connection.
# It can be a long slow try since it retries without coming back.
#
proc mh_needclientconn group {
    variable mh_alias 
    variable mh_server 
    variable mh_status
    if { [info exists mh_alias($group)] } { return $mh_alias($group) }
    set mh_status "Trying initial connect to $group"
    set rc [catch {mbx init $group} txt]
    if { $rc == 0 && $txt != "" } { ; # success
        set mh_status "Successful new connection to $group"
        set proper_group $mh_alias($group)
        dp_atclose $mh_server($proper_group) prepend "::dmh::mh_lostclientconn $proper_group"
        }\
    else { 
        set mh_status "Failed connection attempt to $group at [localtime 1]" 
        set txt {}
        }
    return $txt
    }

# lost a connection to a remote server
proc mh_lostclientconn {lostgroup} {
    variable mh_alias 
    variable mh_status
    set mh_status "cleaning up on lost connection to $lostgroup"
    foreach sub [array names mh_alias] {
        set grp $mh_alias($sub)
        if { $grp == $lostgroup } {
            unset mh_alias($sub)
            }
        }
    }
    
main $argv
if { [info exists tk_library] } {
    wm title . "[lindex $argv 0] Gateway"
    }

} ;# namespace
