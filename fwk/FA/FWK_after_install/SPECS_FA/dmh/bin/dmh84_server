#!/bin/sh
# restart using Tcl/Tk \
exec dmh84 -f "$0" "$@"

# DMH Server program
# 

set group [lindex $argv 0]
if { ![llength $group] } {
   puts {DMH Message Hub Server: $Revision: 1.1.1.1 $}
   puts "Usage: $argv0 <groupname> \[statements\]*"
   exit
   }

# if there are added command line arguments, we execute them
# this is used in some of our test suites
foreach arg [lreplace $argv 0 0] {
    if { $arg == "" } break
    eval $arg
    }


# initialize DMH
::dmh::mbx server $group


# If we are using Tk and X-windows,
#    provide the status window 
#    and provide a shutdown button
# We hide the main window when the status window is up.
# To the user, it looks like one window replaces the other.

proc dmh_server_custom_status {} {
    global argv 
    ::dmh::mh_statuswin
    set w .mh_status
    set name [lindex $argv 0]
    wm title $w "Distributed Message Hub $::dmh::mh_group ($name) - Status"
    bind $w.b.r <Destroy> "+after 1 {wm deiconify .}"
    wm withdraw .
    }

global tk_library 
if { [info exists tk_library] } {
  set varname [dmh_var dmh notk]
  if { [info exists $varname] && [set $varname] } { }\
  else {
    set name [lindex $argv 0]
    set w .mh_status
    button .b -text "DMH Server Status..." -width 25 \
  -command dmh_server_custom_status 
    pack .b -side top  -padx 8m -ipady 2m -pady 4m
    button .b2 -text "Shutdown" -command "destroy ." -width 25
    pack .b2 -side top -padx 8m -ipady 2m -pady 4m
    wm title . "$name Message Hub"
    unset name w
    dmh_server_custom_status
    }
  }

