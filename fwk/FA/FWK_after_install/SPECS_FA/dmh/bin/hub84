#!/bin/sh
# $Header: /usr/cvsroot/dmh84bin/hub84,v 1.4 2005/04/05 12:44:33 hume Exp $
# restart using wish \
exec dmh84 -msgargs "$@" -f "$0"
#
# Data hub GUI - does not assume DMH server role for hub
# 
# Notes
#   has external files hub.xbm and table.xbm in $::dmh::dmh_library
#   insert refreshes hub table list but not table data window
#
# $Log: hub84,v $
# Revision 1.4  2005/04/05 12:44:33  hume
# Updated the Copyright message.
#
# Revision 1.3  2003/03/05 00:04:51  hume
# Prevent update acknowledgement dialog from being too big.
#
# Revision 1.2  2002/11/01 22:33:59  hume
# Get rid of global varname, updated Copyright.
#
# Revision 1.1.1.1  2002/10/06 18:13:21  hume
# From previous version with ::dmh namespace and lset changes.
#
#
#
package require dmh
#
# For hub83client compatibility, import ::dmh:: commands using dmh_import.
# When we get to Tcl 8.5 (9?) we may stop importing and let
# the user execute dmh_import only if desired.
dmh_import
#
# main window - show tables and offer a menu
# 
proc hub_tabwin {{w .}} {
   if { $w != "." } {
       catch { destroy $w }
       toplevel $w
       set win $w
       }\
   else {
       # root window
       set win ""
       wm protocol $w WM_DELETE_WINDOW "hub_tabwin_close $w"
       }
   global hub_status hub_menu_help 
   # usually the group and server mailbox are already known from the command line
   # so the following is accurate
   set server [substr [execute "query server"] "= " "\}"]
   set group  [substr [execute "query group"] "= " "\}"]
   set hubhost [SQL "eval dp_hostname"]
   set name ${server}@${hubhost}:${group}
   if { [info commands mh_server_init] == "mh_server_init" } { set title "Datahub $name" }\
   else { set title "Hub $name" } ;# distinguish when not the DMH server
   wm title $w $title
   wm iconname $w $name
   if { $::tcl_platform(platform) != "windows" } {
       wm iconbitmap $w @[file_local join [set [dmh_var dmh_library]] hub.xbm]
       }
   menu $win.menu -tearoff 0 -relief flat

   set m $win.menu.file
   $win.menu add cascade -label "File" -menu $m -underline 0
   menu $m -tearoff 0
   bind $m <<MenuSelect>> {hub_twMenuSelect %W}
   #set hub_menu_help($m,0) "Tear-off this menu as a new window"
   set hub_menu_help($m,0) "Create a window for executing SQL commands"
   $m add command -label "SQL command..." -underline 0 \
       -command "dmh_cmd_win SQL $name"
   $m add command -label "Include sql file..." -underline 0 \
       -command {fileselect {} {*.sql} "Include SQL File" hub_include}
   set hub_menu_help($m,1) "Execute SQL statements from a file"
   $m add separator ;# 2
   $m add command -label "Tcl command..." -underline 0 \
       -command [list hub_cmd_win Tcl $name]
   set hub_menu_help($m,3) "Create a window for executing Tcl commands"
   $m add command -label "source tcl File..." -underline 11 \
       -command {fileselect {} {*.tcl} "Source Tcl File" hub_source}
   set hub_menu_help($m,4) "Execute Tcl statements from a file"
   $m add separator ;# 5
   $m add command -label "Refresh" -underline 0 \
       -command "hub_table_refresh $win.f.list" -accelerator F5
   set hub_menu_help($m,6) "Refresh the list of tables"
   $m add command -label "save All" -underline 5 \
       -command "hub_save \[hub_tables\]"
   set hub_menu_help($m,7) "Save all tables using default pathnames"
   $m add separator ;# 8
   $m add command -label "Exit" -underline 0 \
       -command "hub_tabwin_close $w"
   set hub_menu_help($m,9) "Terminate the program."

   set m $win.menu.tabm
   set p $win.menu.tabp
   $win.menu add cascade -label Table -menu $m -underline 0
   menu $m -tearoff 0
   bind $m <<MenuSelect>> {hub_twMenuSelect %W}
   menu $p -tearoff 0
   #set hub_menu_help($m,0) "Tear-off this menu as a new window"
   set hub_menu_help($m,0) "Display the schema of the selected table(s)"
   set hub_menu_help($m,1) "Display table data; can browse, update or delete"
   set hub_menu_help($m,2) "Display a subset of the table data"
   set hub_menu_help($m,3) "Display table subscriptions"
   set hub_menu_help($m,4) "Enter new data rows for the selected table"
   set hub_menu_help($m,5) "Display model Tcl statements for the selected table"
   set hub_menu_help($m,6) "Display model SQL statements for the selected table"
   set hub_menu_help($m,8) "Save selected tables using the default pathnames"
   set hub_menu_help($m,9) "Save the selected table using a specified pathname"
   set hub_menu_help($m,10) "Create a table using a saved file."
   set hub_menu_help($m,12) "Replace the table data using a saved file"
   set hub_menu_help($m,13) "Delete all rows leaving an empty table"
   set hub_menu_help($m,14) "Erase the table from memory"
   set hub_menu_help($m,16) "Export selected tables using default pathnames"
   set hub_menu_help($m,17) "Export the selected table using a specified pathname"
   set hub_menu_help($m,19) "Save selected table or schema data as HTML"
   foreach menu [list $m $p] {
   $menu add command -label "Schema..." -underline 0 \
       -command "hub_table_action $win.f.list schema 1 0"
   $menu add command -label "Data..." -underline 0 \
       -command "hub_table_action $win.f.list data 1 0"
   $menu add command -label "Query..." -underline 0 \
       -command "hub_table_action $win.f.list query 0 0"
   $menu add command -label "suBscriptions..." -underline 2 \
       -command "hub_table_action $win.f.list subs 1 0"
   $menu add command -label "Insert..." -underline 0 \
       -command "hub_table_action $win.f.list tbl_insert 0 0"
   $menu add command -label "Tcl templates..." -underline 0 \
       -command "hub_table_action $win.f.list tcl_templates 0 0"
   $menu add command -label "SQL temPlates..." -underline 7 \
       -command "hub_table_action $win.f.list sql_templates 0 0"
   $menu add separator ;# 7
   $menu add command -label "saVe" -underline 2 \
       -command "hub_table_action $win.f.list save 1 0"
   $menu add command -label "saveAs..." -underline 4 \
       -command "hub_table_action $win.f.list saveas 0 0"
   $menu add command -label "Load..." -underline 0 \
       -command {fileselect {} {*.tab} "Load Table File" hub_load}
   $menu add separator ;# 11 
   $menu add command -label "Replace..." -underline 0 \
       -command "hub_table_action $win.f.list replace 0 0"
   $menu add command -label "Empty..." -underline 0 \
       -command "hub_table_action $win.f.list empty 1 1"
   $menu add command -label "dRop..." -underline 1 \
       -command "hub_table_action $win.f.list drop 1 1"
   $menu add separator ;# 15
   $menu add command -label "CSV export" -underline 0 \
       -command "hub_table_action $win.f.list csvwrite 1 0"
   $menu add command -label "CSV eXportAs..." -underline 5 \
       -command "hub_table_action $win.f.list csvexportas 0 0"
   $menu add separator ;# 18
   $menu add command -label "HTML save..." -underline 0 \
       -command "hub_table_action $win.f.list gui_html 1 0"
   }

   set m $win.menu.stat_m
   $win.menu add cascade -label Status -menu $m -underline 0
   menu $m -tearoff 0
   bind $m <<MenuSelect>> {hub_twMenuSelect %W}
   $m add command -label "DMH server status..." -underline 0\
       -command hub_mh_statuswin
   #set hub_menu_help($m,0) "Tear-off this menu as a new window"
   set hub_menu_help($m,0) "Create status window for the DMH"

   $w configure -menu $win.menu
  

   frame $win.f
   pack $win.f -side top -expand yes -fill both
  
   scrollbar $win.f.scroll -relief sunken -command "$win.f.list yview"
   listbox $win.f.list -yscroll "$win.f.scroll set" -relief sunken \
       -setgrid 1 -font fixed -height 18 -width 70 -selectmode extended
   bind $win.f.list <Button-3> "tk_popup $win.menu.tabp %X %Y"
   pack $win.f.scroll -side right -fill y
   pack $win.f.list -side left -expand yes -fill both
   bind $win.f.list <Double-Button-1> "hub_table_action $win.f.list display 0 0"

   global hub_status
   set hub_status "\251 Copyright 2005 Hume Integration Software"
   label $win.status -relief sunken -justify left -textvariable hub_status -anchor w

   pack $win.status -side top -expand no -fill x -anchor w

   bind $w <F5> [list hub_table_refresh $win.f.list]

   }

proc hub_tabwin_close {w} {
    set choice [tk_dialog .rusure "Confirm Exit"\
 "This action will shutdown communication and exit.  Please confirm." \
  questhead 1 Shutdown Cancel]
    if { $choice == 0 } {
        catch { mbx end }
        exit
        }
    }

proc hub_usage {item mult {w ""}} {
    if { $mult } { set p "one or more ${item}s" }\
    else { set p "a $item" }
    tk_dialog $w.hubuse "Hub Usage" "Select $p from the list before\
 indicating this action." info 0 Dismiss
    }

proc hub_table_action {lb verb mult confirm} {
    set tables ""
    set picks [$lb curselection]
    if { !$mult } {
        set picks [lindex $picks 0] 
        }
    foreach index $picks {
        if { $index <= 1 } { return [hub_usage table $mult $lb] }
        lappend tables [lindex [$lb get $index] 0]
        }
    set len [llength $tables]
    if { $len == 0 } { return [hub_usage table $mult $lb] }
    set stuff table
    if { $len > 1 } { set stuff tables }
    if { $confirm } {
        set ttables [join [split $tables] \n]
        set pik [tk_dialog $lb.confirm "Table $verb Confirmation" \
 "Please confirm that you wish to $verb the following $stuff: $ttables"\
 questhead 1 Ok Cancel]
        if { $pik == 0 } {
            hub_$verb $tables
            }
        }\
    else {
        hub_$verb $tables
        }
    }
            

##################### PUBLIC/LEGACY PROCEDURES ##############################
#
# refresh display of tables
# this call has to be maintained for application compatibility
proc hub_table_refresh {{lb .f.list}} {
   set txt [execute "dump table"]
   $lb delete 0 end
   foreach line $txt {
        if { [string first //c $line] == 0 } return
        $lb insert end [string trim $line]
        }
   }

# non-UI procedures have been moved to $::dmh::dmh_library

######################################################################
#
# this same script is used by both the hub server and hub clients
# We may need two "file" commands
#  file - for the file system of the hub
#  file_local - for the file system of whoever is executing this script
if { [info commands file_local] != "file_local" } {
    # in the hub server, file_local, and file are the same
    if { [info commands debugger_init] != "debugger_init" } {
        rename file file_local
        interp alias {} file {} file_local
        }\
    else { ;# you are using the Tcl Pro debugger with the hub script
        interp alias {} file_local {} file
        # passing -msgargs or -tclargs command line arguments 
        # needs workarounds also, like the following: (uncomment?)
        #foreach arg $argv {SQL $argv}
        #mbx server $SQL(GROUP)
        #mbx whenmsg $SQL(SERVER) {mbx whenmsg again; gs_execute $mbxdest $mbxmsg $mbxreply}
        }
    # The hub client redefines "file" "pwd" and "glob" so that filesystem
    # logic executes at the hub
    }

# if running in foreground with Tk, create windows
global tk_library
if { [info exists tk_library] } {
    set varname [dmh_var dmh notk]
    if { [info exists $varname] && [set $varname]} { }\
    else {
        if { ![winfo exists .menu] } {
            hub_tabwin
            hub_table_refresh
            }
        }
    unset varname
    }

#
# customize menu motion events to provide menu hints
# this technique developed by Hume Integration Software, Austin, TX
# based on Tk 8.0
proc hub_twMenuSelect {menu} { 
    global hub_status hub_menu_help
    set i [$menu index active]
    # convert clone menu back to real menu
    # .#menu.#menu#file -> .menu.file
    # .xx.#xx#menu.#xx#menu#file
    set token [lindex [split $menu .] end]
    regsub -all # $token . menu
    if { [info exists hub_menu_help($menu,$i)] } {
        set hub_status $hub_menu_help($menu,$i)
        }\
    elseif { [llength $hub_status] } { set hub_status "" }
    }

proc hub_MenuSelect {lbl helpvar menu} {
    global $helpvar
    set i [$menu index active]
    # convert clone menu back to real menu
    set token [lindex [split $menu .] end]
    regsub -all # $token . menu
    if { [info exists ${helpvar}($i)] } {
        $lbl configure -text [set ${helpvar}($i)]
        }\
    else { $lbl configure -text "" }
    }


proc hub_include {pathname} {
    set reply [execute [list include $pathname]]
    set txt ""
    foreach line $reply { append txt $line\n }
    hub_table_refresh
    dmh_show_text $txt "Include $pathname Results" 
    }

proc hub_source {pathname} {
    set txt [execute [list source $pathname]]
    if { $txt == "{}" } {
        global hub_status
        set hub_status "File $pathname sourced ok." 
        return $hub_status
        }\
    else {
       dmh_show_text $txt "Source $pathname Results" 
       }
    return 
    }

proc hub_empty tablist {
    set txt ""
    foreach tab $tablist {
        append txt [SQL "delete from $tab"]\n
        }
    hub_table_refresh
    tk_dialog .result "Emptying of Table(s)" \
 "The reply was $txt" info 0 Dismiss
    }

proc hub_drop tablist {
    set txt ""
    foreach tab $tablist {
        append txt [SQL "drop table $tab"]\n
        }
    hub_table_refresh
    tk_dialog .result "Dropping of Table(s)" \
 "The reply was $txt" info 0 Dismiss
    }

proc hub_schema tablist {
    foreach tab $tablist {
        set txt ""
        set data [execute "dump schema $tab"]
        foreach line $data {
            if { [string first //c $line] == 0 } break
            append txt $line\n
            }
        dmh_show_text $txt "Schema of $tab"
        }
    }

proc hub_save tablist {
    set txt ""
    foreach tab $tablist {
        append txt [execute "write over $tab"]\n
        }
    dmh_show_text $txt "Save Results"
    }

proc hub_saveas table {
    set file [file join [pwd] $table.tab]
    fileselect $file {*.tab} "Save Table As..." "hub_dosaveas $table"
    }

#
# use default pathname to save tablelist as CSV
# just like hub_save
# when used from hubclient, export is at the hub
# use SQL eval so commands work with hubclient too
proc hub_csvwrite {tablist} {
    set txt ""
    foreach tab $tablist {
        set pathname [file join [pwd] ${tab}.csv]
        set ct [SQL [list eval hub_table_csv $tab $pathname]]
        append txt "$pathname - [format %5d $ct] data rows written\n"
        }
    dmh_show_text $txt "CSV Export Results"
    }

proc hub_csvexportas {table} {
    set file [file join [pwd] ${table}.csv]
    fileselect $file {*.csv} "Write Table Data As CSV file..." \
 [list hub_csvexport_ok $table]
    }

# use SQL eval so command works from hubclient too
proc hub_csvexport_ok {table pathname} {
    set ct [SQL [list eval hub_table_csv $table $pathname]]
    tk_dialog .result "$table CSV Export" "$ct rows written." info 0 Dismiss
    }

proc hub_load {pathname} {
    set tab [file rootname [file tail $pathname]]
    if { [hub_table_exists $tab] } {
        set pik [tk_dialog .result "Table Load" \
 "Table $tab already exists; do you want to Replace it?" questhead 1 Yes No]
        if { $pik == 0 } { hub_doreplace $tab $pathname }
        return
        }
    set txt ""
    foreach line [execute "include $pathname"] { append txt $line\n }
    hub_table_refresh
    dmh_show_text $txt "Load Results"
    }

proc hub_dosaveas {table pathname} {
    set txt [execute [list write over $table $pathname]]
    tk_dialog .result "$table SaveAs" $txt info 0 Dismiss
    }
    
proc hub_replace table {
    set file [file join [pwd] $table.tab]
    fileselect $file ${table}.tab "Replace $table" "hub_doreplace $table"
    }

proc hub_doreplace {table pathname} {
    set log ""
    if { [lindex [SQL [list eval file readable $pathname]] 0] } {
        set subs [hub_table_sub_list $table]
        foreach sub $subs {
            append log [execute "close sub [lindex $sub 1] to $table"]\n
            }
        append log [execute "drop table $table"]\n
        foreach line [execute [list include $pathname]] { append log $line\n }
        foreach sub $subs {
            append log [execute "[lindex $sub 2]"]\n
            }
        }\
    else {
        set log "File $pathname is not accessible - replace action not done"
        }
    hub_table_refresh
    dmh_show_text $log "Replace Table $table Results"
    }
    
proc hub_cmd_win {cmd server} {
    if { ($cmd == "Tcl" ) && ([info commands console] == "console") &&\
 ([info procs SQL] != "SQL" )} {
        # if we are in a process where SQL is c-code 
        # and not a hubclient where SQL is a procedure
        # and the console command exists, use it for Tcl commands
        # since that is where stdout/stderr goes
        console show ; console eval {raise .}
        return
        }
    # else unified hub/ODBC/SQL/Tcl console code
    dmh_cmd_win $cmd $server
    }


#
# table insert/update dialog
# 
proc hub_tbl_insert {table {schema ""} {data ""} {where ""} {lb ""} {index ""}} {
    if { $data == "" } {
        set dlg ins
        set Mode Insert
        set title "Table $table Data Insertion"
        set schema [hub_table_schema_list $table]
        set message "Enter your data values and press Ok."
        }\
    else {
        set title "Table $table Data Update"
        set dlg upd
        set Mode Update
        set message "Press Ok after completing your changes."
        }
    set w .hub${dlg}_${table}
    if { [winfo exists $w] } { 
        wm deiconify $w 
        raise $w 
        if { $Mode == "Update" } {
           tk_dialog $w.usage "Data Update" "You are aleady updating a row in this\
 table.  Complete this dialog first." info 0 Dismiss
           }
        return 
        }
    toplevel $w
    wm title $w $title
    wm iconname $w $Mode\n$table
    message $w.msg -text $message -width 4i 
    pack $w.msg -side top -expand 1 -fill x -padx 4m -pady 4m
    set lblwidth 12
    foreach rec $schema {
        set width [string length [lindex $rec 0]]
        if { $width > $lblwidth } { set lblwidth $width }
        }
    set i 0
    foreach rec $schema {
        vset $rec "Col type key"
        set col [string tolower $Col]
        set dwidth 12
        if { [scan $type varchar(%d) dwidth] == 1 } { 
            incr dwidth
            if { $dwidth > 80 } { set dwidth 80 }
            }\
        elseif { $type == "varchar" } { set dwidth 2 }
        frame $w.c$col 
        label $w.c$col.l -text $Col -width $lblwidth -anchor e
        entry $w.c$col.e -width $dwidth -relief sunken
        if { $dlg == "upd" } {
            set value [lindex $data $i]
            incr i
            $w.c$col.e insert 0 $value
            }
        pack $w.c$col.l $w.c$col.e -side left
        pack $w.c$col -side top -fill x -padx 1m -pady 1m
        }

    frame $w.bot
    button $w.bot.ok -text Ok -width 10 -command \
 [list hub_ins_upd_ok $w $table $schema $data $where $lb $index]
    button $w.bot.cancel -text Dismiss -command "destroy $w"
    pack $w.bot.ok $w.bot.cancel -side left -padx 10m 
    pack $w.bot -side top -fill x -pady 4m

    # if window is too tall for screen, redraw with scrollbar
    dmh_win_shrink $w
    }

#
# do the update or insert - Ok was press
#        
proc hub_ins_upd_ok {w table schema data where lb index} {
    if { $where == "" } {
        set insert 1
        }\
    else { 
        set insert 0 
        }
    set values ""
    set lbvalues ""
    set Cols ""
    foreach rec $schema {
        vset $rec "Col type key"
        set col [string tolower $Col]
        if { [string first char $type] >= 0 } { set string 1 } \
        else { set string 0 }
        set value [$w.c$col.e get]
        lappend lbvalues $value
        if { $insert && [string length $value] == 0 } continue
        if { $string } { 
            regsub -all ' $value '' value
            set value '$value'
            }
        lappend Cols $Col
        lappend values $value
        }
    if { $insert } {
        if { [llength $values] == 0 } {
            tk_dialog $w.usage "$table Insertion" "Enter data before pressing Ok,\
 or press Dismiss." info 0 Dismiss
            return
            }
        set stmt "insert into $table ([join $Cols ,]) values ([join $values ,])"
        set reply [SQL $stmt]
        if { [string first "//c 0" $reply] >= 0 } { 
            if { $lb != "" } { catch { $lb insert end $lbvalues } }
            set bitmap "info" 
            }\
        else { set bitmap "error" }
        tk_dialog $w.usage "$table Insertion" "$stmt\n\n$reply" $bitmap 0 Dismiss
        return
        }
    # update
    set nvlist ""
    set i 0
    foreach value $values {
        set Col [lindex $Cols $i]
        incr i
        lappend nvlist $Col=$value
        }
    set nvlist [join $nvlist {, }]
    set stmt "update $table set $nvlist $where"
    set reply [SQL $stmt]
    if { [string first "//c 0" $reply] >= 0 } {
        catch {
            # the data window may have been dismissed
            $lb delete $index
            $lb insert end $lbvalues
            }
        set bitmap info
        }\
    else { set bitmap error }
    set text "$stmt\n\n$reply"
    # if the message is too big, the simple dialog can be larger than the screen
    if { [string length $text] > 500 } {
        set last [string first {, } $stmt 199]
        if { $last < 0 } { set last 199 }
        set text "[string range $stmt 0 $last]\n...\n$where\n\n$reply"
        if { [string length $text] > 500 } {
            # you could have a huge where clause
            set text "update ${table}\n...\n[string range $where 0 199]....\n\n$reply"
            }
        }
    if {[catch {tk_dialog $w.usage "Data Update" $text $bitmap 0 Dismiss }]} { 
        tk_dialog .usage "Data Update" $text $bitmap 0 Dismiss 
        }
    if { $bitmap != "error" } {
        # you only update a row 1 time
        catch { destroy $w }
        }
    }

proc hub_display tablist {
    foreach table $tablist {
        set count [hub_table_count $table]
        if { $count == 0 } {
            hub_schema $table
           }\
        elseif { $count > 500 } {
            hub_query $table
            }\
        else {
            hub_data $table
            }
        }
    }

proc hub_data tablist {
    foreach table $tablist {
        .menu configure -cursor watch
        hub_data_w t [SQL "select * from $table"] 
        }
    }

proc hub_query table {
    set reply [dmh_gets "Table $table Query" \
 "This action displays a subset of the table data.

 Enter the where clause of an SQL select statement,\
 such as \"my_col='example' and my_col2>100\":" {}]
    if { [set [dmh_var dmh_gets button]] != "Ok" || ![llength $reply] } return
    .menu configure -cursor watch
    hub_data_w q [hub_query_selection "select * from $table where $reply"]
    }

proc hub_query_selection {stmt} {
    # stick the query into the selection result at offset 5
    # so we can use it for Refresh
    set reply [SQL $stmt]
    set errtxt [lindex $reply 5]
    if { $errtxt != "" } {
        tk_dialog .result "Query Error" "There was a problem\
 with your where clause expression - $errtxt" error 0 Dismiss
        set table [lindex $reply 1]
        after 1 "catch {destroy .hubq_$table}"
        }
    set reply [lreplace $reply 5 5 $stmt]
    return $reply
    }

proc hub_sql_templates table {
    dmh_show_text \n[join [hub_templates $table sql] \n\n]\n\n "SQL Statement Templates"
    } 

proc hub_tcl_templates table {
    dmh_show_text \n[join [hub_templates $table tcl] \n\n]\n\n "Tcl Statement Templates"
    }

proc hub_subs tablist {
    hub_data_w s [hub_sub_selection $tablist]
    }

# make the subscription information for a list of tables look like a 
# select result
proc hub_sub_selection tablist {
    set slist [hub_table_sub_list $tablist]
    set ct [llength $slist]
    set tab [lindex $tablist 0]
    return [list select $tab "tablename subscription open_statement"\
 "table subscription" $ct $tablist $slist]
    }

proc hub_data_w {type selection {font fixed}} {
    set table [lindex $selection 1]
    set clientdata [lindex $selection 5]
    set id hub${type}_[join [split $table { .$}] _]
    set helpvar hub_${type}_help
    global $helpvar
    set ${helpvar}(0) "Tear-off this menu as a new window"
    set w .$id
    if { [winfo exists $w] } {
        wm deiconify $w
        raise $w
        $w.menu configure -cursor watch
        hub_data_w_refresh $w $selection
        return
        }
    toplevel $w
    menu $w.menu -tearoff 0 -relief flat
    $w configure -menu $w.menu
    hub_data${type}_menu $w $table $w.f.list $w.f.head $clientdata $helpvar
    frame $w.f
    pack $w.f -side top -expand yes -fill both
    listbox $w.f.head -setgrid 1 -width 60 -height 1 -relief groove -font $font
    pack $w.f.head -side top -fill x
    scrollbar $w.f.sy -relief sunken -command "$w.f.list yview"
    listbox $w.f.list -yscroll "$w.f.sy set" -relief sunken \
      -setgrid 1 -xscroll "$w.f.sx set" -font $font -selectmode extended
    scrollbar $w.f.sx -relief sunken -command "hub_dataw_sx $w"\
       -orient horizontal
    if { $type == "t" } {
        bind $w.f.list <Double-Button-1> "hub_tabrow_upd $table $w.f.list $w.f.head"
        }
    bind  $w.f.list <Button-3> "tk_popup $w.menu.edp %X %Y"
    pack $w.f.sx -side bottom -fill x
    pack $w.f.sy -side right -fill y
    pack $w.f.list -side left -expand yes -fill both

    label $w.status -relief sunken -justify left -anchor w
    pack $w.status -side top -expand no -fill x -anchor w
    bind $w.menu.edm <<MenuSelect>> "hub_MenuSelect $w.status $helpvar %W"
    $w.menu configure -cursor watch
    hub_data_w_refresh $w $selection
    }

# data table menu
proc hub_datat_menu {w table lb lbhead na helpvar} {
    global $helpvar
    wm title $w "Table $table Data"
    wm iconname $w $table
    if { $::tcl_platform(platform) != "windows" } {
        catch { wm iconbitmap $w @[file_local join [set [dmh_var dmh_library]] table.xbm] }
        }
    set m $w.menu.edm
    $w.menu add cascade -label Edit -menu $m -underline 0
    set p $w.menu.edp
    menu $m
    menu $p -tearoff 0
    set ${helpvar}(1) "Enter new data row(s) for this table"
    set ${helpvar}(2) "Edit the selected data row"
    set ${helpvar}(3) "Delete the selected data rows"
    set ${helpvar}(5) "Refresh the list of displayed data"
    set ${helpvar}(7) "Display the Schema of table $table"
    set ${helpvar}(8) "Tcl statement templates for table $table"
    set ${helpvar}(10) "Dismiss this window"
    foreach menu [list $m $p] {
    $menu add command -label "Insert..." -underline 0 \
       -command "hub_tbl_insert $table {} {} {} $lb"
    $menu add command -label "Update..." -underline 0 \
       -command "hub_tabrow_upd $table $lb $lbhead"
    $menu add command -label "Delete..." -underline 0 \
       -command "hub_tabrow_del $table $lb $lbhead" -accelerator Delete
    $menu add separator
    $menu add command -label "Refresh" -underline 0 -accelerator F5 \
       -command "$w.menu configure -cursor watch ;\
 hub_data_w_refresh $w \[SQL \"select * from $table\"\]"
    $menu add separator
    $menu add command -label "Schema..." -underline 0 \
 -command "hub_schema $table"
    $menu add command -label "Templates..." -underline 0 \
 -command "hub_tcl_templates $table"
    $menu add separator
    $menu add separator
    $menu add command -label "Close" -underline 0 \
       -command "destroy $w"
    }
    bind $w <Delete> [list hub_tabrow_del $table $lb $lbhead]
    bind $w <F5> "$w.menu configure -cursor watch ;\
 hub_data_w_refresh $w \[SQL \"select * from $table\"\]"
    }

# Subscription table
proc hub_datas_menu {w table lb lbhead tablist helpvar} {
    global $helpvar
    if { $table == $tablist } {
        set title "Subscriptions of Table $table"
        set iconname $table\nSubscriptions
        }\
    else {
        set title "Subscriptions of Selected Tables"
        set iconname Selected\nSubscriptions
        }
    wm title $w $title
    wm iconname $w $iconname
    if { $::tcl_platform(platform) != "windows" } {
        catch { wm iconbitmap $w @[file_local join [set [dmh_var dmh_library]] table.xbm] }
        }
    set m $w.menu.edm
    $w.menu add cascade -label Edit -menu $m -underline 0
    menu $m
    set p $w.menu.edp
    menu $p -tearoff 0
    set ${helpvar}(1) "Close the selected subscriptions"
    set ${helpvar}(3) "Refresh the list of subscriptions"
    set ${helpvar}(5) "Dismiss this window"
    foreach menu [list $m $p] {
    $menu add command -label "Delete..." -underline 0 -accelerator Delete\
       -command [list hub_subrow_del $w $lb $lbhead $tablist]
    $menu add separator
    $menu add command -label "Refresh" -underline 0 -accelerator F5\
       -command "hub_data_w_refresh $w \[[list hub_sub_selection $tablist]\]"
    $menu add separator
    $menu add command -label "Close" -underline 0 \
       -command "destroy $w"
    }
    bind $w <Delete> [list hub_subrow_del $w $lb $lbhead $tablist]
    bind $w <F5> "hub_data_w_refresh $w \[[list hub_sub_selection $tablist]\]"
    }

# data subset table menu - query
proc hub_dataq_menu {w table lb lbhead stmt helpvar} {
    global $helpvar
    wm title $w "Table $table where [substr $stmt "where " ""]"
    wm iconname $w $table
    if { $::tcl_platform(platform) != "windows" } {
        catch { wm iconbitmap $w @[file_local join [set [dmh_var dmh_library]] table.xbm] }
        }
    set m $w.menu.edm
    $w.menu add cascade -label Edit -menu $m -underline 0
    menu $m
    set p $w.menu.edp
    menu $p -tearoff 0
    set ${helpvar}(1) "Enter new data row(s) for this table"
    set ${helpvar}(2) "Edit the selected data row"
    set ${helpvar}(3) "Delete the selected data rows"
    set ${helpvar}(5) "Refresh the list of displayed data"
    set ${helpvar}(7) "Dismiss this window"
    foreach m [list $m $p] {
    $m add command -label "Insert..." -underline 0 \
       -command "hub_tbl_insert $table {} {} {} $lb"
    $m add command -label "Update..." -underline 0 \
       -command "hub_tabrow_upd $table $lb $lbhead"
    $m add command -label "Delete..." -underline 0 -accelerator Delete\
       -command "hub_tabrow_del $table $lb $lbhead"
    $m add separator
    $m add command -label "Refresh" -underline 0 -accelerator F5\
       -command "$w.menu configure -cursor watch ;\
 hub_data_w_refresh $w \[[list hub_query_selection $stmt]\]"
    $m add separator
    $m add command -label "Close" -underline 0 \
       -command "destroy $w"
    }
    bind $w <Delete> [list hub_tabrow_del $table $lb $lbhead]
    bind $w <F5> "$w.menu configure -cursor watch ;\
 hub_data_w_refresh $w \[[list hub_query_selection $stmt]\]"
    }


# scroll the data and header line together
proc hub_dataw_sx {w args} {
    eval [concat $w.f.list xview $args]
    eval [concat $w.f.head xview $args]
    }

# update displayed row
# get the schema , put together a where clause
# use the column order from the header in case
# this code is being used with a non-default ordering
# arrange the data from the row in schema order
proc hub_tabrow_upd {table lb lbhead} {
    vset [hub_chosen_tabrows $table $lb $lbhead update] "schema data where index"
    if { $where == "" } return
    hub_tbl_insert $table $schema $data $where $lb $index 
    }

proc hub_tabrow_del {table lb lbhead} {
    vset [hub_chosen_tabrows $table $lb $lbhead delete] "wherelist indexlist"
    if { $wherelist == "" } return
    set confirm [tk_dialog $lb.usage "Delete Confirmation" \
 "Please confirm data deletion: \n[join $wherelist \n]" questhead 1 \
 "Confirm Deletion" Cancel]
    if { $confirm == 0 } {
        set result ""
        foreach w $wherelist {
            set reply [SQL "delete from $table $w"]
            if { [string first "//c 0" $reply] < 0 } {
                append result "$reply\n"
                }
            }
        set n [llength $indexlist]
        for {set i [expr $n-1]} {$i >= 0} {incr i -1} {
            set index [lindex $indexlist $i]
            $lb delete $index $index 
            }
        if { $result != "" } {
             dmh_show_text $result "Deletion ERROR Results"
            }
        }    
    }

proc hub_chosen_tabrows {table lb lbhead mode} {
    set ilist [$lb curselection]
    if { $mode == "update" } {
        set ilist [lindex $ilist 0]
        set mult 0
        }\
    else { set mult 1 }
    if { $ilist == "" } { 
         hub_usage "Data Row" $mult $lb
         return ""
         }
    set schema [hub_table_schema_list $table]

    set saw_key 0
    set wherelist ""
    foreach index $ilist {
        set text [$lb get $index]
        set Cols [$lbhead get 0]
        # use array to avoid name conflicts
        set i 0
        foreach Col $Cols {
            set array($Col) [lindex $text $i]
            incr i
            }
        set where_nokeys ""
        set where_keys   ""
        set data ""
        foreach rec $schema {
            vset $rec "Col type key"
            set value $array($Col)
            lappend data $value
            if { $key != "" } { set saw_key 1 }
            if { !$saw_key || $key != "" } {
                if { [string first char $type] >= 0 } { set string 1 }\
                else { set string 0 }
                if { $string } {
                    regsub -all ' $value '' kvalue
                    set kvalue '$kvalue'
                    }\
                else { set kvalue $value }
                if { $key != "" } {
                    lappend where_keys $Col=$kvalue
                    }\
                else {
                    lappend where_nokeys $Col=$kvalue
                    }
                }
            }
        if { $saw_key } {
            set where "where [join $where_keys { and }]"
            }\
        else {
            set where "where [join $where_nokeys { and }]"
            }
        if { $mode == "update" } {
            return [list $schema $data $where $index]
            }
        lappend wherelist $where
        }
    return [list $wherelist $ilist]
    }


proc hub_subrow_del {w lb lbhead tablist} {
    set slist [$lb curselection]
    set n [llength $slist]
    if { $n == 0 } { return [hub_usage Subscription 1 $w] }
    set cmdlist ""
    foreach index $slist {
        set data [$lb get $index]
        vset $data "table subname"
        set cmd "close sub $subname to $table"
        lappend cmdlist $cmd
        }
    set choice [tk_dialog $w.usage "Subscription Close Confirmation" \
 "Please confirm:\n[join $cmdlist \n]" questhead 1 "Close Subscription(s)" Cancel]
    if { $choice == 0 } {
        set result ""
        foreach cmd $cmdlist {
            append result [SQL $cmd]\n
            }
        hub_data_w_refresh $w [hub_sub_selection $tablist]
        hub_table_refresh
        dmh_show_text $result "Subscription Close Results"
        }
    }


#
# format the data nicely and display it
#
proc hub_data_w_refresh {w selection} {
    global env
    if { [info exists env(HUB_ROW_MAX)] } { set hub_row_max $env(HUB_ROW_MAX) }\
    else { set hub_row_max 1000 }
    vset $selection "x Tab Cols k ct x data"
    set lb $w.f.list
    set lbhead $w.f.head
    set menu $w.menu
    #
    set NF 60	;# scan this number of rows and do 1st draw/Update
                ;# only consider this many rows when computing Format
    set NSU 10  ;# N format scan update cycle
    set NIU 4   ;# N insert update cycle
    set n 0
    # scan the column names to get a preliminary idea of spacing based on the
    # lengths of the names
    set c 0
    foreach col $Cols {
        set width($c) [expr [string length $col]+1]
        incr c
        }
    set cmax $c
    # now, as we scan data rows, see if we should provide more space
    # for a field , allowing 2 chars for delimiters and 1 char for separation
    set n 0
    foreach row $data {
        incr n
        if { $n <= $NF } {
            for {set c 0} { $c < $cmax } {incr c} {
                set len [expr [string length [lindex $row $c]]+3]
                if { $len > $width($c) } {
                    set width($c) $len
                    }
                }
            if { ($n % $NSU) == 0 } { 
                update 
                if { ![winfo exists $lb] } return
                }
            }
        if { $n == $NF } {	;# draw first rows 
            .menu configure -cursor ""
            $menu configure -cursor ""
            set pcols [hub_format_row $Cols width 1]
            set maxwidth [string length $pcols]
            append pcols "    "	;# header scrolling correction
            $lbhead delete 0 end
            $lb delete 0 end
            $lbhead insert end $pcols
            set n 0
            foreach row $data {
                incr n
                if { $n == 1 } { set padlast 1 } else {set padlast 0}
                set prow [hub_format_row $row width $padlast]
                $lb insert end $prow
                if { ($n % $NIU ) == 0 } {
                    update
                    if { ![winfo exists $lb] } return
                    }
                if { $n == $NF } break
                }
            }
        if { $n <= $NF } continue
        set prow [hub_format_row $row width 0]
        set plen [string length $prow]
        if { $plen > $maxwidth } {	;# header scrolling correction
            append pcols [format "%*s" [expr 4 + $plen - $maxwidth] ""]
            $lbhead delete 0 end
            $lbhead insert end $pcols
            set maxwidth $plen
            }
        $lb insert end $prow
        if { $n == $hub_row_max } {
            $lb insert end "==== Only First $hub_row_max rows shown (can set HUB_ROW_MAX in environment) ===="
            return
            }
        if { ($n % $NIU ) == 0 } {
            update
            if { ![winfo exists $lb] } return
            }
        }
    # draw the rows that have not been drawn
    if { $n < $NF } {
        .menu configure -cursor ""
        $menu configure -cursor ""
        set pcols [hub_format_row $Cols width 1]
        append pcols "    "	;# header scrolling correction
        $lbhead delete 0 end
        $lbhead insert end $pcols
        $lb delete 0 end
        set n 0
        foreach row $data {
            incr n
            if { $n == 1 } { set padlast 1 } else {set padlast 0}
            set prow [hub_format_row $row width $padlast]
            $lb insert end $prow
            if { ($n % $NIU ) == 0 } {
                update
                if { ![winfo exists $lb] } return
                }
            }
        }
    }

# return a formatted row where the item widths track the widths
# specified in the width array
proc hub_format_row {row wvar wantlast} {
    upvar $wvar width
    set c 0
    set cmax [expr [llength $row]-1]
    set result ""
    set speclen 0
    foreach v $row {
        append result [list $v]
        if { $c == $cmax && !$wantlast } break
        incr speclen $width($c)
        set actlen [string len $result]
        if { $actlen < $speclen } {
            append result [format "%*s" [expr $speclen - $actlen] ""]
            }\
        else { append result " " }
        incr c
        }
     return $result
    }
    
   
proc hub_mh_statuswin {} {
    set groupvar [dmh_var mh_group]
    if { ![info exists $groupvar] } {
        tk_dialog .usage "DMH Status" \
 "Message communication has not been initialized." info 0 Dismiss
        return
        }
    mh_statuswin
    }
