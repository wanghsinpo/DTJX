 Algpanel_launch:SUB Algpanel_launch(Session$,Port$,Project$,Hostname$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : ALGPANEL_LAUNCH
  !  Vers : 1
  !  Desc : Execute Algorithm Panel.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -        Session ID
  !      2 Port            S    -        Port ID
  !      3 Project         S    -        Project ID
  !      4 Hostname        S    -        Hostname
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Buf$(32)[256]
   INTEGER Nopt
  !
   Nopt=0
  !
   Nopt=Nopt+1
   Buf$(Nopt)="-O"
   Nopt=Nopt+1
   Buf$(Nopt)="-c"&Port$
   Nopt=Nopt+1
   Buf$(Nopt)="-g"&Session$
   Nopt=Nopt+1
   Buf$(Nopt)="-j"&Project$
  !
   Ap_init(Buf$(*),Nopt)
  !
 SUBEND
 Algpanel_start:SUB Algpanel_start(INTEGER Mode)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : ALGPANEL_START
  !  Vers : 1
  !  Desc : Popdup Algorithm Panel.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Mode            I    -        0:Normal, 1:Disable problibs
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Ap_popup(Mode)
  !
 SUBEND
 Algpanel_stop:SUB Algpanel_stop
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : ALGPANEL_STOP
  !  Vers : 1
  !  Desc : Popdown Algorithm Panel.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Ap_popdown
  !
 SUBEND
 Apply_fwkconf:SUB Apply_fwkconf(File$,INTEGER Type,Errno,Errmsg$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : APPLY_FWKCONF
  !  Vers : 1
  !  Desc : Read configuration parameter and apply them.
  !       :   SPECS2.5: Added special parameters.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 File            S    -
  !      2 Type            I    -        0:All vars, 1:Normal vars only,
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Errno           I    -
  !      2 Errmsg          S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Line$[8196],Symbol$[8196],Value$[8196],Token$[8196],Name$[32],Src$[8196]
   INTEGER P_col,P_exc,P_comma                      !":", "!" and ","
   INTEGER Idx_tag,Idx_dim1,Typ,Dim,Size1,Size2,Length
   Errno=0
   Errmsg$=""
   ON ERROR GOTO Err
   ASSIGN @Fwkconf TO File$;FORMAT ON
   ON END @Fwkconf GOTO Endoffile
   LOOP
     Symbol$=""
     Value$=""
  !
     ENTER @Fwkconf;Line$
     Line$=TRIM$(Line$)
     P_exc=POS(Line$,"!")
     SELECT P_exc
     CASE 0
     CASE 1
       Line$=""
     CASE ELSE
       Line$=Line$[1,P_exc-1]
     END SELECT
  !
     P_col=POS(Line$,":")
     IF P_col>=2 THEN 
       Symbol$=Line$[1,P_col-1]
       Symbol$=TRIM$(Symbol$)
       IF Symbol$<>"" AND LEN(Line$)>P_col THEN 
         Value$=Line$[P_col+1,LEN(Line$)]
         Value$=TRIM$(Value$)
       END IF
     END IF
  !
     IF Symbol$<>"" AND Value$<>"" THEN 
       IF Symbol$[1,1]="*" THEN 
         IF Type=1 THEN Loop_next
         Src$=Symbol$[2,LEN(Symbol$)]
       ELSE
         IF Type=2 THEN Loop_next
         Src$=Symbol$
       END IF
  !
       Tpltagindex("SYSTEM",Src$,Idx_tag)
       IF Idx_tag=-1 THEN 
         Errno=1
         Errmsg$=Src$&" is not defined as TAG variable"
         GOTO Endoffile
       END IF
       Tpltaginfo("SYSTEM",Idx_tag,Name$,Typ,Dim,Size1,Size2)
       SELECT Dim
       CASE 0
         SELECT Typ
         CASE 0
           Tplputrtag("SYSTEM",Idx_tag,0,VAL(Value$))
         CASE 1
           Tplputitag("SYSTEM",Idx_tag,0,INT(VAL(Value$)))
         CASE 2
           IF LEN(Value$)>0 THEN 
             Tplputctag("SYSTEM",Idx_tag,0,Value$[1,1])
           END IF
         CASE 3
           Tplputstag("SYSTEM",Idx_tag,0,Value$)
         END SELECT
       CASE 1
         SELECT Typ
         CASE 0
           ALLOCATE REAL Ra(Size1)
         CASE 1
           ALLOCATE INTEGER Ia(Size1)
         CASE 2
           ALLOCATE Ca$(Size1)[1]
         CASE 3
           ALLOCATE Sa$(Size1)[255]
         END SELECT
  !
         Idx_dim1=1
         LOOP
           P_comma=POS(Value$,",")
           SELECT P_comma
           CASE 0
             Token$=Value$
           CASE 1
             Token$=""
           CASE ELSE
             Token$=Value$[1,P_comma-1]
           END SELECT
           Token$=TRIM$(Token$)
  !
           SELECT Typ
           CASE 0
             Ra(Idx_dim1)=VAL(Token$)
           CASE 1
             Ia(Idx_dim1)=INT(VAL(Token$))
           CASE 2
             IF LEN(Token$)>0 THEN 
               Ca$(Idx_dim1)=Token$[1,1]
             ELSE
               Ca$(Idx_dim1)=" "
             END IF
           CASE 3
             Sa$(Idx_dim1)=Token$
           END SELECT
  !
           Length=LEN(Value$)
         EXIT IF P_comma=0 OR Length=P_comma
  !
           Value$=Value$[P_comma+1,Length]
           Idx_dim1=Idx_dim1+1
         END LOOP
  !
         SELECT Typ
         CASE 0
           Tplputratag("SYSTEM",Idx_tag,0,Ra(*))
           DEALLOCATE Ra(*)
         CASE 1
           Tplputiatag("SYSTEM",Idx_tag,0,Ia(*))
           DEALLOCATE Ia(*)
         CASE 2
           Tplputcatag("SYSTEM",Idx_tag,0,Ca$(*))
           DEALLOCATE Ca$(*)
         CASE 3
           Tplputsatag("SYSTEM",Idx_tag,0,Sa$(*))
           DEALLOCATE Sa$(*)
         END SELECT
       CASE 2
         SELECT Typ
         CASE 0
           ALLOCATE REAL Ra2(Size2,Size1)
         CASE 1
           ALLOCATE INTEGER Ia2(Size2,Size1)
         CASE 2
           ALLOCATE Ca2$(Size2,Size1)[1]
         CASE 3
           ALLOCATE Sa2$(Size2,Size1)[255]
         END SELECT
  !
         Idx_dim1=1
         FOR J=1 TO Size2
           FOR K=1 TO Size1
             P_comma=POS(Value$,",")
             SELECT P_comma
             CASE 0
               Token$=Value$
             CASE 1
               Token$=""
             CASE ELSE
               Token$=Value$[1,P_comma-1]
             END SELECT
             Token$=TRIM$(Token$)
  !
             SELECT Typ
             CASE 0
               Ra2(J,K)=VAL(Token$)
             CASE 1
               Ia2(J,K)=INT(VAL(Token$))
             CASE 2
               IF LEN(Token$)>0 THEN 
                 Ca2$(J,K)=Token$[1,1]
               ELSE
                 Ca2$(J,K)=" "
               END IF
             CASE 3
               Sa2$(J,K)=Token$
             END SELECT
  !
             Length=LEN(Value$)
             Value$=Value$[P_comma+1,Length]
             Idx_dim1=Idx_dim1+1
           NEXT K
         NEXT J
  !
         SELECT Typ
         CASE 0
           Tplputratag("SYSTEM",Idx_tag,0,Ra2(*))
           DEALLOCATE Ra2(*)
         CASE 1
           Tplputiatag("SYSTEM",Idx_tag,0,Ia2(*))
           DEALLOCATE Ia2(*)
         CASE 2
           Tplputcatag("SYSTEM",Idx_tag,0,Ca2$(*))
           DEALLOCATE Ca2$(*)
         CASE 3
           Tplputsatag("SYSTEM",Idx_tag,0,Sa2$(*))
           DEALLOCATE Sa2$(*)
         END SELECT
       END SELECT
     END IF
 Loop_next: !
   END LOOP
 Endoffile:                                  !
   ASSIGN @Fwkconf TO *
   SUBEXIT
 Err:                                  !
   ASSIGN @Fwkconf TO *
   Errno=ERRN
   Errmsg$=ERRM$
 SUBEND
 Array_lookup1:SUB Array_lookup1(Src$(*),Pat$,INTEGER Pos)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : ARRAY_LOOKUP1
  !  Vers : 1
  !  Desc : Returns the array index for a specified data element of a
  !       :  STRING array.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Src             S    256      Source strings
  !      2 Pat             S    -        Pattern string
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Pos             I    -        Position (>0 position, 0 not fou
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER S,P
   S=SIZE(Src$,1)
   MAT SEARCH Src$(*),LOC(Pat$);P
   IF P>S THEN 
     Pos=0
   ELSE
     Pos=P
   END IF
 SUBEND
 Array_lookup2:SUB Array_lookup2(Src$(*),Pat$(*),INTEGER Pos(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : ARRAY_LOOKUP2
  !  Vers : 1
  !  Desc : Returns the array indices for the specified data elements
  !       :  of a STRING array.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Src             S    256      Source strings
  !      2 Pat             S    256      Pattern strings
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Pos             I    256      Positions of each pattern string
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER S1,S2,P
   S1=SIZE(Src$,1)
   S2=SIZE(Pat$,1)
   FOR I=1 TO S2
     MAT SEARCH Src$(*),LOC(Pat$(I));P
     IF P>S2 THEN 
       Pos(I)=0
     ELSE
       Pos(I)=P
     END IF
   NEXT I
 SUBEND
 Array_lookup3:SUB Array_lookup3(Src$(*),INTEGER Pos(*),Sub$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : ARRAY_LOOKUP3
  !  Vers : 1
  !  Desc : Returns the data elements for the specified indices of a
  !       : STRING array
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Src             S    256      Source strings
  !      2 Pos             I    256      Positions of strings to extract
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Sub             S    256      Extracted strings
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER S1,S2
   S1=SIZE(Src$,1)
   S2=SIZE(Pos,1)
   FOR I=1 TO S2
     IF Pos(I)>=1 AND Pos(I)<=S1 THEN 
       Sub$(I)=Src$(Pos(I))
     ELSE
       Sub$(I)=""
     END IF
   NEXT I
 SUBEND
 Attrib_file:SUB Attrib_file(Filename$,Permission$,Owner$,Group$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : ATTRIB_FILE
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Filename        S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Permission      S    -
  !      2 Owner           S    -
  !      3 Group           S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Mode
  !
   ON ERROR GOTO Err
   ASSIGN @Pipe TO "ls -l -d "&Filename$&" 2>/dev/null | awk '{printf(""%s\n%s\n%s"", $1, $3, $4); }' |"
   ON END @Pipe GOTO Nofile
  !
   ENTER @Pipe;Attrib$
   Mode=0
   IF Attrib$[2,2]="r" THEN Mode=Mode+400
   IF Attrib$[3,3]="w" THEN Mode=Mode+200
   IF Attrib$[4,4]="x" THEN Mode=Mode+100
   IF Attrib$[4,4]="s" THEN Mode=Mode+4100
   IF Attrib$[4,4]="S" THEN Mode=Mode+4000
   IF Attrib$[5,5]="r" THEN Mode=Mode+40
   IF Attrib$[6,6]="w" THEN Mode=Mode+20
   IF Attrib$[7,7]="x" THEN Mode=Mode+10
   IF Attrib$[7,7]="s" THEN Mode=Mode+2010
   IF Attrib$[7,7]="S" THEN Mode=Mode+2000
   IF Attrib$[8,8]="r" THEN Mode=Mode+4
   IF Attrib$[9,9]="w" THEN Mode=Mode+2
   IF Attrib$[10,10]="x" THEN Mode=Mode+1
   IF Attrib$[10,10]="t" THEN Mode=Mode+1001
   Permission$=VAL$(Mode)
  !
   ENTER @Pipe;Owner$
   ENTER @Pipe;Group$
  !
   OFF END @Pipe
   OFF ERROR 
   SUBEXIT
  !
 Nofile: !
   PRINT "ATTRIB_FILE ERROR: "&Filename$&" is not accessible."
   OFF END @Pipe
   OFF ERROR 
   SUBEXIT
  !
 Err: !
   PRINT "ATTRIB_FILE ERROR: "&ERRM$
   OFF END @Pipe
   OFF ERROR 
 SUBEND
 Beep:SUB Beep(REAL Freq,Dur)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : BEEP
  !  Vers : 1
  !  Desc : Specifies frquency and duration for the beep, and sounds
  !       : the beep
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Freq            R    -        Frequency
  !      2 Dur             R    -        Duration
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   BEEP Freq,Dur
 SUBEND
 Call_errhandler:SUB Call_errhandler(Errorno$,Message$,Moreinfo$,INTEGER Status,Errmsg$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : CALL_ERRHANDLER
  !  Vers : 1
  !  Desc : Error Handler.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 ErrorNo         S    -        ErrorCode  .ex  "12-34567"
  !      2 Message         S    -        Error Message
  !      3 MoreInfo        S    -        More Info
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0: OK, -1: Exec Err, -2: No File
  !      2 Errmsg          S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Eflag$[1024],Ecommand$[1024],Oplang$[1024]
   DIM Cmd$[1024],Line$[256]
   DIM Cl$[3072]
   DIM Ver$[20]
   INTEGER St,I,Cmd_ret
   DIM Tmpfile$[256],Logfile$[256]
   DIM Messagefile$[256],Fmessage$[3072]
   DIM Tmperrorno$[1024],Tmpmessage$[1024],Tmpmoreinfo$[1024]
   DIM Tmpstrmp$[3072]
  !
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")
   Logfile$="/var/opt/SPECS/log/syslog"
   Status=0
   Ndetail=0
   FOR I=1 TO 10
     Detail$(I)=""
   NEXT I
   Cmd_ret=0
  !
   Cmd$="/usr/bin/grep -Ee '^[ \t]*"&"ERR_HANDLER"&"[ \t]*=' /opt/SPECS/sys/config/sysconf"
   Cmd$=Cmd$&"| /usr/bin/awk -F '=' '{val=$2;gsub(""^[ \t]*"","""",val);gsub(""[ \t]*$"","""",val); print val;}'"
   ON ERROR GOTO No_error
   ASSIGN @Pipe TO Cmd$&" |"
   OFF ERROR 
   ON END @Pipe GOTO Pipeeof
   ENTER @Pipe;Eflag$
   OFF END @Pipe
   ASSIGN @Pipe TO *
  !
   IF UPC$(Eflag$)="TRUE" THEN 
     Cmd$="/usr/bin/grep -Ee '^[ \t]*"&"ERR_HANDLER_SCRIPT"&"[ \t]*=' /opt/SPECS/sys/config/sysconf"
     Cmd$=Cmd$&"| /usr/bin/awk -F '=' '{val=$2;gsub(""^[ \t]*"","""",val);gsub(""[ \t]*$"","""",val); print val;}'"
     ON ERROR GOTO No_exec
     ASSIGN @Pipe TO Cmd$&" |"
     OFF ERROR 
     ON END @Pipe GOTO Pipeeof
     ENTER @Pipe;Ecommand$
     OFF END @Pipe
     ASSIGN @Pipe TO *
  !
     IF Ecommand$="" THEN 
       GOTO No_exec
     END IF
  !
     Oplang$="C"
  !    Cmd$="/usr/bin/grep -Ee '^[ \t]*"&"OP_LANG"&"[ \t]*=' /opt/SPECS/sys/config/sysconf"
  !    Cmd$=Cmd$&"| /usr/bin/awk -F '=' '{val=$2;gsub(""^[ \t]*"","""",val);gsub(""[ \t]*$"","""",val); print val;}'"
  !    ON ERROR GOTO No_exec
  !    ASSIGN @Pipe TO Cmd$&" |"
  !    OFF ERROR
  !    ON END @Pipe GOTO Pipeeof
  !    ENTER @Pipe;OpLang$
  !    OFF END @Pipe
  !    ASSIGN @Pipe TO *
  !
     IF Errorno$[1,1]="$" THEN 
       Messagefile$="/opt/SPECS/usr/fwk/HPSTD_"&Message$&"~/"&Oplang$&"/"&Errorno$[2]
       ON ERROR GOTO Std_arg_point
       ASSIGN @F TO Messagefile$
       OFF ERROR 
       ON END @F GOTO File_readend
       ENTER @F;Fmessage$
       OFF END @F
       ASSIGN @F TO *
 File_readend:        !
       I=POS(Fmessage$,CHR$(10))
       IF I<1 THEN 
         Tmperrorno$=Fmessage$
         Tmpmessage$=""
       ELSE
         Tmperrorno$=Fmessage$[1,I-1]
         Tmpmessage$=Fmessage$[I+1]
       END IF
       GOTO File_arg_point
     END IF
  !
 Std_arg_point:        !
     Tmperrorno$=Errorno$
     Tmpmessage$=Message$
  !
 File_arg_point:       !
     Tmperrorno$=TRIM$(Tmperrorno$)
     Tmpmessage$=TRIM$(Tmpmessage$)
     Tmpmoreinfo$=TRIM$(Moreinfo$)
     I=POS(Tmperrorno$," ")
     REPEAT
       IF I<1 THEN 
         GOTO Mes_cutenda
       ELSE
         Tmpstrmp$=Tmperrorno$[1;I-1]
         Tmperrorno$=Tmpstrmp$&"\ "&Tmperrorno$[I+1]
       END IF
       J=POS(Tmperrorno$[I+2]," ")
       I=J+I+2-1
     UNTIL J<1
 Mes_cutenda:        !
     I=POS(Tmpmessage$," ")
     REPEAT
       IF I<1 THEN 
         GOTO Mes_cutendb
       ELSE
         Tmpstrmp$=Tmpmessage$[1;I-1]
         Tmpmessage$=Tmpstrmp$&"\ "&Tmpmessage$[I+1]
       END IF
       J=POS(Tmpmessage$[I+2]," ")
       I=J+I+2-1
     UNTIL J<1
 Mes_cutendb:        !
     I=POS(Tmpmessage$,CHR$(10))
     REPEAT
       IF I<1 THEN 
         GOTO Mes_cutendc
       ELSE
         Tmpstrmp$=Tmpmessage$[1;I-1]
         Tmpmessage$=Tmpstrmp$&"\\n"&Tmpmessage$[I+1]
       END IF
       J=POS(Tmpmessage$[I+3],CHR$(10))
       I=J+I+3-1
     UNTIL J<1
 Mes_cutendc:        !
     I=POS(Tmpmoreinfo$," ")
     REPEAT
       IF I<1 THEN 
         GOTO Mes_cutendd
       ELSE
         Tmpstrmp$=Tmpmoreinfo$[1;I-1]
         Tmpmoreinfo$=Tmpstrmp$&"\ "&Tmpmoreinfo$[I+1]
       END IF
       J=POS(Tmpmoreinfo$[I+2]," ")
       I=J+I+2-1
     UNTIL J<1
 Mes_cutendd:        !
     I=POS(Tmpmoreinfo$,CHR$(10))
     REPEAT
       IF I<1 THEN 
         GOTO Mes_cutende
       ELSE
         Tmpstrmp$=Tmpmoreinfo$[1;I-1]
         Tmpmoreinfo$=Tmpstrmp$&"\\n"&Tmpmoreinfo$[I+1]
       END IF
       J=POS(Tmpmoreinfo$[I+3],CHR$(10))
       I=J+I+3-1
     UNTIL J<1
 Mes_cutende:        !
     Cl$=Ecommand$&" "&Tmperrorno$&" "&Tmpmessage$&" "&Tmpmoreinfo$
  !
     CREATE Tmpfile$,1
     ASSIGN @Tmp TO Tmpfile$;FORMAT ON
     OUTPUT @Tmp;DATE$(TIMEDATE)&" "&TIME$(TIMEDATE)&": CALL_ERRHANDLER algorithm utility."
     OUTPUT @Tmp;" Start      : Error Handler."
     OUTPUT @Tmp;" Command    : "&Ecommand$
     OUTPUT @Tmp;"---------------"
     OUTPUT @Tmp;" ERROR CODE : "&Tmperrorno$
     OUTPUT @Tmp;Tmpmessage$
     OUTPUT @Tmp;"---------------"
     OUTPUT @Tmp;""
     EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
     ASSIGN @Tmp TO *
     PURGE Tmpfile$
  !
     ON ERROR GOTO Commanderror
     EXECUTE Cl$;RETURN St
     OFF ERROR 
  !
     Cmd_ret=SHIFT(St,8) MOD 256
     IF Cmd_ret>=128 THEN Cmd_ret=Cmd_ret-256
  !
     Errmsg$="exit("&VAL$(Cmd_ret)&")"
     Status=Cmd_ret
  !
     SUBEXIT
 Commanderror:        !
     Errmsg$="exec() Error"
     Status=-1
     SUBEXIT
   ELSE
     Status=0
     SUBEXIT
   END IF
  !
 Pipeeof:        !
   OFF END @Pipe
   ASSIGN @Pipe TO *
 No_exec:        !
   Errmsg$="Command is """"."
   Status=-2
   SUBEXIT
 No_error:        !
   Status=0
   SUBEXIT
  !
 SUBEND
 Check_datafile:SUB Check_datafile(Filename$,INTEGER Valid)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : CHECK_DATAFILE
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Filename        S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Valid           I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER I,Length
  !
   Valid=1
   Length=LEN(Filename$)
  !
   FOR I=1 TO Length
     IF Filename$[I,I]=" " THEN 
       Valid=0
       I=Length
     END IF
   NEXT I
  !
 SUBEND
 Check_file:SUB Check_file(Testplan$,Limit$,INTEGER Result)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : CHECK_FILE
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Testplan        S    -
  !      2 Limit           S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Result          I    -        0: OK 1: File Mismatch: 2: Revis
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tplattr$[32]
   DIM Tplnam$[1024],Tplver$[128]
   DIM Limnam$[1024],Limver$[128]
   DIM Limtplnam$[1024],Limtplver$[128]
   DIM Spcnam$[1024],Spcver$[128],Spctyp$[32]
   DIM Buffer$[1024]
   INTEGER Verifylimit,Revcont
   INTEGER Tplnum,Limnum,Length,I
  !
   Result=0
   Tplattr$="/opt/SPECS/sys/bin/tplattr"    ! AVPATH_
  !
   ON ERROR GOTO Nofile
   ASSIGN @Pipe TO "grep -c -x VERIFYLIMIT=FALSE /opt/SPECS/sys/config/sysconf 2>/dev/null |"    ! AVPATH_
   OFF ERROR 
   ON END @Pipe GOTO Eof
   ON ERROR GOTO Overflow
   ENTER @Pipe;Buffer$
   IF VAL(Buffer$)>0 THEN 
     Verifylimit=0
   ELSE
     Verifylimit=1
   END IF
   Tplgetrevcont(Revcont)
  !
   Length=LEN(Testplan$)
   IF Length>3 THEN 
     IF Testplan$[Length-3;Length]=".tpl" THEN 
       Testplan$=Testplan$[1;Length-4]
     END IF
   END IF
   Length=LEN(Limit$)
   IF Length>3 THEN 
     IF Limit$[Length-3;Length]=".lim" THEN 
       Limit$=Limit$[1;Length-4]
     END IF
   END IF
  !
   IF NOT LEN(Testplan$) THEN 
     Tplfiletpl(Tplnam$,Tplver$,Tplnum)
     IF NOT LEN(Tplnam$) THEN 
       GOTO Nofile
     END IF
     Tplnam$=Tplnam$&".tpl"
     IF Tplver$="1" THEN 
       Tplver$=""
     END IF
   ELSE
     Tplnam$=Testplan$&".tpl"
     ON ERROR GOTO Nofile
     ASSIGN @Pipe TO Tplattr$&" -a Vers -t tpl "&Testplan$&" 2>/dev/null |"
     OFF ERROR 
     ON END @Pipe GOTO Eof
     ON ERROR GOTO Overflow
     ENTER @Pipe;Buffer$
     Length=LEN(Buffer$)
     Tplver$=Buffer$[7;Length]
     ASSIGN @Pipe TO *
   END IF
  !
   IF NOT LEN(Limit$) THEN 
     Limver$=" "
     Limtplnam$=Tplnam$
     Limtplver$=Tplver$
   ELSE
     Limnam$=Limit$&".lim"
     ON ERROR GOTO Nofile
     ASSIGN @Pipe TO Tplattr$&" -a Vers -t lim "&Limit$&" 2>/dev/null |"
     OFF ERROR 
     ON END @Pipe GOTO Eof
     ON ERROR GOTO Overflow
     ENTER @Pipe;Buffer$
     Length=LEN(Buffer$)
     Limver$=Buffer$[7;Length]
     ASSIGN @Pipe TO *
  !
     ON ERROR GOTO Nofile
     ASSIGN @Pipe TO Tplattr$&" -a TplName -t lim "&Limit$&" 2>/dev/null |"
     OFF ERROR 
     ON END @Pipe GOTO Eof
     ON ERROR GOTO Overflow
     ENTER @Pipe;Buffer$
     Length=LEN(Buffer$)
     Limtplnam$=Buffer$[10;Length]
     ASSIGN @Pipe TO *
  !
     ON ERROR GOTO Nofile
     ASSIGN @Pipe TO Tplattr$&" -a TplVers -t lim "&Limit$&" 2>/dev/null |"
     OFF ERROR 
     ON END @Pipe GOTO Eof
     ON ERROR GOTO Overflow
     ENTER @Pipe;Buffer$
     Length=LEN(Buffer$)
     Limtplver$=Buffer$[10;Length]
     ASSIGN @Pipe TO *
   END IF
  !
   IF (Verifylimit=1) AND (Tplnam$<>Limtplnam$) THEN 
     GOTO Tpl_err
   END IF
   IF (Verifylimit=1) AND (Tplver$<>Limtplver$) THEN 
     GOTO Ver_err
   END IF
   IF (Revcont=1) AND (NOT LEN(Tplver$)) THEN 
     IF NOT LEN(Testplan$) THEN 
       FOR I=0 TO Tplnum
         Tplfilespctpl(I,Spcnam$,Spctyp$,Spcver$)
         IF Spcver$="1" THEN 
           GOTO Norev_tpl
         END IF
       NEXT I
     ELSE
       ON ERROR GOTO Nofile
       ASSIGN @Pipe TO Tplattr$&" -A -a Vers -t tpl "&Testplan$&" 2>/dev/null | grep -c -x \$Vers. |"
       OFF ERROR 
       ON END @Pipe GOTO Eof
       ON ERROR GOTO Overflow
       ENTER @Pipe;Buffer$
       IF VAL(Buffer$)>0 THEN 
         GOTO Norev_tpl
       END IF
     END IF
   END IF
   IF (Revcont=1) AND (NOT LEN(Limver$)) THEN 
     GOTO Norev_lim
   END IF
  !
 No_err: !
   Result=0
   SUBEXIT
 Nofile: !
   Result=-1
   SUBEXIT
 Eof: !
   Result=-1
   SUBEXIT
 Overflow: !
   Result=-1
   SUBEXIT
 Tpl_err: !
   Result=1
   SUBEXIT
 Ver_err: !
   Result=2
   SUBEXIT
 Norev_tpl: !
   Result=3
   SUBEXIT
 Norev_lim: !
   Result=4
   SUBEXIT
 SUBEND
 Check_passwd:SUB Check_passwd(Name$,Command$,INTEGER Result)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : CHECK_PASSWD
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Name            S    -
  !      2 Command         S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Result          I    -        0: Fail 1: OK
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Cmd$[256],Ok$[3]
  !
   Result=0
   Ok$=""
  !
   Tmpfile$="/var/tmp/PASSWD"&SYSTEM$("PROCESS ID")         ! AVPATH_
   ON ERROR GOTO Nofile
   PURGE Tmpfile$
   GOTO Exec_su
 Nofile: !
   IF ERRN<>56 THEN                          ! File name is undefined
     SUBEXIT
   END IF
  !
 Exec_su: !
   ON ERROR GOTO Err
   IF Command$="" THEN 
     Cmd$="/usr/dt/bin/dtterm -e su "&Name$&" -c 'echo OK >"&Tmpfile$&"'"
   ELSE
     Cmd$="/usr/dt/bin/dtterm -e su "&Name$&" -c '"&Command$&"&& echo OK >"&Tmpfile$&"'"
   END IF
   EXECUTE Cmd$
   ASSIGN @File TO Tmpfile$
   ON END @File GOTO Eof
   ENTER @File;Ok$
 Eof: !
   OFF END @File
   ASSIGN @File TO *
   IF Ok$[1,2]="OK" THEN 
     Result=1
   END IF
   PURGE Tmpfile$
 Err: !
   OFF ERROR 
 SUBEND
 Check_prober:SUB Check_prober(Symbol$,Vendor$,Model$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : CHECK_PROBER
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Symbol          S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Vendor          S    -
  !      2 Model           S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   SELECT Symbol$
   CASE "TELP8"
     Vendor$="Tokyo Electron"
     Model$="P-8"
   CASE "TSK90A"
     Vendor$="Tokyo Seimitsu"
     Model$="A-PM-90A/UF200"
   CASE "EG4080"
     Vendor$="Electroglas"
     Model$="4080/4090"
   END SELECT
 SUBEND
 Check_profile:SUB Check_profile(INTEGER Result)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : CHECK_PROFILE
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Result          I    -        0:OK 1:TPL: 2:FWK: 3:MLIB: 4:TLI
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Nam$[1024],Ver$[128],Typ$[32]
   INTEGER Revcont,Num
   INTEGER Length,I,J,Libc
  !
   ON ERROR GOTO Nofile
   Result=0
   Tplgetrevcont(Revcont)
  !
   Tplfiletpl(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_tpl
       FOR I=0 TO Num-1
         Tplfilespctpl(I,Nam$,Typ$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_tpl
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfilefwk(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_fwk
       FOR I=0 TO Num-1
         Tplfilespcfwk(I,Nam$,Typ$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_fwk
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfilenummlib(Libc)
   FOR J=0 TO Libc-1
     Tplfilemlibm(J,Nam$,Ver$,Num)
     IF LEN(Nam$) THEN 
       IF Ver$="1" THEN 
         IF Num=0 THEN GOTO Norev_mlib
         FOR I=0 TO Num-1
           Tplfilespcmlibm(J,I,Nam$,Ver$)
           IF Ver$="1" THEN 
             GOTO Norev_mlib
           END IF
         NEXT I
       END IF
     END IF
   NEXT J
  !
   Tplfiletlib(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_tlib
       FOR I=0 TO Num-1
         Tplfilespctlib(I,Nam$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_tlib
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfileplib(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_plib
       FOR I=0 TO Num-1
         Tplfilespcplib(I,Nam$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_plib
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfileulib(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_ulib
       FOR I=0 TO Num-1
         Tplfilespculib(I,Nam$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_ulib
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfilelim2(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" OR Ver$="" THEN 
       IF Num=0 THEN GOTO Norev_lim
       FOR I=0 TO Num-1
         Tplfilespclim(I,Nam$,Ver$)
         IF Ver$="" THEN 
           GOTO Norev_lim
         END IF
       NEXT I
     END IF
   END IF
  !
   Tplfilenumtco(Num)
   FOR I=0 TO Num-1
     Tplfiletco(I,Nam$,Ver$)
     IF Ver$="1" THEN 
       GOTO Norev_tco
     END IF
   NEXT I
  !
   Tplfiledlib(Nam$,Ver$,Num)
   IF LEN(Nam$) THEN 
     IF Ver$="1" THEN 
       IF Num=0 THEN GOTO Norev_dlib
       FOR I=0 TO Num-1
         Tplfilespcdlib(I,Nam$,Ver$)
         IF Ver$="1" THEN 
           GOTO Norev_dlib
         END IF
       NEXT I
     END IF
   END IF
  !
 No_err: !
   Result=0
   SUBEXIT
 Nofile: !
   Result=-1
   SUBEXIT
 Norev_tpl: !
   Result=1
   SUBEXIT
 Norev_fwk: !
   Result=2
   SUBEXIT
 Norev_mlib: !
   Result=3
   SUBEXIT
 Norev_tlib: !
   Result=4
   SUBEXIT
 Norev_plib: !
   Result=5
   SUBEXIT
 Norev_ulib: !
   Result=6
   SUBEXIT
 Norev_lim: !
   Result=7
   SUBEXIT
 Norev_tco: !
   Result=8
   SUBEXIT
 Norev_dlib: !
   Result=9
   SUBEXIT
 SUBEND
 Check_sysconf:SUB Check_sysconf(INTEGER Errno,Errmsg$,Smode$,Op_lang$,Adtformat$,Clearonretest$,Clearonreject$,Portid$,Projid$,Hostname$,Adtlogging$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : CHECK_SYSCONF
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 ERRNO           I    -
  !      2 ERRMSG          S    -
  !      3 SMODE           S    -
  !      4 OP_LANG         S    -
  !      5 ADTFORMAT       S    -
  !      6 CLEARONRETEST   S    -
  !      7 CLEARONREJECT   S    -
  !      8 PORTID          S    -
  !      9 PROJID          S    -
  !     10 HOSTNAME        S    -
  !     11 ADTLOGGING      S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Line$[4096],Symbol$[4096],Value$[4096]
   INTEGER P
  !
   Errno=0
   Errmsg$=""
   Smode$=""
   Op_lang$=""
   Adtformat$=""
   Clearonretest$=""
   Clearonreject$=""
   Portid$=""
   Projid$=""
   Hostname$=""
   Adtlogging$=""
  !
   ON ERROR GOTO Err
   ASSIGN @Sysconf TO "/opt/SPECS/sys/config/sysconf";FORMAT ON           ! AVPATH_
   ON END @Sysconf GOTO Endoffile
   LOOP
     ENTER @Sysconf;Line$
     Line$=TRIM$(Line$)
     P=POS(Line$,"=")
     IF P>=2 THEN 
       Symbol$=Line$[1,P-1]
       Value$=Line$[P+1,LEN(Line$)]
       SELECT Symbol$
       CASE "SMODE"
         IF Smode$="" THEN Smode$=Value$
       CASE "OP_LANG"
         IF Op_lang$="" THEN Op_lang$=Value$
       CASE "ADTFORMAT"
         IF Adtformat$="" THEN Adtformat$=Value$
       CASE "CLEARONRETEST"
         IF Clearonretest$="" THEN Clearonretest$=Value$
       CASE "CLEARONREJECT"
         IF Clearonreject$="" THEN Clearonreject$=Value$
       CASE "IPCPORT"
         IF Portid$="" THEN Portid$=Value$
       CASE "PROJECT"
         IF Projid$="" THEN Projid$=Value$
       CASE "HOSTNAME"
         IF Hostname$="" THEN Hostname$=Value$
       CASE "ADTLOGGING"
         IF Adtlogging$="" THEN Adtlogging$=Value$
       END SELECT
     END IF
   END LOOP
 Endoffile: !
   IF Smode$="" THEN 
     Errno=-1
     Errmsg$="No SMODE found in /opt/SPECS/sys/config/sysconf"            ! AVPATH_
   END IF
   IF Op_lang$="" THEN 
     Errno=-1
     Errmsg$="No OP_LANG found in /opt/SPECS/sys/config/sysconf"          ! AVPATH_
   END IF
   IF Adtformat$="" THEN 
     Errno=-1
     Errmsg$="No ADTFORMAT found in /opt/SPECS/sys/config/sysconf"        ! AVPATH_
   END IF
   IF Clearonretest$="" THEN 
     Errno=-1
     Errmsg$="No CLEARONRETEST found in /opt/SPECS/sys/config/sysconf"    ! AVPATH_
   END IF
   IF Clearonreject$="" THEN 
     Errno=-1
     Errmsg$="No CLEARONREJECT found in /opt/SPECS/sys/config/sysconf"    ! AVPATH_
   END IF
   IF Portid$="" THEN 
     Errno=-1
     Errmsg$="No IPCPORT found in /opt/SPECS/sys/config/sysconf"          ! AVPATH_
   END IF
   IF Projid$="" THEN 
     Errno=-1
     Errmsg$="No PROJECT found in /opt/SPECS/sys/config/sysconf"          ! AVPATH_
   END IF
   IF Hostname$="" THEN 
     Errno=-1
     Errmsg$="No HOSTNAME found in /opt/SPECS/sys/config/sysconf"         ! AVPATH_
   END IF
   IF Adtlogging$="" THEN 
     Errno=-1
     Errmsg$="No ADTLOGGING found in /opt/SPECS/sys/config/sysconf"       ! AVPATH_
   END IF
   ASSIGN @Sysconf TO *
   SUBEXIT
 Err: !
   Errno=ERRN
   Errmsg$=ERRM$
 SUBEND
 Check_time:SUB Check_time(REAL Time)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : CHECK_TIME
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Time            R    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Time=TIMEDATE
 SUBEND
 Clock:SUB Clock(INTEGER Digit,Year,Month,Day,Hour,Minute,Second,REAL Value)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : CLOCK
  !  Vers : 1
  !  Desc : Returns the present date and time
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Digit           I    -        # digits to represent a year
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Year            I    -        Year:   YY or YYYY
  !      2 Month           I    -        Month:  MM
  !      3 Day             I    -        Day:    DD
  !      4 Hour            I    -        Hour:   HH
  !      5 Minute          I    -        Minute: MM
  !      6 Second          I    -        Second: SS
  !      7 Value           R    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM S$[80]
   Value=TIMEDATE
   ASSIGN @Pipe TO "date +'%C'; date +'%D'; date '+%H:%M:%S' |"
   ENTER @Pipe;S$
   Cent=VAL(S$[1;2])
   ENTER @Pipe;S$
   Year=VAL(S$[7;2])
   Month=VAL(S$[1;2])
   Day=VAL(S$[4;2])
   ENTER @Pipe;S$
   Hour=VAL(S$[1;2])
   Minute=VAL(S$[4;2])
   Second=VAL(S$[7;2])
   ASSIGN @Pipe TO *
   IF Digit=4 THEN Year=Cent*100+Year
 SUBEND
 Create_window:SUB Create_window(INTEGER Window,X,Y,W,H,Label$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : CREATE_WINDOW
  !  Vers : 1
  !  Desc : Opens a new HP BASIC/UX window
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Window          I    -
  !      2 X               I    -
  !      3 Y               I    -
  !      4 W               I    -
  !      5 H               I    -
  !      6 Label           S    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   ON ERROR GOTO Ignored
   CREATE WINDOW Window,X,Y,W,H;LABEL Label$,RETAIN
   GOTO Created
 Ignored:OFF ERROR 
 Created:SUBEXIT
 SUBEND
 Datalog_dieend:SUB Datalog_dieend(Filename$,INTEGER Mode)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : DATALOG_DIEEND
  !  Vers : 1
  !  Desc : Logs datas on the specified file. This uses user bin.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Filename        S    -        Filename.
  !      2 Mode            I    -        All(0), Failed only(1)
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Diepos,Diex,Diey          ! Current die position
   INTEGER Windex                    ! System variable index
   INTEGER Mini,Maxi                 ! Output variable range
   INTEGER Type,Dim,S1,S2            ! Variable information
   INTEGER Judge                     ! Pass=1/Fail=0/Invalid=2
   INTEGER Bin(6)                    ! Binning limit
   INTEGER Bc,Num,Den                ! Statical calculation condition
   INTEGER I                         !
   INTEGER Ival                      ! Integer-type output value
   REAL Lolim(6),Hilim(6)            ! Limit
   REAL Rval                         ! Real-type output value
   DIM Wafid$[256]                   ! Wafer ID
   DIM Outname$[256]                 ! Output variable name
   DIM Jdg$[32],Sp$[8],Info$[1024]
  !
   ON ERROR GOTO Errored
   Sp$=CHR$(9)
   Tpldiepos(Diepos)
   Tpldieinfo(Diepos,Diex,Diey)
   IF Diepos=0 THEN 
     ON ERROR GOTO No_file
     PURGE Filename$
 No_file: !
     OFF ERROR 
   END IF
   ON ERROR GOTO Exist
   CREATE Filename$,1
   EXECUTE "chmod 666 "&Filename$
 Exist: !
   ON ERROR GOTO Errored
   ASSIGN @File TO Filename$;FORMAT ON,APPEND
   ON ERROR GOTO Endalg
  !
   Tpltagindex("WAFER","SYS_WAFERID",Windex)
   Tplgetstag("WAFER",Windex,Diepos,Wafid$)
   Tplgetrangedie(Diepos,Mini,Maxi)
   IF Mini<0 OR Maxi<0 THEN Endalg
  !
   I=Mini
   FOR I=Mini TO Maxi
     Tploutinfo(I,Outname$,Type,Dim,S1,S2)
     Tploutjudge(I,Diepos,Judge)
     Tplgetwafubin(I,Bc,Lolim(*),Uplim(*),Bin(*),Num,Den)
     IF (Dim=0) AND (Mode=0 OR Judge=0) AND (Bc>0) THEN 
       Tplmodulelabel(I,Modlabel$)
       Tpldevicelabel(I,Devlabel$)
       SELECT (Judge)
       CASE 0
         Jdg$="FAIL!!"
       CASE 1
         Jdg$="PASS"
       CASE ELSE
         Jdg$="INVALID"
       END SELECT
       OUTPUT @File USING "#,K";Wafid$;Sp$;Diex;Sp$;Diey;Sp$;Modlabel$;Sp$
       OUTPUT @File USING "#,K";Devlabel$;Sp$;Outname$;Sp$
       SELECT (Type)
       CASE 0
         Tplgetrout(I,Diepos,Rval)
         OUTPUT @File USING "#,SD.3DE";Rval
       CASE 1
         Tplgetiout(I,Diepos,Ival)
         OUTPUT @File USING "#,K";Ival
       CASE ELSE
       END SELECT
       OUTPUT @File USING "-,K,SD.3DE,K,SD.3DE,K,K";Sp$;Lolim(Num);Sp$;Uplim(Num);Sp$;Jdg$
     END IF
   NEXT I
   ASSIGN @File TO *
   OFF ERROR 
   SUBEXIT
  !
 Endalg: !
   OFF ERROR 
   OUTPUT @File USING "-,K";Sp$
   ASSIGN @File TO *
   SUBEXIT
 Errored: !
   OFF ERROR 
 SUBEND
 Destroy_window:SUB Destroy_window(INTEGER Window)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : DESTROY_WINDOW
  !  Vers : 1
  !  Desc : Closes an existing HP BASIC/UX window
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Window          I    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   ON ERROR GOTO Ignored
   DESTROY WINDOW Window
   GOTO Destroyed
 Ignored:OFF ERROR 
 Destroyed:SUBEXIT
 SUBEND
 Fa_bldscr_lim:SUB Fa_bldscr_lim(Masscr$,Fmtscr$,INTEGER Status,Error$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_BLDSCR_LIM
  !  Vers : 1
  !  Desc : This algorithm alters Limit File according to conditions
  !       : specified by external file.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Masscr          S    -        Master script file to read
  !      2 Fmtscr          S    -        Script File for limformat to wri
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Command status
  !      2 Error           S    -        Error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER I,Length
   DIM Cmd$[256],Tab$[1]
   DIM Fa_limit$[256]
   DIM Lim_index$[256],Lim_name$[256]
   DIM Lim_speclo$[256],Lim_spechi$[256]
   DIM Lim_prodlo$[256],Lim_prodhi$[256],Lim_flag$[256]
   DIM Lim_yield$[10]
  !
   Tab$=CHR$(9)
   Status=0
  !
   ON ERROR GOTO File_open_error                        !! Mar.02/01
   ASSIGN @Mas TO Masscr$;FORMAT ON
   OFF ERROR 
  !
   ON ERROR GOTO File_open_error
   ASSIGN @Fmt TO Fmtscr$;FORMAT ON,EOL CHR$(10)
   OFF ERROR 
  !
   OUTPUT @Fmt;"rep";Tab$;"flgd";Tab$;0     ! disable all log flag initially
   OUTPUT @Fmt;"rep";Tab$;"flgl";Tab$;0     ! disable all display flag initially
   ON END @Mas GOTO Eof
 Loop:LOOP
     ENTER @Mas;Fa_limit$
     IF (TRIM$(Fa_limit$[1,1])="#") THEN 
       GOTO Loop
     END IF
     Length=LEN(Fa_limit$)
     IF Length<68 THEN GOTO Eof
     FOR I=22 TO Length
       IF Fa_limit$[I,I]="e" THEN Fa_limit$[I,I]="E"
     NEXT I
     Lim_index$=TRIM$(Fa_limit$[1,5])
     Lim_name$=TRIM$(Fa_limit$[7,20])
     Lim_flag$=TRIM$(Fa_limit$[74,75])
     Lim_speclo$=TRIM$(Fa_limit$[22,32])
     Lim_spechi$=TRIM$(Fa_limit$[34,44])
     Lim_prodlo$=TRIM$(Fa_limit$[46,56])
     Lim_prodhi$=TRIM$(Fa_limit$[58,68])
     Lim_yield$=TRIM$(Fa_limit$[70,72])
     ON ERROR GOTO Next_step1
     IF VAL(Lim_prodlo$)>VAL(Lim_speclo$) THEN 
       PRINT "Index ";Lim_index$;" in LIMIT file,"
       PRINT "WARNING ValidLo=";Lim_prodlo$,"SpecLo=";Lim_speclo$
       Lim_speclo$=VAL$(VAL(Lim_prodlo$)*1.1)
       PRINT " changed to ValidLo=";Lim_prodlo$,"SpecLo=";Lim_speclo$
     END IF
     IF VAL(Lim_spechi$)>VAL(Lim_prodhi$) THEN 
       PRINT "Index ";Lim_index$;" in LIMIT file,"
       PRINT "WARNING,  ValidHi=";Lim_prodhi$,"SpecHi=";Lim_spechi$
       Lim_spechi$=VAL$(VAL(Lim_prodhi$)*.9)
       PRINT " changed to ValidHi=";Lim_spechi$,"SpecHi=";Lim_prodhi$
     END IF
 Next_step1:OFF ERROR 
     OUTPUT @Fmt;"var";Tab$;Lim_name$;Tab$;
     OUTPUT @Fmt;"rep";Tab$;"flgd";Tab$;Lim_flag$[1,1];Tab$;
     OUTPUT @Fmt;"rep";Tab$;"flgl";Tab$;Lim_flag$[2,2];Tab$;
     OUTPUT @Fmt;"rep";Tab$;"limmin";Tab$;"1";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"lim1";Tab$;Lim_prodlo$;Tab$;
     OUTPUT @Fmt;"rep";Tab$;"lim2";Tab$;Lim_speclo$;Tab$;
     OUTPUT @Fmt;"rep";Tab$;"lim3";Tab$;Lim_spechi$;Tab$;
     OUTPUT @Fmt;"rep";Tab$;"lim4";Tab$;Lim_prodhi$;Tab$;
     OUTPUT @Fmt;"rep";Tab$;"limmax";Tab$;"1";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"bin1";Tab$;"2";Tab$;"3";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"bin2";Tab$;"1";Tab$;"4";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"bin3";Tab$;"-";Tab$;"+";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"jdg";Tab$;"1";Tab$;"3";Tab$;
     OUTPUT @Fmt;"rep";Tab$;"yld";Tab$;Lim_yield$
   END LOOP
  !
 Eof:ASSIGN @Fmt TO *
   ASSIGN @Mas TO *
  !
   Status=0
   Error$=""
  !
   SUBEXIT
  !
 File_open_error:   !
   OFF ERROR 
   ASSIGN @Mas TO *
   Status=-1
   Error$="Master file not found."
  !
 SUBEND
 Fa_bldscr_tpl:SUB Fa_bldscr_tpl(Masscr$,Fmtscr$,INTEGER Status,Error$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_BLDSCR_TPL
  !  Vers : 1
  !  Desc : This algorithm alters Test Plan according to conditions s
  !       : pecified by external file.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Masscr          S    -        Master script file to read
  !      2 Fmtscr          S    -        Script File for tplformat to wri
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Command status
  !      2 Error           S    -        Error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Cmd$[256],Tab$[1]
   DIM Fmttpl$[256],Fmterr$[256]
   DIM Fa_limit$[256]
   DIM Lim_index$[256]
   DIM Lim_dname$[256]
   DIM Lim_outname$[256]
  !
   Tab$=CHR$(9)
   Status=0
  !
   ON ERROR GOTO File_open_error                    !! Mar.02/01
   ASSIGN @Mas TO Masscr$;FORMAT ON
   OFF ERROR 
  !
   ON ERROR GOTO File_open_error
   ASSIGN @Fmt TO Fmtscr$;FORMAT ON,EOL CHR$(10)
   OFF ERROR 
  !
   ON END @Mas GOTO Eof
 Loop:LOOP
     ENTER @Mas;Fa_limit$
     PRINT Fa_limit$
     IF (TRIM$(Fa_limit$[1,1])="#") THEN 
       GOTO Loop
     END IF
     IF LEN(Fa_limit$)<26 THEN GOTO Eof
     PRINT Lim_index$;Lim_dname$;Lim_outname$
     Lim_index$=TRIM$(Fa_limit$[1,5])
     Lim_dname$=TRIM$(Fa_limit$[7,24])
     Lim_outname$=TRIM$(Fa_limit$[26,44])
  !
     OUTPUT @Fmt;"rep";Tab$;
     OUTPUT @Fmt;"var";Tab$;Lim_dname$;Tab$;
     OUTPUT @Fmt;Lim_outname$
  !
   END LOOP
  !
 Eof:ASSIGN @Fmt TO *
   ASSIGN @Mas TO *
  !
   Status=0
   Error$=""
  !
   SUBEXIT
  !
 File_open_error:        !
   OFF ERROR 
   Status=-1
   Error$="Master file not found."
  !
 SUBEND
 Fa_chk_files:SUB Fa_chk_files(INTEGER Rev_flag,Dir$,Filename_rev$,Suffix$,Brk_chr$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_CHK_FILES
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Rev_flag        I    -        0:Revision Control not available
  !      2 Dir             S    -        Direcory of file
  !      3 Filename_rev    S    -        Filename with revision number
  !      4 Suffix          S    -        suffix of Filename
  !      5 Brk_chr         S    -        Connection char between filename
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0:OK -1:ERR
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Cmd$[32],Opt$[32],Tplattr$[32]
   DIM Suf$[32],File$[512],Full$[512]
   DIM Rev$[256],Buf$[256]
   INTEGER Rev_mode
   INTEGER Is_rev
   INTEGER Stat,R,W,X,E
   ON ERROR GOTO Basic_err
  !
   Rev_mode=0                 ! 0:RevisionName 1:RevisionNumber
  !
   Status=0
   Tplattr$="/opt/SPECS/sys/bin/tplattr"
   Cmd$="/opt/SPECS/sys/bin/revopen"    ! AVPATH_
   IF Rev_mode=0 THEN 
     Opt$=" -a "
   ELSE
     Opt$=" -n "
   END IF
  !
   IF POS(Filename_rev$,Brk_chr$)>0 THEN 
     Full$=Filename_rev$[1,POS(Filename_rev$,Brk_chr$)-1]
     Rev$=Filename_rev$[POS(Filename_rev$,Brk_chr$)+LEN(Brk_chr$);LEN(Filename_rev$)]
     Is_rev=1
   ELSE
     Full$=Filename_rev$
     Rev$=""
     Is_rev=0
   END IF
   IF POS(Full$,".")>0 THEN 
     File$=Full$[1,POS(Full$,".")-1]
     Suf$=Full$[POS(Full$,".")+1;LEN(Full$)]
   ELSE
     File$=Full$
     Suf$=Suffix$
   END IF
   Full$=Dir$&"/"&File$
   IF Dir$[LEN(Dir$)]="/" THEN Full$=Dir$&File$
  !                                             ! Mode Check
   CALL Verify_file(Full$&"."&Suf$,"Normal",E,R,W,X)
   IF E<>1 THEN GOTO Permit_exist
   IF R<>1 THEN GOTO Permit_read
   IF W<>1 THEN GOTO Permit_write
  !
   IF NOT Is_rev THEN SUBEXIT              ! No revisionname in input parameter
   IF Rev_flag=0 THEN GOTO Rev_unable      ! Revision Control Not Available
  !
   ASSIGN @Pipe TO Tplattr$&" -a Vers -t "&Suf$&" "&Full$&" 2>/dev/null |"
   ON END @Pipe GOTO Eof
   ENTER @Pipe;Buf$
   ASSIGN @Pipe TO *
   IF LEN(Buf$)<7 THEN GOTO No_rev
  !
   EXECUTE Cmd$&Opt$&Rev$&" -t "&Suf$&" "&Full$&" 2> /dev/null";RETURN Stat
  ! PRINT Cmd$&Opt$&Rev$&" -t "&Suf$&" "&Full$&" 2> /dev/null"
   IF Stat<>0 THEN Status=-7
   SUBEXIT
 Permit_exist: !
   Status=-3
   SUBEXIT
 Permit_read: !
   Status=-2
   SUBEXIT
 Permit_write: !
   Status=-1
   SUBEXIT
 Rev_unable: !
   Status=-4
   SUBEXIT
 No_rev: !
   Status=-5
   SUBEXIT
 Eof: !
   Status=-6
   SUBEXIT
 Basic_err: !
   Statsu=-9
 SUBEND
 Fa_chk_files2:SUB Fa_chk_files2(INTEGER Rev_flag,Dir$,Filename_rev$,Suffix$,Brk_chr$,INTEGER Status,File_name$,Rev$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_CHK_FILES2
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Rev_flag        I    -        0:Revision Control not available
  !      2 Dir             S    -        Direcory of file
  !      3 Filename_rev    S    -        Filename with revision number
  !      4 Suffix          S    -        suffix of Filename
  !      5 Brk_chr         S    -        Connection char between filename
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0:OK -1:ERR
  !      2 File_name       S    -        File name without revision name
  !      3 Rev             S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Cmd$[32],Opt$[32],Tplattr$[32]
   DIM Suf$[32],File$[512],Full$[512]
   DIM Buf$[256]
   INTEGER Rev_mode
   INTEGER Is_rev
   INTEGER Stat,R,W,X,E
   ON ERROR GOTO Basic_err
  !
   Rev_mode=0                 ! 0:RevisionName 1:RevisionNumber
  !
   File_name$=""     ! Default value is null string '01/10/10 */
   Status=0
   Tplattr$="/opt/SPECS/sys/bin/tplattr"
   Cmd$="/opt/SPECS/sys/bin/revopen"    ! AVPATH_
   IF Rev_mode=0 THEN 
     Opt$=" -a "
   ELSE
     Opt$=" -n "
   END IF
  !
   IF POS(Filename_rev$,Brk_chr$)>0 THEN 
     Full$=Filename_rev$[1,POS(Filename_rev$,Brk_chr$)-1]
     Rev$=Filename_rev$[POS(Filename_rev$,Brk_chr$)+LEN(Brk_chr$);LEN(Filename_rev$)]
     Is_rev=1
   ELSE
     Full$=Filename_rev$
     Rev$=""
     Is_rev=0
   END IF
   IF POS(Full$,".")>0 THEN 
     File$=Full$[1,POS(Full$,".")-1]
     Suf$=Full$[POS(Full$,".")+1;LEN(Full$)]
   ELSE
     File$=Full$
     Suf$=Suffix$
   END IF
   File_name$=File$&"."&Suf$      ! Make file name again '01/10/10
   Full$=Dir$&"/"&File$
   IF Dir$[LEN(Dir$)]="/" THEN Full$=Dir$&File$
  !                                             ! Mode Check
   CALL Verify_file(Full$&"."&Suf$,"Normal",E,R,W,X)
   IF E<>1 THEN GOTO Permit_exist
   IF R<>1 THEN GOTO Permit_read
   IF W<>1 THEN GOTO Permit_write
  !
   IF NOT Is_rev THEN SUBEXIT              ! No revisionname in input parameter
   IF Rev_flag=0 THEN GOTO Rev_unable      ! Revision Control Not Available
  !
   ASSIGN @Pipe TO Tplattr$&" -a Vers -t "&Suf$&" "&Full$&" 2>/dev/null |"
   ON END @Pipe GOTO Eof
   ENTER @Pipe;Buf$
   ASSIGN @Pipe TO *
   IF LEN(Buf$)<7 THEN GOTO No_rev
  !
   EXECUTE Cmd$&Opt$&Rev$&" -t "&Suf$&" "&Full$&" 2> /dev/null";RETURN Stat
  ! PRINT Cmd$&Opt$&Rev$&" -t "&Suf$&" "&Full$&" 2> /dev/null"
   IF Stat<>0 THEN Status=-7
   SUBEXIT
 Permit_exist: !
   Status=-3
   SUBEXIT
 Permit_read: !
   Status=-2
   SUBEXIT
 Permit_write: !
   Status=-1
   SUBEXIT
 Rev_unable: !
   Status=-4
   SUBEXIT
 No_rev: !
   Status=-5
   SUBEXIT
 Eof: !
   Status=-6
   SUBEXIT
 Basic_err: !
   Statsu=-9
 SUBEND
 Fa_chk_libpath:SUB Fa_chk_libpath(Orig$,INTEGER Status,Pathflug,Path$,Filename$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_CHK_LIBPATH
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Orig            S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -
  !      2 Pathflug        I    -
  !      3 Path            S    -
  !      4 Filename        S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Revpath$[256]     ! Add 2005/11/01 and Modify 2006/11/02
  !
   Status=0
   IF Orig$[1,1]="/" THEN 
     Pathflug=1
   ELSE
     Pathflug=0
   END IF
   Step=LEN(Orig$)
   FOR I=1 TO LEN(Orig$)
     IF Orig$[Step,Step]="/" THEN 
       GOTO Loopend
     END IF
     Step=Step-1
   NEXT I
 Loopend:  !
   IF Step>1 THEN 
     Path$=Orig$[1,LEN(Orig$)-I]
   ELSE
     Status=1
     Path$=""
     Filename$=Orig$
     SUBEXIT
   END IF
   Revpath$=REV$(Orig$)
   Pos_fname=POS(Revpath$,"/")
   IF Pos_fname=0 THEN 
     Filename$=Orig$
   ELSE
     Filename$=REV$(Revpath$[1,Pos_fname-1])
   END IF
   Status=0
 SUBEND
 Fa_chk_measlib:SUB Fa_chk_measlib(INTEGER Revcont,Lib$(*),INTEGER Libnum,Delimiter$,INTEGER Status,Error$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_CHK_MEASLIB
  !  Vers : 1
  !  Desc : Check multi-measurement libraris.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Revcont         I    -        Revision Control Mode
  !      2 Lib             S    256      Measurement Library File (with R
  !      3 Libnum          I    -        Number of Measurement Library
  !      4 Delimiter       S    -        Delimiter between File and Revis
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Error Code
  !      2 Error           S    -        Error Message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Problib$[256],Testlib$[256],Utillib$[256]
   DIM Probrev$[256],Testrev$[256],Utilrev$[256]
   INTEGER Probnum,Testnum,Utilnum
   DIM Measlib$[256],Libname$[256],Basname$[256]
   INTEGER Cnt
  !
   Status=0
   Error$=""
  !
   Tplfileplib(Problib$,Probrev$,Probnum)
   Tplfiletlib(Testlib$,Testrev$,Testnum)
   Tplfileulib(Utillib$,Utilrev$,Utilnum)
  !
   FOR Cnt=1 TO Libnum
 Libnext:     !
     IF Cnt>Libnum OR Cnt>256 THEN 
       GOTO Libend
     END IF
     IF LEN(Lib$(Cnt))=0 THEN 
       Cnt=Cnt+1
       GOTO Libnext
     END IF
  !
     Measlib$=Lib$(Cnt)
     IF Revcont<>0 THEN 
       Pos=POS(Measlib$,Delimiter$)
       Measlib$=Measlib$[1,LEN(Measlib$)-Pos]
     END IF
     IF Measlib$[1]<>"/" THEN 
       Measlib$="/opt/SPECS/usr/alg/"&Measlib$
     END IF
  !
     IF Probnum<>0 AND Measlib$=Problib$ THEN 
       Status=-1
       Error$="Illegal measurement library is specified : "&Problib$
       SUBEXIT
     END IF
     IF Testnum<>0 AND Measlib$=Testlib$ THEN 
       Status=-2
       Error$="Illegal measurement library is specified : "&Testlib$
       SUBEXIT
     END IF
     IF Utilnum<>0 AND Measlib$=Utillib$ THEN 
       Status=-3
       Error$="Illegal measurement library is specified : "&Utillib$
       SUBEXIT
     END IF
  !
     Libname$=Measlib$&".lib"
     Basname$=Measlib$&".bas"
  !
     ON ERROR GOTO Nolib
     ASSIGN @Pipe TO "ls -l -d "&Libname$&" 2>/dev/null | cut -c -10 |"
     ON END @Pipe GOTO Nolib
     ENTER @Pipe;Libmode$
     IF Libmode$[2,2]<>"r" THEN 
       GOTO Nolib
     END IF
     OFF END @Pipe
     OFF ERROR 
  !
     ON ERROR GOTO Nobas
     ASSIGN @Pipe TO "ls -l -d "&Basname$&" 2>/dev/null | cut -c -10 |"
     ON END @Pipe GOTO Nobas
     ENTER @Pipe;Basmode$
     IF Basmode$[2,2]<>"r" THEN 
       GOTO Nobas
     END IF
     OFF END @Pipe
     OFF ERROR 
   NEXT Cnt
 Libend:     !
   SUBEXIT
  !
 Nolib:     !
   OFF END @Pipe
   OFF ERROR 
   Status=-4
   Error$="Cannot access the specified file : "&Libname$
   SUBEXIT
 Nobas:     !
   OFF END @Pipe
   OFF ERROR 
   Status=-5
   Error$="Cannot access the specified file : "&Basname$
   SUBEXIT
 SUBEND
 Fa_chk_rev:SUB Fa_chk_rev(Session$,Kinds$,INTEGER Status,Filename$,Rev$,Path$,Basicpath$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_CHK_REV
  !  Vers : 1
  !  Desc : Read configuration parameter and apply them.
  !       :   SPECS2.5: Added special parameters.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -
  !      2 Kinds           S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -
  !      2 Filename        S    -
  !      3 Rev             S    -
  !      4 Path            S    -
  !      5 BasicPath       S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Line$[256],Rpath$[256]
   INTEGER Idx_tag,Counter,Key_step,Filearea,Revarea,N_session,Pos_l
  !
  !
   ON ERROR GOTO Err
   EXECUTE "/opt/SPECS/sys/bin/tplstat -S "&Session$&" >/usr/tmp/tmp_stat_res"
   ASSIGN @F TO "/usr/tmp/tmp_stat_res";FORMAT ON
   ON END @F GOTO Endoffile
   N_session=VAL(Session$)
   Key_step=0
  !
   Flg=0
   Counter=0
   LOOP
     Counter=Counter+1
     ENTER @F;Line$
     IF Counter=1 THEN 
       IF Line$=Session$ THEN 
         Key_step=Counter-1
         Flg=1
       END IF
     END IF
     IF Counter=25 THEN 
       IF Line$=Session$ THEN 
         Key_step=Counter-1
         Flg=1
       END IF
     END IF
     IF Counter=49 THEN 
       IF Line$=Session$ THEN 
         Key_step=Counter-1
         Flg=1
       END IF
     END IF
     IF Counter=73 THEN 
       IF Line$=Session$ THEN 
         Key_step=Counter-1
         Flg=1
       END IF
     END IF
  !
     IF Flg=1 THEN 
       IF Kinds$="MEAS" THEN 
         Filearea=10+Key_step
         Revarea=11+Key_step
       END IF
       IF Kinds$="TST" THEN 
         Filearea=13+Key_step
         Revarea=14+Key_step
       END IF
       IF Kinds$="PRB" THEN 
         Filearea=16+Key_step
         Revarea=17+Key_step
       END IF
       IF Kinds$="UTL" THEN 
         Filearea=19+Key_step
         Revarea=20+Key_step
       END IF
       IF Kinds$="DEV" THEN 
         Filearea=22+Key_step
         Revarea=23+Key_step
       END IF
  !
       IF Counter=Filearea THEN 
         Path$=Line$
       END IF
       IF Counter=Revarea THEN 
         Rev$=Line$
         GOTO Breakloop
       END IF
     END IF
   END LOOP
 Breakloop:    !
   Rpath$=REV$(Path$)
   Pos_l=POS(Rpath$,"/")
   Basicpath$=Path$[1,LEN(Path$)-Pos_l+1]
   Filename$=REV$(Rpath$[1,Pos_l-1])
   Status=0
   SUBEXIT
 Endoffile:  !
   ASSIGN @F TO *
   Status=-6
   SUBEXIT
 Err:                                  !
   ASSIGN @F TO *
   Status=-9
 SUBEND
 Fa_chk_rev2:SUB Fa_chk_rev2(Session$,Kinds$,INTEGER Count,Status,Filename$,Rev$,Path$,Basicpath$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_CHK_REV2
  !  Vers : 1
  !  Desc : Get TPL file information.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -        Session Number
  !      2 Kinds           S    -        Type of Library
  !      3 Count           I    -        Index of Multi-Measurement Libra
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Error Code
  !      2 Filename        S    -        File Name
  !      3 Rev             S    -        Revision
  !      4 Path            S    -        File Name with Directory
  !      5 BasicPath       S    -        Directory
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Revpath$[256]
   INTEGER Num,Pos
  !
   Status=0
   Filename$=""
   Rev$=""
   Path$=""
   Basicpath$=""
  !
   SELECT Kinds$
   CASE "MEAS"
     Tplfilenummlib(Num)
     IF Count<Num THEN 
       Tplfilemlibm(Count,Path$,Rev$,Num)
     ELSE
       Status=-2
     END IF
   CASE "PRB"
     Tplfileplib(Path$,Rev$,Num)
   CASE "TST"
     Tplfiletlib(Path$,Rev$,Num)
   CASE "UTL"
     Tplfileulib(Path$,Rev$,Num)
   CASE "DEV"
     Tplfiledlib(Path$,Rev$,Num)
   CASE ELSE
     Status=-1
   END SELECT
  !
   IF Num<>0 AND Status=0 THEN 
     Revpath$=REV$(Path$)
     Pos=POS(Revpath$,"/")
     Filename$=REV$(Revpath$[1,Pos-1])
     Basicpath$=Path$[1,LEN(Path$)-Pos+1]
   END IF
 SUBEND
 Fa_chkrun_fwk:SUB Fa_chkrun_fwk(Name$,Status$,INTEGER Numfile,Numrunning)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_CHKRUN_FWK
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Name            S    -        Key word of grep
  !      2 Status          S    -        SPECS Status
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 numFile         I    -        The number of process regarding
  !      2 numRunning      I    -        The number of running process re
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   ON ERROR GOTO Err
  ! ASSIGN @Pipe TO "tplstat 2>/dev/null | awk '{print $8}' | grep "&Name$&" | wc | cut -c -1 |"
   ASSIGN @Pipe TO "tplstat 2>/dev/null | awk '{print $8}' | grep "&Name$&" | wc | awk '{print $1}'|"
   ENTER @Pipe;Numfile
  ! ASSIGN @Pipe TO "tplstat 2>/dev/null | awk '{print $2 $8}' | grep "&Name$&" | grep "&Status$&" | wc | cut -c -1 |"
   ASSIGN @Pipe TO "tplstat 2>/dev/null | awk '{print $2 $8}' | grep "&Name$&" | grep "&Status$&" | wc | awk '{print $1}'|"
   ENTER @Pipe;Numrunning
   GOTO Check_file
 Err:       !
   OFF ERROR 
   PRINT "PROCESS CHECK ERROR: "&Name$&" or "&Status$&" is not accessible."
   SUBEXIT
  !
 Check_file:   !
  !
 SUBEND
 Fa_getkey_items:SUB Fa_getkey_items(Key$,Filename$,Waf$,Die$,Tst$,Prb$,Tpl$,Lim$,Rcp$,Lot_id$,Product_id$,Process_id$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_GETKEY_ITEMS
  !  Vers : 1
  !  Desc : Desc: Get many items in the file from key recipe id.
  !       : Date: '00/Nov/28 Initial revision
  !       : Date: '01/Mar/09 Released  K.N
  !       : Date: '01/Jul/19 Change to Lynx1 by M.N
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Key             S    -        Key ID (PPExecName)
  !      2 Filename        S    -        File Name
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Waf             S    -        Wafer spec name
  !      2 Die             S    -        Die spec name
  !      3 Tst             S    -        Test spec name
  !      4 Prb             S    -        Probe card spec name
  !      5 Tpl             S    -        Test plan file name
  !      6 Lim             S    -        Limit file name
  !      7 Rcp             S    -        Prober recipe file name
  !      8 Lot_id          S    -        LotID
  !      9 Product_id      S    -        ProductID
  !     10 Process_id      S    -        ProcessID
  !     11 Status          I    -        0:OK -1:Eof -2:No Data -3:No Fil
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER I
   DIM Field$[256]
   Field$=""
   Waf$=""
   Die$=""
   Tst$=""
   Prb$=""
   Tpl$=""
   Lim$=""
   Rcp$=""
   Lot_id$=""
   Product_id$=""
   Process_id$=""
   Status=0
   ON ERROR GOTO Nofile
   ASSIGN @Tmp TO Filename$
   ASSIGN @Tmp TO *
   OFF ERROR 
   FOR I=1 TO 10
     ON ERROR GOTO Nofile
     ASSIGN @Pipe TO "grep -v '^#' "&Filename$&" | awk -F: '{ if($1 == """&Key$&"""){ if("&VAL$(I+1)&"<=NF){ print $"&VAL$(I+1)&"; } else { print "":""; }}}'| "
     OFF ERROR 
     ON END @Pipe GOTO Eof
     ON ERROR GOTO Overflow
     ENTER @Pipe;Field$
     ASSIGN @Pipe TO *
     IF Field$=":" THEN 
       Field$=""
       Status=-2
     ELSE
       Status=0
       SELECT I
       CASE 1
         Lot_id$=Field$
       CASE 2
         Product_id$=Field$
       CASE 3
         Process_id$=Field$
       CASE 4
         Waf$=Field$
       CASE 5
         Die$=Field$
       CASE 6
         Tst$=Field$
       CASE 7
         Prb$=Field$
       CASE 8
         Tpl$=Field$
       CASE 9
         Lim$=Field$
       CASE 10
         Rcp$=Field$
       END SELECT
     END IF
   NEXT I
   ASSIGN @Pipe TO *
   SUBEXIT
 Nofile:Status=-3
   ASSIGN @Pipe TO *
   SUBEXIT
 Eof:Status=-1
   ASSIGN @Pipe TO *
   SUBEXIT
 Overflow:Status=-2
   ASSIGN @Pipe TO *
 SUBEND
 Fa_limbld:SUB Fa_limbld(INTEGER Rev_flag,Brk_chr$,Tpl_dir$,Lim_dir$,Tpl$,Lim$,INTEGER Status,Error$,INTEGER Ndetail,Detail$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_LIMBLD
  !  Vers : 1
  !  Desc : This algorithm generates Limit File dynamically.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Rev_flag        I    -        0:Revision Control not available
  !      2 Brk_chr         S    -        Connection char between filename
  !      3 Tpl_dir         S    -        Testplan file directory
  !      4 Lim_dir         S    -        Limit file directory
  !      5 Tpl             S    -        Test Plan name to read
  !      6 Lim             S    -        Limit file name to write
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Command status
  !      2 Error           S    -        Error message
  !      3 Ndetail         I    -        # of lines of detail error messa
  !      4 Detail          S    10       detailed error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Stat
   DIM Cmd$[256],Err$[256]
   DIM T$[512],L$[512]
   DIM T2$[512],L2$[512]
  !
   ON ERROR GOTO Basic_syserr
  !
   Ndetail=0
   Cmd$="/opt/SPECS/sys/bin/limbuild "
   CALL Fa_chk_files(Rev_flag,Tpl_dir$,Tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-1 THEN GOTO File_check_err
   CALL Fa_chk_files(Rev_flag,Lim_dir$,Lim$,"lim",Brk_chr$,Stat)
   IF Stat<-3 THEN GOTO File_check_err
   T2$=Tpl$
   L2$=Lim$
   IF POS(T2$,Brk_chr$)>0 THEN T2$=Tpl$[1,POS(Tpl$,Brk_chr$)-1]
   IF POS(L2$,Brk_chr$)>0 THEN L2$=Lim$[1,POS(Lim$,Brk_chr$)-1]
   IF POS(T2$,".tpl")=0 THEN T2$=T2$&".tpl"
   IF POS(L2$,".lim")=0 THEN L2$=L2$&".lim"
   T$=Tpl_dir$&"/"&T2$
   L$=Lim_dir$&"/"&L2$
   IF Tpl_dir$[LEN(Tpl_dir$)]="/" THEN T$=Tpl_dir$&T2$
   IF Lim_dir$[LEN(Lim_dir$)]="/" THEN L$=Lim_dir$&L2$
   Err$="/usr/tmp/limbld.err"
   EXECUTE Cmd$&T$&" > "&L$&" 2> "&Err$;RETURN Stat
  ! PRINT Cmd$&T$&" > "&L$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     Error$="ERROR"
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO E
     ENTER @E;Error$
     Ndetail=0
     LOOP
       ENTER @E;Detail$(Ndetail+1)
       Ndetail=Ndetail+1
     END LOOP
 E:  ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
   PURGE Err$
   SUBEXIT
 File_check_err: !
   Status=-1
   Error$="File_check_error "&VAL$(Stat)
   SUBEXIT
 Basic_syserr: !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
 SUBEND
 Fa_limbld2:SUB Fa_limbld2(INTEGER Rev_flag,Brk_chr$,Tpl_dir$,Lim_dir$,Lms_dir$,Tpl$,Lim$,Lms$(*),INTEGER Status,Error$,INTEGER Ndetail,Detail$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_LIMBLD2
  !  Vers : 1
  !  Desc : This algorithm generates Limit File dynamically.
  !       : 2005/09/02 Bugfix Call limbuild/limformat
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Rev_flag        I    -        0:Revision Control not available
  !      2 Brk_chr         S    -        Connection char between filename
  !      3 Tpl_dir         S    -        Testplan file directory
  !      4 Lim_dir         S    -        Limit file directory
  !      5 Lms_dir         S    -        Limit spec directory
  !      6 Tpl             S    -        Test Plan name to read
  !      7 Lim             S    -        Limit file name to write
  !      8 Lms             S    256      Limit spec name
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Command status
  !      2 Error           S    -        Error message
  !      3 Ndetail         I    -        # of lines of detail error messa
  !      4 Detail          S    10       detailed error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Stat
   DIM Cmd$[256],Err$[256]
   DIM T$[512],L$[512]
   DIM T2$[512],L2$[512]
   DIM Lms2$[4098]   ! 2005/11/01
   INTEGER Lms_size  ! 2005/11/01
  !
   ON ERROR GOTO Basic_syserr
  !
   Ndetail=0
   Lms_size=256   ! 2005/11/01
   Cmd$="/opt/SPECS/sys/bin/limbuild "
   CALL Fa_chk_files(Rev_flag,Tpl_dir$,Tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-1 THEN GOTO File_check_err
   CALL Fa_chk_files(Rev_flag,Lim_dir$,Lim$,"lim",Brk_chr$,Stat)
   IF Stat<-3 THEN GOTO File_check_err
  ! FOR I=1 TO I<=Lms_size   ! 2005/11/01
   FOR I=1 TO Lms_size       ! 2005/11/01
     IF Lms$(I)="" THEN 
       GOTO End_loop
     END IF
     CALL Fa_chk_files(Rev_flag,Lms_dir$,Lms$(I),"lms",Brk_chr$,Stat)           ! 2005/11/01
  !   Lms2$=Lms2$&" -lms "&Lms_dir$&Lms$(I)                                     ! 2005/11/01
     Lms2$=Lms2$&" -lms "&Lms_dir$&"/"&Lms$(I)                                  ! 2005/11/01
     IF Lms_dir$[LEN(Lms_dir$)]="/" THEN Lms2$=Lms2$&" -lms "&Lms_dir$&Lms$(I)  ! 2005/11/01
  !   IF POS(Lms2$,".lms")=0 THEN Lms2$=Lms2$&".lms"                            ! 2005/11/01
     IF POS(Lms$(I),".lms")=0 THEN Lms2$=Lms2$&".lms"                           ! 2005/11/01
   NEXT I
 End_loop:   !
   T2$=Tpl$
   L2$=Lim$
   IF POS(T2$,Brk_chr$)>0 THEN T2$=Tpl$[1,POS(Tpl$,Brk_chr$)-1]
   IF POS(L2$,Brk_chr$)>0 THEN L2$=Lim$[1,POS(Lim$,Brk_chr$)-1]
   IF POS(T2$,".tpl")=0 THEN T2$=T2$&".tpl"
   IF POS(L2$,".lim")=0 THEN L2$=L2$&".lim"
   T$=Tpl_dir$&"/"&T2$
   L$=Lim_dir$&"/"&L2$
   IF Tpl_dir$[LEN(Tpl_dir$)]="/" THEN T$=Tpl_dir$&T2$
   IF Lim_dir$[LEN(Lim_dir$)]="/" THEN L$=Lim_dir$&L2$
   Err$="/usr/tmp/limbld.err"
   EXECUTE Cmd$&T$&Lms2$&" > "&L$&" 2> "&Err$;RETURN Stat
  ! PRINT Cmd$&T$&Lms2$&" > "&L$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     Error$="ERROR"
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO E
     ENTER @E;Error$
     Ndetail=0
     LOOP
       ENTER @E;Detail$(Ndetail+1)
       Ndetail=Ndetail+1
     END LOOP
 E:  ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
   PURGE Err$
   SUBEXIT
 File_check_err: !
   Status=-1
   Error$="File_check_error "&VAL$(Stat)
   SUBEXIT
 Basic_syserr: !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
 SUBEND
 Fa_limfmt:SUB Fa_limfmt(INTEGER Rev_flag,Brk_chr$,Src_lim_dir$,Script_dir$,Dst_lim_dir$,Src_lim$,Script$,Dst_lim$,INTEGER Status,Error$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_LIMFMT
  !  Vers : 1
  !  Desc : This algorithm alters Limit File according to conditions
  !       : specified by external file.
  !       : 2005/09/02 Bugfix Call limformat
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Rev_flag        I    -        0:Revision Control not available
  !      2 Brk_chr         S    -        Connection char between filename
  !      3 Src_lim_dir     S    -        Temporary file directory
  !      4 Script_dir      S    -        Script file directory
  !      5 Dst_lim_dir     S    -        New limit file directory
  !      6 Src_lim         S    -        Temporay Limit File to read
  !      7 Script          S    -        Specified script file
  !      8 Dst_lim         S    -        Generated Limit File to write"
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Command status
  !      2 Error           S    -        Error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !123456789012345678901234567890123456789012345678901234567890123456789012345678
  !
  !    1 VT_N1 EXT  V 20/20         0.4500      1.0500 12      0.6000      0.9000
  !    2 GAM_N1     20/20           0.0500      1.0000 11      0.3000      0.8000
  !    3 BET_N1 Slo uA/V**2        70.0000    150.0000 11     90.0000    130.0000
  !   17 VT_N6 EXT  V.35/20 PG      0.2000      1.1500 11      0.3200      0.9300
  !
  !  1- 5  index
  !  7-16  name
  ! 18-27  unit
  ! 29-39  spec lo  (wider)
  ! 41-51  spec hi
  ! 53-54  flag
  ! 56-66  prod lo  (narrower)
  ! 68-78  prod hi
  ! 80-82  Yield
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   DIM Cmd$[256],Tab$[1]
   DIM Cmd2$[256]         ! 2005/11/01
   DIM Err$[256],Src$[512],Dst$[512]
   DIM Tmplim$[512],Genlim$[512],Scr$[512]
   DIM Fmtscr$[512]
   INTEGER Stat
  !
   ON ERROR GOTO Basic_syserr
  !
   Cmd$="/opt/SPECS/sys/bin/limformat"
   Cmd2$="/usr/bin/cat"                   ! 2005/11/01
   Err$="/usr/tmp/limerr.err"
   Status=0
  !
   CALL Fa_chk_files(Rev_flag,Src_lim_dir$,Src_lim$,"lim",Brk_chr$,Stat)
   IF Stat<-1 THEN GOTO File_check_err
  !    CALL Fa_chk_files(Rev_flag,Dst_lim_dir$,Dst_lim$,"lim",Brk_chr$,Stat)
  !    IF Stat<-3 THEN GOTO File_check_err
   Src$=Src_lim$
   Dst$=Dst_lim$
   IF POS(Src$,Brk_chr$)>0 THEN Src$=Src_lim$[1,POS(Src_lim$,Brk_chr$)-1]
   IF POS(Dst$,Brk_chr$)>0 THEN Dst$=Dst_lim$[1,POS(Dst_lim$,Brk_chr$)-1]
   IF POS(Src$,".lim")=0 THEN Src$=Src$&".lim"
   IF POS(Dst$,".lim")=0 THEN Dst$=Dst$&".lim"
  !
   Scr$=Script_dir$&"/"&Script$
   Tmplim$=Src_lim_dir$&"/"&Src$
   Genlim$=Dst_lim_dir$&"/"&Dst$
   IF LEN(Script_dir$)>0 THEN   ! 2005/11/01
     IF Script_dir$[LEN(Script_dir$)]="/" THEN Scr$=Script_dir$&Script$
   END IF
   IF Src_lim_dir$[LEN(Src_lim_dir$)]="/" THEN Tmplim$=Src_lim_dir$&Src$
   IF Dst_lim_dir$[LEN(Dst_lim_dir$)]="/" THEN Genlim$=Dst_lim_dir$&Dst$
  !
   Fmtscr$="/usr/tmp/limscr.tmp"
   ON ERROR GOTO E
   PURGE Fmtscr$
 E:OFF ERROR 
   CREATE Fmtscr$,1
   Fa_bldscr_lim(Scr$,Fmtscr$,Status,Error$)      !! Build format from cust's format
  !    EXECUTE Cmd$&" -cmd "&Scr$&" "&Tmplim$&" > "&Genlim$&" 2> "&Err$;RETURN Stat
  ! PRINT Fmtscr$
   IF LEN(Script_dir$)=0 OR LEN(Script$)=0 THEN    ! 2005/11/01
     EXECUTE Cmd2$&" "&Tmplim$&" > "&Genlim$&" 2> "&Err$;RETURN Stat
   ELSE
     EXECUTE Cmd$&" -cmd "&Fmtscr$&" "&Tmplim$&" > "&Genlim$&" 2> "&Err$;RETURN Stat
   END IF
  ! PRINT Cmd$&" -cmd "&Scr$&" "&Tmplim$&" > "&Genlim$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     ON ERROR GOTO File_check_err
     ASSIGN @E TO Err$;FORMAT ON
     ENTER @E;Error$
     ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
  !
   PURGE Err$
   SUBEXIT
  !
 File_check_err: !
   Status=-1
   Error$="File_check_error "&VAL$(Stat)
   SUBEXIT
 Basic_syserr:  !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
 SUBEND
 Fa_lmp_clearln:SUB Fa_lmp_clearln(INTEGER Linenth,Erasemode,Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_LMP_CLEARLN
  !  Vers : 1
  !  Desc : FA Algorithm: Clear a line of LMP User Value Displayment
  !       : area.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 LineNth         I    -        Line number where to erase
  !      2 EraseMode       I    -        1:ClearAll,2:ClearValue(Not chan
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        GEM Reply
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Event$[256]
   DIM Lnth$[256]
   DIM Label$[256]
   DIM Str$[256]
   DIM Fgc$[256],Bgc$[256]
   IF Linenth<=0 OR Linenth>=9 THEN 
     Status=-1
     SUBEXIT
   END IF
   IF Erasemode<=0 OR Erasemode>=3 THEN 
     Status=-1
     SUBEXIT
   END IF
   Lnth$=VAL$(Linenth)
   Label$=""
   Str$=""
   Fgc$="default"
   Bgc$="default"
   IF Erasemode=1 THEN 
     Event$="DISPLINE"
   ELSE
     Event$="CLEARLINE"
   END IF
   Fa_lmpdisp(Event$,Lnth$,Label$,Str$,Fgc$,Bgc$,Status)
 SUBEND
 Fa_lmp_dispint:SUB Fa_lmp_dispint(INTEGER Linenth,Displabel$,INTEGER Dispvalue,Dispfgc$,Dispbgc$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_LMP_DISPINT
  !  Vers : 1
  !  Desc : FA Algorithm: Display a combination of Label + Value in L
  !       : MP User Value Displayment area.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 LineNth         I    -        Line number where to display
  !      2 DispLabel       S    -        Label String (Max 18 Chars)
  !      3 DispValue       I    -        Value Integer (Max 30 Chars)
  !      4 DispFgc         S    -        Foreground Color of the Value St
  !      5 DispBgc         S    -        Background Color of the Value St
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        GEM Reply
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Lnth$[256]
   DIM Label$[256],Value$[256]
   DIM Event$[256]
   DIM Fgc$[256],Bgc$[256]
   IF Linenth<=0 OR Linenth>=9 THEN 
     Status=-1
     SUBEXIT
   END IF
   Lnth$=VAL$(Linenth)
   IF Displabel$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   L=LEN(Displabel$)
   IF L>=19 THEN 
     Label$=Displabel$[1,18]
   ELSE
     Label$=Displabel$
   END IF
   Value$=VAL$(Dispvalue)
   L=LEN(Dispfgc$)
   IF L=0 OR Dispfgc$="" THEN 
     Fgc$="default"
   ELSE
     Fgc$=Dispfgc$
   END IF
   L=LEN(Dispbgc$)
   IF L=0 OR Dispbgc$="" THEN 
     Bgc$="default"
   ELSE
     Bgc$=Dispbgc$
   END IF
   Event$="DISPLINE"
   Fa_lmpdisp(Event$,Lnth$,Label$,Value$,Fgc$,Bgc$,Status)
 SUBEND
 Fa_lmp_displine:SUB Fa_lmp_displine(INTEGER Linenth,Displabel$,Dispstr$,Dispfgc$,Dispbgc$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_LMP_DISPLINE
  !  Vers : 1
  !  Desc : FA Algorithm: Display a combination of Label + Value in L
  !       : MP User Value Displayment area.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 LineNth         I    -        Line Number where to display
  !      2 DispLabel       S    -        Label String (Max 18 Chars)
  !      3 DispStr         S    -        Value String (Max 30 Chars)
  !      4 DispFgc         S    -        Foreground Color of the Value St
  !      5 DispBgc         S    -        Background Color of the Value St
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        GEM Reply
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Lnth$[256]
   DIM Label$[256],Str$[256]
   DIM Event$[256]
   DIM Fgc$[256],Bgc$[256]
   IF Linenth<=0 OR Linenth>=9 THEN 
     Status=-1
     SUBEXIT
   END IF
   Lnth$=VAL$(Linenth)
   IF Displabel$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   L=LEN(Displabel$)
   IF L>=19 THEN 
     Label$=Displabel$[1,18]
   ELSE
     Label$=Displabel$
   END IF
   IF Dispstr$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   L=LEN(Dispstr$)
   IF L>=31 THEN 
     Str$=Dispstr$[1,30]
   ELSE
     Str$=Dispstr$
   END IF
   L=LEN(Dispfgc$)
   IF L=0 OR Dispfgc$="" THEN 
     Fgc$="default"
   ELSE
     Fgc$=Dispfgc$
   END IF
   L=LEN(Dispbgc$)
   IF L=0 OR Dispbgc$="" THEN 
     Bgc$="default"
   ELSE
     Bgc$=Dispbgc$
   END IF
   Event$="DISPLINE"
   Fa_lmpdisp(Event$,Lnth$,Label$,Str$,Fgc$,Bgc$,Status)
 SUBEND
 Fa_lmp_dispvar:SUB Fa_lmp_dispvar(INTEGER Linenth,Displabel$,INTEGER Dispvar,Dispfgc$,Dispbgc$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_LMP_DISPVAR
  !  Vers : 1
  !  Desc : FA Algorithm: Display a combination of Label + VGEM VAL i
  !       : n LMP User Value Displayment area.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 LineNth         I    -        Line number where to display
  !      2 DispLabel       S    -        Label String (Max 18 Chars)
  !      3 DispVar         I    -        Variable ID
  !      4 DispFgc         S    -        Foreground Color of the Value St
  !      5 DispBgc         S    -        Background Color of the Value St
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        GEM Reply
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Lnum$[256]
   DIM Vlabel$[256]
   DIM Varid$[256]
   DIM Vfgc$[256],Vbgc$[256]
   DIM Vevent$[256]
   IF Linenth<=0 OR Linenth>=9 THEN 
     Status=-1
     SUBEXIT
   END IF
   Lnum$=VAL$(Linenth)
   IF Displabel$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   L=LEN(Displabel$)
   IF L>=19 THEN 
     Vlabel$=Displabel$[1,18]
   ELSE
     Vlabel$=Displabel$
   END IF
   IF Dispvar<=0 THEN 
     Status=-1
     SUBEXIT
   END IF
   Varid$=VAL$(Dispvar)
   L=LEN(Dispfgc$)
   IF L=0 OR Dispfgc$="" THEN 
     Vfgc$="default"
   ELSE
     Vfgc$=Dispfgc$
   END IF
   L=LEN(Dispbgc$)
   IF L=0 OR Dispbgc$="" THEN 
     Vbgc$="default"
   ELSE
     Vbgc$=Dispbgc$
   END IF
   Vevent$="DISPVAR"
   PRINT Vevent$
   PRINT Lnum$
   PRINT Vlabel$
   PRINT Varid$
   PRINT Vfgc$
   PRINT Vbgc$
   Fa_lmpdisp(Vevent$,Lnum$,Vlabel$,Varid$,Vfgc$,Vbgc$,Status)
 SUBEND
 Fa_mk_dataname:SUB Fa_mk_dataname(Dir$,File$,INTEGER Slot,Adtfmt$,Session$,Datadir$,Dataname$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_MK_DATANAME
  !  Vers : 1
  !  Desc : This algorithm generates file name to dump data for a cur
  !       : rent wafer.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Dir             S    -        Data Directory
  !      2 File            S    -        File Directory
  !      3 Slot            I    -        SlotNumber
  !      4 Adtfmt          S    -        Adt Format
  !      5 Session         S    -        SessionID
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Datadir         S    -        Data Directory Path
  !      2 Dataname        S    -        Data File Name
  !      3 Status          I    -        0:OK -1:Error
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Outputdir$[255]
   DIM Outputfile$[255]
   DIM Err$[255]
   DIM Adt$[1]
   INTEGER Exist,Read,Write,Exec
   INTEGER I
   INTEGER Stat
  !
   Err$="/tmp/tplbld.err"
   Status=0                              !! Mar.02/01
  !
  !* Check the adt format *!
   SELECT Adtfmt$
   CASE "adt"
     Adt$="2"
   CASE "ad2"
     Adt$="3"
   CASE "ad3"
     Adt$="4"
   CASE "ad5"
     Adt$="5"
   CASE "1"
     Adt$=Adtfmt$
     Adtfmt$="adt"
   CASE "2"
     Adt$=Adtfmt$
     Adtfmt$="adt"
   CASE "3"
     Adt$=Adtfmt$
     Adtfmt$="ad2"
   CASE "4"
     Adt$=Adtfmt$
     Adtfmt$="ad3"
   CASE "5"
     Adt$=Adtfmt$
     Adtfmt$="ad5"
   CASE ELSE
     Status=-1
   END SELECT
   IF Status=-1 THEN SUBEXIT
  !
  !* Verify Directory *!
   Outputdir$=Dir$&"/"&File$
   Datadir$=Outputdir$
   CALL Verify_file(Outputdir$,"Directory",Exist,Read,Write,Exec)
   IF Exist=0 THEN 
     EXECUTE "mkdir "&Outputdir$&" 2> "&Err$;RETURN Stat
     IF Stat THEN Status=-1
   ELSE
     IF Write<>1 AND Exec<>1 THEN Status=-1
   END IF
   IF Status=-1 THEN SUBEXIT
  !
  !* Verify File *!
   I=1
   LOOP
     IF I=1 THEN 
       Outputfile$=Outputdir$&"/"&VAL$(Slot)&"."&Adtfmt$
       Dataname$=VAL$(Slot)
     ELSE
       Outputfile$=Outputdir$&"/"&VAL$(Slot)&"#"&VAL$(I)&"."&Adtfmt$
       Dataname$=VAL$(Slot)&"#"&VAL$(I)
     END IF
     CALL Verify_file(Outputfile$,"Normal",Exist,Read,Write,Exec)
     IF Exist<1 THEN 
       Status=0
     ELSE
       Status=-1
       I=I+1
     END IF
   EXIT IF I>99 OR Status=0
   END LOOP
  !
  !
 SUBEND
 Fa_query_cond:SUB Fa_query_cond(Key$,Level$,Filename$,Tco$(*),Limf$,Dielabel$(*),Dietype$(*),Modlabel$(*),Item$(*),INTEGER Status,Errmsg$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_QUERY_COND
  !  Vers : 1
  !  Desc : Query recipe items in the recipe file from key recipe id.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Key             S    -
  !      2 Level           S    -
  !      3 Filename        S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Tco             S    16
  !      2 Limf            S    -
  !      3 DieLabel        S    256
  !      4 DieType         S    256
  !      5 ModLabel        S    256
  !      6 Item            S    32
  !      7 Status          I    -        0: OK, -1: Exec Err, -2: No File
  !      8 Errmsg          S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[32767],Spc$[256],Line$[4096],Detail$(10)[256],Spc_nm$[256]
   INTEGER I,N_item,Ndetail,Cmd_ret
  !
   Cmd$="/opt/SPECS/usr/recipe/fa_cond_q.sh"
   Spc$="/var/tmp/spc."&SYSTEM$("PROCESS ID")
  !
   FOR I=1 TO SIZE(Item$,1)
     Item$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tco$,1)
     Tco$(I)=""
   NEXT I
   Limf$=""
   FOR I=1 TO SIZE(Dielabel$,1)
     Dielabel$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Dietype$,1)
     Dietype$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Modlabel$,1)
     Modlabel$(I)=""
   NEXT I
  !
   Cmd$=Cmd$&" "&Filename$&" "&Key$&" "&Level$
   Fa_rcp_exec_cmd(Cmd$,Spc$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
  !
   IF Cmd_ret=1 THEN Status=1
   IF Status=0 OR Status=1 THEN 
     ASSIGN @S TO Spc$;FORMAT ON
     ON END @S GOSUB Eof
  !
     FOR I=1 TO SIZE(Item$,1)
       ENTER @S;Item$(I)
     NEXT I
     Spc_nm$=""
     N_item=0
     ENTER @S;Line$
     WHILE (Line$<>"# EOD")
       IF Line$[1,2]="# " THEN 
         Spc_nm$=Line$[3;LEN(Line$)-2]
         N_item=0
       ELSE
         N_item=N_item+1
         SELECT Spc_nm$
         CASE "TCO"
           IF N_item>SIZE(Tco$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tco$(N_item)=Line$
         CASE "Limit File"
           Limf$=Line$
         CASE "DIE Label"
           IF N_item>SIZE(Dielabel$,1) THEN 
             GOSUB Array_overflow
           END IF
  !          Dielabel$(I)=Line$ 2006/02/10
           Dielabel$(N_item)=Line$
         CASE "DIE Type"
           IF N_item>SIZE(Dietype$,1) THEN 
             GOSUB Array_overflow
           END IF
  !          Dietype$(I)=Line$ 2006/02/10
           Dietype$(N_item)=Line$
         CASE "MOD Label"
           IF N_item>SIZE(Modlabel$,1) THEN 
             GOSUB Arrary_overflow
           END IF
  !          Modlabel$(I)=Line$ 2006/02/10
           Modlabel$(N_item)=Line$
         CASE ELSE
           GOSUB Eof
           SUBEXIT
         END SELECT
       END IF
  !
       ENTER @S;Line$
     END WHILE
  !
     ASSIGN @S TO *
   END IF
  !
   GOSUB Del_spc
   SUBEXIT
  !
 Eof:    !
   Status=-3
   Errmsg$="Cannot find a recipe by the key, """&Key$&"""."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Array_overflow:    !
   Status=-4
   Errmsg$="Subscript of spec name array is out of range."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Del_spc:     !
   ON ERROR GOTO Del_end
   PURGE Spc$
 Del_end:     !
   OFF ERROR 
   RETURN 
  !
 SUBEND
 Fa_query_rcp2:SUB Fa_query_rcp2(V1$,V2$,Waf$,Die$(*),Mod$(*),Tst$(*),Prb$,Lms$(*),Tco$(*),Tpl$,Lim$,Mlb$(*),Rcp$,Lt_id$,Pt_id$,Ps_id$,Item$(*),INTEGER Status,Errmsg$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_QUERY_RCP2
  !  Vers : 1
  !  Desc : Query recipe items in the recipe file from key recipe id.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Key             S    -
  !      2 Filename        S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Waf             S    -
  !      2 Die             S    256
  !      3 Mod             S    256
  !      4 Tst             S    256
  !      5 Prb             S    -
  !      6 Lms             S    256
  !      7 Tco             S    16
  !      8 Tpl             S    -
  !      9 Lim             S    -
  !     10 Mlb             S    256
  !     11 Rcp             S    -
  !     12 Lt_id           S    -
  !     13 Pt_id           S    -
  !     14 Ps_id           S    -
  !     15 Item            S    32
  !     16 Status          I    -        0: OK, -1: Exec Err, -2: No File
  !     17 Errmsg          S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Key$[255]                                    ! V1
   DIM Filename$[255]                               ! V2
   Key$=V1$
   Filename$=V2$
  !***** DON'T REMOVE THIS LINE *************************************
  !
   DIM Cmd$[32767],Spc$[256],Line$[4096],Detail$(10)[256],Spc_nm$[256]
   INTEGER I,N_item,Ndetail,Cmd_ret
  !
   Cmd$="/opt/SPECS/usr/recipe/fa_recipe_q2.sh"
   Spc$="/var/tmp/spc."&SYSTEM$("PROCESS ID")
  !
   FOR I=1 TO SIZE(Item$,1)
     Item$(I)=""
   NEXT I
   Waf$=""
   FOR I=1 TO SIZE(Die$,1)
     Die$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Mod$,1)
     Mod$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tst$,1)
     Tst$(I)=""
   NEXT I
   Prb$=""
   FOR I=1 TO SIZE(Lms$,1)
     Lms$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tco$,1)
     Tco$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Mlb$,1)
     Mlb$(I)=""
   NEXT I
   Tpl$=""
   Lim$=""
   Rcp$=""
   Lt_id$=""
   Ps_id$=""
   Pt_id$=""
  !
   Cmd$=Cmd$&" "&Filename$&" "&Key$
   PRINT Cmd$
   Fa_rcp_exec_cmd(Cmd$,Spc$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
  !
   IF Cmd_ret=1 THEN Status=1
   IF Status=0 OR Status=1 THEN 
     ASSIGN @S TO Spc$;FORMAT ON
     ON END @S GOSUB Eof
  !
     FOR I=1 TO SIZE(Item$,1)
       ENTER @S;Item$(I)
     NEXT I
     Spc_nm$=""
     N_item=0
     ENTER @S;Line$
     WHILE (Line$<>"# EOD")
       PRINT Line$
       PRINT Spc_nm$
       IF Line$[1,2]="# " THEN 
         Spc_nm$=Line$[3;LEN(Line$)-2]
         N_item=0
       ELSE
         N_item=N_item+1
         SELECT Spc_nm$
         CASE "WAF"
           Waf$=Line$
         CASE "DIE"
           IF N_item>SIZE(Die$,1) THEN 
             GOSUB Array_overflow
           END IF
           Die$(N_item)=Line$
         CASE "MOD"
           IF N_item>SIZE(Mod$,1) THEN 
             GOSUB Array_overflow
           END IF
           Mod$(N_item)=Line$
         CASE "TST"
           IF N_item>SIZE(Tst$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tst$(N_item)=Line$
         CASE "PRB"
           Prb$=Line$
         CASE "LMS"
           IF N_item>SIZE(Lms$,1) THEN 
             GOSUB Array_overflow
           END IF
           Lms$(N_item)=Line$
         CASE "TCO"
           IF N_item>SIZE(Tco$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tco$(N_item)=Line$
         CASE "TPL"
           Tpl$=Line$
         CASE "Limit File"
           Lim$=Line$
         CASE "Prober RCP"
           Rcp$=Line$
         CASE "STEP"
           Lot_id$=Line$
         CASE "PRODUCT"
           Pt_id$=Line$
         CASE "PROCESS"
           Ps_id$=Line$
         CASE "MEASLIBS"
           IF N_item>SIZE(Mlb$,1) THEN 
             GOSUB Array_overflow
           END IF
           Mlb$(N_item)=Line$
         CASE ELSE
           GOSUB Eof
           SUBEXIT
         END SELECT
       END IF
  !
       ENTER @S;Line$
     END WHILE
  !
     ASSIGN @S TO *
   END IF
  !
   GOSUB Del_spc
   SUBEXIT
  !
 Eof:    !
   Status=-3
   Errmsg$="Cannot find a recipe by the key, """&Key$&"""."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Array_overflow:    !
   Status=-4
   Errmsg$="Subscript of spec name array is out of range."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Del_spc:     !
   ON ERROR GOTO Del_end
   PURGE Spc$
 Del_end:     !
   OFF ERROR 
   RETURN 
  !
 SUBEND
 Fa_query_recip:SUB Fa_query_recip(Key$,Filename$,Waf$,Die$(*),Mod$(*),Tst$(*),Prb$,Lms$(*),Tco$(*),Tpl$,Lim$,Rcp$,Lt_id$,Pt_id$,Ps_id$,Item$(*),INTEGER Status,Errmsg$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_QUERY_RECIP
  !  Vers : 1
  !  Desc : Query recipe items in the recipe file from key recipe id.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Key             S    -
  !      2 Filename        S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Waf             S    -
  !      2 Die             S    256
  !      3 Mod             S    256
  !      4 Tst             S    256
  !      5 Prb             S    -
  !      6 Lms             S    256
  !      7 Tco             S    16
  !      8 Tpl             S    -
  !      9 Lim             S    -
  !     10 Rcp             S    -
  !     11 Lt_id           S    -
  !     12 Pt_id           S    -
  !     13 Ps_id           S    -
  !     14 Item            S    32
  !     15 Status          I    -        0: OK, -1: Exec Err, -2: No File
  !     16 Errmsg          S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[32767],Spc$[256],Line$[4096],Detail$(10)[256],Spc_nm$[256]
   INTEGER I,N_item,Ndetail,Cmd_ret
  !
   Cmd$="/opt/SPECS/usr/recipe/fa_recipe_q.sh"
   Spc$="/var/tmp/spc."&SYSTEM$("PROCESS ID")
  !
   FOR I=1 TO SIZE(Item$,1)
     Item$(I)=""
   NEXT I
   Waf$=""
   FOR I=1 TO SIZE(Die$,1)
     Die$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Mod$,1)
     Mod$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tst$,1)
     Tst$(I)=""
   NEXT I
   Prb$=""
   FOR I=1 TO SIZE(Lms$,1)
     Lms$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tco$,1)
     Tco$(I)=""
   NEXT I
   Tpl$=""
   Lim$=""
   Rcp$=""
   Lt_id$=""
   Ps_id$=""
   Pt_id$=""
  !
   Cmd$=Cmd$&" "&Filename$&" "&Key$
   PRINT Cmd$
   Fa_rcp_exec_cmd(Cmd$,Spc$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
  !
   IF Cmd_ret=1 THEN Status=1
   IF Status=0 OR Status=1 THEN 
     ASSIGN @S TO Spc$;FORMAT ON
     ON END @S GOSUB Eof
  !
     FOR I=1 TO SIZE(Item$,1)
       ENTER @S;Item$(I)
     NEXT I
     Spc_nm$=""
     N_item=0
     ENTER @S;Line$
     WHILE (Line$<>"# EOD")
       PRINT Line$
       PRINT Spc_nm$
       IF Line$[1,2]="# " THEN 
         Spc_nm$=Line$[3;LEN(Line$)-2]
         N_item=0
       ELSE
         N_item=N_item+1
         SELECT Spc_nm$
         CASE "WAF"
           Waf$=Line$
         CASE "DIE"
           IF N_item>SIZE(Die$,1) THEN 
             GOSUB Array_overflow
           END IF
           Die$(N_item)=Line$
         CASE "MOD"
           IF N_item>SIZE(Mod$,1) THEN 
             GOSUB Array_overflow
           END IF
           Mod$(N_item)=Line$
         CASE "TST"
           IF N_item>SIZE(Tst$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tst$(N_item)=Line$
         CASE "PRB"
           Prb$=Line$
         CASE "LMS"
           IF N_item>SIZE(Lms$,1) THEN 
             GOSUB Array_overflow
           END IF
           Lms$(N_item)=Line$
         CASE "TCO"
           IF N_item>SIZE(Tco$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tco$(N_item)=Line$
         CASE "TPL"
           Tpl$=Line$
         CASE "Limit File"
           Lim$=Line$
         CASE "Prober RCP"
           Rcp$=Line$
         CASE "STEP"
           Lot_id$=Line$
         CASE "PRODUCT"
           Pt_id$=Line$
         CASE "PROCESS"
           Ps_id$=Line$
         CASE ELSE
           GOSUB Eof
           SUBEXIT
         END SELECT
       END IF
  !
       ENTER @S;Line$
     END WHILE
  !
     ASSIGN @S TO *
   END IF
  !
   GOSUB Del_spc
   SUBEXIT
  !
 Eof:    !
   Status=-3
   Errmsg$="Cannot find a recipe by the key, """&Key$&"""."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Array_overflow:    !
   Status=-4
   Errmsg$="Subscript of spec name array is out of range."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Del_spc:     !
   ON ERROR GOTO Del_end
   PURGE Spc$
 Del_end:     !
   OFF ERROR 
   RETURN 
  !
 SUBEND
 Fa_rcp_exec_cmd:SUB Fa_rcp_exec_cmd(Cmd$,Result$,INTEGER Status,Errmsg$,INTEGER Ndetail,Detail$(*),INTEGER Cmd_ret)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_RCP_EXEC_CMD
  !  Vers : 1
  !  Desc : Execute command file and get result file.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Cmd             S    -
  !      2 Result          S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0: OK, -1: Exec Err, -2: No File
  !      2 Errmsg          S    -
  !      3 Ndetail         I    -        # of lines of detail error messa
  !      4 Detail          S    10       Detailed error message
  !      5 Cmd_ret         I    -        Return value from Command
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Err$[256],Cl$[32767]
   DIM Ver$[64]
   INTEGER Arg_max
   INTEGER St,I
  !
   Ndetail=0
   FOR I=1 TO 10
     Detail$(I)=""
   NEXT I
   Cmd_ret=0
  !
   IF Cmd$="" THEN 
     Status=-2
     Errmsg$="No command is specified."
     SUBEXIT
   END IF
  !
   EXECUTE "/usr/bin/touch "&Result$;RETURN St
   IF St THEN 
     Status=-2
     Errmsg$="Cannot store the result. """&Result$&""""
     SUBEXIT
   END IF
  !
   Err$="/var/tmp/rcp_exec_cmd."&SYSTEM$("PROCESS ID")
   Status=0
   Errmsg$=""
  !
   ON ERROR GOTO Str_overflow
   Cl$=Cmd$&" > "&Result$&" 2> "&Err$
   OFF ERROR 
  !
   Ver$=SYSTEM$("VERSION:OS")
   Ver$=Ver$[3;5]
   IF Ver$<="10.20" THEN 
     Arg_max=20478
     IF LEN(Cl$)>Arg_max THEN 
       GOSUB Str_overflow
     END IF
   END IF
  !
   EXECUTE Cl$;RETURN St
  !
   Cmd_ret=SHIFT(St,8) MOD 256
   IF Cmd_ret>=128 THEN Cmd_ret=Cmd_ret-256
  !
   IF St<>0 THEN 
     Status=-1
     ON ERROR GOTO No_errfl
     ASSIGN @E TO Err$;FORMAT ON
     ASSIGN @E TO *
     OFF ERROR 
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO Eof
     FOR I=1 TO 10
       ENTER @E;Detail$(I)
       Ndetail=I
     NEXT I
 Eof:    !
     OFF END @E
     ASSIGN @E TO *
  !
     IF Ndetail>0 THEN 
       Errmsg$=Detail$(1)
     ELSE
       Errmsg$="Error found while executing: "&Cl$
     END IF
   END IF
   PURGE Err$
   SUBEXIT
  !
 Str_overflow:    !
   Status=-1
   Errmsg$="Internal string buffer overflow."
   PURGE Err$
   SUBEXIT
  !
 No_errfl:    !
   OFF ERROR            ! 2005/11/01
   Status=-1
   Errmsg$="Cannot execute command: "&Cl$
   ON ERROR GOTO Exit   ! 2005/11/01
   PURGE Err$
   SUBEXIT
  !
 Exit:                  ! 2005/11/01
   OFF ERROR            ! 2005/11/01
   SUBEXIT              ! 2005/11/01
 SUBEND
 Fa_read_card:SUB Fa_read_card(Cardpath$,Cardtype$,Cardname$,REAL Totalcount,Limitcount,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_READ_CARD
  !  Vers : 1
  !  Desc : Desc: Read name, type, and count in probe card.
  !       : Date: '00/11/27 1st revision
  !       : Date: '01/10/07 Read file and return the parameters.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 CardPath        S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 CardType        S    -        Card Type
  !      2 CardName        S    -        Card Name
  !      3 TotalCount      R    -        Total Touchdown Count
  !      4 LimitCount      R    -        Limit of Touchdonw Cound
  !      5 Status          I    -        0:OK -1:Error
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Revision$[255]
   DIM Date$[255]
   DIM Filename$[255]
   DIM Read_file$[255]
   INTEGER Exist,Writable,Readable,Executable
   INTEGER Flag
  !
   Status=0
   Writable=0
  !
   GOSUB Search_card
   GOSUB Read_file
   GOSUB Verify_file
   SUBEXIT
  !
  !!!!! Searching a cardname !!!!!
 Search_card:     !
   Read_file$=Cardpath$&"/"&"read_card"
   ON ERROR GOTO Read_file_err
   ASSIGN @File TO Read_file$
   ENTER @File USING "#,K";Cardname$
   ENTER @File USING "#,K";Cardtype$
   ASSIGN @File TO *
 Read_file_err:      !
   OFF ERROR 
   ASSIGN @File TO *
   IF Cardname$="" THEN 
     Cardname$="cardfile"
   END IF
   IF Cardtype$="" THEN 
     Cardtype$="CardType"
   END IF
   RETURN 
  !
  !!!!! Read parameters from found cardname !!!!!
 Read_file:  !
   Filename$=Cardpath$&"/"&Cardname$
   ON ERROR GOTO Read_card_end
   ASSIGN @File TO Filename$
   ENTER @File USING "#,K";Revision$
   ENTER @File USING "#,K";Totalcount
   ENTER @File USING "#,K";Limitcount
   ENTER @File USING "#,K";Date$
   ASSIGN @File TO *
   OFF ERROR 
   RETURN 
  !
  !!!!! Check the permission !!!!!
 Verify_file:  !
   CALL Verify_file(Filename$,"Normal",Exist,Readable,Writable,Executable)
   IF Writable<>1 THEN GOTO Read_card_end
   RETURN 
  !
 Read_card_end:   !
   OFF ERROR 
   ASSIGN @File TO *
   Status=-1
   Cardtype$=""
   Cardname$=""
   Totalcount=0
   Limitcount=0
   Date$=""
  !
 SUBEND
 Fa_runp_create:SUB Fa_runp_create(Meas_dir$,Fwk_dir$,Meas$,Fwk$,INTEGER Status,Error$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_RUNP_CREATE
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Meas_dir        S    -
  !      2 Fwk_dir         S    -
  !      3 Meas            S    -
  !      4 Fwk             S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -
  !      2 Error           S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   EXECUTE "rm -f /usr/tmp/param"
   EXECUTE "touch /usr/tmp/param"
   ON ERROR GOTO Err
   ASSIGN @Runfile TO "/usr/tmp/param";FORMAT ON
   ON END @Runfile GOTO Endoffile
   OUTPUT @Runfile USING "-,K";"-f"&Fwk_dir$&Fwk$
   OUTPUT @Runfile USING "-,K";"-a"&Meas_dir$&Meas$
   PRINT USING "-,K";"-f"&Fwk_dir$&"|"&Fwk$
   PRINT USING "-,K";"-a"&Meas_dir$&"|"&Meas$
   ASSIGN @Runfile TO *
   SUBEXIT
  !
 Err:   !
   Status=-9
   SUBEXIT
 Endoffile:  !
   Status=-1
   ASSIGN @Runfile TO *
   Error$="run param file not found."
 SUBEND
 Fa_tpl_run:SUB Fa_tpl_run(Session$,INTEGER Status,Error$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_TPL_RUN
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -
  !      2 Error           S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   EXECUTE "/opt/SPECS/sys/bin/sslnc -g"&Session$&" -e/usr/tmp/param";RETURN Status
   IF Status=0 THEN 
     Error$=""
   ELSE
     Error$="ERROR"
   END IF
 SUBEND
 Fa_tpl_verify:SUB Fa_tpl_verify(INTEGER Revcont,Revmode,Lib$(*),INTEGER Libnum,Tco$(*),INTEGER Tconum,Tpl$,Delimiter$,INTEGER Status,Error$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_TPL_VERIFY
  !  Vers : 1
  !  Desc : Validate test plan with multi-measurement libraries and t
  !       : est plan constants.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Revcont         I    -        Revision Control Mode
  !      2 Revmode         I    -        Revision Name/Number Option
  !      3 Lib             S    256      Measurement Library File (with R
  !      4 Libnum          I    -        Number of Measurement Library
  !      5 Tco             S    256      Test Plan Constant File (with Re
  !      6 Tconum          I    -        Number of Test Plan Constant
  !      7 Tpl             S    -        Test Plan File (with Revision)
  !      8 Delimiter       S    -        Delimiter between File and Revis
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Error Code
  !      2 Error           S    -        Error Message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Problib$[256],Testlib$[256],Utillib$[256],Devlib$[256],Fwknam$[256]
   DIM Probrev$[256],Testrev$[256],Utilrev$[256],Devrev$[256],Fwkrev$[256]
   INTEGER Probnum,Testnum,Utilnum,Devnum,Fwknum
   DIM Measlib$[256],Tconam$[256],Tplnam$[256]
   DIM Measrev$[256],Tcorev$[256],Tplrev$[256]
   INTEGER Measnum
   INTEGER Cnt,Num,Pos,Rslt
   DIM Tplverify$[32767],Revopen$[32767]
   DIM Exeverify$[256]
  !
   Status=0
   Error$=""
   Tplverify$="/opt/SPECS/sys/bin/tplverify"
   Exeverify$="/var/tmp/tplverify."&SYSTEM$("PROCESS ID")
  !
   Tplfileplib(Problib$,Probrev$,Probnum)
   IF Probnum<>0 THEN 
     Tplverify$=Tplverify$&" -p "&Problib$
   END IF
   Tplfiletlib(Testlib$,Testrev$,Testnum)
   IF Testnum<>0 THEN 
     Tplverify$=Tplverify$&" -t "&Testlib$
   END IF
   Tplfileulib(Utillib$,Utilrev$,Utilnum)
   IF Utilnum<>0 THEN 
     Tplverify$=Tplverify$&" -u "&Utillib$
   END IF
   Tplfiledlib(Devlib$,Devrev$,Devnum)
   IF Devnum<>0 THEN 
     Tplverify$=Tplverify$&" -dvl "&Devlib$
   END IF
   Tplfilefwk(Fwknam$,Fwkrev$,Fwknum)
   IF Fwknum<>0 THEN 
     Tplverify$=Tplverify$&" -fwk "&Fwknam$
   END IF
  !
   FOR Cnt=1 TO Libnum
 Libnext:    !
     IF Cnt>Libnum OR Cnt>256 THEN 
       GOTO Libend
     END IF
     IF LEN(Lib$(Cnt))=0 THEN 
       Cnt=Cnt+1
       GOTO Libnext
     END IF
  !
     Measlib$=Lib$(Cnt)
     IF Revcont<>0 THEN 
       Pos=POS(Measlib$,Delimiter$)
       IF Pos<>0 THEN 
         Measrev$=Measlib$[LEN(Measlib$)-Pos+1,LEN(Measlib$)]
         Measlib$=Measlib$[1,LEN(Measlib$)-Pos]
       END IF
     END IF
     IF Measlib$[1,1]<>"/" THEN 
       Measlib$="/opt/SPECS/usr/alg/"&Measlib$
     END IF
     IF Cnt=1 THEN 
       Tplverify$=Tplverify$&" -m "&Measlib$
     ELSE
       Tplverify$=Tplverify$&","&Measlib$
     END IF
       !
     IF LEN(Measrev$)<>0 THEN 
       IF Revmode<>0 THEN 
         Revopen$="/opt/SPECS/sys/bin/revopen -t lib -n "&Measrev$&" "&Measlib$
       ELSE
         Revopen$="/opt/SPECS/sys/bin/revopen -t lib -a "&Measrev$&" "&Measlib$
       END IF
       EXECUTE Revopen$;RETURN Rslt
       IF Rslt<>0 THEN 
         Status=-2
         Error$="Fail to open measurement library as revision : "&Measlib$&", "&Measrev$
         SUBEXIT
       END IF
     END IF
   NEXT Cnt
  !
   IF Libnum=0 THEN 
     Tplfilenummlib(Num)
     FOR Cnt=1 TO Num
       Tplfilemlibm(Cnt-1,Measlib$,Measrev$,Measnum)
       IF Cnt=1 THEN 
         Tplverify$=Tplverify$&" -m "&Measlib$
       ELSE
         Tplverify$=Tplverify$&","&Measlib$
       END IF
     NEXT Cnt
   END IF
 Libend:    !
  !
   FOR Cnt=1 TO Tconum
 Tconext:    !
     IF Cnt>Tconum OR Cnt>256 THEN 
       GOTO Tcoend
     END IF
     IF LEN(Tco$(Cnt))=0 THEN 
       Cnt=Cnt+1
       GOTO Tconext
     END IF
       !
     Tconam$=Tco$(Cnt)
     IF Revcont<>0 THEN 
       Pos=POS(Tconam$,Delimiter$)
       IF Pos<>0 THEN 
         Tcorev$=Tconam$[LEN(Tconam$)-Pos+1,LEN(Tconam$)]
         Tconam$=Tconam$[1,LEN(Tconam$)-Pos]
       END IF
     END IF
     IF Tconam$[1,1]<>"/" THEN 
       Tconam$="/opt/SPECS/usr/tco/"&Tconam$
     END IF
     Tplverify$=Tplverify$&" -tco "&Tconam$
       !
     IF LEN(Tcorev$)<>0 THEN 
       IF Revmode<>0 THEN 
         Revopen$="/opt/SPECS/sys/bin/revopen -t tco -n "&Tcorev$&" "&Tconam$
       ELSE
         Revopen$="/opt/SPECS/sys/bin/revopen -t tco -a "&Tcorev$&" "&Tconam$
       END IF
       EXECUTE Revopen$;RETURN Rslt
       IF Rslt<>0 THEN 
         Status=-3
         Error$="Fail to open test plan constant as revision : "&Tconam$&", "&Tcorev$
         SUBEXIT
       END IF
     END IF
   NEXT Cnt
  !
   IF Tconum=0 THEN 
     Tplfilenumtco(Num)
     FOR Cnt=1 TO Num
       Tplfiletco(Cnt-1,Tconam$,Tcorev$,Tconum)
       Tplverify$=Tplverify$&" -tco "&Tconam$
     NEXT Cnt
   END IF
 Tcoend:    !
  !
   IF LEN(Tpl$)=0 THEN 
     Status=-5
     Error$="Test plan is not specified"
     SUBEXIT
   END IF
   Tplnam$=Tpl$
   IF Revcont<>0 THEN 
     Pos=POS(Tplnam$,Delimiter$)
     IF Pos<>0 THEN 
       Tplrev$=Tplnam$[LEN(Tplnam$)-Pos+1,LEN(Tplnam$)]
       Tplnam$=Tplnam$[1,LEN(Tplnam$)-Pos]
     END IF
   END IF
   IF Tplnam$[1,1]<>"/" THEN 
     Tplnam$="/opt/SPECS/usr/tpl/"&Tplnam$
   END IF
   Tplverify$=Tplverify$&" "&Tplnam$
   IF Tplverify$[LEN(Tplverify$)-LEN(".tpl")+1,LEN(Tplverify$)]<>".tpl" THEN 
     Tplverify$=Tplverify$&".tpl"
   END IF
  !
   IF LEN(Tplrev$)<>0 THEN 
     IF Revmode<>0 THEN 
       Revopen$="/opt/SPECS/sys/bin/revopen -t tpl -n "&Tplrev$&" "&Tplnam$
     ELSE
       Revopen$="/opt/SPECS/sys/bin/revopen -t tpl -a "&Tplrev$&" "&Tplnam$
     END IF
     EXECUTE Revopen$;RETURN Rslt
     IF Rslt<>0 THEN 
       Status=-4
       Error$="Fail to open test plan as revision : "&Tplnam$&", "&Tplrev$
       SUBEXIT
     END IF
   END IF
 Tplend:    !
  !
   ON ERROR GOTO Nofile
   PURGE Exeverify$
  !
 Nofile:    !
   ON ERROR GOTO Err
   CREATE Exeverify$,1
   ASSIGN @File TO Exeverify$;FORMAT ON
   OUTPUT @File;Tplverify$
   ASSIGN @File TO *
     !
   ASSIGN @Pipe TO "sh "&Exeverify$&" |"
   ON END @Pipe GOTO Norm
   ENTER @Pipe;Error$
   GOTO Norm
  !
 Err:    !
   ASSIGN @File TO *
   OFF ERROR 
   Status=-5
   Error$="Fail to open file"
   PURGE Exeverify$
   SUBEXIT
  !
 Norm:    !
   ASSIGN @File TO *
   OFF END @Pipe
   OFF ERROR 
   IF LEN(Error$)<>0 THEN 
     Status=-1
   END IF
   PURGE Exeverify$
   SUBEXIT
 SUBEND
 Fa_tplbld:SUB Fa_tplbld(INTEGER V1,V2$,V3$,V4$,V5$,V6$,V7$,V8$,V9$,V10$(*),V11$(*),V12$,INTEGER Status,Error$,INTEGER Ndetail,Detail$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_TPLBLD
  !  Vers : 1
  !  Desc : This algorithm generates Test Plan dynamically.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Rev_flag        I    -        0:Revision Control not available
  !      2 Brk_chr         S    -        Connection char between filename
  !      3 Waf_dir         S    -        Wafer spec search directory
  !      4 Prb_dir         S    -        Probe spec search directory
  !      5 Die_dir         S    -        Die spec search directory
  !      6 Tst_dir         S    -        Test spec search directory
  !      7 Tpl_dir         S    -        Testplan directory
  !      8 Waf             S    -        Wafer spec name to read
  !      9 Prb             S    -        Probe spec name to read
  !     10 Die             S    32       Die spec name to read
  !     11 Tst             S    32       Test spec name to read
  !     12 Tpl             S    -        Test Plan name to write
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Command status
  !      2 Error           S    -        Error message
  !      3 Ndetail         I    -        # of lines of detail error messa
  !      4 Detail          S    10       detailed error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Rev_flag                                 ! V1
   DIM Brk_chr$[255]                                ! V2
   DIM Waf_dir$[255]                                ! V3
   DIM Prb_dir$[255]                                ! V4
   DIM Die_dir$[255]                                ! V5
   DIM Tst_dir$[255]                                ! V6
   DIM Tpl_dir$[255]                                ! V7
   DIM Waf$[255]                                    ! V8
   DIM Prb$[255]                                    ! V9
   DIM Die$(1:32)[255]                              ! V10
   DIM Tst$(1:32)[255]                              ! V11
   DIM Tpl$[255]                                    ! V12
   Rev_flag=V1
   Brk_chr$=V2$
   Waf_dir$=V3$
   Prb_dir$=V4$
   Die_dir$=V5$
   Tst_dir$=V6$
   Tpl_dir$=V7$
   Waf$=V8$
   Prb$=V9$
   MAT Die$= V10$
   MAT Tst$= V11$
   Tpl$=V12$
  !***** DON'T REMOVE THIS LINE *************************************
   DIM Cmd$[256],Opt$[4096],Err$[256]
   DIM Optdie$[4096],Optdt$[4096],Mopt$[8192]
   DIM Fulltpl$[512]
   DIM W$[256],P$[256],D$[256],T$[256],Tp$[256]
   DIM Wd$[256],Pd$[256],Dd$[256],Td$[256]
   INTEGER I,J,Stat
   INTEGER Dietst_num
  !
   ON ERROR GOTO Basic_syserr
   Dietst_num=SIZE(Die$,1)
   ALLOCATE INTEGER Tstflg(Dietst_num)
  !
   CALL Fa_chk_files(Rev_flag,Waf_dir$,Waf$,"waf",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-11
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Prb_dir$,Prb$,"prb",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-12
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Tpl_dir$,Tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-3 THEN GOTO File_check_err
   W$=Waf$
   P$=Prb$
   Tp$=Tpl$
   IF POS(W$,Brk_chr$)>0 THEN W$=Waf$[1,POS(Waf$,Brk_chr$)-1]
   IF POS(P$,Brk_chr$)>0 THEN P$=Prb$[1,POS(Prb$,Brk_chr$)-1]
   IF POS(Tp$,Brk_chr$)>0 THEN Tp$=Tpl$[1,POS(Tpl$,Brk_chr$)-1]
   Wd$=Waf_dir$
   Pd$=Prb_dir$
   Dd$=Die_dir$
   Td$=Tst_dir$
   IF Wd$[LEN(Wd$)]<>"/" THEN Wd$=Wd$&"/"
   IF Pd$[LEN(Pd$)]<>"/" THEN Pd$=Pd$&"/"
   IF Dd$[LEN(Dd$)]<>"/" THEN Dd$=Dd$&"/"
   IF Td$[LEN(Td$)]<>"/" THEN Td$=Td$&"/"
  !
   Cmd$="/opt/SPECS/sys/bin/tplbuild"
   Opt$=" -waf "&Wd$&W$&" -prb "&Pd$&P$
   MAT Tstflg= (1)
   Optdie$=""
   Optdt$=""
   FOR I=1 TO Dietst_num
     IF Die$(I)<>"" AND Tst$(I)<>"" AND Tstflg(I)=1 THEN 
       CALL Fa_chk_files(Rev_flag,Die_dir$,Die$(I),"die",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-13
         GOTO File_check_err2
       END IF
       CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(I),"tst",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-14
         GOTO File_check_err2
       END IF
       D$=Die$(I)
       T$=Tst$(I)
       IF POS(D$,Brk_chr$)>0 THEN D$=Die$(I)[1,POS(Die$(I),Brk_chr$)-1]
       IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(I)[1,POS(Tst$(I),Brk_chr$)-1]
       Optdie$=Optdie$&" -die "&Dd$&D$
       Optdt$=Optdt$&" -tst "&Dd$&D$&" "&Td$&T$
       IF I<Dietst_num THEN 
         FOR J=I+1 TO Dietst_num
           IF Die$(I)=Die$(J) AND Tstflg(J)=1 THEN 
             CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(J),"tst",Brk_chr$,Stat)
             IF Stat<-1 THEN 
               Status=-14
               GOTO File_check_err
             END IF
             T$=Tst$(J)
             IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(J)[1,POS(Tst$(J),Brk_chr$)-1]
             Optdt$=Optdt$&","&Td$&T$
             Tstflg(J)=0
           END IF
         NEXT J
       END IF
     END IF
   NEXT I
   Err$="/usr/tmp/tplbld.err"
   Fulltpl$=Tpl_dir$
   IF Tpl_dir$[LEN(Tpl_dir$)]<>"/" THEN Fulltpl$=Fulltpl$&"/"
   Fulltpl$=Fulltpl$&Tp$
   IF POS(Fulltpl$,".tpl")=0 THEN Fulltpl$=Fulltpl$&".tpl"
   EXECUTE Cmd$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$;RETURN Stat
  !!PRINT Cmd$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO E
     Error$="ERROR"
     ENTER @E;Error$
     Ndetail=0
     LOOP
       ENTER @E;Detail$(Ndetail+1)
       Ndetail=Ndetail+1
     END LOOP
 E:  ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
   PURGE Err$
   DEALLOCATE Tstflg(*)
   SUBEXIT
 File_check_err: !
   Status=-1
 File_check_err2: !
   Error$="File_check_error "&VAL$(Stat)
   DEALLOCATE Tstflg(*)
   SUBEXIT
 Basic_syserr: !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
   DEALLOCATE Tstflg(*)
 SUBEND
 Fa_tplbld2:SUB Fa_tplbld2(INTEGER V1,V2$,V3$,V4$,V5$,V6$,V7$,V8$,V9$,V10$,V11$(*),V12$(*),V13$(*),V14$,V15$,V16$,V17$,V18$,V19$,INTEGER Status,Error$,INTEGER Ndetail,Detail$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_TPLBLD2
  !  Vers : 1
  !  Desc : This algorithm generates Test Plan dynamically.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Rev_flag        I    -        0:Revision Control not available
  !      2 Brk_chr         S    -        Connection char between filename
  !      3 Waf_dir         S    -        Wafer spec search directory
  !      4 Prb_dir         S    -        Probe spec search directory
  !      5 Die_dir         S    -        Die spec search directory
  !      6 Tst_dir         S    -        Test spec search directory
  !      7 Mod_dir         S    -        Module spec search directory
  !      8 Tpl_dir         S    -        Testplan directory
  !      9 Waf             S    -        Wafer spec name to read
  !     10 Prb             S    -        Probe spec name to read
  !     11 Die             S    256      Die spec name to read
  !     12 Tst             S    256      Test spec name to read
  !     13 Mod             S    256      Module spec name to read
  !     14 Tpl             S    -        Test Plan name to write
  !     15 Meas            S    -        Measurement lib
  !     16 Tester          S    -        Tester lib
  !     17 Prober          S    -        Prober lib
  !     18 Utility         S    -        Utility lib
  !     19 Device          S    -        Device lib
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Command status
  !      2 Error           S    -        Error message
  !      3 Ndetail         I    -        # of lines of detail error messa
  !      4 Detail          S    10       detailed error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Rev_flag                                 ! V1
   DIM Brk_chr$[255]                                ! V2
   DIM Waf_dir$[255]                                ! V3
   DIM Prb_dir$[255]                                ! V4
   DIM Die_dir$[255]                                ! V5
   DIM Tst_dir$[255]                                ! V6
   DIM Mod_dir$[255]                                ! V7
   DIM Tpl_dir$[255]                                ! V8
   DIM Waf$[255]                                    ! V9
   DIM Prb$[255]                                    ! V10
   DIM Die$(1:256)[255]                             ! V11
   DIM Tst$(1:256)[255]                             ! V12
   DIM Mod$(1:256)[255]                             ! V13
   DIM Tpl$[255]                                    ! V14
   DIM Meas$[255]                                   ! V15
   DIM Tester$[255]                                 ! V16
   DIM Prober$[255]                                 ! V17
   DIM Utility$[255]                                ! V18
   DIM Device$[255]                                 ! V19
   Rev_flag=V1
   Brk_chr$=V2$
   Waf_dir$=V3$
   Prb_dir$=V4$
   Die_dir$=V5$
   Tst_dir$=V6$
   Mod_dir$=V7$
   Tpl_dir$=V8$
   Waf$=V9$
   Prb$=V10$
   MAT Die$= V11$
   MAT Tst$= V12$
   MAT Mod$= V13$
   Tpl$=V14$
   Meas$=V15$
   Tester$=V16$
   Prober$=V17$
   Utility$=V18$
   Device$=V19$
  !***** DON'T REMOVE THIS LINE *************************************
   DIM Cmd$[256],Opt$[4096],Err$[256]
   DIM Optdie$[4096],Optdt$[4096],Mopt$[4096]
   DIM Fulltpl$[512]
   DIM W$[256],P$[256],D$[256],T$[256],Tp$[256]
   DIM Wd$[256],Pd$[256],Dd$[256],Td$[256]
   DIM Md$[256],M$[256]   ! 2005/11/01
   INTEGER I,J,Stat
   INTEGER Dietst_num,Mod_num
  !
   ON ERROR GOTO Basic_syserr
   Dietst_num=SIZE(Die$,1)
   Mod_num=SIZE(Mod$,1)
   ALLOCATE INTEGER Tstflg(Dietst_num)
  !
   CALL Fa_chk_files(Rev_flag,Waf_dir$,Waf$,"waf",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-11
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Prb_dir$,Prb$,"prb",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-12
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Tpl_dir$,Tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-3 THEN GOTO File_check_err
   W$=Waf$
   P$=Prb$
   Tp$=Tpl$
   IF POS(W$,Brk_chr$)>0 THEN W$=Waf$[1,POS(Waf$,Brk_chr$)-1]
   IF POS(P$,Brk_chr$)>0 THEN P$=Prb$[1,POS(Prb$,Brk_chr$)-1]
   IF POS(Tp$,Brk_chr$)>0 THEN Tp$=Tpl$[1,POS(Tpl$,Brk_chr$)-1]
   Wd$=Waf_dir$
   Pd$=Prb_dir$
   Dd$=Die_dir$
   Td$=Tst_dir$
   Md$=Mod_dir$   ! 2005/11/01
   IF Wd$[LEN(Wd$)]<>"/" THEN Wd$=Wd$&"/"
   IF Pd$[LEN(Pd$)]<>"/" THEN Pd$=Pd$&"/"
   IF Dd$[LEN(Dd$)]<>"/" THEN Dd$=Dd$&"/"
   IF Td$[LEN(Td$)]<>"/" THEN Td$=Td$&"/"
   IF Md$[LEN(Md$)]<>"/" THEN Md$=Md$&"/"   ! 2005/11/01
  !
   Cmd$="/opt/SPECS/sys/bin/tplbuild"
   Opt$=" -waf "&Wd$&W$&" -prb "&Pd$&P$
   Mopt$=""
   FOR I=1 TO Mod_num
     IF Mod$(I)="" THEN 
       GOTO Modloopexit
     END IF
     CALL Fa_chk_files(Rev_flag,Mod_dir$,Mod$(I),"mod",Brk_chr$,Stat)
     IF Stat<-1 THEN 
       Status=-15
       GOTO Filecheck_err2
     END IF
     Mopt$=Mopt$&" -mod "
     M$=Mod$(I)   ! 2005/11/01
     IF POS(M$,Brk_chr$)>0 THEN M$=Mod$(I)[1,POS(Mod$(I),Brk_chr$)-1]   ! 2005/11/01
     Mopt$=Mopt$&Md$&M$
  !   Mopt$=Mopt$&Mod$(I)  ! 2005/11/01
   NEXT I
 Modloopexit:   !
   IF Meas$<>"" THEN 
     Mopt$=Mopt$&" -m "&Meas$
   END IF
   IF Tester$<>"" THEN 
     Mopt$=Mopt$&" -t "&Tester$
   END IF
   IF Prober$<>"" THEN 
     Mopt$=Mopt$&" -p "&Prober$
   END IF
   IF Utility$<>"" THEN 
     Mopt$=Mopt$&" -u "&Utility$
   END IF
   IF Device$<>"" THEN 
     Mopt$=Mopt$&" -dvl "&Device$
   END IF
   MAT Tstflg= (1)
   Optdie$=""
   Optdt$=""
   FOR I=1 TO Dietst_num
     IF Die$(I)<>"" AND Tst$(I)<>"" AND Tstflg(I)=1 THEN 
       CALL Fa_chk_files(Rev_flag,Die_dir$,Die$(I),"die",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-13
         GOTO File_check_err2
       END IF
       CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(I),"tst",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-14
         GOTO File_check_err2
       END IF
       D$=Die$(I)
       T$=Tst$(I)
       IF POS(D$,Brk_chr$)>0 THEN D$=Die$(I)[1,POS(Die$(I),Brk_chr$)-1]
       IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(I)[1,POS(Tst$(I),Brk_chr$)-1]
       Optdie$=Optdie$&" -die "&Dd$&D$
       Optdt$=Optdt$&" -tst "&Dd$&D$&" "&Td$&T$
       IF I<Dietst_num THEN 
         FOR J=I+1 TO Dietst_num
           IF Die$(I)=Die$(J) AND Tstflg(J)=1 THEN 
             CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(J),"tst",Brk_chr$,Stat)
             IF Stat<-1 THEN 
               Status=-14
               GOTO File_check_err
             END IF
             T$=Tst$(J)
             IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(J)[1,POS(Tst$(J),Brk_chr$)-1]
             Optdt$=Optdt$&","&Td$&T$
             Tstflg(J)=0
           END IF
         NEXT J
       END IF
     END IF
   NEXT I
   Err$="/usr/tmp/tplbld.err"
   Fulltpl$=Tpl_dir$
   IF Tpl_dir$[LEN(Tpl_dir$)]<>"/" THEN Fulltpl$=Fulltpl$&"/"
   Fulltpl$=Fulltpl$&Tp$
   IF POS(Fulltpl$,".tpl")=0 THEN Fulltpl$=Fulltpl$&".tpl"
   EXECUTE Cmd$&Mopt$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$;RETURN Stat
  !!PRINT Cmd$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO E
     Error$="ERROR"
     ENTER @E;Error$
     Ndetail=0
     LOOP
       ENTER @E;Detail$(Ndetail+1)
       Ndetail=Ndetail+1
     END LOOP
 E:  ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
   PURGE Err$
   DEALLOCATE Tstflg(*)
   SUBEXIT
 File_check_err: !
   Status=-1
 File_check_err2: !
   Error$="File_check_error "&VAL$(Stat)
   DEALLOCATE Tstflg(*)
   SUBEXIT
 Basic_syserr: !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
   DEALLOCATE Tstflg(*)
 SUBEND
 Fa_tplbld3:SUB Fa_tplbld3(INTEGER V1,V2$,V3$,V4$,V5$,V6$,V7$,V8$,V9$,V10$,V11$(*),V12$(*),V13$(*),V14$,V15$(*),V16$,V17$,V18$,V19$,INTEGER Status,Error$,INTEGER Ndetail,Detail$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_TPLBLD3
  !  Vers : 1
  !  Desc : This algorithm generates Test Plan dynamically.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Rev_flag        I    -        0:Revision Control not available
  !      2 Brk_chr         S    -        Connection char between filename
  !      3 Waf_dir         S    -        Wafer spec search directory
  !      4 Prb_dir         S    -        Probe spec search directory
  !      5 Die_dir         S    -        Die spec search directory
  !      6 Tst_dir         S    -        Test spec search directory
  !      7 Mod_dir         S    -        Module spec search directory
  !      8 Tpl_dir         S    -        Testplan directory
  !      9 Waf             S    -        Wafer spec name to read
  !     10 Prb             S    -        Probe spec name to read
  !     11 Die             S    256      Die spec name to read
  !     12 Tst             S    256      Test spec name to read
  !     13 Mod             S    256      Module spec name to read
  !     14 Tpl             S    -        Test Plan name to write
  !     15 Meas            S    256      Measurement lib
  !     16 Tester          S    -        Tester lib
  !     17 Prober          S    -        Prober lib
  !     18 Utility         S    -        Utility lib
  !     19 Device          S    -        Device lib
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Command status
  !      2 Error           S    -        Error message
  !      3 Ndetail         I    -        # of lines of detail error messa
  !      4 Detail          S    10       Detailed error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Rev_flag                                 ! V1
   DIM Brk_chr$[255]                                ! V2
   DIM Waf_dir$[255]                                ! V3
   DIM Prb_dir$[255]                                ! V4
   DIM Die_dir$[255]                                ! V5
   DIM Tst_dir$[255]                                ! V6
   DIM Mod_dir$[255]                                ! V7
   DIM Tpl_dir$[255]                                ! V8
   DIM Waf$[255]                                    ! V9
   DIM Prb$[255]                                    ! V10
   DIM Die$(1:256)[255]                             ! V11
   DIM Tst$(1:256)[255]                             ! V12
   DIM Mod$(1:256)[255]                             ! V13
   DIM Tpl$[255]                                    ! V14
   DIM Meas$(1:256)[255]                            ! V15
   DIM Tester$[255]                                 ! V16
   DIM Prober$[255]                                 ! V17
   DIM Utility$[255]                                ! V18
   DIM Device$[255]                                 ! V19
   Rev_flag=V1
   Brk_chr$=V2$
   Waf_dir$=V3$
   Prb_dir$=V4$
   Die_dir$=V5$
   Tst_dir$=V6$
   Mod_dir$=V7$
   Tpl_dir$=V8$
   Waf$=V9$
   Prb$=V10$
   MAT Die$= V11$
   MAT Tst$= V12$
   MAT Mod$= V13$
   Tpl$=V14$
   MAT Meas$= V15$
   Tester$=V16$
   Prober$=V17$
   Utility$=V18$
   Device$=V19$
  !***** DON'T REMOVE THIS LINE *************************************
   DIM Cmd$[256],Opt$[4096],Err$[256]
   DIM Optdie$[4096],Optdt$[4096],Mopt$[4096]
   DIM Fulltpl$[512]
   DIM W$[256],P$[256],D$[256],T$[256],Tp$[256]
   DIM Wd$[256],Pd$[256],Dd$[256],Td$[256]
   INTEGER I,J,Stat
   INTEGER Dietst_num,Mod_num,Meas_num
     !
   ON ERROR GOTO Basic_syserr
   Dietst_num=SIZE(Die$,1)
   Mod_num=SIZE(Mod$,1)
   Meas_num=SIZE(Meas$,1)
   ALLOCATE INTEGER Tstflg(Dietst_num)
     !
   CALL Fa_chk_files(Rev_flag,Waf_dir$,Waf$,"waf",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-11
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Prb_dir$,Prb$,"prb",Brk_chr$,Stat)
   IF Stat<-1 THEN 
     Status=-12
     GOTO File_check_err2
   END IF
   CALL Fa_chk_files(Rev_flag,Tpl_dir$,Tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-3 THEN GOTO File_check_err
   W$=Waf$
   P$=Prb$
   Tp$=Tpl$
   IF POS(W$,Brk_chr$)>0 THEN W$=Waf$[1,POS(Waf$,Brk_chr$)-1]
   IF POS(P$,Brk_chr$)>0 THEN P$=Prb$[1,POS(Prb$,Brk_chr$)-1]
   IF POS(Tp$,Brk_chr$)>0 THEN Tp$=Tpl$[1,POS(Tpl$,Brk_chr$)-1]
   Wd$=Waf_dir$
   Pd$=Prb_dir$
   Dd$=Die_dir$
   Td$=Tst_dir$
   IF Wd$[LEN(Wd$)]<>"/" THEN Wd$=Wd$&"/"
   IF Pd$[LEN(Pd$)]<>"/" THEN Pd$=Pd$&"/"
   IF Dd$[LEN(Dd$)]<>"/" THEN Dd$=Dd$&"/"
   IF Td$[LEN(Td$)]<>"/" THEN Td$=Td$&"/"
     !
   Cmd$="/opt/SPECS/sys/bin/tplbuild"
   Opt$=" -waf "&Wd$&W$&" -prb "&Pd$&P$
   Mopt$=""
   FOR I=1 TO Mod_num
     IF Mod$(I)="" THEN 
       GOTO Modloopexit
     END IF
     CALL Fa_chk_files(Rev_flag,Mod_dir$,Mod$(I),"mod",Brk_chr$,Stat)
     IF Stat<-1 THEN 
       Status=-15
       GOTO Filecheck_err2
     END IF
     Mopt$=Mopt$&" -mod "
     Mopt$=Mopt$&Mod$(I)
   NEXT I
 Modloopexit:       !
   FOR I=1 TO Meas_num
     IF Meas$(I)="" THEN 
       GOTO Measloopexit
     END IF
     IF I=1 THEN 
       Mopt$=Mopt$&" -m "&Meas$(I)
     ELSE
       Mopt$=Mopt$&","&Meas$(I)
     END IF
   NEXT I
 Measloopexit:      !
   IF Tester$<>"" THEN 
     Mopt$=Mopt$&" -t "&Tester$
   END IF
   IF Prober$<>"" THEN 
     Mopt$=Mopt$&" -p "&Prober$
   END IF
   IF Utility$<>"" THEN 
     Mopt$=Mopt$&" -u "&Utility$
   END IF
   IF Device$<>"" THEN 
     Mopt$=Mopt$&" -dvl "&Device$
   END IF
   MAT Tstflg= (1)
   Optdie$=""
   Optdt$=""
   FOR I=1 TO Dietst_num
     IF Die$(I)<>"" AND Tst$(I)<>"" AND Tstflg(I)=1 THEN 
       CALL Fa_chk_files(Rev_flag,Die_dir$,Die$(I),"die",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-13
         GOTO File_check_err2
       END IF
       CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(I),"tst",Brk_chr$,Stat)
       IF Stat<-1 THEN 
         Status=-14
         GOTO File_check_err2
       END IF
       D$=Die$(I)
       T$=Tst$(I)
       IF POS(D$,Brk_chr$)>0 THEN D$=Die$(I)[1,POS(Die$(I),Brk_chr$)-1]
       IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(I)[1,POS(Tst$(I),Brk_chr$)-1]
       Optdie$=Optdie$&" -die "&Dd$&D$
       Optdt$=Optdt$&" -tst "&Dd$&D$&" "&Td$&T$
       IF I<Dietst_num THEN 
         FOR J=I+1 TO Dietst_num
           IF Die$(I)=Die$(J) AND Tstflg(J)=1 THEN 
             CALL Fa_chk_files(Rev_flag,Tst_dir$,Tst$(J),"tst",Brk_chr$,Stat)
             IF Stat<-1 THEN 
               Status=-14
               GOTO File_check_err
             END IF
             T$=Tst$(J)
             IF POS(T$,Brk_chr$)>0 THEN T$=Tst$(J)[1,POS(Tst$(J),Brk_chr$)-1]
             Optdt$=Optdt$&","&Td$&T$
             Tstflg(J)=0
           END IF
         NEXT J
       END IF
     END IF
   NEXT I
   Err$="/usr/tmp/tplbld.err"
   Fulltpl$=Tpl_dir$
   IF Tpl_dir$[LEN(Tpl_dir$)]<>"/" THEN Fulltpl$=Fulltpl$&"/"
   Fulltpl$=Fulltpl$&Tp$
   IF POS(Fulltpl$,".tpl")=0 THEN Fulltpl$=Fulltpl$&".tpl"
   EXECUTE Cmd$&Mopt$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$;RETURN Stat
    !!PRINT Cmd$&Opt$&Optdie$&Optdt$&" > "&Fulltpl$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO E
     Error$="ERROR"
     ENTER @E;Error$
     Ndetail=0
     LOOP
       ENTER @E;Detail$(Ndetail+1)
       Ndetail=Ndetail+1
     END LOOP
 E:  ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
   PURGE Err$
   DEALLOCATE Tstflg(*)
   SUBEXIT
 File_check_err:     !
   Status=-1
 File_check_err2:     !
   Error$="File_check_error "&VAL$(Stat)
   DEALLOCATE Tstflg(*)
   SUBEXIT
 Basic_syserr:     !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
   DEALLOCATE Tstflg(*)
 SUBEND
 Fa_tplfmt:SUB Fa_tplfmt(INTEGER Rev_flag,Brk_chr$,Src_tpl_dir$,Script_dir$,Dst_tpl_dir$,Src_tpl$,Script$,Dst_tpl$,INTEGER Status,Error$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_TPLFMT
  !  Vers : 1
  !  Desc : This algorithm alters Test Plan according to conditions s
  !       : pecified by external file.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Rev_flag        I    -        0:Revision Control not available
  !      2 Brk_chr         S    -        Connection char between filename
  !      3 Src_tpl_dir     S    -        Temporary file directory
  !      4 Script_dir      S    -        Script file directory
  !      5 Dst_tpl_dir     S    -        New Testplan file directory
  !      6 Src_tpl         S    -        Temporay Testplan File to read
  !      7 Script          S    -        Specified script file
  !      8 Dst_tpl         S    -        Generated Testplan File to write
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        Command status
  !      2 Error           S    -        Error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Stat
   DIM Cmd$[256],Err$[256]
   DIM Old$[512],New$[512],Scr$[512]
   DIM Src$[256],Dst$[256]
   DIM Fmtscr$[256]
  !
   ON ERROR GOTO Basic_syserr
  !
   Cmd$="/opt/SPECS/sys/bin/tplformat"
   Err$="/usr/tmp/tplfmt.err"
  !
   CALL Fa_chk_files(Rev_flag,Src_tpl_dir$,Src_tpl$,"tpl",Brk_chr$,Stat)
   IF Stat<-1 THEN GOTO File_check_err
  !    CALL Fa_chk_files(Rev_flag,Dst_tpl_dir$,Dst_tpl$,"tpl",Brk_chr$,Stat)
  !    IF Stat<-3 THEN GOTO File_check_err
   Src$=Src_tpl$
   Dst$=Dst_tpl$
   IF POS(Src$,Brk_chr$)>0 THEN Src$=Src_tpl$[1,POS(Src_tpl$,Brk_chr$)-1]
   IF POS(Dst$,Brk_chr$)>0 THEN Dst$=Dst_tpl$[1,POS(Dst_tpl$,Brk_chr$)-1]
   IF POS(Src$,".tpl")=0 THEN Src$=Src$&".tpl"
   IF POS(Dst$,".tpl")=0 THEN Dst$=Dst$&".tpl"
   Old$=Src_tpl_dir$&"/"&Src$
   New$=Dst_tpl_dir$&"/"&Dst$
   Scr$=Script_dir$&"/"&Script$
   IF Src_tpl_dir$[LEN(Src_tpl_dir$)]="/" THEN Old$=Src_tpl_dir$&Src$
   IF Dst_tpl_dir$[LEN(Dst_tpl_dir$)]="/" THEN New$=Dst_tpl_dir$&Dst$
   IF Script_dir$[LEN(Script_dir$)]="/" THEN Scr$=Script_dir$&Script$
  !
   Fmtscr$="/usr/tmp/tplscr.tmp"
   ON ERROR GOTO E
   PURGE Fmtscr$
 E:OFF ERROR 
   CREATE Fmtscr$,1
   Fa_bldscr_tpl(Scr$,Fmtscr$,Status,Error$)      !! Build format from cust's format
  !
   PRINT Fmtscr$
   EXECUTE Cmd$&" -cmd "&Fmtscr$&" "&Old$&" > "&New$&" 2> "&Err$;RETURN Stat
  !    EXECUTE Cmd$&" -cmd "&Scr$&" "&Old$&" > "&New$&" 2> "&Err$;RETURN Stat
  ! PRINT Cmd$&" -cmd "&Scr$&" "&Old$&" > "&New$&" 2> "&Err$
   IF Stat THEN 
     Status=-1
     ASSIGN @E TO Err$;FORMAT ON
     ENTER @E;Error$
     ASSIGN @E TO *
   ELSE
     Status=0
     Error$=""
   END IF
  !
   PURGE Err$
   SUBEXIT
  !
 File_check_err: !
   Status=-1
   Error$="File_check_error "&VAL$(Stat)
   SUBEXIT
 Basic_syserr: !
   OFF ERROR 
   Status=-2
   Error$=ERRM$
 SUBEND
 Fa_upd_vgemlvar:SUB Fa_upd_vgemlvar(INTEGER Sendceid,Varname$,INTEGER Varnum,Vardata$(*),INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_UPD_VGEMLVAR
  !  Vers : 1
  !  Desc : Update VGEM list type variable
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 SendCEID        I    -        CEID to Host
  !      2 VarName         S    -        Variable Name to update
  !      3 VarNum          I    -        Num of Data
  !      4 VarData         S    32       New Data List(MAX 32 elements)
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        GEM Reply
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Ceid$[256],Num$[256]
   DIM Ptr$(32)[256]
   INTEGER I
   IF Sendceid<0 THEN 
     Status=-1
     SUBEXIT
   END IF
   Ceid$=VAL$(Sendceid)
   IF Varnum<0 OR Varnum>32 THEN 
     Status=-1
     SUBEXIT
   END IF
   Num$=VAL$(Varnum)
   IF Varname$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   IF SIZE(Vardata$,1)<Varnum THEN 
     Status=-1
     SUBEXIT
   END IF
   FOR I=1 TO 32
     Ptr$(I)=""
   NEXT I
   FOR I=1 TO Varnum
     Ptr$(I)=Vardata$(I)
   NEXT I
   Fa_updlistvar(Ceid$,Varname$,Num$,Ptr$(*),Status)
 SUBEND
 Fa_upd_vgemvar:SUB Fa_upd_vgemvar(INTEGER Sendceid,Varname$,Vardata$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_UPD_VGEMVAR
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 SendCEID        I    -        CEID to Host
  !      2 VarName         S    -        Variable Name to update
  !      3 VarData         S    -        New Data
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        GEM Reply
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Ceid$[256]
   IF Sendceid<0 THEN 
     Status=-1
     SUBEXIT
   END IF
   Ceid$=VAL$(Sendceid)
   IF Varname$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   IF Vardata$="" THEN 
     Status=-1
     SUBEXIT
   END IF
   Fa_updvar(Ceid$,Varname$,Vardata$,Status)
 SUBEND
 Fa_update_card:SUB Fa_update_card(Cardpath$,Cardname$,REAL Totalcount,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_UPDATE_CARD
  !  Vers : 1
  !  Desc : FA: Update probecard touchdown counts
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 CardPath        S    -        Card File Directory
  !      2 CardName        S    -        Card File Name
  !      3 TotalCount      R    -        Total Touchdown Count
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0:OK -1:Error
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Cardfile$[255]
   DIM A$[255]
   DIM Revision$[255],Date$[255]
   REAL Limitcount
  !
   Cardfile$=Cardpath$&"/"&Cardname$
  !
   ON ERROR GOTO Update_card_end
   ASSIGN @File TO Cardfile$
  !
   ENTER @File USING "#,K";Revision$
   ENTER @File USING "#,K";A$
   ENTER @File USING "#,K";Limitcount
   ENTER @File USING "#,K";Date$
   ASSIGN @File TO *
  !
   EXECUTE "rm "&Cardfile$
   EXECUTE "touch "&Cardfile$
  !
   ASSIGN @File TO Cardfile$
   OUTPUT @File USING "-,K";Revision$
   OUTPUT @File USING "-,K";Totalcount
   OUTPUT @File USING "-,K";Limitcount
   OUTPUT @File USING "-,K";Date$
  !
   Status=0
   SUBEXIT
 Update_card_end:    !
   ASSIGN @File TO *
   OFF ERROR 
   Status=-1
 SUBEND
 Fa_waferdump:SUB Fa_waferdump(Dir$,File$,INTEGER Slot,Adtfmt$,Session$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_WAFERDUMP
  !  Vers : 1
  !  Desc : This algorithm generates adtfile to a current wafer.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Dir             S    -        Data Directory
  !      2 File            S    -        File Directory
  !      3 Slot            I    -        SlotNumber
  !      4 Adtfmt          S    -        Adt Format
  !      5 Session         S    -        SessionID
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0:OK -1:Error
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Outputdir$[255]
   DIM Outputfile$[255]
   DIM Err$[255]
   DIM Adt$[1]
   DIM Cmd$[255]
   INTEGER Exist,Read,Write,Exec
   INTEGER I
   INTEGER Stat
  !
   Cmd$="/opt/SPECS/sys/bin/datadump"
   Err$="/tmp/tplbld.err"
   Status=0                              !! Mar.02/01
  !
  !* Check the adt format *!
   SELECT Adtfmt$
   CASE "adt"
     Adt$="2"
   CASE "ad2"
     Adt$="3"
   CASE "ad3"
     Adt$="4"
   CASE "ad5"
     Adt$="5"
   CASE "1"
     Adt$=Adtfmt$
     Adtfmt$="adt"
   CASE "2"
     Adt$=Adtfmt$
     Adtfmt$="adt"
   CASE "3"
     Adt$=Adtfmt$
     Adtfmt$="ad2"
   CASE "4"
     Adt$=Adtfmt$
     Adtfmt$="ad3"
   CASE "5"
     Adt$=Adtfmt$
     Adtfmt$="ad5"
   CASE ELSE
     Status=-1
   END SELECT
   IF Status=-1 THEN SUBEXIT
  !
  !* Verify Directory *!
   Outputdir$=Dir$&"/"&File$
   CALL Verify_file(Outputdir$,"Directory",Exist,Read,Write,Exec)
   IF Exist=0 THEN 
     EXECUTE "mkdir "&Outputdir$&" 2> "&Err$;RETURN Stat
     IF Stat THEN Status=-1
   ELSE
     IF Write<>1 AND Exec<>1 THEN Status=-1
   END IF
   IF Status=-1 THEN SUBEXIT
  !
  !* Verify File *!
   I=1
   LOOP
     IF I=1 THEN 
       Outputfile$=Outputdir$&"/"&VAL$(Slot)&"."&Adtfmt$
     ELSE
       Outputfile$=Outputdir$&"/"&VAL$(Slot)&"#"&VAL$(I)&"."&Adtfmt$
     END IF
     CALL Verify_file(Outputfile$,"Normal",Exist,Read,Write,Exec)
     IF Exist<1 THEN 
       Status=0
     ELSE
       Status=-1
       I=I+1
     END IF
   EXIT IF I>99 OR Status=0
   END LOOP
  !
   IF Status=0 THEN 
     EXECUTE Cmd$&" -"&Session$&" -"&Adt$&" > "&Outputfile$&" 2> "&Err$;RETURN Stat
     IF Stat THEN Status=-1
   END IF
  !
  !
 SUBEND
 Fa_wait:SUB Fa_wait(REAL Wait)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FA_WAIT
  !  Vers : 1
  !  Desc : Waits for the speicifed duration
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Wait            R    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   WAIT Wait
 SUBEND
 File_hwconfig:SUB File_hwconfig(File$,Config$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FILE_HWCONFIG
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 File            S    -
  !      2 Config          S    50
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER I,Valid
   DIM Tmpfile$[255]
  !
   Tmpfile$=File$&".tmp"
  !
   ON ERROR GOTO Nofile_file
   PURGE File$
   GOTO Noerr_file
 Nofile_file: !
   IF ERRN<>56 THEN 
     PRINT "FILE_HWCONFIG: PURGE "&File$&" causes "&ERRM$
     SUBEXIT
   END IF
 Noerr_file: !
  !
   ON ERROR GOTO Nofile_tmp
   PURGE Tmpfile$
   GOTO Noerr_tmp
 Nofile_tmp: !
   IF ERRN<>56 THEN 
     PRINT "FILE_HWCONFIG: PURGE "&Tmpfile$&" causes "&ERRM$
     SUBEXIT
   END IF
 Noerr_tmp: !
  !
   Valid=0
   FOR I=50 TO 1 STEP -1
     IF LEN(Config$(I))>0 THEN 
       Valid=I
       GOTO Make
     END IF
   NEXT I
  !
 Make: !
   ON ERROR GOTO Err
   CREATE Tmpfile$,1
   ASSIGN @File TO Tmpfile$
   FOR I=1 TO Valid
     OUTPUT @File;Config$(I)&CHR$(10)
   NEXT I
   ASSIGN @File TO *
  !
   EXECUTE "/usr/bin/col -bx < "&Tmpfile$&" > "&File$
   PURGE Tmpfile$
   SUBEXIT
  !
 Err: !
   PRINTER IS CRT
   PRINT "FILE_HWCONFIG: "&ERRM$
 SUBEND
 File_lookup:SUB File_lookup(Dir$,Suffix$,Files$(*),INTEGER Count,Depth)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FILE_LOOKUP
  !  Vers : 1
  !  Desc : Searches for and returns all the file names (in all direc
  !       : tories under a specified directory) that have a specified
  !       :  suffix
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Dir             S    -        Search directory name
  !      2 Suffix          S    -        Suffix
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Files           S    1024     Found files
  !      2 Count           I    -        Number of found files
  !      3 Depth           I    -        Max directory depth + 1
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Script$[255],Buf$[255]
   INTEGER N
   Script$="/var/tmp/dirlook."&SYSTEM$("PROCESS ID")    ! AVPATH_
   ON ERROR GOTO Create
   PURGE Script$
 Create:OFF ERROR 
  !
   ON ERROR GOTO Error
   CREATE Script$,1
   ASSIGN @Script TO Script$
   IF LEN(Suffix$) THEN 
     OUTPUT @Script;"cd "&Dir$&"; find . -name '*."&Suffix$&"' | awk -F '/' '{ print NF - 1 }' | sort -n | uniq | tail -1"&CHR$(10)
     OUTPUT @Script;"cd "&Dir$&"; find . -name '*."&Suffix$&"' | sed -e 's=^./==' -e 's/."&Suffix$&"$//'"&CHR$(10)
   ELSE
     OUTPUT @Script;"cd "&Dir$&"; find . | awk -F '/' '{ print NF - 1 }' | sort -n | uniq | tail -1"&CHR$(10)
     OUTPUT @Script;"cd "&Dir$&"; find . | sed -e 's=^./=='"&CHR$(10)
   END IF
   ASSIGN @Script TO *
   ASSIGN @Pipe TO "sh < "&Script$&" |"
   ON END @Pipe GOTO Eof
   ENTER @Pipe;Depth
   N=0
   LOOP
     ENTER @Pipe;Buf$
     IF LEN(Buf$) THEN 
       IF N<1024 THEN 
         Files$(N+1)=Buf$
       END IF
       N=N+1
     END IF
   END LOOP
 Eof:ASSIGN @Pipe TO *
   Count=N
   PURGE Script$
   SUBEXIT
 Error:OFF ERROR 
   Count=0
   Depth=0
   SUBEXIT
 SUBEND
 Format_path:SUB Format_path(Original$,Path$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : FORMAT_PATH
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Original        S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Path            S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Pos,Head,Length
  !
   Original$=TRIM$(Original$)
   Path$=""
   Length=LEN(Original$)
   IF Length=0 THEN 
     Path$="/"
     SUBEXIT
   END IF
  !
   Head=1
   REPEAT
     Pos=POS(Original$[Head],"/")
     SELECT Pos
     CASE 0
       Path$=Path$&"/"&Original$[Head]
       Head=Length+1
     CASE 1
       Head=Head+1
     CASE ELSE
       Path$=Path$&"/"&Original$[Head,Head+Pos-2]
       Head=Head+Pos-1
     END SELECT
   UNTIL Head>Length
  !
   IF Path$="" THEN    ! Original$="/"
     Path$="/"
   END IF
 SUBEND
 G_cv:SUB G_cv(REAL Vstart,Vstop,Vstep,Delay,Hold,INTEGER Pins(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : G_CV
  !  Vers : 1
  !  Desc : Measures the Capacitance-Voltage characteristics (C-V cha
  !       : racteristics), and displays the measurement results on a
  !       : graph
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Vstart          R    -        Inversion voltage
  !      2 Vstop           R    -        Accumulation voltage
  !      3 Vstep           R    -        Step voltage
  !      4 Delay           R    -        Step delay time
  !      5 Hold            R    -        Hold time
  !
  !    Device Terminals:
  !      1 H               I    -
  !      2 L               I    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   REAL Freq
   INTEGER H,L,N
   H=Pins(1)
   L=Pins(2)
   N=ABS((Vstop-Vstart)/Vstep)+1
   ALLOCATE REAL C(N),G(N),V(N)
  !
   Connect(FNCmh,H)
   Connect(FNCml,L)
   Set_cv84(Vstart,Vstop,N,Hold,Delay)               ! freq is default (1MHz)
   Sweep_cv84(0,C(*),G(*),V(*))
   Connect(FNCmh,0)
   Connect(FNCml,0)
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=Vstart
   Xmax=Vstop
   Ymin=MIN(C(*))
   Ymax=MAX(C(*))
   Lingraph1(Xmin,Xmax,Ymin,Ymax,"Bias [V]","Cap [F]","C-V")
   PEN 1
   MOVE Vstart,C(1)
   FOR I=2 TO N
     V1=Vstart+Vstep*(I-1)
     DRAW V1,C(I)
   NEXT I
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE C(*),G(*),V(*)
 Error:OFF ERROR 
 SUBEND
 G_hfe:SUB G_hfe(REAL Ibestart,Ibestop,INTEGER Ibestep,REAL Vce,INTEGER Pins(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : G_HFE
  !  Vers : 1
  !  Desc : Measures the bipolar transistor Collector Current-hFE cha
  !       : racteristics (Ic-hFE characteristics), and displays the m
  !       : easurement results on a graph
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Ibestart        R    -        Base start current
  !      2 Ibestop         R    -        Base stop current
  !      3 Ibestep         I    -        Base number of steps
  !      4 Vce             R    -        Collector voltage
  !
  !    Device Terminals:
  !      1 E               I    -
  !      2 B               I    -
  !      3 C               I    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   INTEGER Emitter,Base,Collector
   INTEGER N1,N2
   Emitter=Pins(1)
   Base=Pins(2)
   Collector=Pins(3)
   N1=Ibestep
   ALLOCATE REAL Ib(N1),Ic(N1),V(N1),Hfe(N1),Absib(N1),Absic(N1)
  !
   Connect(FNGnd,Emitter)
   Connect(FNSmu(1),Base)
   Connect(FNSmu(2),Collector)
   Force_v(Collector,Vce,20,.1)
   Set_iv(Base,-2,ABS(MAX(Ibestart,Ibestop)),Ibestart,Ibestop,N1,0,0,20)               ! Log
   Sweep_iv(Collector,2,0,Ic(*),Ib(*))
   Disable_port(Collector)
   Disable_port(Base)
   Connect(FNSmu(1),0)
   Connect(FNSmu(2),0)
   Connect(FNGnd,0)
  !
   Icsum=0
   FOR I1=1 TO N1
     Icsum=Ic(I1)+Icsum
   NEXT I1
   IF Icsum>0 THEN 
     Sign=1
   ELSE
     Sign=-1
   END IF
   FOR I1=1 TO N1
     IF Ib(I1)=0 THEN Ib(I1)=Sign*1.E-15
     IF Ic(I1)=0 THEN Ic(I1)=Sign*1.E-15
   NEXT I1
   MAT Absib= ABS(Ib)
   MAT Absic= ABS(Ic)
   MAT Hfe= Absic/Absib
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=MAX(MIN(Absic(*)),1.E-15)*Sign
   Xmax=MAX(MAX(Absic(*)),1.E-14)*Sign*2
   Ymin=MAX(MIN(Hfe(*)),1.E-15)
   Ymax=MAX(MAX(Hfe(*)),1.E-14)*2
   Loggraph1(Xmin,Xmax,Ymin,Ymax,"Ic [A]","hFE","hFE",3)
  !
   PEN 1
   MOVE LGT(Absic(1))*Sign,LGT(Hfe(1))
   FOR I1=2 TO N1
     DRAW LGT(Absic(I1))*Sign,LGT(Hfe(I1))
   NEXT I1
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE Ib(*),Ic(*),V(*),Hfe(*),Absib(*),Absic(*)
 Error:OFF ERROR 
 SUBEND
 G_icvb:SUB G_icvb(REAL Vbestart,Vbestop,Vbestep,INTEGER Pins(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : G_ICVB
  !  Vers : 1
  !  Desc : Measures the bipolar transistor Collector Current-Base Vo
  !       : ltage characteristics (Ic-Vb characteristics), and displa
  !       : ys the measurement results on a graph
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Vbestart        R    -        Base start voltage
  !      2 Vbestop         R    -        Base stop voltage
  !      3 Vbestep         R    -        Base step voltage
  !
  !    Device Terminals:
  !      1 E               I    -
  !      2 B               I    -
  !      3 C               I    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   INTEGER Emitter,Base,Collector
   INTEGER N1,N2,Ports(2)
   REAL Ranges(2)
   Emitter=Pins(1)
   Base=Pins(2)
   Collector=Pins(3)
   N1=ABS((Vbestop-Vbestart)/Vbestep)+1
   ALLOCATE REAL Ib(N1),Ic(N1),V(N1),Absib(N1),Absic(N1)
  !
   Connect(FNSmu(1),Emitter)
   Connect(FNSmu(2),Base)
   Connect(FNSmu(3),Collector)
   Ports(1)=Base
   Ports(2)=Collector
   Ranges(1)=0
   Ranges(2)=0
   Force_v(Collector,0,20,.1)
   Force_v(Base,0,20,.1)
   Set_iv(Emitter,1,ABS(MAX(Vbestart,Vbestop)),-Vbestart,-Vbestop,N1,0,0,.1)                      ! Lin
   Sweep_miv(Ports(*),Ranges(*),Ib(*),Ic(*))                               ! Im
   Disable_port(Base)
   Connect(FNSmu(1),0)
   Connect(FNSmu(2),0)
   Connect(FNSmu(3),0)
  !
   Ibsum=0
   Icsum=0
   FOR I1=1 TO N1
     Ibsum=Ib(I1)+Ibsum
     Icsum=Ic(I1)+Icsum
   NEXT I1
   IF Ibsum+Icsum>0 THEN 
     Sign=1
   ELSE
     Sign=-1
   END IF
   FOR I1=1 TO N1
     IF Ib(I1)=0 THEN Ib(I1)=Sign*1.E-15
     IF Ic(I1)=0 THEN Ic(I1)=Sign*1.E-15
   NEXT I1
   MAT Absib= ABS(Ib)
   MAT Absic= ABS(Ic)
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=Vbestart
   Xmax=Vbestop
   Ymin=MAX(MIN(MIN(Absib(*)),MIN(Absic(*))),1.E-15)*Sign
   Ymax=MAX(MAX(MAX(Absib(*)),MAX(Absic(*))),1.E-14)*Sign
   Loggraph1(Xmin,Xmax,Ymin,Ymax,"Vb [V]","Ic/Ib [A]","Vb - Ic/Ib")
   PEN 1
   MOVE Vbestart,LGT(Absib(1))*Sign
   FOR I1=2 TO N1
     V1=Vbestart+Vbestep*(I1-1)
     DRAW V1,LGT(Absib(I1))*Sign
   NEXT I1
   PEN 2
   MOVE Vbestart,LGT(Absic(1))*Sign
   FOR I1=2 TO N1
     V1=Vbestart+Vbestep*(I1-1)
     DRAW V1,LGT(Absic(I1))*Sign
   NEXT I1
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE Ib(*),Ic(*),V(*),Absib(*),Absic(*)
 Error:OFF ERROR 
 SUBEND
 G_icvc:SUB G_icvc(REAL Vcestart,Vcestop,Vcestep,Ibstart,Ibstop,Ibstep,INTEGER Pins(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : G_ICVC
  !  Vers : 1
  !  Desc : Measures the bipolar transistor Collector Current-Collect
  !       : or Voltage characteristics (Ic-Vc characteristics), and d
  !       : isplays the measurement results on a graph
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Vcestart        R    -        Collector start voltage
  !      2 Vcestop         R    -        Collector stop voltage
  !      3 Vcestep         R    -        Collector step voltage
  !      4 Ibstart         R    -        Base start current
  !      5 Ibstop          R    -        Base stop current
  !      6 Ibstep          R    -        Base step current
  !
  !    Device Terminals:
  !      1 E               I    -
  !      2 B               I    -
  !      3 C               I    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   INTEGER Emitter,Base,Collector
   INTEGER N1,N2
   Emitter=Pins(1)
   Base=Pins(2)
   Collector=Pins(3)
   N1=ABS((Vcestop-Vcestart)/Vcestep)+1
   N2=ABS((Ibstop-Ibstart)/Ibstep)+1
   ALLOCATE REAL Ic(N2,N1),Im(N1),V(N1)
  !
   Connect(FNSmu(1),Emitter)
   Connect(FNSmu(2),Base)
   Connect(FNSmu(3),Collector)
   Force_v(Emitter,0,20,.1)
   FOR I2=1 TO N2
     V2=Ibstart+Ibstep*(I2-1)
     Force_i(Base,V2,V2,20)
     Set_iv(Collector,1,ABS(MAX(Vcestart,Vcestop)),Vcestart,Vcestop,N1,0,0,.1)               ! Lin
     Sweep_iv(Collector,2,0,Im(*),V(*))
     MAT Ic(I2,*)= Im
   NEXT I2
   Disable_port(Collector)
   Disable_port(Base)
   Connect(FNSmu(1),0)
   Connect(FNSmu(2),0)
   Connect(FNSmu(3),0)
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=Vcestart
   Xmax=Vcestop
   Ymin=MIN(Ic(*))
   Ymax=MAX(Ic(*))
   Lingraph1(Xmin,Xmax,Ymin,Ymax,"Vc [V]","Ic [A]","Vc - Ic")
   PEN 1
   FOR I2=1 TO N2
     MOVE Vcestart,Ic(I2,1)
     FOR I1=2 TO N1
       V1=Vcestart+Vcestep*(I1-1)
       DRAW V1,Ic(I2,I1)
     NEXT I1
   NEXT I2
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE Ic(*),Im(*),V(*)
 Error:OFF ERROR 
 SUBEND
 G_idvd:SUB G_idvd(REAL Vdstart,Vdstop,Vdstep,Vgstart,Vgstop,Vgstep,INTEGER Pins(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : G_IDVD
  !  Vers : 1
  !  Desc : Measures the MOSFET Drain Current-Drain Voltage character
  !       : istics (Id-Vd characteristics), and displays the measurem
  !       : ent results on a graph
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Vdstart         R    -        Drain start voltage
  !      2 Vdstop          R    -        Drain stop voltage
  !      3 Vdstep          R    -        Drain step voltage
  !      4 Vgstart         R    -        Gate start voltage
  !      5 Vgstop          R    -        Gate stop voltage
  !      6 Vgstep          R    -        Gate step voltage
  !
  !    Device Terminals:
  !      1 S               I    -
  !      2 G               I    -        Gate terminal
  !      3 D               I    -        Drain terminal
  !      4 Sub             I    -        Substrate terminal
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   INTEGER Source,Gate,Drain,Substrate
   INTEGER N1,N2
   Source=Pins(1)
   Gate=Pins(2)
   Drain=Pins(3)
   Substrate=Pins(4)
   N1=ABS((Vdstop-Vdstart)/Vdstep)+1
   N2=ABS((Vgstop-Vgstart)/Vgstep)+1
   ALLOCATE REAL Id(N2,N1),Im(N1),V(N1)
  !
   Connect(FNSmu(1),Drain)
   Connect(FNGnd,Source)
   Connect(FNSmu(3),Gate)
   Connect(FNSmu(4),Substrate)
   IF Substrate THEN 
     Force_v(Substrate,0,0,.1)
   END IF
   FOR I2=1 TO N2
     V2=Vgstart+Vgstep*(I2-1)
     Force_v(Gate,V2,V2,.1)
     Set_iv(Drain,1,ABS(MAX(Vdstart,Vdstop)),Vdstart,Vdstop,N1,0,0,.1)
     Sweep_iv(Drain,2,0,Im(*),V(*))
     MAT Id(I2,*)= Im
   NEXT I2
   Disable_port(Drain)
   Disable_port(Gate)
   Connect(FNSmu(1),0)
   Connect(FNGnd,0)
   Connect(FNSmu(3),0)
   Connect(FNSmu(4),0)
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=Vdstart
   Xmax=Vdstop
   Ymin=MIN(Id(*))
   Ymax=MAX(Id(*))
   Lingraph1(Xmin,Xmax,Ymin,Ymax,"Vd [V]","Id [A]","Vd - Id")
   PEN 1
   FOR I2=1 TO N2
     MOVE Vdstart,Id(I2,1)
     FOR I1=2 TO N1
       V1=Vdstart+Vdstep*(I1-1)
       DRAW V1,Id(I2,I1)
     NEXT I1
   NEXT I2
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE Id(*),Im(*),V(*)
 Error:OFF ERROR 
 SUBEND
 G_idvg:SUB G_idvg(REAL Vgstart,Vgstop,Vgstep,Vsubstart,Vsubstop,Vsubstep,Vd,INTEGER Pins(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : G_IDVG
  !  Vers : 1
  !  Desc : Measures the MOSFET Drain Current-Gate Voltage characteri
  !       : stics (Id-Vg characteristics), and displays the measureme
  !       : nt results on a graph
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Vgstart         R    -        Gate start voltage
  !      2 Vgstop          R    -        Gate stop voltage
  !      3 Vgstep          R    -        Gate step voltage
  !      4 Vsubstart       R    -        Substrate start voltage
  !      5 Vsubstop        R    -        Substrate stop voltage
  !      6 Vsubstep        R    -        Substrate step voltage
  !      7 Vd              R    -        Drain voltage
  !
  !    Device Terminals:
  !      1 S               I    -
  !      2 G               I    -        Gate terminal
  !      3 D               I    -        Drain terminal
  !      4 Sub             I    -        Substrate terminal
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF NOT INMEM("Lingraph") THEN 
     ON ERROR GOTO Secondfile
     LOADSUB ALL FROM "/opt/hp4070/lib/XYGRAPH"
     GOTO Find
 Secondfile:OFF ERROR 
     ON ERROR GOTO Error
     LOADSUB ALL FROM "/usr/pcs/lib/XYGRAPH"
 Find:OFF ERROR 
   END IF
   FOR I=1 TO 10
     ON ERROR GOTO Ignored
     CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
     GOTO Created
 Ignored:OFF ERROR 
   NEXT I
   I=1
   DESTROY WINDOW 601
   CREATE WINDOW 600+I,0,0,512,384;LABEL "Sweep",RETAIN
 Created:OFF ERROR 
   PLOTTER IS 600+I,"WINDOW"
  !
   ON ERROR GOTO Error
   INTEGER Source,Gate,Drain,Substrate
   INTEGER N1,N2
   Source=Pins(1)
   Gate=Pins(2)
   Drain=Pins(3)
   Substrate=Pins(4)
   N1=ABS((Vgstop-Vgstart)/Vgstep)+1
   N2=ABS((Vsubstop-Vsubstart)/Vsubstep)+1
   ALLOCATE REAL Id(N2,N1),Im(N1),V(N1)
  !
   Connect(FNSmu(1),Drain)
   Connect(FNGnd,Source)
   Connect(FNSmu(3),Gate)
   Connect(FNSmu(4),Substrate)
   Force_v(Drain,Vd,Vd,.1)
   Force_v(Gate,0,20,.1)
   FOR I2=1 TO N2
     V2=Vsubstart+Vsubstep*(I2-1)
     IF Substrate THEN 
       Force_v(Substrate,V2,V2,.1)
     END IF
     Set_iv(Gate,1,ABS(MAX(Vgstart,Vgstop)),Vgstart,Vgstop,N1,0,0,.1)                ! Lin
     Sweep_iv(Drain,2,0,Im(*),V(*))
     MAT Id(I2,*)= Im
   NEXT I2
   Disable_port(Drain)
   Disable_port(Gate)
   IF Substrate THEN 
     Disable_port(Substrate)
   END IF
   Connect(FNSmu(1),0)
   Connect(FNGnd,0)
   Connect(FNSmu(3),0)
   Connect(FNSmu(4),0)
  !
   REAL Xmin,Xmax,Ymin,Ymax
   Xmin=Vgstart
   Xmax=Vgstop
   Ymin=MIN(Id(*))
   Ymax=MAX(Id(*))
   Lingraph1(Xmin,Xmax,Ymin,Ymax,"Vg [V]","Id [A]","Vg - Id")
   PEN 1
   FOR I2=1 TO N2
     MOVE Vgstart,Id(I2,1)
     FOR I1=2 TO N1
       V1=Vgstart+Vgstep*(I1-1)
       DRAW V1,Id(I2,I1)
     NEXT I1
   NEXT I2
   PLOTTER IS CRT,"INTERNAL"
  !
   DEALLOCATE Id(*),Im(*),V(*)
 Error:OFF ERROR 
 SUBEND
 Gem_getcmd:SUB Gem_getcmd(Cmd$,Rply$,Parms$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GEM_GETCMD
  !  Vers : 1
  !  Desc : Get all of commands for using this algorirthm.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Cmd             S    -        Command
  !      2 Rply            S    -        Reply string
  !      3 Parms           S    500
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Fa_getcmd(Cmd$,Rply$,Parms$(*))
  !!  PRINT Cmd$
  !!  FOR I=1 TO 300
  !!    IF Parms$(I)<>"" THEN
  !!      PRINT I;Parms$(I)
  !!    END IF
  !!  NEXT I
 SUBEND
 Gem_init:SUB Gem_init(INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GEM_INIT
  !  Vers : 1
  !  Desc : Initialize GEM module
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Fa_init(Status)
 SUBEND
 Gem_respond_nok:SUB Gem_respond_nok(Replymailbox$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GEM_RESPOND_NOK
  !  Vers : 1
  !  Desc : GEM_RESPOND_NotOK:
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 ReplyMailbox    S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0:OK -1:Error
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Fa_respond_nok(Replymailbox$,Status)
 SUBEND
 Gem_respond_ok:SUB Gem_respond_ok(Replymailbox$,REAL Timeout,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GEM_RESPOND_OK
  !  Vers : 1
  !  Desc : GEM_RESPOND_OK:
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 ReplyMailbox    S    -
  !      2 Timeout         R    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0:OK -1:Error
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Fa_respond_ok(Replymailbox$,Timeout,Status)
 SUBEND
 Gem_sendevent:SUB Gem_sendevent(Event$,Parms$(*),INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GEM_SENDEVENT
  !  Vers : 1
  !  Desc : Send all of event for using this command.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Event           S    -        Event name
  !      2 Parms           S    500
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        GEM Reply
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   PRINT Parms$(2)
   Fa_sendevent(Event$,Parms$(*),Status)
 SUBEND
 Get_brk_mod:SUB Get_brk_mod(INTEGER Typeindex,Dieindex,Modindex,Break)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GET_BRK_MOD
  !  Vers : 1
  !  Desc : Return breakpoint flag value of specified module.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER)
  !      2 Dieindex        I    -        Die index in die type (DIE.NUMBE
  !      3 Modindex        I    -        Module index (MODULE.NUMBER)
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Break           I    -        1: Break, 0: Unbreak, -1: Error
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos
  !
   Tpldietype2pos(Typeindex-1,Dieindex-1,Diepos)
  !
   Tplgetbrkmod(Diepos,Modindex-1,Break)
 SUBEND
 Get_dielabel:SUB Get_dielabel(Label$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GET_DIELABEL
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Label           S    -        Die Label
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Tmpdiepos
   CALL Tpldiepos(Tmpdiepos)
   CALL Tpldielabel(Tmpdiepos,Label$)
 SUBEND
 Get_dietype:SUB Get_dietype(Type$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GET_DIETYPE
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Type            S    -        Die type
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Tmpdiepos
   CALL Tpldiepos(Tmpdiepos)
   CALL Tpldielabel(Tmpdiepos,Type$)
  ! CALL Tpldietype(Tmpdiepos,Type$) ! 2006/02/10
 SUBEND
 Get_jdg_die:SUB Get_jdg_die(INTEGER Typeindex,Dieindex,Judge,Offsetx,Offsety)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GET_JDG_DIE
  !  Vers : 1
  !  Desc : Return judgement flag value of specified die.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER)
  !      2 Dieindex        I    -        Die index in die type (DIE.NUMBE
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Judge           I    -        Judgement value.
  !      2 Offsetx         I    -        Die X position offset.
  !      3 Offsety         I    -        Die Y position offset.
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos
  !
   Judge=-1
  !
   IF Typeindex<=0 THEN 
     SUBEXIT
   END IF
   IF Dieindex<=0 THEN 
     SUBEXIT
   END IF
  !
   Tpldietype2pos(Typeindex-1,Dieindex-1,Diepos)
   IF Diepos<0 THEN 
     SUBEXIT
   END IF
  !
   Tplgetjdgdie(Diepos,Judge,Offsetx,Offsety)
 SUBEND
 Get_loc_mod:SUB Get_loc_mod(INTEGER Typeindex,Modname$,REAL X,Y,INTEGER Stat)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GET_LOC_MOD
  !  Vers : 1
  !  Desc : Return module position of specified module relative to di
  !       : e.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER).
  !      2 Modname         S    -        Module name.
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 X               R    -        X Position
  !      2 Y               R    -        Y Position
  !      3 Stat            I    -        0:No error, -1:Error
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos
  !
   Stat=-1
  !
   IF Typeindex<=0 THEN 
     SUBEXIT
   END IF
   IF LEN(Modname$)<=0 THEN 
     SUBEXIT
   END IF
  !
   Tpldietype2pos(Typeindex-1,0,Diepos)
   IF Diepos<0 THEN 
     SUBEXIT
   END IF
  !
   Tplgetlocmod(Diepos,Modname$,X,Y,Stat)
 SUBEND
 Get_modlabel:SUB Get_modlabel(Label$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GET_MODLABEL
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Label           S    -        Module Label
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Tmpmodpos
   CALL Tplmodulepos(Tmpmodpos)
   CALL Tplmodulelabel(Tmpmodpos,Label$)
 SUBEND
 Get_next_mod:SUB Get_next_mod(INTEGER Typeindex_c,Diex_c,Diey_c,Modname_c$,INTEGER Typeindex,Diex,Diey,Modname$,INTEGER Stat)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GET_NEXT_MOD
  !  Vers : 1
  !  Desc : Search failed module.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Typeindex_c     I    -        Current type index.
  !      2 Diex_c          I    -        Current die x.
  !      3 Diey_c          I    -        Current die y.
  !      4 Modname_c       S    -        Current module name.
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Typeindex       I    -        Next die type w/ failed module.
  !      2 Diex            I    -        Next die x w/ failed module.
  !      3 Diey            I    -        Next die y w/ failed module.
  !      4 Modname         S    -        Next failed module name.
  !      5 Stat            I    -        0:ok/-1:error
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Diebegin,Dietotal,Diepos,Dieindex
   INTEGER Modtotal,Modbegin,Modindex
   INTEGER Min_in_mod,Max_in_mod,Min_in_die,Max_in_die,Outindex
   INTEGER Judge,Pass,Fail,Total
   INTEGER Duplicated
   DIM Tmpname$[33]
  !
   Stat=-1
   Typeindex_c=Typeindex_c-1  ! DIE.TYPENUMBER starts from 1 -> 0 based
   IF Typeindex_c<0 THEN 
     Diebegin=0  !default:Typeindex_c=0(Search from the beginning)
   ELSE
     Tpldiexy2pos(Typeindex_c,Diex_c,Diey_c,Diebegin)
     IF Diebegin<0 THEN 
       SUBEXIT
     END IF
   END IF
  !
   Tpldietotal(Dietotal)
   FOR Diepos=Diebegin TO Dietotal-1
     Tpldiepos2type(Diepos,Typeindex,Dieindex)
     Tpldiepos2xy(Diepos,Typeindex,Diex,Diey)
     Tplmoduletotal(Diepos,Modtotal)
  !
     Modbegin=0
     Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
     Tplmodulelabel(Min_in_mod,Modname$)
     IF Typeindex=Typeindex_c AND Diex=Diex_c AND Diey=Diey_c THEN 
       FOR Modindex=0 TO Modtotal-1
         Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
         Tplmodulelabel(Min_in_mod,Modname$)
         IF Modname$=Modname_c$ THEN 
           Modbegin=Modindex+1
           GOTO Search_begin
         END IF
       NEXT Modindex
     END IF
  !
 Search_begin:  !
     FOR Modindex=Modbegin TO Modtotal-1
       Jdg_mod_at_pos(Diepos,Modindex,0,Judge,Pass,Fail,Total)
       IF Judge=0 THEN 
         Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
         Tplmodulelabel(Min_in_mod,Modname$)
  !
         IF Typeindex=Typeindex_c OR Diex=Diex_c OR Diey=Diey_c THEN 
           Stat=0
           Typeindex=Typeindex+1
           SUBEXIT
         END IF
  !
         IF Modname$<>Modname_c$ THEN 
           Tplgetrangedie(Diepos,Min_in_die,Max_in_die)
           Duplicated=0
           FOR Outindex=Min_in_die TO Min_in_mod-1
             Tplmodulelabel(Outindex,Tmpname$)
             IF Modname$=Tmpname$ THEN 
               Duplicated=1
             END IF
           NEXT Outindex
           IF Duplicated=0 THEN 
             Stat=0
             Typeindex=Typeindex+1
             SUBEXIT
           END IF
         END IF
       END IF
     NEXT Modindex
   NEXT Diepos
   SUBEXIT
  !
 SUBEND
 Get_prev_mod:SUB Get_prev_mod(INTEGER Typeindex_c,Diex_c,Diey_c,Modname_c$,INTEGER Typeindex,Diex,Diey,Modname$,INTEGER Stat)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GET_PREV_MOD
  !  Vers : 1
  !  Desc : Search failed module.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Typeindex_c     I    -        Current type index.
  !      2 Diex_c          I    -        Current die x.
  !      3 Diey_c          I    -        Current die y.
  !      4 Modname_c       S    -        Current module name.
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Typeindex       I    -        Prev die type w/ failed module.
  !      2 Diex            I    -        Prev die x w/ failed module.
  !      3 Diey            I    -        Prev die y w/ failed module.
  !      4 Modname         S    -        Prev failed module name.
  !      5 Stat            I    -        0:ok/-1:error
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Diebegin,Dieindex,Diepos,Min_in_die,Max_in_die
   INTEGER Modbegin,Modindex,Modtotal,Min_in_mod,Max_in_mod
   INTEGER Outindex
   INTEGER Judge,Pass,Fail,Total
   INTEGER Duplicated
   DIM Tmpname$[33]
  !
   Stat=-1
   Typeindex_c=Typeindex_c-1
   IF Typeindex_c>=0 THEN 
     Tpldiexy2pos(Typeindex_c,Diex_c,Diey_c,Diebegin)
   ELSE
     Tpldietotal(Diebegin)
     Diebegin=Diebegin-1
   END IF
   IF Diebegin<0 THEN 
     SUBEXIT
   END IF
  !
   FOR Diepos=Diebegin TO 0 STEP -1
     Tpldiepos2type(Diepos,Typeindex,Dieindex)
     Tpldiepos2xy(Diepos,Typeindex,Diex,Diey)
     Tplmoduletotal(Diepos,Modtotal)
  !
     Modbegin=Modtotal-1
     Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
     Tplmodulelabel(Min_in_mod,Modname$)
     IF Typeindex=Typeindex_c AND Diex=Diex_c AND Diey=Diey_c THEN 
       FOR Modindex=Modtotal-1 TO 0 STEP -1
         Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
         Tplmodulelabel(Min_in_mod,Modname$)
         IF Modname$=Modname_c$ THEN 
           Modbegin=Modindex-1
           GOTO Search_begin
         END IF
       NEXT Modindex
     END IF
  !
 Search_begin:  !
     FOR Modindex=Modbegin TO 0 STEP -1
       Jdg_mod_at_pos(Diepos,Modindex,0,Judge,Pass,Fail,Total)
       IF Judge=0 THEN 
         Tplgetrangemod(Diepos,Modindex,Min_in_mod,Max_in_mod)
         Tplmodulelabel(Min_in_mod,Modname$)
  !
         IF Typeindex<>Typeindex_c OR Diex<>Diex_c OR Diey<>Diey_c THEN 
           Stat=0
           Typeindex=Typeindex+1
           SUBEXIT
         END IF
  !
         IF Modname$<>Modname_c$ THEN 
           Tplgetrangedie(Diepos,Min_in_die,Max_in_die)
           Duplicated=0
           FOR Outindex=Max_in_die TO Max_in_mod+1 STEP -1
             Tplmodulelabel(Outindex,Tmpname$)
             IF Tmname$=Modname$ THEN 
               Duplicated=1
             END IF
           NEXT Outindex
           IF Duplicated=0 THEN 
             Stat=0
             Typeindex=Typeindex+1
             SUBEXIT
           END IF
         END IF
       END IF
     NEXT Modindex
   NEXT Diepos
  !
 SUBEND
 Get_slot_no:SUB Get_slot_no(Lotid$,Waferid$,INTEGER Slotno)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GET_SLOT_NO
  !  Vers : 1
  !  Desc : Get slot number from lot ID and wafer ID.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Lotid           S    -
  !      2 Waferid         S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Slotno          I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Slot_num
  !
   INTEGER Index
   DIM Name$[32]
   INTEGER Type,Dim,Size1,Size2
   DIM Sys_class$[10]
  !
  ! !! initialize
   Slotno=0
   Sys_class$="SYSTEM"
  !
  ! !! total slot number
   Tpltagindex(Sys_class$,"PRB_SLOT_TOTAL_ALL",Index)
   IF Index=-1 THEN SUBEXIT
   Tplgetitag(Sys_class$,Index,0,Slot_num)
  !
  ! !! lot ID index (TST_SLOT_LOT_INDEX)
   Tpltagindex(Sys_class$,"TST_SLOT_LOT_INDEX",Index)
   IF Index=-1 THEN SUBEXIT
   Tpltaginfo(Sys_class$,Index,Name$,Type,Dim,Size1,Size2)
   ALLOCATE INTEGER Lot_index(Size1)
   Tplgetiatag(Sys_class$,Index,0,Lot_index(*))
  !
  ! !! lot ID (TST_LOT_ID)
   Tpltagindex(Sys_class$,"TST_LOT_ID",Index)
   IF Index=-1 THEN GOTO Exit_1
   Tpltaginfo(Sys_class$,Index,Name$,Type,Dim,Size1,Size2)
   ALLOCATE Lot_id$(Size1)[255]
   Tplgetsatag(Sys_class$,Index,0,Lot_id$(*))
  !
  ! !! wafer ID (TST_SLOT_WAFERID)
   Tpltagindex(Sys_class$,"TST_SLOT_WAFERID",Index)
   IF Index=-1 THEN GOTO Exit_2
   Tpltaginfo(Sys_class$,Index,Name$,Type,Dim,Size1,Size2)
   ALLOCATE Wafer_id$(Size1)[255]
   Tplgetsatag(Sys_class$,Index,0,Wafer_id$(*))
  !
  ! !! slot selection (TST_SLOT_SELECT)
   Tpltagindex(Sys_class$,"TST_SLOT_SELECT",Index)
   IF Index=-1 THEN Exit_3
   Tpltaginfo(Sys_class$,Index,Name$,Type,Dim,Size1,Size2)
   ALLOCATE INTEGER Slot_selection(Size1)
   Tplgetiatag(Sys_class$,Index,0,Slot_selection(*))
  !
  ! !! find slot number
   FOR I=1 TO Slot_num
  !
  !  skip unselect slot
     IF Slot_selection(I)<>1 THEN GOTO For_end
  !
  !  !! compare lot ID and wafer ID
     IF Lotid$=Lot_id$(Lot_index(I)) AND Waferid$=Wafer_id$(I) THEN 
       Slotno=I
       GOTO Fin
     END IF
 For_end:    !
   NEXT I
  !
 Fin:    !
   DEALLOCATE Slot_selection(*)
 Exit_3:    !
   DEALLOCATE Wafer_id$(*)
 Exit_2:    !
   DEALLOCATE Lot_id$(*)
 Exit_1:    !
   DEALLOCATE Lot_index(*)
  !
 SUBEND
 Get_vgemdefault:SUB Get_vgemdefault(Rcpmode$,Rcpfilename$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : GET_VGEMDEFAULT
  !  Vers : 1
  !  Desc : Read configuration parameter and apply them.
  !       :   SPECS2.5: Added special parameters.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Rcpmode         S    -
  !      2 Rcpfilename     S    -
  !      3 Status          I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Line$[256],Symbol$[256],Value$[256],Token$[256],Name$[32],Src$[256]
   DIM Subsymbol$[256]
   INTEGER P_col,P_exc,P_comma                 !":", "!" and ","
   INTEGER Idx_tag,Idx_dim1,Typ,Dim,Size1,Size2,Length
   Errno=0
   Errmsg$=""
   ON ERROR GOTO Err
   ASSIGN @Vgemdef TO "/opt/SPECS_FA/dmh/vgem/defaults.ini";FORMAT ON
   ON END @Vgemdef GOTO Endoffile
   LOOP
     Symbol$=""
     Value$=""
  !
     ENTER @Vgemdef;Line$
     Line$=TRIM$(Line$)
     P_exc=POS(Line$,"#")
     SELECT P_exc
     CASE 0
     CASE 1
       Line$=""
     CASE ELSE
       Line$=Line$[1,P_exc-1]
     END SELECT
  !
     P_col=POS(Line$," ")
     IF P_col>=2 THEN 
       Symbol$=Line$[1,P_col-1]
       Symbol$=TRIM$(Symbol$)
       IF Symbol$="VGEM" AND LEN(Line$)>P_col THEN 
         Value$=Line$[P_col+1,LEN(Line$)]
         Value$=TRIM$(Value$)
         P_sep=POS(Value$," ")
         IF P_sep>=2 THEN 
           Subsymbol$=Value$[1,P_sep-1]
           Subsymbol$=TRIM$(Subsymbol$)
           IF Subsymbol$="RecipeFile" AND LEN(Value$)>P_sep THEN 
             Rcpfilename$=Value$[P_sep+1,LEN(Value$)]
             Rcpfilename$=TRIM$(Rcpfilename$)
           END IF
           IF Subsymbol$="CompatibilityMode" AND LEN(Value$)>P_sep THEN 
             Rcpmode$=Value$[P_sep+1,LEN(Value$)]
             Rcpmode$=TRIM$(Rcpmode$)
           END IF
         END IF
       END IF
     END IF
  !
  !
 Loop_next: !
   END LOOP
   SUBEXIT
 Endoffile:                                  !
   ASSIGN @Vgemdef TO *
   SUBEXIT
 Err:                                  !
   ASSIGN @Vgemdef TO *
   Status=-1
 SUBEND
 Is_calg:SUB Is_calg(INTEGER Lang)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : IS_CALG
  !  Vers : 1
  !  Desc : Check the lang of algorithm
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Lang            I    -        BASIC:0, C:1
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Lang=0     ! BASIC
 SUBEND
 Is_first:SUB Is_first(INTEGER First)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : IS_FIRST
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 First           I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   First=0
 SUBEND
 Jdg_die:SUB Jdg_die(INTEGER Tgt_yld,Last,Critical,Ignore,Jdg,REAL Yld,INTEGER Pass_cnt,Fail_cnt,Total_cnt)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : JDG_DIE
  !  Vers : 1
  !  Desc : Judge current die by parameter yield.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Tgt_yld         I    -        target parameter yield to be pas
  !      2 Last            I    -        all test are finished or not
  !      3 Critical        I    -        user flag index as "critical" pa
  !      4 Ignore          I    -        user flag index as "ignored" par
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Jdg             I    -        0:fail/1:pass/2:unknown
  !      2 Yld             R    -        parameter yield
  !      3 Pass_cnt        I    -        pass count of parameter
  !      4 Fail_cnt        I    -        fail count of parameter
  !      5 Total_cnt       I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Current_pos
  !
   Tpldiepos(Current_pos)
  !
   CALL Jdg_die_at_pos2(Current_pos,Tgt_yld,Last,Critical,Ignore,Jdg,Yld,Pass_cnt,Fail_cnt,Total_cnt)
 SUBEND
 Jdg_die_at_pos:SUB Jdg_die_at_pos(INTEGER Die_pos,Tgt_yld,Last,Jdg,REAL Yld,INTEGER Pass_cnt,Fail_cnt,Total_cnt)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : JDG_DIE_AT_POS
  !  Vers : 1
  !  Desc : Judge specified die by parameter yield.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Die_pos         I    -        index of die
  !      2 Tgt_yld         I    -        target parameter yield to be pas
  !      3 Last            I    -        all test are finished or not
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Jdg             I    -        0:fail/1:pass/2:unknown
  !      2 Yld             R    -        parameter yield
  !      3 Pass_cnt        I    -        pass count of parameter
  !      4 Fail_cnt        I    -        fail count of parameter
  !      5 Total_cnt       I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Out_cnt,Out_index,Type,Dim,Size1,Size2,Current_jdg,Selected
   DIM Name$[256]
  !
   Jdg=2
   Yld=0
   Pass_cnt=0
   Fail_cnt=0
   Total_cnt=0
   Tploutcount(Out_cnt)
  !
  !  output variable index starts from zero
   FOR Out_index=0 TO Out_cnt-1
     CALL Tploutstat(Out_index,Die_pos,Selected)
     IF Selected<>0 THEN 
       CALL Tploutinfo(Out_index,Name$,Type,Dim,Size1,Size2)
       IF Dim=0 AND (Type=0 OR Type=1) THEN 
         CALL Tploutjudge(Out_index,Die_pos,Current_jdg)
         IF Current_jdg<>2 THEN 
           Total_cnt=Total_cnt+1
         END IF
         SELECT Current_jdg
         CASE 0
           Fail_cnt=Fail_cnt+1
         CASE 1
           Pass_cnt=Pass_cnt+1
         CASE 2          ! Invalid
         CASE 3          ! Untested
         END SELECT
       END IF
     END IF
   NEXT Out_index
  !
   IF Pass_cnt+Fail_cnt>0 THEN 
     IF Last=1 THEN 
       Yld=Pass_cnt/(Pass_cnt+Fail_cnt)*100
       IF Yld>=Tgt_yld THEN 
         Jdg=1
       ELSE
         Jdg=0
       END IF
     ELSE
       Yld=100-Fail_cnt/Total_cnt*100
       IF Yld<Tgt_yld THEN 
         Jdg=0
       END IF
       Yld=Pass_cnt/Total_cnt*100
       IF Jdg<>0 AND Yld>=Tgt_yld THEN 
         Jdg=1
       END IF
     END IF
   ELSE
     Yld=0
   END IF
 SUBEND
 Jdg_die_at_pos2:SUB Jdg_die_at_pos2(INTEGER Die_pos,Tgt_yld,Last,Critical,Ignore,Jdg,REAL Yld,INTEGER Pass_cnt,Fail_cnt,Total_cnt)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : JDG_DIE_AT_POS2
  !  Vers : 1
  !  Desc : Judge specified die by parameter yield.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Die_pos         I    -        index of die
  !      2 Tgt_yld         I    -        target parameter yield to be pas
  !      3 Last            I    -        all test are finished or not
  !      4 Critical        I    -        user flag index as "critical" pa
  !      5 Ignore          I    -        user flag index as "ignored" par
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Jdg             I    -        0:fail/1:pass/2:unknown
  !      2 Yld             R    -        parameter yield
  !      3 Pass_cnt        I    -        pass count of parameter
  !      4 Fail_cnt        I    -        fail count of parameter
  !      5 Total_cnt       I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Out_cnt,Out_index,Type,Dim,Size1,Size2,Current_jdg,Selected
   INTEGER Usrflag,Force_fail
   DIM Name$[256]
  !
   Jdg=2
   Yld=0
   Pass_cnt=0
   Fail_cnt=0
   Total_cnt=0
   Force_fail=0
   Tploutcount(Out_cnt)
  !
  !  output variable index starts from zero
   FOR Out_index=0 TO Out_cnt-1
     CALL Tploutstat(Out_index,Die_pos,Selected)
     IF Selected<>0 THEN 
       IF Ignore<>0 THEN 
         CALL Tplgetusrflag(Out_index,Ignore-1,Usrflag)
         IF Usrflag<>0 THEN Next_var
       END IF
       CALL Tploutinfo(Out_index,Name$,Type,Dim,Size1,Size2)
       IF Dim=0 AND (Type=0 OR Type=1) THEN 
         CALL Tploutjudge(Out_index,Die_pos,Current_jdg)
         IF Current_jdg<>2 THEN 
           Total_cnt=Total_cnt+1
         END IF
         SELECT Current_jdg
         CASE 0
           Fail_cnt=Fail_cnt+1
           IF Critical<>0 THEN 
             CALL Tplgetusrflag(Out_index,Critical-1,Usrflag)
             IF Usrflag<>0 THEN Force_fail=1
           END IF
         CASE 1
           Pass_cnt=Pass_cnt+1
         CASE 2          ! Invalid
         CASE 3          ! Untested
         END SELECT
       END IF
     END IF
 Next_var: !
   NEXT Out_index
  !
   IF Pass_cnt+Fail_cnt>0 THEN 
     IF Last=1 THEN 
       Yld=Pass_cnt/(Pass_cnt+Fail_cnt)*100
       IF Yld>=Tgt_yld THEN 
         Jdg=1
       ELSE
         Jdg=0
       END IF
     ELSE
       Yld=100-Fail_cnt/Total_cnt*100
       IF Yld<Tgt_yld THEN 
         Jdg=0
       END IF
       Yld=Pass_cnt/Total_cnt*100
       IF Jdg<>0 AND Yld>=Tgt_yld THEN 
         Jdg=1
       END IF
     END IF
   ELSE
     Yld=0
   END IF
  !
   IF Force_fail=1 THEN Jdg=0
  !
 SUBEND
 Jdg_mod:SUB Jdg_mod(INTEGER Ignore,Jdg,Pass_cnt,Fail_cnt,Total_cnt)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : JDG_MOD
  !  Vers : 1
  !  Desc : Return if current module has failed outputs.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Ignore          I    -        user flag index as "ignored" par
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Jdg             I    -        0:fail/1:pass/2:unknown
  !      2 Pass_cnt        I    -        pass count of item
  !      3 Fail_cnt        I    -        fail count of item
  !      4 Total_cnt       I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Current_die
   INTEGER Current_mod
  !
   Tpldiepos(Current_die)
   Tplmodulepos(Current_mod)
  !
   Jdg_mod_at_pos(Current_die,Current_mod,Ignore,Jdg,Pass_cnt,Fail_cnt,Total_cnt)
  !
 SUBEND
 Jdg_mod_at_pos:SUB Jdg_mod_at_pos(INTEGER Die_pos,Mod_pos,Ignore,Jdg,Pass_cnt,Fail_cnt,Total_cnt)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : JDG_MOD_AT_POS
  !  Vers : 1
  !  Desc : Return if specified module has failed outputs.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Die_pos         I    -        index of die
  !      2 Mod_pos         I    -        Index of module
  !      3 Ignore          I    -        user flag index as "ignored" par
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Jdg             I    -        0:fail/1:pass/2:unknown
  !      2 Pass_cnt        I    -        pass count of item
  !      3 Fail_cnt        I    -        fail count of item
  !      4 Total_cnt       I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Out_cnt,Out_index,Type,Dim,Size1,Size2,Current_jdg,Selected
   INTEGER Min_in_mod,Max_in_mod,Usrflag
   DIM Name$[256]
  !
   Jdg=2
   Pass_cnt=0
   Fail_cnt=0
   Total_cnt=0
  !
   Tplgetrangemod(Die_pos,Mod_pos,Min_in_mod,Max_in_mod)
   FOR Out_index=Min_in_mod TO Max_in_mod
     IF Ignore<>0 THEN 
       CALL Tplgetusrflag(Out_index,Ignore-1,Usrflag)
       IF Usrflag<>0 THEN Next_var
     END IF
     CALL Tploutstat(Out_index,Die_pos,Selected)
     IF Selected<>0 THEN 
       CALL Tploutinfo(Out_index,Name$,Type,Dim,Size1,Size2)
       IF Dim=0 AND (Type=0 OR Type=1) THEN 
         CALL Tploutjudge(Out_index,Die_pos,Current_jdg)
         IF Current_jdg<>2 THEN 
           Total_cnt=Total_cnt+1
         END IF
         SELECT Current_jdg
         CASE 0
           Fail_cnt=Fail_cnt+1
         CASE 1
           Pass_cnt=Pass_cnt+1
         CASE 2           ! Invalid
         CASE 3           ! Untested
         END SELECT
       END IF
     END IF
 Next_var: !
   NEXT Out_index
  !
   IF Fail_cnt>0 THEN 
     Jdg=0
   ELSE
     IF Pass_cnt>0 THEN 
       Jdg=1
     END IF
   END IF
  !
 SUBEND
 Jdg_waf_by_die:SUB Jdg_waf_by_die(INTEGER Tgt_wafyld,Tgt_dieyld,Last,Jdg,REAL Yld,INTEGER Pass_cnt,Fail_cnt,Total_cnt)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : JDG_WAF_BY_DIE
  !  Vers : 1
  !  Desc : Judge current wafer by die yield.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Tgt_wafyld      I    -        target parameter yield to be pas
  !      2 Tgt_dieyld      I    -
  !      3 Last            I    -        all test are finished or not
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Jdg             I    -        0:fail/1:pass/2:unknown
  !      2 Yld             R    -        die yield
  !      3 Pass_cnt        I    -        pass count of die
  !      4 Fail_cnt        I    -        fail count of die
  !      5 Total_cnt       I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Total_die,Die_pos,Current_jdg,Para_pass,Para_fail,Para_total,Selected
  !
   Jdg=2
   Yld=0
   Pass_cnt=0
   Fail_cnt=0
   Total_cnt=0
   Tpldietotal(Total_die)
  !
  !  die index starts from zero
   FOR Die_pos=0 TO Total_die-1
     CALL Tpldiestat(Die_pos,Selected)
     IF Selected<>0 THEN 
       Total_cnt=Total_cnt+1
       CALL Jdg_die_at_pos(Die_pos,Tgt_dieyld,Last,Current_jdg,Para_yld,Para_pass,Para_fail,Para_total)
       SELECT Current_jdg
       CASE 0
         Fail_cnt=Fail_cnt+1
       CASE 1
         Pass_cnt=Pass_cnt+1
       CASE 2
       END SELECT
     END IF
   NEXT Die_pos
  !
   IF Pass_cnt+Fail_cnt>0 THEN 
     IF Last=1 THEN 
       Yld=Pass_cnt/(Pass_cnt+Fail_cnt)*100
       IF Yld>=Tgt_wafyld THEN 
         Jdg=1
       ELSE
         Jdg=0
       END IF
     ELSE
       Yld=100-Fail_cnt/Total_cnt*100
       IF Yld<Tgt_wafyld THEN 
         Jdg=0
       END IF
       Yld=Pass_cnt/Total_cnt*100
       IF Jdg<>0 AND Yld>=Tgt_wafyld THEN 
         Jdg=1
       END IF
     END IF
   ELSE
     Yld=0
   END IF
 SUBEND
 Jdg_waf_by_para:SUB Jdg_waf_by_para(INTEGER Tgt_yld,Last,Critical,Ignore,Jdg,REAL Yld,INTEGER Pass_cnt,Fail_cnt,Total_cnt)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : JDG_WAF_BY_PARA
  !  Vers : 1
  !  Desc : Judge current wafer by parameter yield.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Tgt_yld         I    -        target parameter yield to be pas
  !      2 Last            I    -        all test are finished or not
  !      3 Critical        I    -        user flag index as "critical" pa
  !      4 Ignore          I    -        user flag index as "ignored" par
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Jdg             I    -        0:fail/1:pass/2:unknown
  !      2 Yld             R    -        parameter yield
  !      3 Pass_cnt        I    -        pass count of parameter
  !      4 Fail_cnt        I    -        fail count of parameter
  !      5 Total_cnt       I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Total_out,Total_die,Die_pos,Out_index
   INTEGER Tgt_item_yld,Item_yld,Current_jdg
   INTEGER Type,Dim,Size1,Size2
   INTEGER Select_die,Select_out,Pass_waf,Fail_waf,Total_waf
   INTEGER Force_fail,Usrflag
   REAL Out_yld
   DIM Name$[256]
  !
   Jdg=2
   Yld=0
   Pass_cnt=0
   Fail_cnt=0
   Total_cnt=0
   Force_fail=0
   Tploutcount(Total_out)
   Tpldietotal(Total_die)
  !
  !  output variable index starts from zero
   IF Last=1 THEN 
     FOR Out_index=0 TO Total_out-1
       IF Ignore<>0 THEN 
         CALL Tplgetusrflag(Out_index,Ignore-1,Usrflag)
         IF Usrflag<>0 THEN Next_var
       END IF
       CALL Tploutinfo(Out_index,Name$,Type,Dim,Size1,Size2)
       IF Dim=0 AND (Type=0 OR Type=1) THEN 
         CALL Tplgetwafjudge(Out_index,Tgt_item_yld,Item_yld,Current_jdg)
         Total_cnt=Total_cnt+1
         SELECT Current_jdg
         CASE 0
           Fail_cnt=Fail_cnt+1
           IF Critical<>0 THEN 
             CALL Tplgetusrflag(Out_index,Critical-1,Usrflag)
             IF Usrflag<>0 THEN Force_fail=1
           END IF
         CASE 1
           Pass_cnt=Pass_cnt+1
         END SELECT
       END IF
 Next_var: !
     NEXT Out_index
     IF Pass_cnt+Fail_cnt>0 THEN 
       Yld=Pass_cnt/(Pass_cnt+Fail_cnt)*100
       IF Yld>=Tgt_yld THEN 
         Jdg=1
       ELSE
         Jdg=0
       END IF
     END IF
   ELSE
     FOR Out_index=0 TO Total_out-1
       Pass_waf=0
       Fail_waf=0
       Total_waf=0
       IF Ignore<>0 THEN 
         CALL Tplgetusrflag(Out_index,Ignore-1,Usrflag)
         IF Usrflag<>0 THEN Next_var2
       END IF
       FOR Die_pos=0 TO Total_die-1
         CALL Tpldiestat(Die_pos,Select_die)
         IF Select_die<>0 THEN 
           CALL Tploutstat(Out_index,Die_pos,Select_out)
           IF Select_out<>0 THEN 
             CALL Tploutinfo(Out_index,Name$,Type,Dim,Size1,Size2)
             IF Dim=0 AND (Type=0 OR Type=1) THEN 
               CALL Tploutjudge(Out_index,Die_pos,Current_jdg)
               IF Current_jdg<>2 THEN           ! if not invalid
                 Total_waf=Total_waf+1
               END IF
               SELECT Current_jdg
               CASE 0
                 Fail_waf=Fail_waf+1
                 IF Critical<>0 THEN 
                   CALL Tplgetusrflag(Out_index,Critical-1,Usrflag)
                   IF Usrflag<>0 THEN Force_fail=1
                 END IF
               CASE 1
                 Pass_waf=Pass_waf+1
               CASE 2           ! Invalid
               CASE 3           ! Untested
               END SELECT
             END IF
           END IF
         END IF
       NEXT Die_pos
       IF Total_waf>0 THEN 
         Total_cnt=Total_cnt+1
       END IF
       IF Pass_waf+Fail_waf>0 THEN 
         CALL Tplgetwafjudge(Out_index,Tgt_item_yld,Item_yld,Current_jdg)
         Out_yld=Pass_waf/Total_waf*100
         IF Out_yld>=Tgt_item_yld THEN 
           Pass_cnt=Pass_cnt+1
         ELSE
           Out_yld=100-Fail_waf/Total_waf*100
           IF Out_yld<Tgt_item_yld THEN 
             Fail_cnt=Fail_cnt+1
           END IF
         END IF
       END IF
 Next_var2: !
     NEXT Out_index
     IF Pass_cnt+Fail_cnt>0 THEN 
       Yld=Pass_cnt/Total_cnt*100
       IF Yld>=Tgt_yld THEN 
         Jdg=1
       ELSE
         Yld=100-Fail_cnt/Total_cnt*100
         IF Yld<Tgt_yld THEN 
           Jdg=0
         END IF
       END IF
     END IF
   END IF
  !
   IF Force_fail=1 THEN Jdg=0
  !
 SUBEND
 Log_lot_begin:SUB Log_lot_begin(Session$,Lotid$,Testplan$,Algorithm$,Limitfile$,Operator$,Date$,Time$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : LOG_LOT_BEGIN
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -
  !      2 Lotid           S    -
  !      3 Testplan        S    -
  !      4 Algorithm       S    -
  !      5 Limitfile       S    -
  !      6 Operator        S    -
  !      7 Date            S    -
  !      8 Time            S    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;RPT$("=",31)&" LOT TEST START "&RPT$("=",31)
   OUTPUT @Tmp;""
   OUTPUT @Tmp;"     Lot ID:     "&Lotid$
   OUTPUT @Tmp;"     Test Plan:  "&Testplan$
   OUTPUT @Tmp;"     Algorithm:  "&Algorithm$
   OUTPUT @Tmp;"     Limit File: "&Limitfile$
   OUTPUT @Tmp;"     Operator:   "&Operator$
   OUTPUT @Tmp;"     Date:       "&Date$
   OUTPUT @Tmp;"     Start:      "&Time$
   OUTPUT @Tmp;""
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Log_lot_end:SUB Log_lot_end(Session$,State$,INTEGER Result,Datadir$,Dataname$,Time$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : LOG_LOT_END
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -
  !      2 State           S    -
  !      3 Result          I    -
  !      4 Datadir         S    -
  !      5 Dataname        S    -
  !      6 Time            S    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256],Judge$[4]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   SELECT Result
   CASE 0
     Judge$="Fail"
   CASE 1
     Judge$="Pass"
   END SELECT
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;"     End:        "&Time$
   OUTPUT @Tmp;"     State:      "&State$
   OUTPUT @Tmp;"     Result:     "&Judge$
   OUTPUT @Tmp;"     Data File:  "&Datadir$&"/"&Dataname$
   OUTPUT @Tmp;""
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Log_prober:SUB Log_prober(Session$,Message$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : LOG_PROBER
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -
  !      2 Message         S    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;"     >>>>> PROBER ERROR "&DATE$(TIMEDATE)&" "&TIME$(TIMEDATE)&" >>>>> "&Message$
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Log_system:SUB Log_system(Session$,Message$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : LOG_SYSTEM
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -
  !      2 Message         S    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;"     >>>>> SYSTEM ERROR "&DATE$(TIMEDATE)&" "&TIME$(TIMEDATE)&" >>>>> "&Message$
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Log_wafer_begin:SUB Log_wafer_begin(Session$,Waferid$,Time$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : LOG_WAFER_BEGIN
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -
  !      2 Waferid         S    -
  !      3 Time            S    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;"          Wafer ID: "&Waferid$
   OUTPUT @Tmp;"          Start:    "&Time$
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Log_wafer_end:SUB Log_wafer_end(Session$,State$,INTEGER Result,Time$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : LOG_WAFER_END
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -
  !      2 State           S    -
  !      3 Result          I    -
  !      4 Time            S    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpfile$[256],Logfile$[256],Judge$[4]
  !
   Logfile$="/var/opt/SPECS/log/testlog."&Session$    ! AVPATH_
   Tmpfile$="/var/tmp/LOGFWK"&SYSTEM$("PROCESS ID")    ! AVPATH_
  !
   SELECT Result
   CASE 0
     Judge$="Fail"
   CASE 1
     Judge$="Pass"
   END SELECT
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:    !
   ON ERROR GOTO Err
   IF ERRN<>0 AND ERRN<>56 THEN     ! File name is undefined
     SUBEXIT
   END IF
  !
   CREATE Tmpfile$,1
   ASSIGN @Tmp TO Tmpfile$;FORMAT ON
   OUTPUT @Tmp;"          End:      "&Time$
   OUTPUT @Tmp;"          State:    "&State$
   OUTPUT @Tmp;"          Result:   "&Judge$
   OUTPUT @Tmp;""
   ASSIGN @Tmp TO *
  !
   EXECUTE "cat "&Tmpfile$&" | col -bx >> "&Logfile$
 Err:    !
   ON ERROR GOTO Fatal
   PURGE Tmpfile$
 Fatal:    !
 SUBEND
 Master_lookup:SUB Master_lookup(File$,Key$,INTEGER Fnum,Field$,INTEGER Stat)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : MASTER_LOOKUP
  !  Vers : 1
  !  Desc : Returns specified field of specified line in an ASCII dat
  !       : a file
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 File            S    -        Master filename
  !      2 Key             S    -        Key string
  !      3 Fnum            I    -        Field number, 1 ~ 199
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Field           S    -        Extracted field
  !      2 Stat            I    -        0(ok),-1(no key),-2(invalid),-3(
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Field$=""
   ON ERROR GOTO Nofile
   ASSIGN @Tmp TO File$
   ASSIGN @Tmp TO *
   OFF ERROR 
   ON ERROR GOTO Nofile
   ASSIGN @Pipe TO "grep -v '^#' "&File$&" | awk -F: '{ if($1 == """&Key$&"""){ if("&VAL$(Fnum)&"<=NF){ print $"&VAL$(Fnum)&"; } else { print "":""; }}}'| "
   OFF ERROR 
   ON END @Pipe GOTO Eof
   ON ERROR GOTO Overflow
   ENTER @Pipe;Field$
   ASSIGN @Pipe TO *
   IF Field$=":" THEN 
     Field$=""
     Stat=-2
   ELSE
     Stat=0
   END IF
   SUBEXIT
 Nofile:Stat=-3
   SUBEXIT
 Eof:Stat=-1
   SUBEXIT
 Overflow:Field$=""
   Stat=-2
   SUBEXIT
 SUBEND
 Merge_datafile:SUB Merge_datafile(Original$,New$,Format$,INTEGER Numwaf,Waferid$(*),INTEGER Stat,Error$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : MERGE_DATAFILE
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Original        S    -
  !      2 New             S    -
  !      3 Format          S    -
  !      4 Numwaf          I    -
  !      5 Waferid         S    50
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Stat            I    -
  !      2 Error           S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Merge$[256],Stderr$[256],Tag$[4],Cmd$[1024],Wafer$[1024]
   INTEGER I
  !
   Error$=""
   Tag$="base"
  !
   Wafer$=""
   FOR I=1 TO Numwaf
     Wafer$=Wafer$&Waferid$(I)&" "
   NEXT I
  !
   Merge$=Original$&".mrg"
   Stderr$=Original$&".err"
   Original$=Original$&"."&Format$
   New$=New$&"."&Format$
  !
   ON ERROR GOTO Nofile
   PURGE Stderr$
 Nofile:  !
   IF ERRN<>0 AND ERRN<>56 THEN 
     OFF ERROR 
     Stat=-1
     Error$=ERRM$
     PRINT Error$
     SUBEXIT
   END IF
  !
   ON ERROR GOTO Err
   Cmd$="/opt/SPECS/sys/bin/datamerge -t "&Tag$&" "&Original$&" \"&New$&" "&Wafer$&" 1>"&Merge$&" 2>"&Stderr$    ! AVPATH_
   EXECUTE Cmd$
   ASSIGN @File TO Stderr$
   ON END @File GOTO Eof_stderr
   Error$=""
   ENTER @File;Error$
 Eof_stderr:  !
   OFF END @File
   ASSIGN @File TO *
   PURGE Stderr$
   IF Error$<>"" THEN 
     PURGE Merge$
     Stat=-1
     PRINT Error$
     SUBEXIT
   END IF
  !
   Cmd$="mv \"&Merge$&" "&Original$&" 2>&1 |"
   ASSIGN @Pipe TO Cmd$
   ON END @Pipe GOTO Eof_mv
   ENTER @Pipe;Error$
   OFF END @Pipe
   ASSIGN @Pipe TO *
   OFF ERROR 
   PURGE Merge$
   Stat=-1
   PRINT Error$
   SUBEXIT
  !
 Eof_mv:                            !
   OFF END @Pipe
   ASSIGN @Pipe TO *
   OFF ERROR 
   Stat=0
   SUBEXIT
 Err:                              !
   OFF ERROR 
   Stat=-1
   Error$=ERRM$
   PRINT Error$
 SUBEND
 Name_tmpdata:SUB Name_tmpdata(Basename$,Session$,Tmpname$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : NAME_TMPDATA
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Basename        S    -
  !      2 Session         S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Tmpname         S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Tmpname$="#"&Session$&TRIM$(Basename$)
 SUBEND
 Plotter_is:SUB Plotter_is(INTEGER Sel)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : PLOTTER_IS
  !  Vers : 1
  !  Desc : Changes the PLOTTER IS device
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Sel             I    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   PLOTTER IS Sel,"WINDOW"
 SUBEND
 Prbcount:SUB Prbcount(INTEGER Count)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : PRBCOUNT
  !  Vers : 1
  !  Desc : Return the number of Pins
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Count           I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Tplprbcount(Count)
 SUBEND
 Prbinfo:SUB Prbinfo(INTEGER Index,Pad,Pin)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : PRBINFO
  !  Vers : 1
  !  Desc : Return pin number and pad number.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Index           I    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Pad             I    -
  !      2 Pin             I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Tplprbinfo(Index,Pad,Pin)
 SUBEND
 Print:SUB Print(S$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : PRINT
  !  Vers : 1
  !  Desc : Prints the specified STRING variable to the present PRINT
  !       : ER IS device
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 S               S    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   PRINT S$
 SUBEND
 Print_char:SUB Print_char(Format$,Value$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : PRINT_CHAR
  !  Vers : 1
  !  Desc : Writes a CHARACTER value to a STRING variable, then print
  !       : s it to the present PRINTER IS device
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 Value           C    -        Value to convert
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM String$[255]
   INTEGER Length
   Writechar(Format$,Value$,String$,Length)
   PRINT String$
 SUBEND
 Print_integer:SUB Print_integer(Format$,INTEGER Value)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : PRINT_INTEGER
  !  Vers : 1
  !  Desc : Writes an INTEGER value to a STRING variable, then prints
  !       :  it to the present PRINTER IS device
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 Value           I    -        Value to convert
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM String$[255]
   INTEGER Length
   Writeinteger(Format$,Value,String$,Length)
   PRINT String$
 SUBEND
 Print_real:SUB Print_real(Format$,REAL Value)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : PRINT_REAL
  !  Vers : 1
  !  Desc : Writes a REAL value to a STRING variable, then prints it
  !       : to the present PRINTER IS device
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 Value           R    -        Value to convert
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM String$[255]
   INTEGER Length
   Writereal(Format$,Value,String$,Length)
   PRINT String$
 SUBEND
 Print_string:SUB Print_string(Format$,Value$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : PRINT_STRING
  !  Vers : 1
  !  Desc : Writes a STRING value to a STRING variable, then prints i
  !       : t to the present PRINTER IS device
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 Value           S    -        Value to convert
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM String$[255]
   INTEGER Length
   Writestring(Format$,Value$,String$,Length)
   PRINT String$
 SUBEND
 Printer_is:SUB Printer_is(INTEGER Sel)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : PRINTER_IS
  !  Vers : 1
  !  Desc : Changes the PRINTER IS device
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Sel             I    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   PRINTER IS Sel
 SUBEND
 Query_dir:SUB Query_dir(Dir$,INTEGER Stat)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : QUERY_DIR
  !  Vers : 1
  !  Desc : Let Quick Query open specified directory.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Dir             S    -        Opened directory.
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Stat            I    -        0:ok, -1:not found
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Qq_open_dir(Dir$,Stat)
  !
 SUBEND
 Query_file:SUB Query_file(File$,INTEGER Stat)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : QUERY_FILE
  !  Vers : 1
  !  Desc : Let Quick Query open specified file.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 File            S    -        Opened file.
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Stat            I    -        0:ok, -1:not found
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Qq_open_file(File$,Stat)
  !
 SUBEND
 Query_graph:SUB Query_graph(INTEGER Filter,Type,Unit,Variable$,INTEGER Update)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : QUERY_GRAPH
  !  Vers : 1
  !  Desc : Let Quick Query open Graph. Must be executed after QUERY_
  !       : FILE.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Filter          I    -        Filter item.
  !      2 Type            I    -        0:XY, 1:Hist, 2:WaferMap
  !      3 Unit            I    -        0:Lot, 1:Wafer, 2:Die
  !      4 Variable        S    -        Output variable name.
  !      5 Update          I    -        0:New, 1:Update
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   IF Update=0 THEN 
     Qq_graph_start(Filter,Type,Unit,Variable$)
   ELSE
     Qq_graph_update(Filter,Type,Unit,Variable$)
   END IF
  !
 SUBEND
 Query_launch:SUB Query_launch(Session$,Port$,Project$,Hostname$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : QUERY_LAUNCH
  !  Vers : 1
  !  Desc : Start Quick Query.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Session         S    -        Session ID
  !      2 Port            S    -        Port ID
  !      3 Project         S    -        Project ID
  !      4 Hostname        S    -        Hostname
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Buf$(32)[256]
   INTEGER Nopt
  !
   Nopt=0
  !
   Nopt=Nopt+1
   Buf$(Nopt)="-c"&Port$
   Nopt=Nopt+1
   Buf$(Nopt)="-g"&Session$
   Nopt=Nopt+1
   Buf$(Nopt)="-h"&Hostname$
  !
   Qq_init(Buf$(*),Nopt)
  !
 SUBEND
 Query_start:SUB Query_start
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : QUERY_START
  !  Vers : 1
  !  Desc : Popup Quick Query.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Qq_popup
  !
 SUBEND
 Query_stop:SUB Query_stop
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : QUERY_STOP
  !  Vers : 1
  !  Desc : Popdown Quick Query.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   Qq_popdown
  !
 SUBEND
 Query_view:SUB Query_view(Variable$,INTEGER Update)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : QUERY_VIEW
  !  Vers : 1
  !  Desc : Let Quick Query open Quick View. Must be executed after Q
  !       : UERY_FILE.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Variable        S    -        Output variable name.
  !      2 Update          I    -        0:New, 1:Update
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   IF Update=0 THEN 
     Qq_view_start(Variable$)
   ELSE
     Qq_view_update(Variable$)
   END IF
  !
 SUBEND
 Rcp_check_key:SUB Rcp_check_key(Filename$,INTEGER Status,Errmsg$,Dupkey$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : RCP_CHECK_KEY
  !  Vers : 1
  !  Desc : Check if recipe file has duplicate key fields.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Filename        S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0: OK, -1: Err, -2: No File
  !      2 Errmsg          S    -
  !      3 Dupkey          S    -        Duplicated key
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[8192],Dst$[256],Keylst$[256],Diff$[256],Nullkey$[256],Detail$(10)[256]
   DIM Key$[4096],Key2$[256]
   DIM File_nm$(3)[256],Pat$(3)[256],Rep$(3)[256],Rep_fl$(3)[256],Name$(3)[256]
   INTEGER Cmd_ret,Ndetail,Pos,Rep_fl_len,I,File_name_len
   REAL Line_no
   Tab$=CHR$(9)
  !
   Dst$="/var/tmp/rcp_key."&SYSTEM$("PROCESS ID")
   Keylst$="/var/tmp/rcp_keylst."&SYSTEM$("PROCESS ID")
   Diff$="/var/tmp/rcp_keydif."&SYSTEM$("PROCESS ID")
   Nullkey$="/var/tmp/rcp_nullkey."&SYSTEM$("PROCESS ID")
   Dupkey$=""
   Status=0
  !
   ON ERROR GOTO No_recipe_file
   ASSIGN @Fn TO Filename$
   ASSIGN @Fn TO *
   OFF ERROR 
  !
   Cmd$="/usr/bin/grep -Ee '^[^#][^\t ]*' "&Filename$&" | /usr/bin/cut -f 1"
   Cmd$=Cmd$&" | /usr/bin/grep -Ee '^[^\t]' | /usr/bin/sort"
   Rcp_exec_cmd(Cmd$,Dst$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status THEN 
     GOSUB Remove_file
     SUBEXIT
   END IF
  !
   Cmd$="/usr/bin/awk '/^.+$/{if (!match($0,""^[A-Za-z0-9_]+$"")){print $0;exit}}' "&Dst$
   ASSIGN @Pipe TO Cmd$&" | "
   ON END @Pipe GOTO Invalid_eof
   ENTER @Pipe;Key$
  !
   Status=-1
   Errmsg$="Recipe key must consist of A-Z,a-z,0-9 and '_': """&Key$&""""
   GOSUB Remove_file
   SUBEXIT
 Invalid_eof:     !
   OFF END @Pipe
   ASSIGN @Pipe TO *
  !
   Cmd$="/usr/bin/uniq "&Dst$
   Rcp_exec_cmd(Cmd$,Keylst$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status THEN 
     GOSUB Remove_file
     SUBEXIT
   END IF
  !
   Cmd$="/usr/bin/diff "&Dst$&" "&Keylst$
   Rcp_exec_cmd(Cmd$,Diff$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status THEN 
     IF Cmd_ret=1 THEN 
       Cmd$="/usr/bin/awk '{if (match($1,""^[<>]+"")){print $2;}}' "&Diff$
       ON ERROR GOTO No_exec
       ASSIGN @Pipe TO Cmd$&" | "
       ON END @Pipe GOTO Eof
       ENTER @Pipe;Key$
       Errmsg$="Duplicate key is found, """&Key$&"""."
       Dupkey$=Key$
 Eof:  !
       OFF END @Pipe
       ASSIGN @Pipe TO *
 No_exec:  !
     END IF
     GOSUB Remove_file
     SUBEXIT
   END IF
  !
   Cmd$="/usr/bin/sed -e 's/"&Tab$&"[^"&Tab$&"][^"&Tab$&"]*/"&Tab$&"X/g' "&Filename$
   Cmd$=Cmd$&" | /usr/bin/awk -F'\t' 'BEGIN{ln=0;}"
   Cmd$=Cmd$&"/^[^#]/{ln=ln+1;"
   Cmd$=Cmd$&"if((!match($0,""^[ \t]*$""))&&match($1,""^[ ]*$"")){print ln;exit 0;}}"
   Cmd$=Cmd$&"END{print 0;}'"
   Rcp_exec_cmd(Cmd$,Nullkey$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status THEN 
     GOSUB Remove_file
     SUBEXIT
   END IF
  !
   ON ERROR GOTO No_null_key
   ASSIGN @Pipe TO "/usr/bin/cat "&Nullkey$&" | "
   ON END @Pipe GOTO Eof_null_key
   ENTER @Pipe;Line_no
   IF Line_no>0 THEN 
     Status=-1
     Errmsg$="Null key is found at line "&VAL$(Line_no)&"."
   END IF
 Eof_null_key:  !
   OFF END @Pipe
   ASSIGN @Pipe TO *
 No_null_key:  !
  !
   Name$(1)="RCP_TPL"
   Name$(2)="RCP_LIM"
   Name$(3)=""
   File_nm$(1)=""
   File_nm$(2)=""
   File_nm$(3)=""
   FOR I=1 TO SIZE(Name$,1)-1
     Rcp_sysconf(Name$(I),File_nm$(I),Status)
     IF (Status<>0) THEN 
       Errmsg$=""""&Name$(I)&""""&"is not found in sysconf."
     END IF
   NEXT I
   Pat$(1)="$(RCP)"
   Pat$(2)="$(SI)"
   Pat$(3)=""
   Rep$(1)=""
   Rep$(2)="0"
   Rep$(3)=""
   FOR I=1 TO SIZE(Rep_fl$,1)-1
     Pos=0
     Rep_fl$(I)=""
     String_lookup(File_nm$(I),Pat$(1),Pos)
     IF (Pos>0) THEN 
       Rcp_replace_wd(File_nm$(I),Pat$(*),Rep$(*),Rep_fl$(I))
     END IF
   NEXT I
  !
   ON ERROR GOTO Internal_file
   ASSIGN @Keylst TO Keylst$;FORMAT ON
   ON END @Keylst GOTO Eof_name_check
   File_name_len=32
   LOOP
     ENTER @Keylst;Key$
     Key$=Key$[1;255]
     FOR I=1 TO SIZE(Rep_fl$,1)-1
       Rep_fl_len=LEN(Rep_fl$(I))
       IF Rep_fl_len>0 THEN 
         IF Rep_fl_len+LEN(Key$)>File_name_len THEN 
           Status=-1
           Key2$=Key$[1;File_name_len]
           Errmsg$="Recipe key is too long. (0 < key lenght <= "&VAL$(File_name_len-Rep_fl_len)&")"
           Errmsg$=Errmsg$&CHR$(10)&"It is used as a part of test plan or limit file name. ("&Key2$&")"
           ASSIGN @Keylst TO *
           GOSUB Remove_file
           SUBEXIT
         END IF
       END IF
     NEXT I
   END LOOP
 Internal_file:   !
   OFF ERROR 
   ASSIGN @Keylst TO *
   Status=-1
   Errmsg$="Error on accessing internal file, "&Keylst$
   GOSUB Remove_file
   SUBEXIT
 Eof_name_check:   !
   ASSIGN @Keylst TO *
  !
   GOSUB Remove_file
   SUBEXIT
  !
 Remove_file:  !
   ON ERROR GOTO Rm_nullkey
   PURGE Nullkey$
 Rm_nullkey:  !
   OFF ERROR 
   ON ERROR GOTO Rm_keylst
   PURGE Dst$
 Rm_keylst:  !
   OFF ERROR 
   ON ERROR GOTO Rm_dif
   PURGE Keylst$
 Rm_dif:  !
   OFF ERROR 
   ON ERROR GOTO Rm_end
   PURGE Diff$
 Rm_end:  !
   OFF ERROR 
   RETURN 
  !
 No_recipe_file:  !
   ASSIGN @Fl TO *
   OFF ERROR 
   Status=-2
   Errmsg$="Recipe file is not found."
   SUBEXIT
  !
 SUBEND
 Rcp_dietst:SUB Rcp_dietst(Die$(*),Tst$(*),Rule$,Die_tst$(*),INTEGER Status,Errmsg$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : RCP_DIETST
  !  Vers : 1
  !  Desc : The Algorithm makes a Die Spec-Test Spec list for tplbuil
  !       : d command.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Die             S    256
  !      2 Tst             S    256
  !      3 Rule            S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Die_tst         S    256
  !      2 Status          I    -        0: Ok
  !      3 Errmsg          S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER I,Die_sz,Tst_sz,Sz
  !
   FOR I=1 TO SIZE(Die_tst$,1)
     Die_tst$(I)=""
   NEXT I
   Status=0
   Errmsg$=""
  !
   I=1
   LOOP
   EXIT IF I>SIZE(Die$,1)
     Die_sz=I
   EXIT IF Die$(I)=""
     I=I+1
   END LOOP
  !
   I=1
   LOOP
   EXIT IF I>SIZE(Tst$,1)
     Tst_sz=I
   EXIT IF Tst$(I)=""
     I=I+1
   END LOOP
  !
   IF (Die_sz<Tst_sz) THEN 
     Status=1
     Errmsg$="Not enough number of die spec files to make die-test pairs."
   END IF
   IF (Die_sz>Tst_sz) THEN 
     Errmsg$="Test spec files that cannot make die-test pairs are skipped."
   END IF
  !
   Sz=MIN(SIZE(Die$,1),SIZE(Tst$,1))
   Sz=MIN(Sz,SIZE(Die_tst$,1))
   I=1
   LOOP
   EXIT IF I>Sz
   EXIT IF Die$(I)="" OR Tst$(I)=""
     Die_tst$(I)=Die$(I)&" "&Tst$(I)
     I=I+1
   END LOOP
  !
 SUBEND
 Rcp_exec_cmd:SUB Rcp_exec_cmd(Cmd$,Result$,INTEGER Status,Errmsg$,INTEGER Ndetail,Detail$(*),INTEGER Cmd_ret)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : RCP_EXEC_CMD
  !  Vers : 1
  !  Desc : Execute command file and get result file.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Cmd             S    -
  !      2 Result          S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0: OK, -1: Exec Err, -2: No File
  !      2 Errmsg          S    -
  !      3 Ndetail         I    -        # of lines of detail error messa
  !      4 Detail          S    10       Detailed error message
  !      5 Cmd_ret         I    -        Return value from Command
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Err$[256],Cl$[32767]
   DIM Ver$[20]
   INTEGER Arg_max
   INTEGER St,I
  !
   Ndetail=0
   FOR I=1 TO 10
     Detail$(I)=""
   NEXT I
   Cmd_ret=0
  !
   IF Cmd$="" THEN 
     Status=-2
     Errmsg$="No command is specified."
     SUBEXIT
   END IF
  !
   EXECUTE "/usr/bin/touch "&Result$;RETURN St
   IF St THEN 
     Status=-2
     Errmsg$="Cannot store the result. """&Result$&""""
     SUBEXIT
   END IF
  !
   Err$="/var/tmp/rcp_exec_cmd."&SYSTEM$("PROCESS ID")
   Status=0
   Errmsg$=""
  !
   ON ERROR GOTO Str_overflow
   Cl$=Cmd$&" > "&Result$&" 2> "&Err$
   OFF ERROR 
  !
   Ver$=SYSTEM$("VERSION:OS")
   Ver$=Ver$[3;5]
   IF Ver$<="10.20" THEN 
     Arg_max=20478
     IF LEN(Cl$)>Arg_max THEN 
       GOSUB Str_overflow
     END IF
   END IF
  !
   EXECUTE Cl$;RETURN St
  !
   Cmd_ret=SHIFT(St,8) MOD 256
   IF Cmd_ret>=128 THEN Cmd_ret=Cmd_ret-256
  !
   IF St<>0 THEN 
     Status=-1
     ON ERROR GOTO No_errfl
     ASSIGN @E TO Err$;FORMAT ON
     ASSIGN @E TO *
     OFF ERROR 
     ASSIGN @E TO Err$;FORMAT ON
     ON END @E GOTO Eof
     FOR I=1 TO 10
       ENTER @E;Detail$(I)
       Ndetail=I
     NEXT I
 Eof:   !
     OFF END @E
     ASSIGN @E TO *
  !
     IF Ndetail>0 THEN 
       Errmsg$=Detail$(1)
     ELSE
       Errmsg$="Error found while executing: "&Cl$
     END IF
   END IF
   PURGE Err$
   SUBEXIT
  !
 Str_overflow:   !
   Status=-1
   Errmsg$="Internal string buffer overflow."
   PURGE Err$
   SUBEXIT
  !
 No_errfl:   !
   Status=-1
   Errmsg$="Cannot execute command: "&Cl$
   PURGE Err$
   SUBEXIT
  !
 SUBEND
 Rcp_limbld:SUB Rcp_limbld(Tpl_dir$,Lms_dir$,Lim_dir$,Tpl$,Lms$(*),Lim$,INTEGER Status,Errmsg$,INTEGER Ndetail,Detail$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : RCP_LIMBLD
  !  Vers : 1
  !  Desc : This algorithm generates Limit File dynamically.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Tpl_dir         S    -
  !      2 Lms_dir         S    -
  !      3 Lim_dir         S    -
  !      4 Tpl             S    -
  !      5 Lms             S    256
  !      6 Lim             S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0: OK, -1: Exec Err, -2: No File
  !      2 Errmsg          S    -
  !      3 Ndetail         I    -        # of lines of detail error messa
  !      4 Detail          S    10       Detailed error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[32767],Opt$[32767],Err$[256]
   DIM T$[256],L$[256]
   INTEGER I,Cmd_ret
  !
   Ndetail=0
   IF Tpl$="" THEN 
     Status=-2
     Errmsg$="No test plan name is specified."
     SUBEXIT
   END IF
   IF Lim$="" THEN 
     Status=-2
     Errmsg$="No limit file name is specified."
     SUBEXIT
   END IF
   Rcp_mk_filename(Tpl_dir$,Tpl$,"",T$)
   Rcp_mk_filename(Lim_dir$,Lim$,".lim",L$)
  !
   ON ERROR GOTO Str_overflow
   Cmd$="/opt/SPECS/sys/bin/limbuild"
   Opt$=""
   I=1
   LOOP
   EXIT IF I>SIZE(Lms$,1)
   EXIT IF Lms$(I)=""
     Opt$=Opt$&" -lms "&Lms$(I)
     I=I+1
   END LOOP
   IF Lms_dir$<>"" THEN 
     Opt$=Opt$&" -lmspath "&Lms_dir$
   END IF
   Opt$=Opt$&" "&T$
  !
   Cmd$=Cmd$&Opt$
   OFF ERROR 
   Rcp_exec_cmd(Cmd$,L$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status<0 THEN 
     GOSUB Remove_file
   END IF
  !
  !
   SUBEXIT
  !
 Remove_file:   !
   ON ERROR GOTO Rm_end
   PURGE L$
 Rm_end:   !
   OFF ERROR 
   RETURN 
  !
 Str_overflow:   !
   Status=-1
   Errmsg$="Internal string buffer overflow."
   SUBEXIT
  !
 SUBEND
 Rcp_mk_filename:SUB Rcp_mk_filename(Dirname$,Filename$,Suffix$,Fullfile$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : RCP_MK_FILENAME
  !  Vers : 1
  !  Desc : Make file name from directory name and file name.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Dirname         S    -
  !      2 Filename        S    -
  !      3 Suffix          S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Fullfile        S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Dir$[256],Fil$[256]
   INTEGER Sl,Fl
  !
   IF Dirname$="" OR Filename$[1,1]="/" THEN 
     Fullfile$=Filename$
   ELSE
     Dir$=Dirname$
     IF Dir$[LEN(Dir$)]<>"/" THEN Dir$=Dir$&"/"
     Fullfile$=Dir$&Filename$
   END IF
  !
   Sl=LEN(Suffix$)
   Fl=LEN(Fullfile$)
   IF Sl THEN 
     IF Fl<Sl THEN 
       Fullfile$=Fullfile$&Suffix$
     ELSE
       IF Fullfile$[Fl-Sl+1]<>Suffix$ THEN 
         Fullfile$=Fullfile$&Suffix$
       END IF
     END IF
   END IF
 SUBEND
 Rcp_query_recip:SUB Rcp_query_recip(Key$,Filename$,Waf$,Die$(*),Mod$(*),Tst$(*),Prb$,Lms$(*),Tco$(*),Mlib$(*),Item$(*),INTEGER Status,Errmsg$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : RCP_QUERY_RECIP
  !  Vers : 1
  !  Desc : Query recipe items in the recipe file from key recipe id.
  !       :   SPECS3.1: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Key             S    -
  !      2 Filename        S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Waf             S    -
  !      2 Die             S    256
  !      3 Mod             S    256
  !      4 Tst             S    256
  !      5 Prb             S    -
  !      6 Lms             S    256
  !      7 Tco             S    16
  !      8 Mlib            S    6
  !      9 Item            S    32
  !     10 Status          I    -        0: OK, -1: Exec Err, -2: No File
  !     11 Errmsg          S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[32767],Spc$[256],Line$[4096],Detail$(10)[256],Spc_nm$[256]
   INTEGER I,N_item,Ndetail,Cmd_ret
  !
   Cmd$="/opt/SPECS/usr/recipe/recipe_q.sh"
   Spc$="/var/tmp/spc."&SYSTEM$("PROCESS ID")
  !
   FOR I=1 TO SIZE(Item$,1)
     Item$(I)=""
   NEXT I
   Waf$=""
   FOR I=1 TO SIZE(Die$,1)
     Die$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Mod$,1)
     Mod$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tst$,1)
     Tst$(I)=""
   NEXT I
   Prb$=""
   FOR I=1 TO SIZE(Lms$,1)
     Lms$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Tco$,1)
     Tco$(I)=""
   NEXT I
   FOR I=1 TO SIZE(Mlib$,1)
     Mlib$(I)=""
   NEXT I
  !
   Cmd$=Cmd$&" "&Filename$&" "&Key$
   Rcp_exec_cmd(Cmd$,Spc$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
  !
   IF Cmd_ret=1 THEN Status=1
   IF Status=0 OR Status=1 THEN 
     ASSIGN @S TO Spc$;FORMAT ON
     ON END @S GOSUB Eof
  !
     Spc_nm$=""
     N_item=0
     ENTER @S;Line$
     WHILE (Line$<>"# EOD")
       IF Line$[1,2]="# " THEN 
         Spc_nm$=Line$[3;LEN(Line$)-2]
         N_item=0
       ELSE
         N_item=N_item+1
         SELECT Spc_nm$
         CASE "WAF"
           IF N_item>1 THEN 
             GOSUB Array_overflow
           END IF
           Waf$=Line$
         CASE "DIE"
           IF N_item>SIZE(Die$,1) THEN 
             GOSUB Array_overflow
           END IF
           Die$(N_item)=Line$
         CASE "MOD"
           IF N_item>SIZE(Mod$,1) THEN 
             GOSUB Array_overflow
           END IF
           Mod$(N_item)=Line$
         CASE "TST"
           IF N_item>SIZE(Tst$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tst$(N_item)=Line$
         CASE "PRB"
           IF N_item>1 THEN 
             GOSUB Array_overflow
           END IF
           Prb$=Line$
         CASE "LMS"
           IF N_item>SIZE(Lms$,1) THEN 
             GOSUB Array_overflow
           END IF
           Lms$(N_item)=Line$
         CASE "TCO"
           IF N_item>SIZE(Tco$,1) THEN 
             GOSUB Array_overflow
           END IF
           Tco$(N_item)=Line$
         CASE "MLIB"
           IF N_item>SIZE(Mlib$,1) THEN 
             GOSUB Array_overflow
           END IF
           Mlib$(N_item)=Line$
         CASE "ITEM"
           IF N_item>SIZE(Item$,1) THEN 
             GOSUB Column_overflow
           END IF
           Item$(N_item)=Line$[1;255]
         CASE ELSE
           GOSUB Eof
           SUBEXIT
         END SELECT
       END IF
  !
       ENTER @S;Line$
     END WHILE
  !
     ASSIGN @S TO *
   END IF
  !
   GOSUB Del_spc
   SUBEXIT
  !
 Eof:   !
   Status=-3
   Errmsg$="Cannot find a recipe by the key, """&Key$&"""."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Array_overflow:   !
   Status=-4
   Errmsg$="Too many file names at the column, """&Spc_nm$&"""."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Column_overflow:   !
   Status=-4
   Errmsg$="Too many columns in the recipe file."
   OFF END @S
   ASSIGN @S TO *
   GOSUB Del_spc
   SUBEXIT
  !
 Del_spc:    !
   ON ERROR GOTO Del_end
   PURGE Spc$
 Del_end:    !
   OFF ERROR 
   RETURN 
  !
 SUBEND
 Rcp_replace_wd:SUB Rcp_replace_wd(Format$,Find_wd$(*),Replace_wd$(*),String$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : RCP_REPLACE_WD
  !  Vers : 1
  !  Desc : Replace keyword in Format String.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -
  !      2 Find_wd         S    5
  !      3 Replace_wd      S    5
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 String          S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Cmd$[4096],Line$[256]
   INTEGER I
  !
   String$=""
  !
   IF Find_wd$(1)="" THEN 
     String$=Format$
     SUBEXIT
   END IF
  !
   Cmd$="/usr/bin/echo '"&Format$&"' | /usr/bin/sed "
   FOR I=1 TO 5
     IF Find_wd$(I)="" THEN 
       GOTO Exec_cmd
     END IF
     Cmd$=Cmd$&"-e 's/"&Find_wd$(I)&"/"&Replace_wd$(I)&"/' "
   NEXT I
  !
 Exec_cmd:   !
   ON ERROR GOTO No_exec
   ASSIGN @Pipe TO Cmd$&" |"
   OFF ERROR 
   ON END @Pipe GOTO Eof
   ENTER @Pipe;Line$
  !
   OFF END @Pipe
   ASSIGN @Pipe TO *
   String$=Line$
   SUBEXIT
  !
 Eof:   !
   OFF END @Pipe
   ASSIGN @Pipe TO *
  !
 No_exec:   !
   SUBEXIT
  !
 SUBEND
 Rcp_sysconf:SUB Rcp_sysconf(Name$,Value$,INTEGER Status)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : RCP_SYSCONF
  !  Vers : 1
  !  Desc : Read a parameter written in sysconf file.
  !       :   SPECS3.0: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Name            S    -        Parameter name for Recipe Manage
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Value           S    -        Parameter value read from syscon
  !      2 Status          I    -        0: Ok, -1: Not found, -2: Exec f
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   DIM Cmd$[1024],Line$[256]
  !
   Status=0
  !
   Cmd$="/usr/bin/grep -Ee '^[ \t]*"&Name$&"[ \t]*=' /opt/SPECS/sys/config/sysconf"
   Cmd$=Cmd$&"| /usr/bin/awk -F '=' '{val=$2;gsub(""^[ \t]*"","""",val);gsub(""[ \t]*$"","""",val); print val;}'"
   ON ERROR GOTO No_exec
   ASSIGN @Pipe TO Cmd$&" |"
   OFF ERROR 
   ON END @Pipe GOTO Eof
   ENTER @Pipe;Value$
  !
   OFF END @Pipe
   ASSIGN @Pipe TO *
   SUBEXIT
  !
 Eof:   !
   OFF END @Pipe
   ASSIGN @Pipe TO *
   Status=-1
   SUBEXIT
  !
 No_exec:   !
   Status=-2
   SUBEXIT
  !
 SUBEND
 Rcp_tplbld:SUB Rcp_tplbld(V1$,V2$,V3$,V4$,V5$,V6$,V7$,V8$,V9$(*),V10$(*),V11$(*),V12$(*),V13$,INTEGER Status,Errmsg$,INTEGER Ndetail,Detail$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : RCP_TPLBLD
  !  Vers : 1
  !  Desc : This algorithm generates Test Plan dynamically.
  !       :   SPECS3.1: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Waf_dir         S    -
  !      2 Prb_dir         S    -
  !      3 Die_dir         S    -
  !      4 Mod_dir         S    -
  !      5 Tst_dir         S    -
  !      6 Tpl_dir         S    -
  !      7 Waf             S    -
  !      8 Prb             S    -
  !      9 Die             S    256
  !     10 Mod             S    256
  !     11 Tst             S    256
  !     12 Mlib            S    6
  !     13 Tpl             S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Status          I    -        0: OK, -1: Exec Err, -2: No File
  !      2 Errmsg          S    -
  !      3 Ndetail         I    -        # of lines of detail error messa
  !      4 Detail          S    10       Detailed error message
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Waf_dir$[255]                                ! V1
   DIM Prb_dir$[255]                                ! V2
   DIM Die_dir$[255]                                ! V3
   DIM Mod_dir$[255]                                ! V4
   DIM Tst_dir$[255]                                ! V5
   DIM Tpl_dir$[255]                                ! V6
   DIM Waf$[255]                                    ! V7
   DIM Prb$[255]                                    ! V8
   DIM Die$(1:256)[255]                             ! V9
   DIM Mod$(1:256)[255]                             ! V10
   DIM Tst$(1:256)[255]                             ! V11
   DIM Mlib$(1:6)[255]                              ! V12
   DIM Tpl$[255]                                    ! V13
   Waf_dir$=V1$
   Prb_dir$=V2$
   Die_dir$=V3$
   Mod_dir$=V4$
   Tst_dir$=V5$
   Tpl_dir$=V6$
   Waf$=V7$
   Prb$=V8$
   MAT Die$= V9$
   MAT Mod$= V10$
   MAT Tst$= V11$
   MAT Mlib$= V12$
   Tpl$=V13$
  !***** DON'T REMOVE THIS LINE *************************************
   DIM Cmd$[32767],Opt$[32767],Opt_dir$[4096],Die_tst$(256)[256]
   DIM Tmpstr$[32767]
   DIM T$[256]
   INTEGER Cmd_ret
   INTEGER I,J,Die_dup
  !
   Ndetail=0
   IF Tpl$="" THEN 
     Status=-2
     Errmsg$="No test plan name is specified."
     SUBEXIT
   END IF
  !
   Rcp_dietst(Die$(*),Tst$(*),"",Die_tst$(*),Status,Errmsg$)
   IF Status<>0 THEN SUBEXIT
  !
   Rcp_mk_filename(Tpl_dir$,Tpl$,".tpl",T$)
  !
   ON ERROR GOSUB Str_overflow
   Cmd$="/opt/SPECS/sys/bin/tplbuild"
   Opt$=""
   IF Waf$<>"" THEN 
     Opt$=Opt$&" -waf "&Waf$
   END IF
   IF Prb$<>"" THEN 
     Opt$=Opt$&" -prb "&Prb$
   END IF
   I=1
   LOOP
   EXIT IF I>SIZE(Die$,1)
   EXIT IF Die$(I)=""
     Die_dup=0
     J=1
     LOOP
     EXIT IF J>=I
       IF Die$(I)=Die$(J) THEN Die_dup=1
     EXIT IF Die$(I)=Die$(J)
       J=J+1
     END LOOP
  !
     IF Die_dup=0 THEN 
       Opt$=Opt$&" -die "&Die$(I)
     END IF
     I=I+1
   END LOOP
   I=1
   LOOP
   EXIT IF I>SIZE(Mod$,1)
   EXIT IF Mod$(I)=""
     Opt$=Opt$&" -mod "&Mod$(I)
     I=I+1
   END LOOP
   I=1
   LOOP
   EXIT IF I>SIZE(Die_tst$,1)
   EXIT IF Die_tst$(I)=""
     Opt$=Opt$&" -tst "&Die_tst$(I)
     I=I+1
   END LOOP
   I=1
   Tmpstr$=""
   LOOP
   EXIT IF I>SIZE(Mlib$,1)
   EXIT IF Mlib$(I)=""
     IF I<>0 THEN 
       Tmpstr$=Tmpstr$&","
     END IF
     Tmpstr$=Tmpstr$&Mlib$(I)
     I=I+1
   END LOOP
   IF Tmpstr$<>"" THEN 
     Opt$=Opt$&" -m "&Tmpstr$
   END IF
  !
   Opt_dir$=""
   IF Waf_dir$<>"" THEN 
     Opt_dir$=Opt_dir$&" -wafpath "&Waf_dir$
   END IF
   IF Prb_dir$<>"" THEN 
     Opt_dir$=Opt_dir$&" -prbpath "&Prb_dir$
   END IF
   IF Die_dir$<>"" THEN 
     Opt_dir$=Opt_dir$&" -diepath "&Die_dir$
   END IF
   IF Mod_dir$<>"" THEN 
     Opt_dir$=Opt_dir$&" -modpath "&Mod_dir$
   END IF
   IF Tst_dir$<>"" THEN 
     Opt_dir$=Opt_dir$&" -tstpath "&Tst_dir$
   END IF
  !
   Cmd$=Cmd$&Opt$&Opt_dir$
   OFF ERROR 
   Rcp_exec_cmd(Cmd$,T$,Status,Errmsg$,Ndetail,Detail$(*),Cmd_ret)
   IF Status<0 THEN 
     GOSUB Remove_file
   END IF
  !
   SUBEXIT
  !
 Remove_file:    !
   ON ERROR GOTO Rm_end
   PURGE T$
 Rm_end:    !
   OFF ERROR 
   RETURN 
  !
 Str_overflow:   !
   Status=-1
   Errmsg$="Internal string buffer overflow."
   SUBEXIT
  !
 SUBEND
 Read_char:SUB Read_char(Format$,String$,Value$,INTEGER Stat)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : READ_CHAR
  !  Vers : 1
  !  Desc : Reads a character from a STRING variable, and returns it
  !       : to a CHARACTER variable
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 String          S    -        String to read from
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Value           C    -        Read value
  !      2 Stat            I    -        1(ok), 0(no data), -1(EOF)
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Readchar(Format$,String$,Value$,Stat)
 SUBEND
 Read_integer:SUB Read_integer(Format$,String$,INTEGER Value,Stat)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : READ_INTEGER
  !  Vers : 1
  !  Desc : Reads a value from a STRING variable, and returns it to a
  !       : n INTEGER variable
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 String          S    -        String to read from
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Value           I    -        Read value
  !      2 Stat            I    -        1(ok), 0(no data), -1(EOF)
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Readinteger(Format$,String$,Value,Stat)
 SUBEND
 Read_proccond:SUB Read_proccond(Filename$,INTEGER Ret,Readnum)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : READ_PROCCOND
  !  Vers : 1
  !  Desc : Read process condition file.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Filename        S    -        file name
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Ret             I    -        return code
  !      2 Readnum         I    -        the number of read condition
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Idx_tag
   DIM Name$[32]
   INTEGER Type,Dim,Size1,Size2
   INTEGER Cond_val_num,Cond_name_num
   DIM Line$[1025]
   INTEGER Find_header
   DIM Deli$[4]
   DIM Lot_id$[255],Wafer_id$[255],Value$[255]
   INTEGER Slot_no
   INTEGER Cond_no
   INTEGER Max_name_num
   INTEGER Line_num
  !
   Ret=0
   Deli$=","
   Max_name_num=10
  !
  ! check tag variable exists or not
   Tpltagindex("SYSTEM","TST_PROCCOND_VAL",Idx_tag)
   IF Idx_tag=-1 THEN 
     GOTO Other_err
   END IF
  !
  ! tag variable must be type of STRING[5][n]
   Tpltaginfo("SYSTEM",Idx_tag,Name$,Type,Dim,Size1,Size2)
   IF (Type<>3) OR (Dim<>2) OR (Size2<>5) THEN 
     GOTO Other_err
   END IF
  !
  ! open process condition file
   ON ERROR GOTO Nofile
   ASSIGN @File TO Filename$;FORMAT ON
   OFF ERROR 
  !
  ! allocate and initialize buffer
   ALLOCATE Conds$(Size2,Size1)[255]
   FOR I=1 TO Size2
     FOR J=1 TO Size1
       Conds$(I,J)=""
     NEXT J
   NEXT I
   ALLOCATE Names$(Max_name_num)[255]
  !
  ! ============
  !  main loop
  ! ============
  !
   Cond_val_num=0
   Cond_name_num=0
   Find_header=0
   Line_num=0
   ON END @File GOTO Eof
   LOOP
     ENTER @File;Line$
     Line_num=Line_num+1
  !
  !   !! skip empty line
     IF LEN(Line$)=0 THEN GOTO Loop_end
  !
  !   !! check if line length <= 1024
     IF LEN(Line$)=1025 THEN GOTO Bad_format
  !
  !   !! find header line (only 1st)
     IF Find_header=0 AND Line$[1;5]="#lot," THEN 
  !     !! skip 1st and 2nd element
       FOR I=1 TO 2
         Line$=Line$[POS(Line$,Deli$)+1]
       NEXT I
  !
  !     !! read condition names
       LOOP
       EXIT IF LEN(Line$)=0
         Strpos=POS(Line$,Deli$)
  !
  !       !! count up
         Cond_name_num=Cond_name_num+1
  !
  !       !! check max number of condition
         IF Cond_name_num>Max_name_num THEN GOTO Bad_format
  !
  !       !! hold condition name
         IF Strpos=0 THEN 
           Names$(Cond_name_num)=Line$
           Line$=""
         ELSE
           Names$(Cond_name_num)=Line$[1;Strpos-1]
           IF Strpos=LEN(Line$) THEN 
             Line$=""
           ELSE
             Line$=Line$[Strpos+1]
           END IF
         END IF
       END LOOP
  !     !! go to next line
       Find_header=1
       GOTO Loop_end
     END IF
  !
  !   !! skip comment line
     IF Line$[1;1]="#" THEN GOTO Loop_end
  !
  !   !!-------------
  !   !! valid line
  !   !!-------------
  !   !! lot ID
     Strpos=POS(Line$,Deli$)
     IF Strpos=0 THEN GOTO Bad_format
     Lot_id$=Line$[1;Strpos-1]
     IF Strpos=LEN(Line$) THEN GOTO Bad_format
     Line$=Line$[Strpos+1]
  !
  !   !! wafer ID
     Strpos=POS(Line$,Deli$)
     IF Strpos=0 THEN GOTO Bad_format
     Wafer_id$=Line$[1;Strpos-1]
     IF Strpos=LEN(Line$) THEN GOTO Bad_format
     Line$=Line$[Strpos+1]
  !
  !   !! find slot number
     Get_slot_no(Lot_id$,Wafer_id$,Slot_no)
     IF Slot_no=0 THEN GOTO Loop_end
  !
  !   !! read each condition value
     Cond_no=0
     LOOP
     EXIT IF LEN(Line$)=0
       Strpos=POS(Line$,Deli$)
  !
  !     !! count up counter
       Cond_val_num=Cond_val_num+1
       Cond_no=Cond_no+1
  !
  !     !! check limitation
       IF Cond_val_num>Size1 THEN GOTO Too_many
       IF Cond_no>Cond_name_num THEN GOTO Bad_format
  !
  !     !! get value
       IF Strpos=0 THEN 
         Value$=Line$
         Line$=""
       ELSE
         Value$=Line$[1;Strpos-1]
         IF Strpos=LEN(Line$) THEN 
           Line$=""
         ELSE
           Line$=Line$[Strpos+1]
         END IF
       END IF
  !
  !     !! set value
       Conds$(1,Cond_val_num)=VAL$(Slot_no)
       Conds$(2,Cond_val_num)=Lot_id$
       Conds$(3,Cond_val_num)=Wafer_id$
       Conds$(4,Cond_val_num)=Names$(Cond_no)
       Conds$(5,Cond_val_num)=Value$
  !
     END LOOP
  !
 Loop_end:    !
   END LOOP
  !
 Nofile:    !
   Ret=-1
   SUBEXIT
  !
 Bad_format:    !
   Ret=-2
   GOTO Eof
  !
 Too_many:    !
   Ret=-3
   GOTO Eof
  !
 Other_err:    !
   Ret=-4
   SUBEXIT
  !
 Eof:    !
   OFF END @File
  !
   ASSIGN @File TO *
  !
  ! !! set result
   Tplputsatag("SYSTEM",Idx_tag,0,Conds$(*))
   IF Ret=0 THEN Readnum=Cond_val_num
   IF Ret=-2 THEN Readnum=Line_num
  !
   DEALLOCATE Conds$(*)
   DEALLOCATE Names$(*)
  !
 SUBEND
 Read_real:SUB Read_real(Format$,String$,REAL Value,INTEGER Stat)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : READ_REAL
  !  Vers : 1
  !  Desc : Reads a value from a STRING variable, and returns it to a
  !       :  REAL variable
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 String          S    -        String to read from
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Value           R    -        Read value
  !      2 Stat            I    -        1(ok), 0(no data), -1(EOF)
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Readreal(Format$,String$,Value,Stat)
 SUBEND
 Read_string:SUB Read_string(Format$,String$,Value$,INTEGER Stat)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : READ_STRING
  !  Vers : 1
  !  Desc : Reads string data from a STRING variable, and returns it
  !       : to another STRING variable
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 String          S    -        String to read from
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Value           S    -        Read value
  !      2 Stat            I    -        1(ok), 0(no data), -1(EOF)
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Readstring(Format$,String$,Value$,Stat)
 SUBEND
 Save_tmpdata:SUB Save_tmpdata(Path$,Name$,Format$,Session$,INTEGER Stat,Error$,Pubname$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SAVE_TMPDATA
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Path            S    -
  !      2 Name            S    -
  !      3 Format          S    -
  !      4 Session         S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Stat            I    -        0: No temporary file exists 1: S
  !      2 Error           S    -
  !      3 Pubname         S    -        Official name
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Tmpname$[256],Filename$[256],Orgdir$[256],Cmd$[256]
   INTEGER Serial,Last,Pos,Skipmove
  !
   Skipmove=0
   Error$=""
  !
   Orgdir$=SYSTEM$("MSI")
   ON ERROR GOTO No_path
   MASS STORAGE IS Path$
   GOTO Move_path
 No_path:                              !
   OFF ERROR 
   MASS STORAGE IS Orgdir$
   Stat=-1
   Error$="SAVE_TMPDATA: MASS STORAGE IS """&Path$&""",1 failed. ERRN="&VAL$(ERRN)
   PRINT Error$
   SUBEXIT
  !
 Move_path:                              !
   OFF ERROR 
  !
   Name_tmpdata(Name$,Session$,Tmpname$)
   Tmpname$=Tmpname$&"."&Format$
   ON ERROR GOTO Err
   Cmd$="ls \"&Tmpname$&" 2>/dev/null |"
   ASSIGN @Pipe TO Cmd$
   ON END @Pipe GOTO Eof_ls_tmp
   ENTER @Pipe;Filename$
 Eof_ls_tmp:                           !
   OFF END @Pipe
   ASSIGN @Pipe TO *
   OFF ERROR 
   IF Filename$="" THEN 
     Skipmove=1
   END IF
  !
 Scan_pub:                           !
   ON ERROR GOTO Err
   ASSIGN @Pipe TO "ls "&Name$&"_[0-9]*."&Format$&" |"
   ON END @Pipe GOTO Eof_ls_pub
   Last=0
   LOOP
     ENTER @Pipe;Filename$
     Filename$=REV$(Filename$)
     Pos=POS(Filename$,".")
     IF Pos>1 AND REV$(Filename$[1,Pos-1])=Format$ THEN 
       Filename$=Filename$[Pos+1]
       Pos=POS(Filename$,"_")
       IF Pos>1 THEN 
         Serial=VAL(REV$(Filename$[1,Pos-1]))
         IF Serial>Last THEN 
           Last=Serial
         END IF
       END IF
     END IF
   END LOOP
 Eof_ls_pub:                              !
   OFF END @Pipe
   ASSIGN @Pipe TO *
  !
   Last=Last+1
   Pubname$=Name$&"_"&VAL$(Last)
   IF Skipmove=1 THEN 
     GOTO Skip_mv
   END IF
   ASSIGN @Pipe TO "mv \"&Tmpname$&" "&Pubname$&"."&Format$&" 2>&1 |"
   ON END @Pipe GOTO Eof_mv
   ENTER @Pipe;Error$
   MASS STORAGE IS Orgdir$
   OFF END @Pipe
   ASSIGN @Pipe TO *
   OFF ERROR 
   Stat=-1
   PRINT Error$
   SUBEXIT
  !
 Eof_mv:                            !
   MASS STORAGE IS Orgdir$
   OFF END @Pipe
   ASSIGN @Pipe TO *
   OFF ERROR 
   Stat=1
   SUBEXIT
 Skip_mv:                           !
   MASS STORAGE IS Orgdir$
   Stat=1
   SUBEXIT
 Err:                              !
   OFF ERROR 
   MASS STORAGE IS Orgdir$
   Stat=-1
   Error$=ERRM$
   PRINT Error$
 SUBEND
 Set_brk_mod:SUB Set_brk_mod(INTEGER Typeindex,Dieindex,Modindex,Break)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SET_BRK_MOD
  !  Vers : 1
  !  Desc : Set judgement flag of specified module.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER)
  !      2 Dieindex        I    -        Die index in die type (DIE.NUMBE
  !      3 Modindex        I    -        Module index (MODULE.NUMBER)
  !      4 Break           I    -        Breakpoint flag.
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos
  !
   Tpldietype2pos(Typeindex-1,Dieindex-1,Diepos)
  !
   Tplgetbrkmod(Diepos,Modindex-1,Break)
 SUBEND
 Set_jdg_die:SUB Set_jdg_die(INTEGER Typeindex,Dieindex,Judge,Offsetx,Offsety)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SET_JDG_DIE
  !  Vers : 1
  !  Desc : Set judgement flag of specified die.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER)
  !      2 Dieindex        I    -        Die index in die type (DIE.NUMBE
  !      3 Judge           I    -        Judgement value.
  !      4 Offsetx         I    -        Die X position offset.
  !      5 Offsety         I    -        Die Y position offset.
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos
  !
   IF Typeindex<=0 THEN 
     SUBEXIT
   END IF
   IF Dieindex<=0 THEN 
     SUBEXIT
   END IF
  !
   Tpldietype2pos(Typeindex-1,Dieindex-1,Diepos)
   IF Diepos<0 THEN 
     SUBEXIT
   END IF
  !
   Tplsetjdgdie(Diepos,Judge,Offsetx,Offsety)
 SUBEND
 Set_jdg_die_all:SUB Set_jdg_die_all(INTEGER Judge,Offsetx,Offsety)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SET_JDG_DIE_ALL
  !  Vers : 1
  !  Desc : Set judgement flag of all dice.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Judge           I    -         Judgement value
  !      2 Offsetx         I    -        Die X position offset.
  !      3 Offsety         I    -        Die Y position offset.
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Diepos,Total
  !
   Tpldietotal(Total)
   IF Total<=0 THEN 
     SUBEXIT
   END IF
  !
   FOR Diepos=0 TO Total-1 STEP 1
     Tplsetjdgdie(Diepos,Judge,Offsetx,Offsety)
   NEXT Diepos
 SUBEND
 Set_jdg_die_typ:SUB Set_jdg_die_typ(INTEGER Typeindex,Judge,Offsetx,Offsety)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SET_JDG_DIE_TYP
  !  Vers : 1
  !  Desc : Set judgement flag of specified die type.
  !       :   SPECS2.5: Initial revision.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Typeindex       I    -        Die type index (DIE.TYPENUMBER)
  !      2 Judge           I    -        Judgement value.
  !      3 Offsetx         I    -        Die X position offset.
  !      4 Offsety         I    -        Die Y position offset.
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Typei,Diei,Diepos,Total
  !
   IF Typeindex<=0 THEN 
     SUBEXIT
   END IF
  !
   Tpldietotal(Total)
   IF Total<=0 THEN 
     SUBEXIT
   END IF
  !
   Diepos=-1
   REPEAT
     Diepos=Diepos+1
     IF Diepos>=Total THEN 
       SUBEXIT
     END IF
     Tpldiepos2type(Diepos,Typei,Diei)
   UNTIL Typei=Typeindex-1
  !
   WHILE Diepos<Total
     Tpldiepos2type(Diepos,Typei,Diei)
     IF Typei<>Typeindex-1 THEN 
       SUBEXIT
     END IF
     Tplsetjdgdie(Diepos,Judge,Offsetx,Offsety)
     Diepos=Diepos+1
   END WHILE
 SUBEND
 Set_samelen:SUB Set_samelen(Original$,Reference$,Modified$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SET_SAMELEN
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Original        S    -
  !      2 Reference       S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Modified        S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Length,Lenref
   Modified$=TRIM$(Original$)
   Length=LEN(Modified$)
   Lenref=LEN(Reference$)
   IF Length<Lenref THEN 
     Modified$=Modified$&RPT$(" ",Lenref-Length)
   END IF
   IF Length>Lenref THEN 
     Modified$=Modified$[1,Lenref]
   END IF
 SUBEND
 Set_samelen20:SUB Set_samelen20(Original$(*),Modified$(*))
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SET_SAMELEN20
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Original        S    20
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Modified        S    20
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Length,Maxlength,I
  !
   Maxlength=0
   FOR I=1 TO 20
     Modified$(I)=TRIM$(Original$(I))
     Length=LEN(Modified$(I))
     IF Length>Maxlength THEN 
       Maxlength=Length
     END IF
   NEXT I
  !
   FOR I=1 TO 20
     Length=LEN(Modified$(I))
     Modified$(I)=Modified$(I)&RPT$(" ",Maxlength-Length)
   NEXT I
 SUBEND
 Set_tag_char:SUB Set_tag_char(Name$,Value$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SET_TAG_CHAR
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Name            S    -
  !      2 Value           C    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Idx,Typ,Dim,Size1,Size2,I,J
   ON ERROR GOTO Err
   Tpltagindex("SYSTEM",Name$,Idx)
   IF Idx=-1 THEN 
     SUBEXIT
   END IF
   Tpltaginfo("SYSTEM",Idx,Name$,Typ,Dim,Size1,Size2)
   IF Typ<>2 THEN 
     SUBEXIT
   END IF
   SELECT Dim
   CASE 0
     Tplputctag("SYSTEM",Idx,0,Value$[1,1])
   CASE 1
     ALLOCATE Array$(Size1)[1]
     FOR I=1 TO Size1
       Array$(I)=Value$[1,1]
     NEXT I
     Tplputcatag("SYSTEM",Idx,0,Array$(*))
     DEALLOCATE Array$(*)
   CASE 2
     ALLOCATE Array2$(Size2,Size1)[1]
     FOR I=1 TO Size2
       FOR J=1 TO Size1
         Array2$(I,J)=Value$[1,1]
       NEXT J
     NEXT I
     Tplputcatag("SYSTEM",Idx,0,Array2$(*))
     DEALLOCATE Array2$(*)
   END SELECT
 Err:                                  !
   OFF ERROR 
 SUBEND
 Set_tag_integer:SUB Set_tag_integer(Name$,INTEGER Value)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SET_TAG_INTEGER
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Name            S    -
  !      2 Value           I    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Idx,Typ,Dim,Size1,Size2,I,J
   ON ERROR GOTO Err
   Tpltagindex("SYSTEM",Name$,Idx)
   IF Idx=-1 THEN 
     SUBEXIT
   END IF
   Tpltaginfo("SYSTEM",Idx,Name$,Typ,Dim,Size1,Size2)
   IF Typ<>1 THEN 
     SUBEXIT
   END IF
   SELECT Dim
   CASE 0
     Tplputitag("SYSTEM",Idx,0,Value)
   CASE 1
     ALLOCATE INTEGER Array(Size1)
     FOR I=1 TO Size1
       Array(I)=Value
     NEXT I
     Tplputiatag("SYSTEM",Idx,0,Array(*))
     DEALLOCATE Array(*)
   CASE 2
     ALLOCATE INTEGER Array2(Size2,Size1)
     FOR I=1 TO Size2
       FOR J=1 TO Size1
         Array2(I,J)=Value
       NEXT J
     NEXT I
     Tplputiatag("SYSTEM",Idx,0,Array2(*))
     DEALLOCATE Array2(*)
   END SELECT
 Err:                                  !
   OFF ERROR 
 SUBEND
 Set_tag_real:SUB Set_tag_real(Name$,REAL Value)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SET_TAG_REAL
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Name            S    -
  !      2 Value           R    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Idx,Typ,Dim,Size1,Size2,I,J
   ON ERROR GOTO Err
   Tpltagindex("SYSTEM",Name$,Idx)
   IF Idx=-1 THEN 
     SUBEXIT
   END IF
   Tpltaginfo("SYSTEM",Idx,Name$,Typ,Dim,Size1,Size2)
   IF Typ<>0 THEN 
     SUBEXIT
   END IF
   SELECT Dim
   CASE 0
     Tplputrtag("SYSTEM",Idx,0,Value)
   CASE 1
     ALLOCATE REAL Array(Size1)
     FOR I=1 TO Size1
       Array(I)=Value
     NEXT I
     Tplputratag("SYSTEM",Idx,0,Array(*))
     DEALLOCATE Array(*)
   CASE 2
     ALLOCATE REAL Array2(Size2,Size1)
     FOR I=1 TO Size2
       FOR J=1 TO Size1
         Array2(I,J)=Value
       NEXT J
     NEXT I
     Tplputratag("SYSTEM",Idx,0,Array2(*))
     DEALLOCATE Array2(*)
   END SELECT
 Err:                                  !
   OFF ERROR 
 SUBEND
 Set_tag_string:SUB Set_tag_string(Name$,Value$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SET_TAG_STRING
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Name            S    -
  !      2 Value           S    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Idx,Typ,Dim,Size1,Size2,I,J
   ON ERROR GOTO Err
   Tpltagindex("SYSTEM",Name$,Idx)
   IF Idx=-1 THEN 
     SUBEXIT
   END IF
   Tpltaginfo("SYSTEM",Idx,Name$,Typ,Dim,Size1,Size2)
   IF Typ<>3 THEN 
     SUBEXIT
   END IF
   SELECT Dim
   CASE 0
     Tplputstag("SYSTEM",Idx,0,Value$)
   CASE 1
     ALLOCATE Array$(Size1)[255]
     FOR I=1 TO Size1
       Array$(I)=Value$
     NEXT I
     Tplputsatag("SYSTEM",Idx,0,Array$(*))
     DEALLOCATE Array$(*)
   CASE 2
     ALLOCATE Array2$(Size2,Size1)[255]
     FOR I=1 TO Size2
       FOR J=1 TO Size1
         Array2$(I,J)=Value$
       NEXT J
     NEXT I
     Tplputsatag("SYSTEM",Idx,0,Array2$(*))
     DEALLOCATE Array2$(*)
   END SELECT
 Err:                                  !
   OFF ERROR 
 SUBEND
 Setusrbin_lpbgn:SUB Setusrbin_lpbgn(INTEGER Waftgt,Lottgt)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SETUSRBIN_LPBGN
  !  Vers : 1
  !  Desc : Initializes "user bin" condition.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Waftgt          I    -        Wafer-level yield target.
  !      2 Lottgt          I    -        Lot-level yield target.
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Outcount                 ! Output variable total
   INTEGER Type,Dim,S1,S2           ! Variable information
   INTEGER Bin(11)                  ! Bin
   INTEGER Binc,Limc,Limtmp         !
   INTEGER Lolim(5),Uplim(5)        ! Limit index
   INTEGER I,J
   REAL Lim(10)                     ! Limit value
   DIM Name$[256]
   ON ERROR GOTO Errored
  !
   Tploutcount(Outcount)
   FOR I=0 TO Outcount-1
     Tploutinfo(I,Name$,Type,Dim,S1,S2)
     IF (Type<>0 OR Type<>1) AND Dim=0 THEN 
       Tplgetwafbin(I,Binc,Lim(*),Bin(*),Limc)
       Limtmp=Limc DIV 2
       IF (Limc MOD 2)=0 THEN 
         FOR J=1 TO Limtmp
           Lolim(J)=Limtmp-J+1
           Uplim(J)=Limtmp+J
         NEXT J
       ELSE
         FOR J=1 TO Limtmp
           Lolim(J)=Limtmp-J+1
           Uplim(J)=Limtmp+J+1
         NEXT J
       END IF
       Tplsetusrbin(I,Limtmp,Lolim(*),Uplim(*),1,Limtmp,Waftgt,Lottgt)
     END IF
   NEXT I
 Errored: !
 SUBEND
 Sizeofdisplay:SUB Sizeofdisplay(INTEGER Width,Height)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : SIZEOFDISPLAY
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Width           I    -
  !      2 Height          I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Wid$[16],Hei$[16]
  !
   ASSIGN @Pipe TO "/opt/SPECS/sys/bin/xrootsize |"
   ENTER @Pipe;Wid$
   ENTER @Pipe;Hei$
   ASSIGN @Pipe TO *
   Width=INT(VAL(TRIM$(Wid$)))
   Height=INT(VAL(TRIM$(Hei$)))
 SUBEND
 Statlog_dieend:SUB Statlog_dieend(Filename$,INTEGER Mode)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : STATLOG_DIEEND
  !  Vers : 1
  !  Desc : logs statistics on the specified file. This users user bi
  !       : n.
  !       :
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Filename        S    -        Filename.
  !      2 Mode            I    -        All(0), Failed only(1)
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Diepos,Diex,Diey            ! Current die position
   INTEGER Windex                      ! System variable index
   INTEGER Mini,Maxi                   ! Output variable range
   INTEGER Type,Dim,S1,S2              ! Variable information
   INTEGER Outjudge                    ! Pass=1,Fail=0,Invalid=2
   INTEGER Bin(6)                      ! Binning limit
   INTEGER Bc,Num,Den                  ! Statical calculation condition
   INTEGER I
   INTEGER Ival                        ! Integer-type output value
   REAL Lolim(6),Uplim(6)              ! Limit
   REAL Mean,Stdv,Minval,Maxval        ! Statistics
   REAL Rval                           ! Real-type output value
   DIM Wafid$[256]                     ! Wafer ID
   DIM Outname$[256]                   ! Output variable name
   DIM Sp$[8],Info$[1024]
  !
   ON ERROR GOTO Errored
   Sp$=CHR$(9)
   Tpldiepos(Diepos)
   Tpldieinfo(Diepos,Diex,Diey)
   IF Diepos=0 THEN 
     ON ERROR GOTO No_file
     PURGE Filename$
 No_file: !
     OFF ERROR 
   END IF
   ON ERROR GOTO Exist
   CREATE Filename$,1
   EXECUTE "chmod 666 "&Filename$
 Exist: !
   ON ERROR GOTO Errored
   ASSIGN @File TO Filename$;FORMAT ON,APPEND
   ON ERROR GOTO Endalg
  !
   Tpltagindex("WAFER","SYS_WAFERID",Windex)
   Tplgetstag("WAFER",Windex,Diepos,Wafid$)
   Tplgetrangedie(Diepos,Mini,Maxi)
   IF Mini<0 OR Maxi<0 THEN Endalg
  !
   I=Mini
   FOR I=Mini TO Maxi
     Tploutinfo(I,Outname$,Type,Dim,S1,S2)
     Tploutjudge(I,Diepos,Outjudge)
     Tplgetwafubin(I,Bc,Lolim(*),Uplim(*),Bin(*),Num,Den)
     IF (Dim=0) AND (Mode=0 OR Outjudge=0) AND (Bc>0) THEN 
       Tplmodulelabel(I,Modlabel$)
       Tpldevicelabel(I,Devlabel$)
       Tplgetwafustat(I,Den,Mean,Stdv,Minval,Maxval)
       OUTPUT @File USING "#,K";Wafid$;Sp$;Diex;Sp$;Diey;Sp$;Modlabel$;Sp$
       OUTPUT @File USING "#,K";Devlabel$;Sp$;Outname$;Sp$
       SELECT (Type)
       CASE 0
         Tplgetrout(I,Diepos,Rval)
         OUTPUT @File USING "#,SD.3DE";Rval
       CASE 1
         Tplgetiout(I,Diepos,Ival)
         OUTPUT @File USING "#,K";Ival
       CASE ELSE
       END SELECT
       OUTPUT @File USING "-,K,SD.4DE,K,SD.3DE,K,SD.3DE,K,SD.3DE";Sp$;Minval;Sp$;Maxval;Sp$;Mean;Sp$;Stdv
     END IF
   NEXT I
   ASSIGN @File TO *
   OFF ERROR 
   SUBEXIT
  !
 Endalg: !
   OFF ERROR 
   OUTPUT @File USING "-,K";Sp$
   ASSIGN @File TO *
   SUBEXIT
 Errored: !
   OFF ERROR 
 SUBEND
 String_lookup:SUB String_lookup(Src$,Pat$,INTEGER Pos)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : STRING_LOOKUP
  !  Vers : 1
  !  Desc : Returns the position of specified character(s) in a STRIN
  !       : G variable
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Src             S    -        Source string
  !      2 Pat             S    -        Pattern string
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Pos             I    -        Position (>0 position, 0 not fou
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Pos=POS(Src$,Pat$)
 SUBEND
 String_split:SUB String_split(Src$,Del$,Elem$(*),INTEGER Count)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : STRING_SPLIT
  !  Vers : 1
  !  Desc : Returns data (without separators) from a STRING variable,
  !       :  which contains data separated by data separators
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Src             S    -        Source string
  !      2 Del             S    -        Delimiter
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Elem            S    128      Substrings
  !      2 Count           I    -        Number of substrings
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM S$[511]
   INTEGER P,D
   S$=Src$&Del$
   D=LEN(Del$)
   Count=1
   P=POS(S$,Del$)
   IF P>=1 THEN 
     WHILE P>0
       Elem$(Count)=S$[1,P-1]
       S$=S$[P+D]
       P=POS(S$,Del$)
       Count=Count+1
     END WHILE
     Count=Count-1
   ELSE
     Count=1
   END IF
 SUBEND
 String_time:SUB String_time(REAL Time,Symbol$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : STRING_TIME
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Time            R    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Symbol          S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   REAL Hour,Minu,Seco
   DIM Buf$[2]
   Hour=INT(Time/3600)
   Time=Time-3600*Hour
   Minu=INT(Time/60)
   Time=Time-60*Minu
   Seco=INT(Time)
   Symbol$=VAL$(Hour)&":"
   Buf$=VAL$(Minu)
   IF LEN(Buf$)=1 THEN Symbol$=Symbol$&"0"
   Symbol$=Symbol$&Buf$&":"
   Buf$=VAL$(Seco)
   IF LEN(Buf$)=1 THEN Symbol$=Symbol$&"0"
   Symbol$=Symbol$&Buf$
 SUBEND
 Timedate:SUB Timedate(INTEGER Digit,Date$,Time$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : TIMEDATE
  !  Vers : 1
  !  Desc : Returns the present date and time
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Digit           I    -        # digits to represent a year
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Date            S    -        mm/dd/yy or mm/dd/yyyy
  !      2 Time            S    -        hh:mm:ss
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   IF Digit=4 THEN 
     ASSIGN @Pipe TO "date +'%m/%d/%C%y'; date '+%H:%M:%S' |"
   ELSE
     ASSIGN @Pipe TO "date +'%m/%d/%y'; date '+%H:%M:%S' |"
   END IF
   ENTER @Pipe;Date$
   ENTER @Pipe;Time$
   ASSIGN @Pipe TO *
 SUBEND
 Update_fwkconf:SUB Update_fwkconf(File$,INTEGER Type,Errno,Errmsg$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : UPDATE_FWKCONF
  !  Vers : 1
  !  Desc : Store current configuration parameters.
  !       :   SPECS2.5: Added type parameter.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 File            S    -
  !      2 Type            I    -        0:All vars, 1:Normal vars only,
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Errno           I    -
  !      2 Errmsg          S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Line$[8196],Org$[8196],Symbol$[8196],Value$[8196],Name$[32],Tmpfile$[256],Bakfile$[256],Src$[256]
   INTEGER P_col,P_exc,I                                                       !":", "!"
   INTEGER Idx_tag,Idx_dim1,Typ,Dim,Size1,Size2,Length
   INTEGER Int0
   REAL Real0
   DIM Str0$[255],Char0$[1]
  !
   Errno=0
   Errmsg$=""
   Tmpfile$=File$&".tmp"
   Bakfile$=File$&"~"
  !
   ON ERROR GOTO No_tmpfile
   PURGE Tmpfile$
 No_tmpfile:                  !
   IF ERRN<>56 THEN                    ! File name is undefined
     Errno=ERRN
     Errmsg$=ERRM$
     SUBEXIT
   END IF
  !
   ON ERROR GOTO Err
   CREATE Tmpfile$,1
   ASSIGN @Fwkconf TO File$;FORMAT ON
   PRINTER IS Tmpfile$
   ON END @Fwkconf GOTO Eof
  !
   LOOP
     Symbol$=""
     Value$=""
  !
     ENTER @Fwkconf;Line$
     Org$=Line$
     Line$=TRIM$(Line$)
     P_exc=POS(Line$,"!")
     SELECT P_exc
     CASE 0
     CASE 1
       Line$=""
     CASE ELSE
       Line$=Line$[1,P_exc-1]
     END SELECT
  !
     P_col=POS(Line$,":")
     IF P_col>=2 THEN 
       Symbol$=Line$[1,P_col-1]
       Symbol$=TRIM$(Symbol$)
       IF Symbol$<>"" AND LEN(Line$)>P_col THEN 
         Value$=Line$[P_col+1,LEN(Line$)]
         Value$=TRIM$(Value$)
       END IF
     END IF
  !
     IF Symbol$<>"" THEN 
       IF (Type=1 AND Symbol$[1,1]="*") OR (Type=2 AND Symbol$[1,1]<>"*") THEN 
         Symbol$=Org$
       ELSE
         IF Symbol$[1,1]="*" THEN 
           Src$=Symbol$[2,LEN(Symbol$)]
         ELSE
           Src$=Symbol$
         END IF
  !
         Line$=""
         Tpltagindex("SYSTEM",Src$,Idx_tag)
         IF Idx_tag=-1 THEN 
           Errno=1
           Errmsg$=Src$&" is not defined as TAG variable"
           GOTO Eof
         END IF
         Tpltaginfo("SYSTEM",Idx_tag,Name$,Typ,Dim,Size1,Size2)
         Line$=Symbol$&":"
         IF Dim=0 THEN 
           SELECT Typ
           CASE 0
             Tplgetrtag("SYSTEM",Idx_tag,0,Real0)
             Line$=Line$&VAL$(Real0)
           CASE 1
             Tplgetitag("SYSTEM",Idx_tag,0,Int0)
             Line$=Line$&VAL$(Int0)
           CASE 2
             IF LEN(Value$)>0 THEN 
               Tplgetctag("SYSTEM",Idx_tag,0,Char0$)
               Line$=Line$&Char0$
             END IF
           CASE 3
             Tplgetstag("SYSTEM",Idx_tag,0,Str0$)
             Line$=Line$&Str0$
           END SELECT
         END IF
         IF Dim=1 THEN 
           SELECT Typ
           CASE 0
             ALLOCATE REAL Real1(Size1)
             Tplgetratag("SYSTEM",Idx_tag,0,Real1(*))
             Line$=Line$&VAL$(Real1(1))
             FOR I=2 TO Size1-1
               Line$=Line$&","&VAL$(Real1(I))
             NEXT I
             IF Size1>1 THEN 
               Line$=Line$&","&VAL$(Real1(Size1))
             END IF
             DEALLOCATE Real1(*)
           CASE 1
             ALLOCATE INTEGER Int1(Size1)
             Tplgetiatag("SYSTEM",Idx_tag,0,Int1(*))
             Line$=Line$&VAL$(Int1(1))
             FOR I=2 TO Size1-1
               Line$=Line$&","&VAL$(Int1(I))
             NEXT I
             IF Size1>1 THEN 
               Line$=Line$&","&VAL$(Int1(Size1))
             END IF
             DEALLOCATE Int1(*)
           CASE 2
             ALLOCATE Char1$(Size1)[1]
             Tplgetcatag("SYSTEM",Idx_tag,0,Char1$(*))
             Line$=Line$&Char1$(1)
             FOR I=2 TO Size1-1
               Line$=Line$&","&Char1$(I)
             NEXT I
             IF Size1>1 THEN 
               Line$=Line$&","&Char1$(Size1)
             END IF
             DEALLOCATE Char1$(*)
           CASE 3
             ALLOCATE Str1$(Size1)[255]
             Tplgetsatag("SYSTEM",Idx_tag,0,Str1$(*))
             Line$=Line$&Str1$(1)
             FOR I=2 TO Size1-1
               Line$=Line$&","&Str1$(I)
             NEXT I
             IF Size1>1 THEN 
               Line$=Line$&","&Str1$(Size1)
             END IF
             DEALLOCATE Str1$(*)
           END SELECT
         END IF
         IF Dim=2 THEN 
           SELECT Typ
           CASE 0
             ALLOCATE REAL Real1(Size1*Size2)
             Tplgetratag("SYSTEM",Idx_tag,0,Real1(*))
             Counter=0
             FOR J=1 TO Size2
               FOR I=1 TO Size1
                 Counter=Counter+1
                 IF Counter=1 THEN 
                   Line$=Line$&VAL$(Real1(Counter))
                 ELSE
                   Line$=Line$&","&VAL$(Real1(Counter))
                 END IF
               NEXT I
             NEXT J
             DEALLOCATE Real1(*)
           CASE 1
             ALLOCATE INTEGER Int1(Size1*Size2)
             Tplgetiatag("SYSTEM",Idx_tag,0,Int1(*))
             Counter=0
             FOR J=1 TO Size2
               FOR I=1 TO Size1
                 Counter=Counter+1
                 IF Counter=1 THEN 
                   Line$=Line$&VAL$(Int1(Counter))
                 ELSE
                   Line$=Line$&","&VAL$(Int1(Counter))
                 END IF
               NEXT I
             NEXT J
             DEALLOCATE Int1(*)
           CASE 2
             ALLOCATE Char1$(Size1*Size2)[1]
             Tplgetcatag("SYSTEM",Idx_tag,0,Char1$(*))
             Counter=0
             FOR J=1 TO Size2
               FOR I=1 TO Size1
                 Counter=Counter+1
                 IF Counter=1 THEN 
                   Line$=Line$&Char1$(Counter)
                 ELSE
                   Line$=Line$&","&Char1$(Counter)
                 END IF
               NEXT I
             NEXT J
             DEALLOCATE Char1$(*)
           CASE 3
             ALLOCATE Str1$(Size1*Size2)[255]
             Tplgetsatag("SYSTEM",Idx_tag,0,Str1$(*))
             Counter=0
             FOR J=1 TO Size2
               FOR I=1 TO Size1
                 Counter=Counter+1
                 IF Counter=1 THEN 
                   Line$=Line$&Str1$(Counter)
                 ELSE
                   Line$=Line$&","&Str1$(Counter)
                 END IF
               NEXT I
             NEXT J
             DEALLOCATE Str1$(*)
           END SELECT
         END IF
       END IF
     ELSE
       Line$=Org$
     END IF
  !
     PRINT Line$
   END LOOP
 Eof:                   !                    !
   PRINTER IS CRT
   ASSIGN @Fwkconf TO *
  !
   ON ERROR GOTO No_bckfile
   PURGE Bakfile$
 No_bckfile:                  !
   IF ERRN<>56 THEN                    ! File name is undefined
     Errno=ERRN
     Errmsg$=ERRM$
     SUBEXIT
   END IF
  !
   ON ERROR GOTO Err
   COPY File$ TO Bakfile$
   PURGE File$
   EXECUTE "/opt/SPECS/sys/bin/dos2unix.sh "&File$&".tmp "&File$
   PURGE Tmpfile$
   SUBEXIT
 Err:                           !
   PRINTER IS CRT
   ASSIGN @Fwkconf TO *
   Errno=ERRN
   Errmsg$=ERRM$
 SUBEND
 Verify_file:SUB Verify_file(Filename$,Type$,INTEGER Exist,Readable,Writable,Executable)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : VERIFY_FILE
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Filename        S    -
  !      2 Type            S    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Exist           I    -
  !      2 Readable        I    -
  !      3 Writable        I    -
  !      4 Executable      I    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Dumfile$[32]
   DIM Mode$[11],Usr_own$[256],Grp_own$[256],Usr_file$[256],Grp_file$[256]
  !
  ! Check mode of target file
  !
   Exist=0
   Readable=0
   Writable=0
   Executable=0
   ON ERROR GOTO Err
   ASSIGN @Pipe TO "ls -l -d "&Filename$&" 2>/dev/null | cut -c -10 |"
   ON END @Pipe GOTO Nomode
   ENTER @Pipe;Mode$
   GOTO Check_file
 Nomode:   !
   OFF END @Pipe
   OFF ERROR 
   PRINT "VERIFY_FILE ERROR: "&Filename$&" is not accessible."
   SUBEXIT
  !
 Check_file:   !
   OFF END @Pipe
   OFF ERROR 
  !
   SELECT Type$
   CASE "Normal"
     IF Mode$[1,1]<>"-" AND Mode$[1,1]<>"l" THEN SUBEXIT
   CASE "Directory"
     IF Mode$[1,1]<>"d" THEN SUBEXIT
   CASE "Special"
     IF Mode$[1,1]="-" OR Mode$[1,1]="l" OR Mode$[1,1]="d" THEN SUBEXIT
   END SELECT
  !
   Exist=1
  !
  ! Check user/group of target file
  !
   IF Type$="Directory" THEN 
     ASSIGN @Pipe TO "ls -l -d "&Filename$&"| awk '{print $3}'|"
     ENTER @Pipe;Usr_file$
     ASSIGN @Pipe TO "ls -l -d "&Filename$&"| awk '{print $4}'|"
     ENTER @Pipe;Grp_file$
   ELSE
     ASSIGN @Pipe TO "ls -l "&Filename$&"| awk '{print $3}'|"
     ENTER @Pipe;Usr_file$
     ASSIGN @Pipe TO "ls -l "&Filename$&"| awk '{print $4}'|"
     ENTER @Pipe;Grp_file$
   END IF
   OFF ERROR 
  !
  ! Check user/group of myself
  !
   Dumfile$="/var/tmp/VERIFY"&SYSTEM$("PROCESS ID")    ! AVPATH_
   ON ERROR GOTO Ignore
   PURGE Dumfile$
 Ignore:                                  !
   ON ERROR GOTO Err
   CREATE Dumfile$,1
   ASSIGN @Pipe TO "ls -l "&Dumfile$&"| awk '{print $3}'|"
   ENTER @Pipe;Usr_own$
   ASSIGN @Pipe TO "ls -l "&Dumfile$&"| awk '{print $4}'|"
   ENTER @Pipe;Grp_own$
   PURGE Dumfile$
   OFF ERROR 
  !
   IF Usr_own$=Usr_file$ THEN 
     IF Mode$[2,2]="r" THEN Readable=1
     IF Mode$[3,3]="w" THEN Writable=1
     IF Mode$[4,4]="x" OR Mode$[4,4]="s" THEN Executable=1
   ELSE
     IF Grp_own$=Grp_file$ THEN 
       IF Mode$[5,5]="r" THEN Readable=1
       IF Mode$[6,6]="w" THEN Writable=1
       IF Mode$[7,7]="x" OR Mode$[7,7]="s" THEN Executable=1
     ELSE
       IF Mode$[8,8]="r" THEN Readable=1
       IF Mode$[9,9]="w" THEN Writable=1
       IF Mode$[10,10]="x" OR Mode$[10,10]="t" THEN Executable=1
     END IF
   END IF
   SUBEXIT
 Err:   !
   PRINT "VERIFY_FILE ERROR: "&ERRM$
   OFF END @Pipe
   OFF ERROR 
 SUBEND
 Wait:SUB Wait(REAL Wait)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : WAIT
  !  Vers : 1
  !  Desc : Waits for the speicifed duration
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Wait            R    -
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   WAIT Wait
 SUBEND
 Write_char:SUB Write_char(Format$,Value$,String$,INTEGER Length)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : WRITE_CHAR
  !  Vers : 1
  !  Desc : Writes a CHARACTER value to a STRING variable
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 Value           C    -        Value to convert
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 String          S    -        Formatted to string
  !      2 Length          I    -        Length of string
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Writechar(Format$,Value$,String$,Length)
 SUBEND
 Write_integer:SUB Write_integer(Format$,INTEGER Value,String$,INTEGER Length)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : WRITE_INTEGER
  !  Vers : 1
  !  Desc : Writes an INTEGER value to a STRING variable
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 Value           I    -        Value to convert
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 String          S    -        Formatted to string
  !      2 Length          I    -        Length of string
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Writeinteger(Format$,Value,String$,Length)
 SUBEND
 Write_real:SUB Write_real(Format$,REAL Value,String$,INTEGER Length)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : WRITE_REAL
  !  Vers : 1
  !  Desc : Writes a REAL value to a STRING variable
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 Value           R    -        Value to convert
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 String          S    -        Formatted to string
  !      2 Length          I    -        Length of string
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Writereal(Format$,Value,String$,Length)
 SUBEND
 Write_string:SUB Write_string(Format$,Value$,String$,INTEGER Length)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : WRITE_STRING
  !  Vers : 1
  !  Desc : Writes a STRING value to a STRING variable
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Format          S    -        Format string
  !      2 Value           S    -        Value to convert
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 String          S    -        Formatted to string
  !      2 Length          I    -        Length of string
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   Writestring(Format$,Value$,String$,Length)
 SUBEND
 Write_wafer_sum:SUB Write_wafer_sum(INTEGER Slot,Lot$,Wafer$,REAL Yld_item,Yld_die,INTEGER Judge,Summary$)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : WRITE_WAFER_SUM
  !  Vers : 1
  !  Desc : Description for this Algorithm spec.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Slot            I    -
  !      2 Lot             S    -
  !      3 Wafer           S    -
  !      4 Yld_item        R    -
  !      5 Yld_die         R    -
  !      6 Judge           I    -
  !
  !  Output Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Output Parameters:
  !      1 Summary         S    -
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   INTEGER Length
   DIM Yield$[255]
  ! Slot
   Summary$=" "&VAL$(Slot)
   Summary$=Summary$&RPT$(" ",10-LEN(Summary$))
  ! Lot ID
   IF LEN(Lot$)>24 THEN 
     Lot$=Lot$[1,24]
   END IF
   Summary$=Summary$&Lot$
   Summary$=Summary$&RPT$(" ",35-LEN(Summary$))
  !
   IF LEN(Wafer$)>10 THEN 
     Wafer$=Wafer$[1,10]
   END IF
   Summary$=Summary$&Wafer$
   Summary$=Summary$&RPT$(" ",46-LEN(Summary$))
  !
   IF Judge<0 THEN 
     SUBEXIT
   END IF
  !
   Writereal("%5.2f",Yld_item,Yield$,Length)
   IF LEN(Yield$)>10 THEN 
     Yield$=Yield$[1,10]
   END IF
   Summary$=Summary$&Yield$
   Summary$=Summary$&RPT$(" ",57-LEN(Summary$))
  !
   Writereal("%5.2f",Yld_die,Yield$,Length)
   IF LEN(Yield$)>10 THEN 
     Yield$=Yield$[1,10]
   END IF
   Summary$=Summary$&Yield$
   Summary$=Summary$&RPT$(" ",68-LEN(Summary$))
  !
   SELECT Judge
   CASE 0
     Summary$=Summary$&"Fail"
   CASE 1
     Summary$=Summary$&"Pass"
   END SELECT
 SUBEND
 Xwud:SUB Xwud(File$,INTEGER Xpos,Ypos,Noclick)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : XWUD
  !  Vers : 1
  !  Desc : Executes the xwud(1) command to display a window image, w
  !       : hich is stored in the specified dump file
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 File            S    -        xwd dump file (see xwd(1))
  !      2 Xpos            I    -        X position
  !      3 Ypos            I    -        Y position
  !      4 Noclick         I    -        1 to ignore mouse click
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
   DIM Str$[80],Click$[80]
   Pos$="+"&VAL$(Xpos)&"+"&VAL$(Ypos)
   IF Noclick=1 THEN Click$=" -noclick"
   Str$=" -in "&File$&" -geometry "&Pos$&Click$
   EXECUTE "/usr/bin/X11/xwud "&Str$&" &"
 SUBEND
 Yieldlog_wafend:SUB Yieldlog_wafend(Filename$,INTEGER Dieyield)
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Type : Algorithm
  !  Name : YIELDLOG_WAFEND
  !  Vers : 1
  !  Desc : Logs yield on the specified file. This uses user bin.
  !  Date : 11/15/2006
  !  Time : 03:40:00
  !  User : root
  !
  !***** DON'T REMOVE THIS LINE *************************************
  !
  !  Input Variables:
  !
  !     #  Name            Type Size     Description
  !    --- --------------- ---- -------- --------------------------------
  !    Measurement Parameters:
  !      1 Filename        S    -        Filename.
  !      2 Dieyield        I    -        Die yield target value.
  !
  !  Output Variables:
  !
  !***** DON'T REMOVE THIS LINE *************************************
   OPTION BASE 1                !***** DON'T REMOVE THIS LINE *****
  !
   INTEGER Windex                      ! System variable index
   INTEGER Dietotal                    ! Total # of die
   INTEGER Itemtotal                   ! Total # of output variable
   INTEGER Itemyield                   ! Item yield
   INTEGER Target,Yield,Judge          ! Yield and Pass/Fail
   INTEGER Diepass,Diefail             ! Die count
   INTEGER Dieyldrslt                  ! Calculated die yield
   INTEGER Wafnum                      ! Wafer number
   INTEGER Mini,Maxi
   INTEGER I,J
   DIM Wafid$[256]                     ! Wafer ID
   DIM Jdg$[256],Sp$[8]
  !
   ON ERROR GOTO Errored
  !
   Sp$=CHR$(9)
   Tpltagindex("WAFER","SYS_WAFERID",Windex)
   Tplgetstag("WAFER",Windex,0,Wafid$)
   Tpldietotal(Dietotal)
   Tploutcount(Itemtotal)
  !
   Itemyield=100
   FOR I=0 TO Itemtotal-1
     Tplgetwafjudge(I,Target,Yield,Judge)
     IF Yield<Itemyield THEN 
       Itemyield=Yield
     END IF
   NEXT I
  !
   Diepass=0
   Diefail=0
   Dieyldrslt=100
   FOR I=0 TO Dietotal-1
     F=0
     Tplgetrangedie(I,Mini,Maxi)
     FOR J=Mini TO Maxi
       Tploutjudge(J,I,Judge)
       IF Judge=0 THEN 
         F=1
       END IF
     NEXT J
     IF F=1 THEN 
       Diefail=Diefail+1
     ELSE
       Diepass=Diepass+1
     END IF
   NEXT I
   IF Diepass+Diefail>0 THEN 
     Dieyldrslt=(Diepass*100)/(Diepass+Diefail)
   END IF
   IF Dieyldrslt>=Dieyield THEN 
     Jdg$="PASS"
   ELSE
     Jdg$="FAIL!!"
   END IF
  !
   Tplsysindex("WAFER","NUMBER",Windex)
   Tplgetisys("WAFER",Windex,Wafnum)
   IF Wafnum=1 THEN 
     ON ERROR GOTO No_file
     PURGE Filename$
 No_file: !
     OFF ERROR 
   END IF
   ON ERROR GOTO Exist
   CREATE Filename$,1
   EXECUTE "chmod 666 "&Filename$
 Exist: !
   ASSIGN @File TO Filename$;FORMAT ON,APPEND
   ON ERROR GOTO Endalg
   OUTPUT @File USING "-,K";Wafid$;Sp$;Itemyield;Sp$;Dieyldrslt;Sp$;Jdg$
   ASSIGN @File TO Filename$
   OFF ERROR 
   SUBEXIT
 Endalg: !
   OFF ERROR 
   ASSIGN @File TO *
   SUBEXIT
 Errored: !
   OFF ERROR 
 SUBEND
 Algo_tail:SUB Algo_tail  !**** DON'T REMOVE THIS SUBPROGRAM ****
 SUBEND
